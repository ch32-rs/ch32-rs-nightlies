//!Peripheral access API for CH32V103XX microcontrollers (generated using svd2rust v0.28.0 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
#[cfg(feature = "rt")]
extern "C" {
    fn RESET();
    fn NMI();
    fn EXC();
    fn SYS_TICK();
    fn SWI();
    fn WWDG();
    fn PVD();
    fn TAMPER();
    fn RTC();
    fn FLASH();
    fn RCC();
    fn EXTI0();
    fn EXTI1();
    fn EXTI2();
    fn EXTI3();
    fn EXTI4();
    fn DMA1_CH1();
    fn DMA1_CH2();
    fn DMA1_CH3();
    fn DMA1_CH4();
    fn DMA1_CH5();
    fn DMA1_CH6();
    fn DMA1_CH7();
    fn ADC();
    fn EXTI9_5();
    fn TIM1_BRK();
    fn TIM1_UP();
    fn TIM1_TRG_COM();
    fn TIM1_CC();
    fn TIM2();
    fn TIM3();
    fn TIM4();
    fn I2C1_EV();
    fn I2C1_ER();
    fn I2C2_EV();
    fn I2C2_ER();
    fn SPI1();
    fn SPI2();
    fn USART1();
    fn USART2();
    fn USART3();
    fn EXTI15_10();
    fn RTCALARM();
    fn USBWAKE_UP();
    fn USBHD();
}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 60] = [
    Vector { _reserved: 0 },
    Vector { _handler: RESET },
    Vector { _handler: NMI },
    Vector { _handler: EXC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: SYS_TICK },
    Vector { _reserved: 0 },
    Vector { _handler: SWI },
    Vector { _reserved: 0 },
    Vector { _handler: WWDG },
    Vector { _handler: PVD },
    Vector { _handler: TAMPER },
    Vector { _handler: RTC },
    Vector { _handler: FLASH },
    Vector { _handler: RCC },
    Vector { _handler: EXTI0 },
    Vector { _handler: EXTI1 },
    Vector { _handler: EXTI2 },
    Vector { _handler: EXTI3 },
    Vector { _handler: EXTI4 },
    Vector { _handler: DMA1_CH1 },
    Vector { _handler: DMA1_CH2 },
    Vector { _handler: DMA1_CH3 },
    Vector { _handler: DMA1_CH4 },
    Vector { _handler: DMA1_CH5 },
    Vector { _handler: DMA1_CH6 },
    Vector { _handler: DMA1_CH7 },
    Vector { _handler: ADC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: EXTI9_5 },
    Vector { _handler: TIM1_BRK },
    Vector { _handler: TIM1_UP },
    Vector {
        _handler: TIM1_TRG_COM,
    },
    Vector { _handler: TIM1_CC },
    Vector { _handler: TIM2 },
    Vector { _handler: TIM3 },
    Vector { _handler: TIM4 },
    Vector { _handler: I2C1_EV },
    Vector { _handler: I2C1_ER },
    Vector { _handler: I2C2_EV },
    Vector { _handler: I2C2_ER },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI2 },
    Vector { _handler: USART1 },
    Vector { _handler: USART2 },
    Vector { _handler: USART3 },
    Vector {
        _handler: EXTI15_10,
    },
    Vector { _handler: RTCALARM },
    Vector {
        _handler: USBWAKE_UP,
    },
    Vector { _handler: USBHD },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///1 - Reset
        RESET = 1,
        ///2 - NMI
        NMI = 2,
        ///3 - EXC
        EXC = 3,
        ///12 - SysTick
        SYS_TICK = 12,
        ///14 - SWI
        SWI = 14,
        ///16 - Window Watchdog interrupt
        WWDG = 16,
        ///17 - PVD through EXTI line detection interrupt
        PVD = 17,
        ///18 - Tamper interrupt
        TAMPER = 18,
        ///19 - RTC global interrupt
        RTC = 19,
        ///20 - Flash global interrupt
        FLASH = 20,
        ///21 - RCC global interrupt
        RCC = 21,
        ///22 - EXTI Line0 interrupt
        EXTI0 = 22,
        ///23 - EXTI Line1 interrupt
        EXTI1 = 23,
        ///24 - EXTI Line2 interrupt
        EXTI2 = 24,
        ///25 - EXTI Line3 interrupt
        EXTI3 = 25,
        ///26 - EXTI Line4 interrupt
        EXTI4 = 26,
        ///27 - DMA1 Channel1 global interrupt
        DMA1_CH1 = 27,
        ///28 - DMA1 Channel2 global interrupt
        DMA1_CH2 = 28,
        ///29 - DMA1 Channel3 global interrupt
        DMA1_CH3 = 29,
        ///30 - DMA1 Channel4 global interrupt
        DMA1_CH4 = 30,
        ///31 - DMA1 Channel5 global interrupt
        DMA1_CH5 = 31,
        ///32 - DMA1 Channel6 global interrupt
        DMA1_CH6 = 32,
        ///33 - DMA1 Channel7 global interrupt
        DMA1_CH7 = 33,
        ///34 - ADC1 global interrupt
        ADC = 34,
        ///39 - EXTI Line\[9:5\]
        ///interrupts
        EXTI9_5 = 39,
        ///40 - TIM1 Break interrupt
        TIM1_BRK = 40,
        ///41 - TIM1 Update interrupt
        TIM1_UP = 41,
        ///42 - TIM1 Trigger and Commutation interrupts
        TIM1_TRG_COM = 42,
        ///43 - TIM1 Capture Compare interrupt
        TIM1_CC = 43,
        ///44 - TIM2 global interrupt
        TIM2 = 44,
        ///45 - TIM3 global interrupt
        TIM3 = 45,
        ///46 - TIM4 global interrupt
        TIM4 = 46,
        ///47 - I2C1 event interrupt
        I2C1_EV = 47,
        ///48 - I2C1 error interrupt
        I2C1_ER = 48,
        ///49 - I2C2 event interrupt
        I2C2_EV = 49,
        ///50 - I2C2 error interrupt
        I2C2_ER = 50,
        ///51 - SPI1 global interrupt
        SPI1 = 51,
        ///52 - SPI2 global interrupt
        SPI2 = 52,
        ///53 - USART1 global interrupt
        USART1 = 53,
        ///54 - USART2 global interrupt
        USART2 = 54,
        ///55 - USART3 global interrupt
        USART3 = 55,
        ///56 - EXTI Line\[15:10\]
        ///interrupts
        EXTI15_10 = 56,
        ///57 - RTC Alarms through EXTI line interrupt
        RTCALARM = 57,
        ///58 - USB Device FS Wakeup through EXTI line interrupt
        USBWAKE_UP = 58,
        ///59 - USBHD_IRQHandler
        USBHD = 59,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                1 => Ok(Interrupt::RESET),
                2 => Ok(Interrupt::NMI),
                3 => Ok(Interrupt::EXC),
                12 => Ok(Interrupt::SYS_TICK),
                14 => Ok(Interrupt::SWI),
                16 => Ok(Interrupt::WWDG),
                17 => Ok(Interrupt::PVD),
                18 => Ok(Interrupt::TAMPER),
                19 => Ok(Interrupt::RTC),
                20 => Ok(Interrupt::FLASH),
                21 => Ok(Interrupt::RCC),
                22 => Ok(Interrupt::EXTI0),
                23 => Ok(Interrupt::EXTI1),
                24 => Ok(Interrupt::EXTI2),
                25 => Ok(Interrupt::EXTI3),
                26 => Ok(Interrupt::EXTI4),
                27 => Ok(Interrupt::DMA1_CH1),
                28 => Ok(Interrupt::DMA1_CH2),
                29 => Ok(Interrupt::DMA1_CH3),
                30 => Ok(Interrupt::DMA1_CH4),
                31 => Ok(Interrupt::DMA1_CH5),
                32 => Ok(Interrupt::DMA1_CH6),
                33 => Ok(Interrupt::DMA1_CH7),
                34 => Ok(Interrupt::ADC),
                39 => Ok(Interrupt::EXTI9_5),
                40 => Ok(Interrupt::TIM1_BRK),
                41 => Ok(Interrupt::TIM1_UP),
                42 => Ok(Interrupt::TIM1_TRG_COM),
                43 => Ok(Interrupt::TIM1_CC),
                44 => Ok(Interrupt::TIM2),
                45 => Ok(Interrupt::TIM3),
                46 => Ok(Interrupt::TIM4),
                47 => Ok(Interrupt::I2C1_EV),
                48 => Ok(Interrupt::I2C1_ER),
                49 => Ok(Interrupt::I2C2_EV),
                50 => Ok(Interrupt::I2C2_ER),
                51 => Ok(Interrupt::SPI1),
                52 => Ok(Interrupt::SPI2),
                53 => Ok(Interrupt::USART1),
                54 => Ok(Interrupt::USART2),
                55 => Ok(Interrupt::USART3),
                56 => Ok(Interrupt::EXTI15_10),
                57 => Ok(Interrupt::RTCALARM),
                58 => Ok(Interrupt::USBWAKE_UP),
                59 => Ok(Interrupt::USBHD),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///Power control
pub struct PWR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWR {}
impl PWR {
    ///Pointer to the register block
    pub const PTR: *const pwr::RegisterBlock = 0x4000_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWR {
    type Target = pwr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWR").finish()
    }
}
///Power control
pub mod pwr {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Power control register (PWR_CTRL)
        pub ctlr: CTLR,
        ///0x04 - Power control register (PWR_CSR)
        pub csr: CSR,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Power control register (PWR_CTRL)
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LPDS` reader - Low Power Deep Sleep
        pub type LPDS_R = crate::BitReader<LPDS_A>;
        ///Low Power Deep Sleep
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LPDS_A {
            ///0: Regulator works normally at halting mode
            Normal = 0,
            ///1: Regulator works at low power at halting mode
            LowPower = 1,
        }
        impl From<LPDS_A> for bool {
            #[inline(always)]
            fn from(variant: LPDS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LPDS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LPDS_A {
                match self.bits {
                    false => LPDS_A::Normal,
                    true => LPDS_A::LowPower,
                }
            }
            ///Checks if the value of the field is `Normal`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == LPDS_A::Normal
            }
            ///Checks if the value of the field is `LowPower`
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                *self == LPDS_A::LowPower
            }
        }
        ///Field `LPDS` writer - Low Power Deep Sleep
        pub type LPDS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, LPDS_A, O>;
        impl<'a, const O: u8> LPDS_W<'a, O> {
            ///Regulator works normally at halting mode
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(LPDS_A::Normal)
            }
            ///Regulator works at low power at halting mode
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(LPDS_A::LowPower)
            }
        }
        ///Field `PDDS` reader - Power Down Deep Sleep
        pub type PDDS_R = crate::BitReader<PDDS_A>;
        ///Power Down Deep Sleep
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PDDS_A {
            ///0: Turn into halting mode on deepsleep
            Halting = 0,
            ///1: Turn into stand-by mode on deepsleep
            StandBy = 1,
        }
        impl From<PDDS_A> for bool {
            #[inline(always)]
            fn from(variant: PDDS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PDDS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PDDS_A {
                match self.bits {
                    false => PDDS_A::Halting,
                    true => PDDS_A::StandBy,
                }
            }
            ///Checks if the value of the field is `Halting`
            #[inline(always)]
            pub fn is_halting(&self) -> bool {
                *self == PDDS_A::Halting
            }
            ///Checks if the value of the field is `StandBy`
            #[inline(always)]
            pub fn is_stand_by(&self) -> bool {
                *self == PDDS_A::StandBy
            }
        }
        ///Field `PDDS` writer - Power Down Deep Sleep
        pub type PDDS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, PDDS_A, O>;
        impl<'a, const O: u8> PDDS_W<'a, O> {
            ///Turn into halting mode on deepsleep
            #[inline(always)]
            pub fn halting(self) -> &'a mut W {
                self.variant(PDDS_A::Halting)
            }
            ///Turn into stand-by mode on deepsleep
            #[inline(always)]
            pub fn stand_by(self) -> &'a mut W {
                self.variant(PDDS_A::StandBy)
            }
        }
        ///Field `CWUF` reader - Clear Wake-up Flag
        pub type CWUF_R = crate::BitReader<CWUFW_A>;
        ///Clear Wake-up Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CWUFW_A {
            ///1: Clear Wake-Up Flag
            Clear = 1,
        }
        impl From<CWUFW_A> for bool {
            #[inline(always)]
            fn from(variant: CWUFW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CWUF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CWUFW_A> {
                match self.bits {
                    true => Some(CWUFW_A::Clear),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Clear`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == CWUFW_A::Clear
            }
        }
        ///Field `CWUF` writer - Clear Wake-up Flag
        pub type CWUF_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, CTLR_SPEC, CWUFW_A, O>;
        impl<'a, const O: u8> CWUF_W<'a, O> {
            ///Clear Wake-Up Flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CWUFW_A::Clear)
            }
        }
        ///Field `CSBF` reader - Clear STANDBY Flag
        pub type CSBF_R = crate::BitReader<CSBFW_A>;
        ///Clear STANDBY Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CSBFW_A {
            ///1: Clear Stand-By Flag
            Clear = 1,
        }
        impl From<CSBFW_A> for bool {
            #[inline(always)]
            fn from(variant: CSBFW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CSBF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CSBFW_A> {
                match self.bits {
                    true => Some(CSBFW_A::Clear),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Clear`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                *self == CSBFW_A::Clear
            }
        }
        ///Field `CSBF` writer - Clear STANDBY Flag
        pub type CSBF_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, CTLR_SPEC, CSBFW_A, O>;
        impl<'a, const O: u8> CSBF_W<'a, O> {
            ///Clear Stand-By Flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CSBFW_A::Clear)
            }
        }
        ///Field `PVDE` reader - Power Voltage Detector Enable
        pub type PVDE_R = crate::BitReader<bool>;
        ///Field `PVDE` writer - Power Voltage Detector Enable
        pub type PVDE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PLS` reader - PVD Level Selection
        pub type PLS_R = crate::FieldReader<u8, PLS_A>;
        ///PVD Level Selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PLS_A {
            ///0: Rising edge 2.65V, falling edge 2.5V
            R265f250 = 0,
            ///1: Rising edge 2.87V, falling edge 2.7V
            R287f270 = 1,
            ///2: Rising edge 3.07V, falling edge 2.89V
            R307f289 = 2,
            ///3: Rising edge 3.27V, falling edge 3.08V
            R327f308 = 3,
            ///4: Rising edge 3.46V, falling edge 3.27V
            R346f327 = 4,
            ///5: Rising edge 3.76V, falling edge 3.55V
            R376f355 = 5,
            ///6: Rising edge 4.07V, falling edge 3.84V
            R407f384 = 6,
            ///7: Rising edge 4.43V, falling edge 4.13V
            R443f413 = 7,
        }
        impl From<PLS_A> for u8 {
            #[inline(always)]
            fn from(variant: PLS_A) -> Self {
                variant as _
            }
        }
        impl PLS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PLS_A {
                match self.bits {
                    0 => PLS_A::R265f250,
                    1 => PLS_A::R287f270,
                    2 => PLS_A::R307f289,
                    3 => PLS_A::R327f308,
                    4 => PLS_A::R346f327,
                    5 => PLS_A::R376f355,
                    6 => PLS_A::R407f384,
                    7 => PLS_A::R443f413,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `R265f250`
            #[inline(always)]
            pub fn is_r265f250(&self) -> bool {
                *self == PLS_A::R265f250
            }
            ///Checks if the value of the field is `R287f270`
            #[inline(always)]
            pub fn is_r287f270(&self) -> bool {
                *self == PLS_A::R287f270
            }
            ///Checks if the value of the field is `R307f289`
            #[inline(always)]
            pub fn is_r307f289(&self) -> bool {
                *self == PLS_A::R307f289
            }
            ///Checks if the value of the field is `R327f308`
            #[inline(always)]
            pub fn is_r327f308(&self) -> bool {
                *self == PLS_A::R327f308
            }
            ///Checks if the value of the field is `R346f327`
            #[inline(always)]
            pub fn is_r346f327(&self) -> bool {
                *self == PLS_A::R346f327
            }
            ///Checks if the value of the field is `R376f355`
            #[inline(always)]
            pub fn is_r376f355(&self) -> bool {
                *self == PLS_A::R376f355
            }
            ///Checks if the value of the field is `R407f384`
            #[inline(always)]
            pub fn is_r407f384(&self) -> bool {
                *self == PLS_A::R407f384
            }
            ///Checks if the value of the field is `R443f413`
            #[inline(always)]
            pub fn is_r443f413(&self) -> bool {
                *self == PLS_A::R443f413
            }
        }
        ///Field `PLS` writer - PVD Level Selection
        pub type PLS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CTLR_SPEC, u8, PLS_A, 3, O>;
        impl<'a, const O: u8> PLS_W<'a, O> {
            ///Rising edge 2.65V, falling edge 2.5V
            #[inline(always)]
            pub fn r265f250(self) -> &'a mut W {
                self.variant(PLS_A::R265f250)
            }
            ///Rising edge 2.87V, falling edge 2.7V
            #[inline(always)]
            pub fn r287f270(self) -> &'a mut W {
                self.variant(PLS_A::R287f270)
            }
            ///Rising edge 3.07V, falling edge 2.89V
            #[inline(always)]
            pub fn r307f289(self) -> &'a mut W {
                self.variant(PLS_A::R307f289)
            }
            ///Rising edge 3.27V, falling edge 3.08V
            #[inline(always)]
            pub fn r327f308(self) -> &'a mut W {
                self.variant(PLS_A::R327f308)
            }
            ///Rising edge 3.46V, falling edge 3.27V
            #[inline(always)]
            pub fn r346f327(self) -> &'a mut W {
                self.variant(PLS_A::R346f327)
            }
            ///Rising edge 3.76V, falling edge 3.55V
            #[inline(always)]
            pub fn r376f355(self) -> &'a mut W {
                self.variant(PLS_A::R376f355)
            }
            ///Rising edge 4.07V, falling edge 3.84V
            #[inline(always)]
            pub fn r407f384(self) -> &'a mut W {
                self.variant(PLS_A::R407f384)
            }
            ///Rising edge 4.43V, falling edge 4.13V
            #[inline(always)]
            pub fn r443f413(self) -> &'a mut W {
                self.variant(PLS_A::R443f413)
            }
        }
        ///Field `DBP` reader - Disable Backup Domain write protection
        pub type DBP_R = crate::BitReader<bool>;
        ///Field `DBP` writer - Disable Backup Domain write protection
        pub type DBP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Low Power Deep Sleep
            #[inline(always)]
            pub fn lpds(&self) -> LPDS_R {
                LPDS_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            pub fn pdds(&self) -> PDDS_R {
                PDDS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Clear Wake-up Flag
            #[inline(always)]
            pub fn cwuf(&self) -> CWUF_R {
                CWUF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Clear STANDBY Flag
            #[inline(always)]
            pub fn csbf(&self) -> CSBF_R {
                CSBF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            pub fn pvde(&self) -> PVDE_R {
                PVDE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            pub fn pls(&self) -> PLS_R {
                PLS_R::new(((self.bits >> 5) & 7) as u8)
            }
            ///Bit 8 - Disable Backup Domain write protection
            #[inline(always)]
            pub fn dbp(&self) -> DBP_R {
                DBP_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Low Power Deep Sleep
            #[inline(always)]
            #[must_use]
            pub fn lpds(&mut self) -> LPDS_W<0> {
                LPDS_W::new(self)
            }
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            #[must_use]
            pub fn pdds(&mut self) -> PDDS_W<1> {
                PDDS_W::new(self)
            }
            ///Bit 2 - Clear Wake-up Flag
            #[inline(always)]
            #[must_use]
            pub fn cwuf(&mut self) -> CWUF_W<2> {
                CWUF_W::new(self)
            }
            ///Bit 3 - Clear STANDBY Flag
            #[inline(always)]
            #[must_use]
            pub fn csbf(&mut self) -> CSBF_W<3> {
                CSBF_W::new(self)
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            #[must_use]
            pub fn pvde(&mut self) -> PVDE_W<4> {
                PVDE_W::new(self)
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            #[must_use]
            pub fn pls(&mut self) -> PLS_W<5> {
                PLS_W::new(self)
            }
            ///Bit 8 - Disable Backup Domain write protection
            #[inline(always)]
            #[must_use]
            pub fn dbp(&mut self) -> DBP_W<8> {
                DBP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Power control register (PWR_CTRL)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0c;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CSR (rw) register accessor: an alias for `Reg<CSR_SPEC>`
    pub type CSR = crate::Reg<csr::CSR_SPEC>;
    ///Power control register (PWR_CSR)
    pub mod csr {
        ///Register `CSR` reader
        pub struct R(crate::R<CSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CSR` writer
        pub struct W(crate::W<CSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CSR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WUF` reader - Wake-Up Flag
        pub type WUF_R = crate::BitReader<bool>;
        ///Field `SBF` reader - STANDBY Flag
        pub type SBF_R = crate::BitReader<bool>;
        ///Field `PVDO` reader - PVD Output
        pub type PVDO_R = crate::BitReader<PVDOR_A>;
        ///PVD Output
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PVDOR_A {
            ///0: VDD and VDDA is higher than PVD threshold
            Higher = 0,
            ///1: VDD and VDDA is lower than PVD threshold
            Lower = 1,
        }
        impl From<PVDOR_A> for bool {
            #[inline(always)]
            fn from(variant: PVDOR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PVDO_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PVDOR_A {
                match self.bits {
                    false => PVDOR_A::Higher,
                    true => PVDOR_A::Lower,
                }
            }
            ///Checks if the value of the field is `Higher`
            #[inline(always)]
            pub fn is_higher(&self) -> bool {
                *self == PVDOR_A::Higher
            }
            ///Checks if the value of the field is `Lower`
            #[inline(always)]
            pub fn is_lower(&self) -> bool {
                *self == PVDOR_A::Lower
            }
        }
        ///Field `EWUP` reader - Enable WKUP pin
        pub type EWUP_R = crate::BitReader<bool>;
        ///Field `EWUP` writer - Enable WKUP pin
        pub type EWUP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CSR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Wake-Up Flag
            #[inline(always)]
            pub fn wuf(&self) -> WUF_R {
                WUF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - STANDBY Flag
            #[inline(always)]
            pub fn sbf(&self) -> SBF_R {
                SBF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - PVD Output
            #[inline(always)]
            pub fn pvdo(&self) -> PVDO_R {
                PVDO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 8 - Enable WKUP pin
            #[inline(always)]
            pub fn ewup(&self) -> EWUP_R {
                EWUP_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - Enable WKUP pin
            #[inline(always)]
            #[must_use]
            pub fn ewup(&mut self) -> EWUP_W<8> {
                EWUP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Power control register (PWR_CSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [csr](index.html) module
        pub struct CSR_SPEC;
        impl crate::RegisterSpec for CSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [csr::R](R) reader structure
        impl crate::Readable for CSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [csr::W](W) writer structure
        impl crate::Writable for CSR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CSR to value 0
        impl crate::Resettable for CSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Reset and clock control
pub struct RCC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RCC {}
impl RCC {
    ///Pointer to the register block
    pub const PTR: *const rcc::RegisterBlock = 0x4002_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rcc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RCC {
    type Target = rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RCC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RCC").finish()
    }
}
///Reset and clock control
pub mod rcc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Clock control register
        pub ctlr: CTLR,
        ///0x04 - Clock configuration register(RCC_CFGR0)
        pub cfgr0: CFGR0,
        ///0x08 - Clock interrupt register(RCC_INTR)
        pub intr: INTR,
        ///0x0c - APB2 peripheral reset register(RCC_APB2PRSTR)
        pub apb2prstr: APB2PRSTR,
        ///0x10 - APB1 peripheral reset register(RCC_APB1PRSTR)
        pub apb1prstr: APB1PRSTR,
        ///0x14 - AHB Peripheral Clock enable register(RCC_AHBPCENR)
        pub ahbpcenr: AHBPCENR,
        ///0x18 - APB2 peripheral clock enable register (RCC_APB2PCENR)
        pub apb2pcenr: APB2PCENR,
        ///0x1c - APB1 peripheral clock enable register (RCC_APB1PCENR)
        pub apb1pcenr: APB1PCENR,
        ///0x20 - Backup domain control register(RCC_BDCTLR)
        pub bdctlr: BDCTLR,
        ///0x24 - Control/status register(RCC_RSTSCKR)
        pub rstsckr: RSTSCKR,
        ///0x28 - AHB reset register(RCC_APHBRSTR)
        pub ahbrstr: AHBRSTR,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Clock control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HSION` reader - Internal High Speed clock enable
        pub type HSION_R = crate::BitReader<HSION_A>;
        ///Internal High Speed clock enable
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HSION_A {
            ///0: System Off
            Off = 0,
            ///1: System On
            On = 1,
        }
        impl From<HSION_A> for bool {
            #[inline(always)]
            fn from(variant: HSION_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HSION_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HSION_A {
                match self.bits {
                    false => HSION_A::Off,
                    true => HSION_A::On,
                }
            }
            ///Checks if the value of the field is `Off`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == HSION_A::Off
            }
            ///Checks if the value of the field is `On`
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == HSION_A::On
            }
        }
        ///Field `HSION` writer - Internal High Speed clock enable
        pub type HSION_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, HSION_A, O>;
        impl<'a, const O: u8> HSION_W<'a, O> {
            ///System Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(HSION_A::Off)
            }
            ///System On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(HSION_A::On)
            }
        }
        ///Field `HSIRDY` reader - Internal High Speed clock ready flag
        pub type HSIRDY_R = crate::BitReader<HSIRDYR_A>;
        ///Internal High Speed clock ready flag
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HSIRDYR_A {
            ///0: Clock not ready
            NotReady = 0,
            ///1: Clock ready
            Ready = 1,
        }
        impl From<HSIRDYR_A> for bool {
            #[inline(always)]
            fn from(variant: HSIRDYR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HSIRDY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HSIRDYR_A {
                match self.bits {
                    false => HSIRDYR_A::NotReady,
                    true => HSIRDYR_A::Ready,
                }
            }
            ///Checks if the value of the field is `NotReady`
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == HSIRDYR_A::NotReady
            }
            ///Checks if the value of the field is `Ready`
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == HSIRDYR_A::Ready
            }
        }
        ///Field `HSITRIM` reader - Internal High Speed clock trimming
        pub type HSITRIM_R = crate::FieldReader<u8, u8>;
        ///Field `HSITRIM` writer - Internal High Speed clock trimming
        pub type HSITRIM_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR_SPEC, u8, u8, 5, O>;
        ///Field `HSICAL` reader - Internal High Speed clock Calibration
        pub type HSICAL_R = crate::FieldReader<u8, u8>;
        ///Field `HSEON` reader - External High Speed clock enable
        pub use HSION_R as HSEON_R;
        ///Field `HSEON` writer - External High Speed clock enable
        pub use HSION_W as HSEON_W;
        ///Field `HSERDY` reader - External High Speed clock ready flag
        pub use HSIRDY_R as HSERDY_R;
        ///Field `HSEBYP` reader - External High Speed clock Bypass
        pub type HSEBYP_R = crate::BitReader<HSEBYP_A>;
        ///External High Speed clock Bypass
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HSEBYP_A {
            ///0: HSE crystal oscillator not bypassed
            NotBypassed = 0,
            ///1: HSE crystal oscillator bypassed with external clock
            Bypassed = 1,
        }
        impl From<HSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: HSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HSEBYP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HSEBYP_A {
                match self.bits {
                    false => HSEBYP_A::NotBypassed,
                    true => HSEBYP_A::Bypassed,
                }
            }
            ///Checks if the value of the field is `NotBypassed`
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                *self == HSEBYP_A::NotBypassed
            }
            ///Checks if the value of the field is `Bypassed`
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                *self == HSEBYP_A::Bypassed
            }
        }
        ///Field `HSEBYP` writer - External High Speed clock Bypass
        pub type HSEBYP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, HSEBYP_A, O>;
        impl<'a, const O: u8> HSEBYP_W<'a, O> {
            ///HSE crystal oscillator not bypassed
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::NotBypassed)
            }
            ///HSE crystal oscillator bypassed with external clock
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::Bypassed)
            }
        }
        ///Field `CSSON` reader - Clock Security System enable
        pub use HSION_R as CSSON_R;
        ///Field `PLLON` reader - PLL enable
        pub use HSION_R as PLLON_R;
        ///Field `CSSON` writer - Clock Security System enable
        pub use HSION_W as CSSON_W;
        ///Field `PLLON` writer - PLL enable
        pub use HSION_W as PLLON_W;
        ///Field `PLLRDY` reader - PLL clock ready flag
        pub use HSIRDY_R as PLLRDY_R;
        impl R {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            pub fn hsion(&self) -> HSION_R {
                HSION_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Internal High Speed clock ready flag
            #[inline(always)]
            pub fn hsirdy(&self) -> HSIRDY_R {
                HSIRDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            pub fn hsitrim(&self) -> HSITRIM_R {
                HSITRIM_R::new(((self.bits >> 3) & 0x1f) as u8)
            }
            ///Bits 8:15 - Internal High Speed clock Calibration
            #[inline(always)]
            pub fn hsical(&self) -> HSICAL_R {
                HSICAL_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            pub fn hseon(&self) -> HSEON_R {
                HSEON_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - External High Speed clock ready flag
            #[inline(always)]
            pub fn hserdy(&self) -> HSERDY_R {
                HSERDY_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            pub fn hsebyp(&self) -> HSEBYP_R {
                HSEBYP_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            pub fn csson(&self) -> CSSON_R {
                CSSON_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            pub fn pllon(&self) -> PLLON_R {
                PLLON_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - PLL clock ready flag
            #[inline(always)]
            pub fn pllrdy(&self) -> PLLRDY_R {
                PLLRDY_R::new(((self.bits >> 25) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            #[must_use]
            pub fn hsion(&mut self) -> HSION_W<0> {
                HSION_W::new(self)
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            #[must_use]
            pub fn hsitrim(&mut self) -> HSITRIM_W<3> {
                HSITRIM_W::new(self)
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            #[must_use]
            pub fn hseon(&mut self) -> HSEON_W<16> {
                HSEON_W::new(self)
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            #[must_use]
            pub fn hsebyp(&mut self) -> HSEBYP_W<18> {
                HSEBYP_W::new(self)
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            #[must_use]
            pub fn csson(&mut self) -> CSSON_W<19> {
                CSSON_W::new(self)
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            #[must_use]
            pub fn pllon(&mut self) -> PLLON_W<24> {
                PLLON_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0x83
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x83;
        }
    }
    ///CFGR0 (rw) register accessor: an alias for `Reg<CFGR0_SPEC>`
    pub type CFGR0 = crate::Reg<cfgr0::CFGR0_SPEC>;
    ///Clock configuration register(RCC_CFGR0)
    pub mod cfgr0 {
        ///Register `CFGR0` reader
        pub struct R(crate::R<CFGR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR0` writer
        pub struct W(crate::W<CFGR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SW` reader - System clock Switch
        pub type SW_R = crate::FieldReader<u8, SW_A>;
        ///System clock Switch
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SW_A {
            ///0: HSI as system clock
            Hsi = 0,
            ///1: HSE as system clock
            Hse = 1,
            ///2: PLL as system clock
            Pll = 2,
        }
        impl From<SW_A> for u8 {
            #[inline(always)]
            fn from(variant: SW_A) -> Self {
                variant as _
            }
        }
        impl SW_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<SW_A> {
                match self.bits {
                    0 => Some(SW_A::Hsi),
                    1 => Some(SW_A::Hse),
                    2 => Some(SW_A::Pll),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Hsi`
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == SW_A::Hsi
            }
            ///Checks if the value of the field is `Hse`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == SW_A::Hse
            }
            ///Checks if the value of the field is `Pll`
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == SW_A::Pll
            }
        }
        ///Field `SW` writer - System clock Switch
        pub type SW_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, SW_A, 2, O>;
        impl<'a, const O: u8> SW_W<'a, O> {
            ///HSI as system clock
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(SW_A::Hsi)
            }
            ///HSE as system clock
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(SW_A::Hse)
            }
            ///PLL as system clock
            #[inline(always)]
            pub fn pll(self) -> &'a mut W {
                self.variant(SW_A::Pll)
            }
        }
        ///Field `SWS` reader - System Clock Switch Status
        pub type SWS_R = crate::FieldReader<u8, SWSR_A>;
        ///System Clock Switch Status
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SWSR_A {
            ///0: HSI as system clock
            Hsi = 0,
            ///1: HSE as system clock
            Hse = 1,
            ///2: PLL as system clock
            Pll = 2,
        }
        impl From<SWSR_A> for u8 {
            #[inline(always)]
            fn from(variant: SWSR_A) -> Self {
                variant as _
            }
        }
        impl SWS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<SWSR_A> {
                match self.bits {
                    0 => Some(SWSR_A::Hsi),
                    1 => Some(SWSR_A::Hse),
                    2 => Some(SWSR_A::Pll),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Hsi`
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == SWSR_A::Hsi
            }
            ///Checks if the value of the field is `Hse`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == SWSR_A::Hse
            }
            ///Checks if the value of the field is `Pll`
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                *self == SWSR_A::Pll
            }
        }
        ///Field `HPRE` reader - AHB prescaler
        pub type HPRE_R = crate::FieldReader<u8, HPRE_A>;
        ///AHB prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum HPRE_A {
            ///0: AHB clock source SYSCLK no division
            NoDiv = 0,
            ///8: AHB clock source SYSCLK divided by 2
            Div2 = 8,
            ///9: AHB clock source SYSCLK divided by 4
            Div4 = 9,
            ///10: AHB clock source SYSCLK divided by 8
            Div8 = 10,
            ///11: AHB clock source SYSCLK divided by 16
            Div16 = 11,
            ///12: AHB clock source SYSCLK divided by 64
            Div64 = 12,
            ///13: AHB clock source SYSCLK divided by 128
            Div128 = 13,
            ///14: AHB clock source SYSCLK divided by 256
            Div256 = 14,
            ///15: AHB clock source SYSCLK divided by 512
            Div512 = 15,
        }
        impl From<HPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: HPRE_A) -> Self {
                variant as _
            }
        }
        impl HPRE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<HPRE_A> {
                match self.bits {
                    0 => Some(HPRE_A::NoDiv),
                    8 => Some(HPRE_A::Div2),
                    9 => Some(HPRE_A::Div4),
                    10 => Some(HPRE_A::Div8),
                    11 => Some(HPRE_A::Div16),
                    12 => Some(HPRE_A::Div64),
                    13 => Some(HPRE_A::Div128),
                    14 => Some(HPRE_A::Div256),
                    15 => Some(HPRE_A::Div512),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == HPRE_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == HPRE_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == HPRE_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == HPRE_A::Div8
            }
            ///Checks if the value of the field is `Div16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == HPRE_A::Div16
            }
            ///Checks if the value of the field is `Div64`
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == HPRE_A::Div64
            }
            ///Checks if the value of the field is `Div128`
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == HPRE_A::Div128
            }
            ///Checks if the value of the field is `Div256`
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == HPRE_A::Div256
            }
            ///Checks if the value of the field is `Div512`
            #[inline(always)]
            pub fn is_div512(&self) -> bool {
                *self == HPRE_A::Div512
            }
        }
        ///Field `HPRE` writer - AHB prescaler
        pub type HPRE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, HPRE_A, 4, O>;
        impl<'a, const O: u8> HPRE_W<'a, O> {
            ///AHB clock source SYSCLK no division
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(HPRE_A::NoDiv)
            }
            ///AHB clock source SYSCLK divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(HPRE_A::Div2)
            }
            ///AHB clock source SYSCLK divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(HPRE_A::Div4)
            }
            ///AHB clock source SYSCLK divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(HPRE_A::Div8)
            }
            ///AHB clock source SYSCLK divided by 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(HPRE_A::Div16)
            }
            ///AHB clock source SYSCLK divided by 64
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(HPRE_A::Div64)
            }
            ///AHB clock source SYSCLK divided by 128
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(HPRE_A::Div128)
            }
            ///AHB clock source SYSCLK divided by 256
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(HPRE_A::Div256)
            }
            ///AHB clock source SYSCLK divided by 512
            #[inline(always)]
            pub fn div512(self) -> &'a mut W {
                self.variant(HPRE_A::Div512)
            }
        }
        ///Field `PPRE1` reader - APB Low speed prescaler(APB1)
        pub type PPRE1_R = crate::FieldReader<u8, PPRE1_A>;
        ///APB Low speed prescaler(APB1)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PPRE1_A {
            ///0: APB clock source HCLK no division
            NoDiv = 0,
            ///4: APB clock source HCLK divided by 2
            Div2 = 4,
            ///5: APB clock source HCLK divided by 4
            Div4 = 5,
            ///6: APB clock source HCLK divided by 8
            Div8 = 6,
            ///7: APB clock source HCLK divided by 16
            Div16 = 7,
        }
        impl From<PPRE1_A> for u8 {
            #[inline(always)]
            fn from(variant: PPRE1_A) -> Self {
                variant as _
            }
        }
        impl PPRE1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PPRE1_A> {
                match self.bits {
                    0 => Some(PPRE1_A::NoDiv),
                    4 => Some(PPRE1_A::Div2),
                    5 => Some(PPRE1_A::Div4),
                    6 => Some(PPRE1_A::Div8),
                    7 => Some(PPRE1_A::Div16),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == PPRE1_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PPRE1_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PPRE1_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PPRE1_A::Div8
            }
            ///Checks if the value of the field is `Div16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PPRE1_A::Div16
            }
        }
        ///Field `PPRE1` writer - APB Low speed prescaler(APB1)
        pub type PPRE1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, PPRE1_A, 3, O>;
        impl<'a, const O: u8> PPRE1_W<'a, O> {
            ///APB clock source HCLK no division
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(PPRE1_A::NoDiv)
            }
            ///APB clock source HCLK divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE1_A::Div2)
            }
            ///APB clock source HCLK divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE1_A::Div4)
            }
            ///APB clock source HCLK divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE1_A::Div8)
            }
            ///APB clock source HCLK divided by 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE1_A::Div16)
            }
        }
        ///Field `PPRE2` reader - APB High speed prescaler(APB2)
        pub use PPRE1_R as PPRE2_R;
        ///Field `PPRE2` writer - APB High speed prescaler(APB2)
        pub use PPRE1_W as PPRE2_W;
        ///Field `ADCPRE` reader - ADC prescaler
        pub type ADCPRE_R = crate::FieldReader<u8, ADCPRE_A>;
        ///ADC prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ADCPRE_A {
            ///0: ADC clock source PCLK2 divided by 2
            Div2 = 0,
            ///1: ADC clock source PCLK2 divided by 4
            Div4 = 1,
            ///2: ADC clock source PCLK2 divided by 6
            Div6 = 2,
            ///3: ADC clock source PCLK2 divided by 8
            Div8 = 3,
        }
        impl From<ADCPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: ADCPRE_A) -> Self {
                variant as _
            }
        }
        impl ADCPRE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADCPRE_A {
                match self.bits {
                    0 => ADCPRE_A::Div2,
                    1 => ADCPRE_A::Div4,
                    2 => ADCPRE_A::Div6,
                    3 => ADCPRE_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ADCPRE_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ADCPRE_A::Div4
            }
            ///Checks if the value of the field is `Div6`
            #[inline(always)]
            pub fn is_div6(&self) -> bool {
                *self == ADCPRE_A::Div6
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ADCPRE_A::Div8
            }
        }
        ///Field `ADCPRE` writer - ADC prescaler
        pub type ADCPRE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR0_SPEC, u8, ADCPRE_A, 2, O>;
        impl<'a, const O: u8> ADCPRE_W<'a, O> {
            ///ADC clock source PCLK2 divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ADCPRE_A::Div2)
            }
            ///ADC clock source PCLK2 divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ADCPRE_A::Div4)
            }
            ///ADC clock source PCLK2 divided by 6
            #[inline(always)]
            pub fn div6(self) -> &'a mut W {
                self.variant(ADCPRE_A::Div6)
            }
            ///ADC clock source PCLK2 divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ADCPRE_A::Div8)
            }
        }
        ///Field `PLLSRC` reader - PLL entry clock source
        pub type PLLSRC_R = crate::BitReader<PLLSRC_A>;
        ///PLL entry clock source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PLLSRC_A {
            ///0: HSI as PLL clock source
            Hsi = 0,
            ///1: HSE as PLL clock source
            Hse = 1,
        }
        impl From<PLLSRC_A> for bool {
            #[inline(always)]
            fn from(variant: PLLSRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PLLSRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PLLSRC_A {
                match self.bits {
                    false => PLLSRC_A::Hsi,
                    true => PLLSRC_A::Hse,
                }
            }
            ///Checks if the value of the field is `Hsi`
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == PLLSRC_A::Hsi
            }
            ///Checks if the value of the field is `Hse`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == PLLSRC_A::Hse
            }
        }
        ///Field `PLLSRC` writer - PLL entry clock source
        pub type PLLSRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR0_SPEC, PLLSRC_A, O>;
        impl<'a, const O: u8> PLLSRC_W<'a, O> {
            ///HSI as PLL clock source
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(PLLSRC_A::Hsi)
            }
            ///HSE as PLL clock source
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(PLLSRC_A::Hse)
            }
        }
        ///Field `PLLXTPRE` reader - HSE divider for PLL entry
        pub type PLLXTPRE_R = crate::BitReader<PLLXTPRE_A>;
        ///HSE divider for PLL entry
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PLLXTPRE_A {
            ///0: PLL clock source HSE no division
            NoDiv = 0,
            ///1: PLL clock source HSE divided by 2
            Div2 = 1,
        }
        impl From<PLLXTPRE_A> for bool {
            #[inline(always)]
            fn from(variant: PLLXTPRE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PLLXTPRE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PLLXTPRE_A {
                match self.bits {
                    false => PLLXTPRE_A::NoDiv,
                    true => PLLXTPRE_A::Div2,
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == PLLXTPRE_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == PLLXTPRE_A::Div2
            }
        }
        ///Field `PLLXTPRE` writer - HSE divider for PLL entry
        pub type PLLXTPRE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR0_SPEC, PLLXTPRE_A, O>;
        impl<'a, const O: u8> PLLXTPRE_W<'a, O> {
            ///PLL clock source HSE no division
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(PLLXTPRE_A::NoDiv)
            }
            ///PLL clock source HSE divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PLLXTPRE_A::Div2)
            }
        }
        ///Field `PLLMUL` reader - PLL Multiplication Factor
        pub type PLLMUL_R = crate::FieldReader<u8, PLLMUL_A>;
        ///PLL Multiplication Factor
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PLLMUL_A {
            ///0: PLL output multiplier 2
            Mul2 = 0,
            ///1: PLL output multiplier 3
            Mul3 = 1,
            ///2: PLL output multiplier 4
            Mul4 = 2,
            ///3: PLL output multiplier 5
            Mul5 = 3,
            ///4: PLL output multiplier 6
            Mul6 = 4,
            ///5: PLL output multiplier 7
            Mul7 = 5,
            ///6: PLL output multiplier 8
            Mul8 = 6,
            ///7: PLL output multiplier 9
            Mul9 = 7,
            ///8: PLL output multiplier 10
            Mul10 = 8,
            ///9: PLL output multiplier 11
            Mul11 = 9,
            ///10: PLL output multiplier 12
            Mul12 = 10,
            ///11: PLL output multiplier 13
            Mul13 = 11,
            ///12: PLL output multiplier 14
            Mul14 = 12,
            ///13: PLL output multiplier 15
            Mul15 = 13,
            ///14: PLL output multiplier 16
            Mul16 = 14,
        }
        impl From<PLLMUL_A> for u8 {
            #[inline(always)]
            fn from(variant: PLLMUL_A) -> Self {
                variant as _
            }
        }
        impl PLLMUL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PLLMUL_A> {
                match self.bits {
                    0 => Some(PLLMUL_A::Mul2),
                    1 => Some(PLLMUL_A::Mul3),
                    2 => Some(PLLMUL_A::Mul4),
                    3 => Some(PLLMUL_A::Mul5),
                    4 => Some(PLLMUL_A::Mul6),
                    5 => Some(PLLMUL_A::Mul7),
                    6 => Some(PLLMUL_A::Mul8),
                    7 => Some(PLLMUL_A::Mul9),
                    8 => Some(PLLMUL_A::Mul10),
                    9 => Some(PLLMUL_A::Mul11),
                    10 => Some(PLLMUL_A::Mul12),
                    11 => Some(PLLMUL_A::Mul13),
                    12 => Some(PLLMUL_A::Mul14),
                    13 => Some(PLLMUL_A::Mul15),
                    14 => Some(PLLMUL_A::Mul16),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Mul2`
            #[inline(always)]
            pub fn is_mul2(&self) -> bool {
                *self == PLLMUL_A::Mul2
            }
            ///Checks if the value of the field is `Mul3`
            #[inline(always)]
            pub fn is_mul3(&self) -> bool {
                *self == PLLMUL_A::Mul3
            }
            ///Checks if the value of the field is `Mul4`
            #[inline(always)]
            pub fn is_mul4(&self) -> bool {
                *self == PLLMUL_A::Mul4
            }
            ///Checks if the value of the field is `Mul5`
            #[inline(always)]
            pub fn is_mul5(&self) -> bool {
                *self == PLLMUL_A::Mul5
            }
            ///Checks if the value of the field is `Mul6`
            #[inline(always)]
            pub fn is_mul6(&self) -> bool {
                *self == PLLMUL_A::Mul6
            }
            ///Checks if the value of the field is `Mul7`
            #[inline(always)]
            pub fn is_mul7(&self) -> bool {
                *self == PLLMUL_A::Mul7
            }
            ///Checks if the value of the field is `Mul8`
            #[inline(always)]
            pub fn is_mul8(&self) -> bool {
                *self == PLLMUL_A::Mul8
            }
            ///Checks if the value of the field is `Mul9`
            #[inline(always)]
            pub fn is_mul9(&self) -> bool {
                *self == PLLMUL_A::Mul9
            }
            ///Checks if the value of the field is `Mul10`
            #[inline(always)]
            pub fn is_mul10(&self) -> bool {
                *self == PLLMUL_A::Mul10
            }
            ///Checks if the value of the field is `Mul11`
            #[inline(always)]
            pub fn is_mul11(&self) -> bool {
                *self == PLLMUL_A::Mul11
            }
            ///Checks if the value of the field is `Mul12`
            #[inline(always)]
            pub fn is_mul12(&self) -> bool {
                *self == PLLMUL_A::Mul12
            }
            ///Checks if the value of the field is `Mul13`
            #[inline(always)]
            pub fn is_mul13(&self) -> bool {
                *self == PLLMUL_A::Mul13
            }
            ///Checks if the value of the field is `Mul14`
            #[inline(always)]
            pub fn is_mul14(&self) -> bool {
                *self == PLLMUL_A::Mul14
            }
            ///Checks if the value of the field is `Mul15`
            #[inline(always)]
            pub fn is_mul15(&self) -> bool {
                *self == PLLMUL_A::Mul15
            }
            ///Checks if the value of the field is `Mul16`
            #[inline(always)]
            pub fn is_mul16(&self) -> bool {
                *self == PLLMUL_A::Mul16
            }
        }
        ///Field `PLLMUL` writer - PLL Multiplication Factor
        pub type PLLMUL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, PLLMUL_A, 4, O>;
        impl<'a, const O: u8> PLLMUL_W<'a, O> {
            ///PLL output multiplier 2
            #[inline(always)]
            pub fn mul2(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul2)
            }
            ///PLL output multiplier 3
            #[inline(always)]
            pub fn mul3(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul3)
            }
            ///PLL output multiplier 4
            #[inline(always)]
            pub fn mul4(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul4)
            }
            ///PLL output multiplier 5
            #[inline(always)]
            pub fn mul5(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul5)
            }
            ///PLL output multiplier 6
            #[inline(always)]
            pub fn mul6(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul6)
            }
            ///PLL output multiplier 7
            #[inline(always)]
            pub fn mul7(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul7)
            }
            ///PLL output multiplier 8
            #[inline(always)]
            pub fn mul8(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul8)
            }
            ///PLL output multiplier 9
            #[inline(always)]
            pub fn mul9(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul9)
            }
            ///PLL output multiplier 10
            #[inline(always)]
            pub fn mul10(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul10)
            }
            ///PLL output multiplier 11
            #[inline(always)]
            pub fn mul11(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul11)
            }
            ///PLL output multiplier 12
            #[inline(always)]
            pub fn mul12(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul12)
            }
            ///PLL output multiplier 13
            #[inline(always)]
            pub fn mul13(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul13)
            }
            ///PLL output multiplier 14
            #[inline(always)]
            pub fn mul14(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul14)
            }
            ///PLL output multiplier 15
            #[inline(always)]
            pub fn mul15(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul15)
            }
            ///PLL output multiplier 16
            #[inline(always)]
            pub fn mul16(self) -> &'a mut W {
                self.variant(PLLMUL_A::Mul16)
            }
        }
        ///Field `USBPRE` reader - USB prescaler
        pub type USBPRE_R = crate::BitReader<USBPRE_A>;
        ///USB prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum USBPRE_A {
            ///1: USB clock source use PLL directly
            Direct = 1,
            ///0: USB clock source PLL divided by 1.5
            Pll1p5 = 0,
        }
        impl From<USBPRE_A> for bool {
            #[inline(always)]
            fn from(variant: USBPRE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl USBPRE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> USBPRE_A {
                match self.bits {
                    true => USBPRE_A::Direct,
                    false => USBPRE_A::Pll1p5,
                }
            }
            ///Checks if the value of the field is `Direct`
            #[inline(always)]
            pub fn is_direct(&self) -> bool {
                *self == USBPRE_A::Direct
            }
            ///Checks if the value of the field is `Pll1p5`
            #[inline(always)]
            pub fn is_pll1p5(&self) -> bool {
                *self == USBPRE_A::Pll1p5
            }
        }
        ///Field `USBPRE` writer - USB prescaler
        pub type USBPRE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR0_SPEC, USBPRE_A, O>;
        impl<'a, const O: u8> USBPRE_W<'a, O> {
            ///USB clock source use PLL directly
            #[inline(always)]
            pub fn direct(self) -> &'a mut W {
                self.variant(USBPRE_A::Direct)
            }
            ///USB clock source PLL divided by 1.5
            #[inline(always)]
            pub fn pll1p5(self) -> &'a mut W {
                self.variant(USBPRE_A::Pll1p5)
            }
        }
        ///Field `MCO` reader - Microcontroller clock output
        pub type MCO_R = crate::FieldReader<u8, MCO_A>;
        ///Microcontroller clock output
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MCO_A {
            ///0: No microcontroller clock output
            NoOutput = 0,
            ///4: Output SYSCLK
            Sysclk = 4,
            ///5: Output HSI
            Hsi = 5,
            ///6: Output HSE
            Hse = 6,
            ///7: Output PLL divided by 2
            Plldiv2 = 7,
        }
        impl From<MCO_A> for u8 {
            #[inline(always)]
            fn from(variant: MCO_A) -> Self {
                variant as _
            }
        }
        impl MCO_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MCO_A> {
                match self.bits {
                    0 => Some(MCO_A::NoOutput),
                    4 => Some(MCO_A::Sysclk),
                    5 => Some(MCO_A::Hsi),
                    6 => Some(MCO_A::Hse),
                    7 => Some(MCO_A::Plldiv2),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NoOutput`
            #[inline(always)]
            pub fn is_no_output(&self) -> bool {
                *self == MCO_A::NoOutput
            }
            ///Checks if the value of the field is `Sysclk`
            #[inline(always)]
            pub fn is_sysclk(&self) -> bool {
                *self == MCO_A::Sysclk
            }
            ///Checks if the value of the field is `Hsi`
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                *self == MCO_A::Hsi
            }
            ///Checks if the value of the field is `Hse`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == MCO_A::Hse
            }
            ///Checks if the value of the field is `Plldiv2`
            #[inline(always)]
            pub fn is_plldiv2(&self) -> bool {
                *self == MCO_A::Plldiv2
            }
        }
        ///Field `MCO` writer - Microcontroller clock output
        pub type MCO_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, MCO_A, 3, O>;
        impl<'a, const O: u8> MCO_W<'a, O> {
            ///No microcontroller clock output
            #[inline(always)]
            pub fn no_output(self) -> &'a mut W {
                self.variant(MCO_A::NoOutput)
            }
            ///Output SYSCLK
            #[inline(always)]
            pub fn sysclk(self) -> &'a mut W {
                self.variant(MCO_A::Sysclk)
            }
            ///Output HSI
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(MCO_A::Hsi)
            }
            ///Output HSE
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(MCO_A::Hse)
            }
            ///Output PLL divided by 2
            #[inline(always)]
            pub fn plldiv2(self) -> &'a mut W {
                self.variant(MCO_A::Plldiv2)
            }
        }
        impl R {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            pub fn sw(&self) -> SW_R {
                SW_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - System Clock Switch Status
            #[inline(always)]
            pub fn sws(&self) -> SWS_R {
                SWS_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            pub fn hpre(&self) -> HPRE_R {
                HPRE_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:10 - APB Low speed prescaler(APB1)
            #[inline(always)]
            pub fn ppre1(&self) -> PPRE1_R {
                PPRE1_R::new(((self.bits >> 8) & 7) as u8)
            }
            ///Bits 11:13 - APB High speed prescaler(APB2)
            #[inline(always)]
            pub fn ppre2(&self) -> PPRE2_R {
                PPRE2_R::new(((self.bits >> 11) & 7) as u8)
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            pub fn adcpre(&self) -> ADCPRE_R {
                ADCPRE_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            pub fn pllsrc(&self) -> PLLSRC_R {
                PLLSRC_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - HSE divider for PLL entry
            #[inline(always)]
            pub fn pllxtpre(&self) -> PLLXTPRE_R {
                PLLXTPRE_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bits 18:21 - PLL Multiplication Factor
            #[inline(always)]
            pub fn pllmul(&self) -> PLLMUL_R {
                PLLMUL_R::new(((self.bits >> 18) & 0x0f) as u8)
            }
            ///Bit 22 - USB prescaler
            #[inline(always)]
            pub fn usbpre(&self) -> USBPRE_R {
                USBPRE_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            pub fn mco(&self) -> MCO_R {
                MCO_R::new(((self.bits >> 24) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            #[must_use]
            pub fn sw(&mut self) -> SW_W<0> {
                SW_W::new(self)
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            #[must_use]
            pub fn hpre(&mut self) -> HPRE_W<4> {
                HPRE_W::new(self)
            }
            ///Bits 8:10 - APB Low speed prescaler(APB1)
            #[inline(always)]
            #[must_use]
            pub fn ppre1(&mut self) -> PPRE1_W<8> {
                PPRE1_W::new(self)
            }
            ///Bits 11:13 - APB High speed prescaler(APB2)
            #[inline(always)]
            #[must_use]
            pub fn ppre2(&mut self) -> PPRE2_W<11> {
                PPRE2_W::new(self)
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            #[must_use]
            pub fn adcpre(&mut self) -> ADCPRE_W<14> {
                ADCPRE_W::new(self)
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            #[must_use]
            pub fn pllsrc(&mut self) -> PLLSRC_W<16> {
                PLLSRC_W::new(self)
            }
            ///Bit 17 - HSE divider for PLL entry
            #[inline(always)]
            #[must_use]
            pub fn pllxtpre(&mut self) -> PLLXTPRE_W<17> {
                PLLXTPRE_W::new(self)
            }
            ///Bits 18:21 - PLL Multiplication Factor
            #[inline(always)]
            #[must_use]
            pub fn pllmul(&mut self) -> PLLMUL_W<18> {
                PLLMUL_W::new(self)
            }
            ///Bit 22 - USB prescaler
            #[inline(always)]
            #[must_use]
            pub fn usbpre(&mut self) -> USBPRE_W<22> {
                USBPRE_W::new(self)
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            #[must_use]
            pub fn mco(&mut self) -> MCO_W<24> {
                MCO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock configuration register(RCC_CFGR0)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr0](index.html) module
        pub struct CFGR0_SPEC;
        impl crate::RegisterSpec for CFGR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr0::R](R) reader structure
        impl crate::Readable for CFGR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr0::W](W) writer structure
        impl crate::Writable for CFGR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR0 to value 0
        impl crate::Resettable for CFGR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTR (rw) register accessor: an alias for `Reg<INTR_SPEC>`
    pub type INTR = crate::Reg<intr::INTR_SPEC>;
    ///Clock interrupt register(RCC_INTR)
    pub mod intr {
        ///Register `INTR` reader
        pub struct R(crate::R<INTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTR` writer
        pub struct W(crate::W<INTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LSIRDYF` reader - LSI Ready Interrupt flag
        pub type LSIRDYF_R = crate::BitReader<LSIRDYFR_A>;
        ///LSI Ready Interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSIRDYFR_A {
            ///0: No interrupt occurred
            NotInterrupted = 0,
            ///1: Interrupt occurred
            Interrupted = 1,
        }
        impl From<LSIRDYFR_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSIRDYF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSIRDYFR_A {
                match self.bits {
                    false => LSIRDYFR_A::NotInterrupted,
                    true => LSIRDYFR_A::Interrupted,
                }
            }
            ///Checks if the value of the field is `NotInterrupted`
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == LSIRDYFR_A::NotInterrupted
            }
            ///Checks if the value of the field is `Interrupted`
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == LSIRDYFR_A::Interrupted
            }
        }
        ///Field `LSERDYF` reader - LSE Ready Interrupt flag
        pub use LSIRDYF_R as LSERDYF_R;
        ///Field `HSIRDYF` reader - HSI Ready Interrupt flag
        pub use LSIRDYF_R as HSIRDYF_R;
        ///Field `HSERDYF` reader - HSE Ready Interrupt flag
        pub use LSIRDYF_R as HSERDYF_R;
        ///Field `PLLRDYF` reader - PLL Ready Interrupt flag
        pub use LSIRDYF_R as PLLRDYF_R;
        ///Field `CSSF` reader - Clock Security System Interrupt flag
        pub use LSIRDYF_R as CSSF_R;
        ///Field `LSIRDYIE` reader - LSI Ready Interrupt Enable
        pub type LSIRDYIE_R = crate::BitReader<LSIRDYIE_A>;
        ///LSI Ready Interrupt Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSIRDYIE_A {
            ///0: Ready interrupt disabled
            Disabled = 0,
            ///1: Ready interrupt enabled
            Enabled = 1,
        }
        impl From<LSIRDYIE_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSIRDYIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSIRDYIE_A {
                match self.bits {
                    false => LSIRDYIE_A::Disabled,
                    true => LSIRDYIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LSIRDYIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LSIRDYIE_A::Enabled
            }
        }
        ///Field `LSIRDYIE` writer - LSI Ready Interrupt Enable
        pub type LSIRDYIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, LSIRDYIE_A, O>;
        impl<'a, const O: u8> LSIRDYIE_W<'a, O> {
            ///Ready interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::Disabled)
            }
            ///Ready interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::Enabled)
            }
        }
        ///Field `LSERDYIE` reader - LSE Ready Interrupt Enable
        pub use LSIRDYIE_R as LSERDYIE_R;
        ///Field `HSIRDYIE` reader - HSI Ready Interrupt Enable
        pub use LSIRDYIE_R as HSIRDYIE_R;
        ///Field `HSERDYIE` reader - HSE Ready Interrupt Enable
        pub use LSIRDYIE_R as HSERDYIE_R;
        ///Field `PLLRDYIE` reader - PLL Ready Interrupt Enable
        pub use LSIRDYIE_R as PLLRDYIE_R;
        ///Field `LSERDYIE` writer - LSE Ready Interrupt Enable
        pub use LSIRDYIE_W as LSERDYIE_W;
        ///Field `HSIRDYIE` writer - HSI Ready Interrupt Enable
        pub use LSIRDYIE_W as HSIRDYIE_W;
        ///Field `HSERDYIE` writer - HSE Ready Interrupt Enable
        pub use LSIRDYIE_W as HSERDYIE_W;
        ///Field `PLLRDYIE` writer - PLL Ready Interrupt Enable
        pub use LSIRDYIE_W as PLLRDYIE_W;
        ///LSI Ready Interrupt Clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSIRDYCW_AW {
            ///1: Clear interrupt flag
            Clear = 1,
        }
        impl From<LSIRDYCW_AW> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYCW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSIRDYC` writer - LSI Ready Interrupt Clear
        pub type LSIRDYC_W<'a, const O: u8> =
            crate::BitWriter1C<'a, u32, INTR_SPEC, LSIRDYCW_AW, O>;
        impl<'a, const O: u8> LSIRDYC_W<'a, O> {
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYCW_AW::Clear)
            }
        }
        ///Field `LSERDYC` writer - LSE Ready Interrupt Clear
        pub use LSIRDYC_W as LSERDYC_W;
        ///Field `HSIRDYC` writer - HSI Ready Interrupt Clear
        pub use LSIRDYC_W as HSIRDYC_W;
        ///Field `HSERDYC` writer - HSE Ready Interrupt Clear
        pub use LSIRDYC_W as HSERDYC_W;
        ///Field `PLLRDYC` writer - PLL Ready Interrupt Clear
        pub use LSIRDYC_W as PLLRDYC_W;
        ///Field `CSSC` writer - Clock security system interrupt clear
        pub use LSIRDYC_W as CSSC_W;
        impl R {
            ///Bit 0 - LSI Ready Interrupt flag
            #[inline(always)]
            pub fn lsirdyf(&self) -> LSIRDYF_R {
                LSIRDYF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - LSE Ready Interrupt flag
            #[inline(always)]
            pub fn lserdyf(&self) -> LSERDYF_R {
                LSERDYF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - HSI Ready Interrupt flag
            #[inline(always)]
            pub fn hsirdyf(&self) -> HSIRDYF_R {
                HSIRDYF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - HSE Ready Interrupt flag
            #[inline(always)]
            pub fn hserdyf(&self) -> HSERDYF_R {
                HSERDYF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PLL Ready Interrupt flag
            #[inline(always)]
            pub fn pllrdyf(&self) -> PLLRDYF_R {
                PLLRDYF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - Clock Security System Interrupt flag
            #[inline(always)]
            pub fn cssf(&self) -> CSSF_R {
                CSSF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            pub fn lsirdyie(&self) -> LSIRDYIE_R {
                LSIRDYIE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - LSE Ready Interrupt Enable
            #[inline(always)]
            pub fn lserdyie(&self) -> LSERDYIE_R {
                LSERDYIE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            pub fn hsirdyie(&self) -> HSIRDYIE_R {
                HSIRDYIE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            pub fn hserdyie(&self) -> HSERDYIE_R {
                HSERDYIE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            pub fn pllrdyie(&self) -> PLLRDYIE_R {
                PLLRDYIE_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn lsirdyie(&mut self) -> LSIRDYIE_W<8> {
                LSIRDYIE_W::new(self)
            }
            ///Bit 9 - LSE Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn lserdyie(&mut self) -> LSERDYIE_W<9> {
                LSERDYIE_W::new(self)
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn hsirdyie(&mut self) -> HSIRDYIE_W<10> {
                HSIRDYIE_W::new(self)
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn hserdyie(&mut self) -> HSERDYIE_W<11> {
                HSERDYIE_W::new(self)
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn pllrdyie(&mut self) -> PLLRDYIE_W<12> {
                PLLRDYIE_W::new(self)
            }
            ///Bit 16 - LSI Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn lsirdyc(&mut self) -> LSIRDYC_W<16> {
                LSIRDYC_W::new(self)
            }
            ///Bit 17 - LSE Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn lserdyc(&mut self) -> LSERDYC_W<17> {
                LSERDYC_W::new(self)
            }
            ///Bit 18 - HSI Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn hsirdyc(&mut self) -> HSIRDYC_W<18> {
                HSIRDYC_W::new(self)
            }
            ///Bit 19 - HSE Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn hserdyc(&mut self) -> HSERDYC_W<19> {
                HSERDYC_W::new(self)
            }
            ///Bit 20 - PLL Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn pllrdyc(&mut self) -> PLLRDYC_W<20> {
                PLLRDYC_W::new(self)
            }
            ///Bit 23 - Clock security system interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cssc(&mut self) -> CSSC_W<23> {
                CSSC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock interrupt register(RCC_INTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intr](index.html) module
        pub struct INTR_SPEC;
        impl crate::RegisterSpec for INTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intr::R](R) reader structure
        impl crate::Readable for INTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intr::W](W) writer structure
        impl crate::Writable for INTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x009f_0000;
        }
        ///`reset()` method sets INTR to value 0
        impl crate::Resettable for INTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///APB2PRSTR (rw) register accessor: an alias for `Reg<APB2PRSTR_SPEC>`
    pub type APB2PRSTR = crate::Reg<apb2prstr::APB2PRSTR_SPEC>;
    ///APB2 peripheral reset register(RCC_APB2PRSTR)
    pub mod apb2prstr {
        ///Register `APB2PRSTR` reader
        pub struct R(crate::R<APB2PRSTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB2PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB2PRSTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB2PRSTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB2PRSTR` writer
        pub struct W(crate::W<APB2PRSTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB2PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB2PRSTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB2PRSTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AFIORST` reader - Alternate function I/O reset
        pub type AFIORST_R = crate::BitReader<AFIORSTW_A>;
        ///Alternate function I/O reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AFIORSTW_A {
            ///1: Reset peripheral
            Reset = 1,
        }
        impl From<AFIORSTW_A> for bool {
            #[inline(always)]
            fn from(variant: AFIORSTW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl AFIORST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<AFIORSTW_A> {
                match self.bits {
                    true => Some(AFIORSTW_A::Reset),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == AFIORSTW_A::Reset
            }
        }
        ///Field `AFIORST` writer - Alternate function I/O reset
        pub type AFIORST_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, APB2PRSTR_SPEC, AFIORSTW_A, O>;
        impl<'a, const O: u8> AFIORST_W<'a, O> {
            ///Reset peripheral
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW_A::Reset)
            }
        }
        ///Field `IOPARST` reader - IO port A reset
        pub use AFIORST_R as IOPARST_R;
        ///Field `IOPBRST` reader - IO port B reset
        pub use AFIORST_R as IOPBRST_R;
        ///Field `IOPCRST` reader - IO port C reset
        pub use AFIORST_R as IOPCRST_R;
        ///Field `IOPDRST` reader - IO port D reset
        pub use AFIORST_R as IOPDRST_R;
        ///Field `ADCRST` reader - ADC interface reset
        pub use AFIORST_R as ADCRST_R;
        ///Field `TIM1RST` reader - TIM1 timer reset
        pub use AFIORST_R as TIM1RST_R;
        ///Field `SPI1RST` reader - SPI 1 reset
        pub use AFIORST_R as SPI1RST_R;
        ///Field `USART1RST` reader - USART1 reset
        pub use AFIORST_R as USART1RST_R;
        ///Field `IOPARST` writer - IO port A reset
        pub use AFIORST_W as IOPARST_W;
        ///Field `IOPBRST` writer - IO port B reset
        pub use AFIORST_W as IOPBRST_W;
        ///Field `IOPCRST` writer - IO port C reset
        pub use AFIORST_W as IOPCRST_W;
        ///Field `IOPDRST` writer - IO port D reset
        pub use AFIORST_W as IOPDRST_W;
        ///Field `ADCRST` writer - ADC interface reset
        pub use AFIORST_W as ADCRST_W;
        ///Field `TIM1RST` writer - TIM1 timer reset
        pub use AFIORST_W as TIM1RST_W;
        ///Field `SPI1RST` writer - SPI 1 reset
        pub use AFIORST_W as SPI1RST_W;
        ///Field `USART1RST` writer - USART1 reset
        pub use AFIORST_W as USART1RST_W;
        impl R {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            pub fn afiorst(&self) -> AFIORST_R {
                AFIORST_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            pub fn ioparst(&self) -> IOPARST_R {
                IOPARST_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - IO port B reset
            #[inline(always)]
            pub fn iopbrst(&self) -> IOPBRST_R {
                IOPBRST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            pub fn iopcrst(&self) -> IOPCRST_R {
                IOPCRST_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            pub fn iopdrst(&self) -> IOPDRST_R {
                IOPDRST_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 9 - ADC interface reset
            #[inline(always)]
            pub fn adcrst(&self) -> ADCRST_R {
                ADCRST_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            pub fn tim1rst(&self) -> TIM1RST_R {
                TIM1RST_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            pub fn spi1rst(&self) -> SPI1RST_R {
                SPI1RST_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            pub fn usart1rst(&self) -> USART1RST_R {
                USART1RST_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            #[must_use]
            pub fn afiorst(&mut self) -> AFIORST_W<0> {
                AFIORST_W::new(self)
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            #[must_use]
            pub fn ioparst(&mut self) -> IOPARST_W<2> {
                IOPARST_W::new(self)
            }
            ///Bit 3 - IO port B reset
            #[inline(always)]
            #[must_use]
            pub fn iopbrst(&mut self) -> IOPBRST_W<3> {
                IOPBRST_W::new(self)
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            #[must_use]
            pub fn iopcrst(&mut self) -> IOPCRST_W<4> {
                IOPCRST_W::new(self)
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            #[must_use]
            pub fn iopdrst(&mut self) -> IOPDRST_W<5> {
                IOPDRST_W::new(self)
            }
            ///Bit 9 - ADC interface reset
            #[inline(always)]
            #[must_use]
            pub fn adcrst(&mut self) -> ADCRST_W<9> {
                ADCRST_W::new(self)
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            #[must_use]
            pub fn tim1rst(&mut self) -> TIM1RST_W<11> {
                TIM1RST_W::new(self)
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            #[must_use]
            pub fn spi1rst(&mut self) -> SPI1RST_W<12> {
                SPI1RST_W::new(self)
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            #[must_use]
            pub fn usart1rst(&mut self) -> USART1RST_W<14> {
                USART1RST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB2 peripheral reset register(RCC_APB2PRSTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb2prstr](index.html) module
        pub struct APB2PRSTR_SPEC;
        impl crate::RegisterSpec for APB2PRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb2prstr::R](R) reader structure
        impl crate::Readable for APB2PRSTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb2prstr::W](W) writer structure
        impl crate::Writable for APB2PRSTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB2PRSTR to value 0
        impl crate::Resettable for APB2PRSTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///APB1PRSTR (rw) register accessor: an alias for `Reg<APB1PRSTR_SPEC>`
    pub type APB1PRSTR = crate::Reg<apb1prstr::APB1PRSTR_SPEC>;
    ///APB1 peripheral reset register(RCC_APB1PRSTR)
    pub mod apb1prstr {
        ///Register `APB1PRSTR` reader
        pub struct R(crate::R<APB1PRSTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB1PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB1PRSTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB1PRSTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB1PRSTR` writer
        pub struct W(crate::W<APB1PRSTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB1PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB1PRSTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB1PRSTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TIM2RST` reader - Timer 2 reset
        pub type TIM2RST_R = crate::BitReader<TIM2RSTW_A>;
        ///Timer 2 reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIM2RSTW_A {
            ///1: Reset peripheral
            Reset = 1,
        }
        impl From<TIM2RSTW_A> for bool {
            #[inline(always)]
            fn from(variant: TIM2RSTW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TIM2RST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<TIM2RSTW_A> {
                match self.bits {
                    true => Some(TIM2RSTW_A::Reset),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == TIM2RSTW_A::Reset
            }
        }
        ///Field `TIM2RST` writer - Timer 2 reset
        pub type TIM2RST_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, APB1PRSTR_SPEC, TIM2RSTW_A, O>;
        impl<'a, const O: u8> TIM2RST_W<'a, O> {
            ///Reset peripheral
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW_A::Reset)
            }
        }
        ///Field `TIM3RST` reader - Timer 3 reset
        pub use TIM2RST_R as TIM3RST_R;
        ///Field `TIM4RST` reader - Timer 4 reset
        pub use TIM2RST_R as TIM4RST_R;
        ///Field `WWDGRST` reader - Window watchdog reset
        pub use TIM2RST_R as WWDGRST_R;
        ///Field `SPI2RST` reader - SPI2 reset
        pub use TIM2RST_R as SPI2RST_R;
        ///Field `USART2RST` reader - USART 2 reset
        pub use TIM2RST_R as USART2RST_R;
        ///Field `USART3RST` reader - USART 3 reset
        pub use TIM2RST_R as USART3RST_R;
        ///Field `I2C1RST` reader - I2C1 reset
        pub use TIM2RST_R as I2C1RST_R;
        ///Field `I2C2RST` reader - I2C2 reset
        pub use TIM2RST_R as I2C2RST_R;
        ///Field `USBDRST` reader - USBD reset
        pub use TIM2RST_R as USBDRST_R;
        ///Field `CANRST` reader - CAN reset
        pub use TIM2RST_R as CANRST_R;
        ///Field `BKPRST` reader - Backup interface reset
        pub use TIM2RST_R as BKPRST_R;
        ///Field `PWRRST` reader - Power interface reset
        pub use TIM2RST_R as PWRRST_R;
        ///Field `DACRST` reader - DAC interface reset
        pub use TIM2RST_R as DACRST_R;
        ///Field `TIM3RST` writer - Timer 3 reset
        pub use TIM2RST_W as TIM3RST_W;
        ///Field `TIM4RST` writer - Timer 4 reset
        pub use TIM2RST_W as TIM4RST_W;
        ///Field `WWDGRST` writer - Window watchdog reset
        pub use TIM2RST_W as WWDGRST_W;
        ///Field `SPI2RST` writer - SPI2 reset
        pub use TIM2RST_W as SPI2RST_W;
        ///Field `USART2RST` writer - USART 2 reset
        pub use TIM2RST_W as USART2RST_W;
        ///Field `USART3RST` writer - USART 3 reset
        pub use TIM2RST_W as USART3RST_W;
        ///Field `I2C1RST` writer - I2C1 reset
        pub use TIM2RST_W as I2C1RST_W;
        ///Field `I2C2RST` writer - I2C2 reset
        pub use TIM2RST_W as I2C2RST_W;
        ///Field `USBDRST` writer - USBD reset
        pub use TIM2RST_W as USBDRST_W;
        ///Field `CANRST` writer - CAN reset
        pub use TIM2RST_W as CANRST_W;
        ///Field `BKPRST` writer - Backup interface reset
        pub use TIM2RST_W as BKPRST_W;
        ///Field `PWRRST` writer - Power interface reset
        pub use TIM2RST_W as PWRRST_W;
        ///Field `DACRST` writer - DAC interface reset
        pub use TIM2RST_W as DACRST_W;
        impl R {
            ///Bit 0 - Timer 2 reset
            #[inline(always)]
            pub fn tim2rst(&self) -> TIM2RST_R {
                TIM2RST_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Timer 3 reset
            #[inline(always)]
            pub fn tim3rst(&self) -> TIM3RST_R {
                TIM3RST_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Timer 4 reset
            #[inline(always)]
            pub fn tim4rst(&self) -> TIM4RST_R {
                TIM4RST_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            pub fn wwdgrst(&self) -> WWDGRST_R {
                WWDGRST_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 14 - SPI2 reset
            #[inline(always)]
            pub fn spi2rst(&self) -> SPI2RST_R {
                SPI2RST_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 17 - USART 2 reset
            #[inline(always)]
            pub fn usart2rst(&self) -> USART2RST_R {
                USART2RST_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - USART 3 reset
            #[inline(always)]
            pub fn usart3rst(&self) -> USART3RST_R {
                USART3RST_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            pub fn i2c1rst(&self) -> I2C1RST_R {
                I2C1RST_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - I2C2 reset
            #[inline(always)]
            pub fn i2c2rst(&self) -> I2C2RST_R {
                I2C2RST_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - USBD reset
            #[inline(always)]
            pub fn usbdrst(&self) -> USBDRST_R {
                USBDRST_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 25 - CAN reset
            #[inline(always)]
            pub fn canrst(&self) -> CANRST_R {
                CANRST_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 27 - Backup interface reset
            #[inline(always)]
            pub fn bkprst(&self) -> BKPRST_R {
                BKPRST_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            pub fn pwrrst(&self) -> PWRRST_R {
                PWRRST_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - DAC interface reset
            #[inline(always)]
            pub fn dacrst(&self) -> DACRST_R {
                DACRST_R::new(((self.bits >> 29) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Timer 2 reset
            #[inline(always)]
            #[must_use]
            pub fn tim2rst(&mut self) -> TIM2RST_W<0> {
                TIM2RST_W::new(self)
            }
            ///Bit 1 - Timer 3 reset
            #[inline(always)]
            #[must_use]
            pub fn tim3rst(&mut self) -> TIM3RST_W<1> {
                TIM3RST_W::new(self)
            }
            ///Bit 2 - Timer 4 reset
            #[inline(always)]
            #[must_use]
            pub fn tim4rst(&mut self) -> TIM4RST_W<2> {
                TIM4RST_W::new(self)
            }
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            #[must_use]
            pub fn wwdgrst(&mut self) -> WWDGRST_W<11> {
                WWDGRST_W::new(self)
            }
            ///Bit 14 - SPI2 reset
            #[inline(always)]
            #[must_use]
            pub fn spi2rst(&mut self) -> SPI2RST_W<14> {
                SPI2RST_W::new(self)
            }
            ///Bit 17 - USART 2 reset
            #[inline(always)]
            #[must_use]
            pub fn usart2rst(&mut self) -> USART2RST_W<17> {
                USART2RST_W::new(self)
            }
            ///Bit 18 - USART 3 reset
            #[inline(always)]
            #[must_use]
            pub fn usart3rst(&mut self) -> USART3RST_W<18> {
                USART3RST_W::new(self)
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            #[must_use]
            pub fn i2c1rst(&mut self) -> I2C1RST_W<21> {
                I2C1RST_W::new(self)
            }
            ///Bit 22 - I2C2 reset
            #[inline(always)]
            #[must_use]
            pub fn i2c2rst(&mut self) -> I2C2RST_W<22> {
                I2C2RST_W::new(self)
            }
            ///Bit 23 - USBD reset
            #[inline(always)]
            #[must_use]
            pub fn usbdrst(&mut self) -> USBDRST_W<23> {
                USBDRST_W::new(self)
            }
            ///Bit 25 - CAN reset
            #[inline(always)]
            #[must_use]
            pub fn canrst(&mut self) -> CANRST_W<25> {
                CANRST_W::new(self)
            }
            ///Bit 27 - Backup interface reset
            #[inline(always)]
            #[must_use]
            pub fn bkprst(&mut self) -> BKPRST_W<27> {
                BKPRST_W::new(self)
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            #[must_use]
            pub fn pwrrst(&mut self) -> PWRRST_W<28> {
                PWRRST_W::new(self)
            }
            ///Bit 29 - DAC interface reset
            #[inline(always)]
            #[must_use]
            pub fn dacrst(&mut self) -> DACRST_W<29> {
                DACRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB1 peripheral reset register(RCC_APB1PRSTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb1prstr](index.html) module
        pub struct APB1PRSTR_SPEC;
        impl crate::RegisterSpec for APB1PRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb1prstr::R](R) reader structure
        impl crate::Readable for APB1PRSTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb1prstr::W](W) writer structure
        impl crate::Writable for APB1PRSTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB1PRSTR to value 0
        impl crate::Resettable for APB1PRSTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///AHBPCENR (rw) register accessor: an alias for `Reg<AHBPCENR_SPEC>`
    pub type AHBPCENR = crate::Reg<ahbpcenr::AHBPCENR_SPEC>;
    ///AHB Peripheral Clock enable register(RCC_AHBPCENR)
    pub mod ahbpcenr {
        ///Register `AHBPCENR` reader
        pub struct R(crate::R<AHBPCENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AHBPCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AHBPCENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AHBPCENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AHBPCENR` writer
        pub struct W(crate::W<AHBPCENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AHBPCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AHBPCENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AHBPCENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAEN` reader - DMA clock enable
        pub type DMAEN_R = crate::BitReader<DMAEN_A>;
        ///DMA clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMAEN_A {
            ///0: Module disabled
            Disable = 0,
            ///1: Module enabled
            Enabled = 1,
        }
        impl From<DMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMAEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAEN_A {
                match self.bits {
                    false => DMAEN_A::Disable,
                    true => DMAEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disable`
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == DMAEN_A::Disable
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN_A::Enabled
            }
        }
        ///Field `DMAEN` writer - DMA clock enable
        pub type DMAEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, AHBPCENR_SPEC, DMAEN_A, O>;
        impl<'a, const O: u8> DMAEN_W<'a, O> {
            ///Module disabled
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(DMAEN_A::Disable)
            }
            ///Module enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN_A::Enabled)
            }
        }
        ///Field `SRAMEN` reader - SRAM interface clock enable
        pub use DMAEN_R as SRAMEN_R;
        ///Field `FLITFEN` reader - FLITF clock enable
        pub use DMAEN_R as FLITFEN_R;
        ///Field `CRCEN` reader - CRC clock enable
        pub use DMAEN_R as CRCEN_R;
        ///Field `USBHDEN` reader - USBHD clock enable
        pub use DMAEN_R as USBHDEN_R;
        ///Field `SRAMEN` writer - SRAM interface clock enable
        pub use DMAEN_W as SRAMEN_W;
        ///Field `FLITFEN` writer - FLITF clock enable
        pub use DMAEN_W as FLITFEN_W;
        ///Field `CRCEN` writer - CRC clock enable
        pub use DMAEN_W as CRCEN_W;
        ///Field `USBHDEN` writer - USBHD clock enable
        pub use DMAEN_W as USBHDEN_W;
        impl R {
            ///Bit 0 - DMA clock enable
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            pub fn sramen(&self) -> SRAMEN_R {
                SRAMEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - FLITF clock enable
            #[inline(always)]
            pub fn flitfen(&self) -> FLITFEN_R {
                FLITFEN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - CRC clock enable
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 12 - USBHD clock enable
            #[inline(always)]
            pub fn usbhden(&self) -> USBHDEN_R {
                USBHDEN_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA clock enable
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<0> {
                DMAEN_W::new(self)
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn sramen(&mut self) -> SRAMEN_W<2> {
                SRAMEN_W::new(self)
            }
            ///Bit 4 - FLITF clock enable
            #[inline(always)]
            #[must_use]
            pub fn flitfen(&mut self) -> FLITFEN_W<4> {
                FLITFEN_W::new(self)
            }
            ///Bit 6 - CRC clock enable
            #[inline(always)]
            #[must_use]
            pub fn crcen(&mut self) -> CRCEN_W<6> {
                CRCEN_W::new(self)
            }
            ///Bit 12 - USBHD clock enable
            #[inline(always)]
            #[must_use]
            pub fn usbhden(&mut self) -> USBHDEN_W<12> {
                USBHDEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AHB Peripheral Clock enable register(RCC_AHBPCENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ahbpcenr](index.html) module
        pub struct AHBPCENR_SPEC;
        impl crate::RegisterSpec for AHBPCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ahbpcenr::R](R) reader structure
        impl crate::Readable for AHBPCENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ahbpcenr::W](W) writer structure
        impl crate::Writable for AHBPCENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AHBPCENR to value 0x14
        impl crate::Resettable for AHBPCENR_SPEC {
            const RESET_VALUE: Self::Ux = 0x14;
        }
    }
    ///APB2PCENR (rw) register accessor: an alias for `Reg<APB2PCENR_SPEC>`
    pub type APB2PCENR = crate::Reg<apb2pcenr::APB2PCENR_SPEC>;
    ///APB2 peripheral clock enable register (RCC_APB2PCENR)
    pub mod apb2pcenr {
        ///Register `APB2PCENR` reader
        pub struct R(crate::R<APB2PCENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB2PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB2PCENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB2PCENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB2PCENR` writer
        pub struct W(crate::W<APB2PCENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB2PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB2PCENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB2PCENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AFIOEN` reader - Alternate function I/O clock enable
        pub type AFIOEN_R = crate::BitReader<AFIOEN_A>;
        ///Alternate function I/O clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AFIOEN_A {
            ///0: Module disabled
            Disable = 0,
            ///1: Module enabled
            Enabled = 1,
        }
        impl From<AFIOEN_A> for bool {
            #[inline(always)]
            fn from(variant: AFIOEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl AFIOEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AFIOEN_A {
                match self.bits {
                    false => AFIOEN_A::Disable,
                    true => AFIOEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disable`
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == AFIOEN_A::Disable
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == AFIOEN_A::Enabled
            }
        }
        ///Field `AFIOEN` writer - Alternate function I/O clock enable
        pub type AFIOEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, AFIOEN_A, O>;
        impl<'a, const O: u8> AFIOEN_W<'a, O> {
            ///Module disabled
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(AFIOEN_A::Disable)
            }
            ///Module enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::Enabled)
            }
        }
        ///Field `IOPAEN` reader - I/O port A clock enable
        pub use AFIOEN_R as IOPAEN_R;
        ///Field `IOPBEN` reader - I/O port B clock enable
        pub use AFIOEN_R as IOPBEN_R;
        ///Field `IOPCEN` reader - I/O port C clock enable
        pub use AFIOEN_R as IOPCEN_R;
        ///Field `IOPDEN` reader - I/O port D clock enable
        pub use AFIOEN_R as IOPDEN_R;
        ///Field `ADCEN` reader - ADC interface clock enable
        pub use AFIOEN_R as ADCEN_R;
        ///Field `TIM1EN` reader - TIM1 Timer clock enable
        pub use AFIOEN_R as TIM1EN_R;
        ///Field `SPI1EN` reader - SPI 1 clock enable
        pub use AFIOEN_R as SPI1EN_R;
        ///Field `USART1EN` reader - USART1 clock enable
        pub use AFIOEN_R as USART1EN_R;
        ///Field `IOPAEN` writer - I/O port A clock enable
        pub use AFIOEN_W as IOPAEN_W;
        ///Field `IOPBEN` writer - I/O port B clock enable
        pub use AFIOEN_W as IOPBEN_W;
        ///Field `IOPCEN` writer - I/O port C clock enable
        pub use AFIOEN_W as IOPCEN_W;
        ///Field `IOPDEN` writer - I/O port D clock enable
        pub use AFIOEN_W as IOPDEN_W;
        ///Field `ADCEN` writer - ADC interface clock enable
        pub use AFIOEN_W as ADCEN_W;
        ///Field `TIM1EN` writer - TIM1 Timer clock enable
        pub use AFIOEN_W as TIM1EN_W;
        ///Field `SPI1EN` writer - SPI 1 clock enable
        pub use AFIOEN_W as SPI1EN_W;
        ///Field `USART1EN` writer - USART1 clock enable
        pub use AFIOEN_W as USART1EN_W;
        impl R {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            pub fn afioen(&self) -> AFIOEN_R {
                AFIOEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            pub fn iopaen(&self) -> IOPAEN_R {
                IOPAEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - I/O port B clock enable
            #[inline(always)]
            pub fn iopben(&self) -> IOPBEN_R {
                IOPBEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            pub fn iopcen(&self) -> IOPCEN_R {
                IOPCEN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            pub fn iopden(&self) -> IOPDEN_R {
                IOPDEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 9 - ADC interface clock enable
            #[inline(always)]
            pub fn adcen(&self) -> ADCEN_R {
                ADCEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            pub fn tim1en(&self) -> TIM1EN_R {
                TIM1EN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            pub fn spi1en(&self) -> SPI1EN_R {
                SPI1EN_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            pub fn usart1en(&self) -> USART1EN_R {
                USART1EN_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            #[must_use]
            pub fn afioen(&mut self) -> AFIOEN_W<0> {
                AFIOEN_W::new(self)
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopaen(&mut self) -> IOPAEN_W<2> {
                IOPAEN_W::new(self)
            }
            ///Bit 3 - I/O port B clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopben(&mut self) -> IOPBEN_W<3> {
                IOPBEN_W::new(self)
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopcen(&mut self) -> IOPCEN_W<4> {
                IOPCEN_W::new(self)
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopden(&mut self) -> IOPDEN_W<5> {
                IOPDEN_W::new(self)
            }
            ///Bit 9 - ADC interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn adcen(&mut self) -> ADCEN_W<9> {
                ADCEN_W::new(self)
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim1en(&mut self) -> TIM1EN_W<11> {
                TIM1EN_W::new(self)
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn spi1en(&mut self) -> SPI1EN_W<12> {
                SPI1EN_W::new(self)
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn usart1en(&mut self) -> USART1EN_W<14> {
                USART1EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB2 peripheral clock enable register (RCC_APB2PCENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb2pcenr](index.html) module
        pub struct APB2PCENR_SPEC;
        impl crate::RegisterSpec for APB2PCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb2pcenr::R](R) reader structure
        impl crate::Readable for APB2PCENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb2pcenr::W](W) writer structure
        impl crate::Writable for APB2PCENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB2PCENR to value 0
        impl crate::Resettable for APB2PCENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///APB1PCENR (rw) register accessor: an alias for `Reg<APB1PCENR_SPEC>`
    pub type APB1PCENR = crate::Reg<apb1pcenr::APB1PCENR_SPEC>;
    ///APB1 peripheral clock enable register (RCC_APB1PCENR)
    pub mod apb1pcenr {
        ///Register `APB1PCENR` reader
        pub struct R(crate::R<APB1PCENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB1PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB1PCENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB1PCENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB1PCENR` writer
        pub struct W(crate::W<APB1PCENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB1PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB1PCENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB1PCENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TIM2EN` reader - Timer 2 clock enable
        pub type TIM2EN_R = crate::BitReader<TIM2EN_A>;
        ///Timer 2 clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIM2EN_A {
            ///0: Module disabled
            Disable = 0,
            ///1: Module enabled
            Enabled = 1,
        }
        impl From<TIM2EN_A> for bool {
            #[inline(always)]
            fn from(variant: TIM2EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TIM2EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIM2EN_A {
                match self.bits {
                    false => TIM2EN_A::Disable,
                    true => TIM2EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disable`
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == TIM2EN_A::Disable
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TIM2EN_A::Enabled
            }
        }
        ///Field `TIM2EN` writer - Timer 2 clock enable
        pub type TIM2EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PCENR_SPEC, TIM2EN_A, O>;
        impl<'a, const O: u8> TIM2EN_W<'a, O> {
            ///Module disabled
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(TIM2EN_A::Disable)
            }
            ///Module enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::Enabled)
            }
        }
        ///Field `TIM3EN` reader - Timer 3 clock enable
        pub use TIM2EN_R as TIM3EN_R;
        ///Field `TIM4EN` reader - Timer 4 clock enable
        pub use TIM2EN_R as TIM4EN_R;
        ///Field `WWDGEN` reader - Window watchdog clock enable
        pub use TIM2EN_R as WWDGEN_R;
        ///Field `SPI2EN` reader - SPI 2 clock enable
        pub use TIM2EN_R as SPI2EN_R;
        ///Field `USART2EN` reader - USART 2 clock enable
        pub use TIM2EN_R as USART2EN_R;
        ///Field `USART3EN` reader - USART 3 clock enable
        pub use TIM2EN_R as USART3EN_R;
        ///Field `I2C1EN` reader - I2C 1 clock enable
        pub use TIM2EN_R as I2C1EN_R;
        ///Field `I2C2EN` reader - I2C 2 clock enable
        pub use TIM2EN_R as I2C2EN_R;
        ///Field `USBDEN` reader - USBD clock enable
        pub use TIM2EN_R as USBDEN_R;
        ///Field `CANEN` reader - CAN clock enable
        pub use TIM2EN_R as CANEN_R;
        ///Field `BKPEN` reader - Backup interface clock enable
        pub use TIM2EN_R as BKPEN_R;
        ///Field `PWREN` reader - Power interface clock enable
        pub use TIM2EN_R as PWREN_R;
        ///Field `DACEN` reader - DAC interface clock enable
        pub use TIM2EN_R as DACEN_R;
        ///Field `TIM3EN` writer - Timer 3 clock enable
        pub use TIM2EN_W as TIM3EN_W;
        ///Field `TIM4EN` writer - Timer 4 clock enable
        pub use TIM2EN_W as TIM4EN_W;
        ///Field `WWDGEN` writer - Window watchdog clock enable
        pub use TIM2EN_W as WWDGEN_W;
        ///Field `SPI2EN` writer - SPI 2 clock enable
        pub use TIM2EN_W as SPI2EN_W;
        ///Field `USART2EN` writer - USART 2 clock enable
        pub use TIM2EN_W as USART2EN_W;
        ///Field `USART3EN` writer - USART 3 clock enable
        pub use TIM2EN_W as USART3EN_W;
        ///Field `I2C1EN` writer - I2C 1 clock enable
        pub use TIM2EN_W as I2C1EN_W;
        ///Field `I2C2EN` writer - I2C 2 clock enable
        pub use TIM2EN_W as I2C2EN_W;
        ///Field `USBDEN` writer - USBD clock enable
        pub use TIM2EN_W as USBDEN_W;
        ///Field `CANEN` writer - CAN clock enable
        pub use TIM2EN_W as CANEN_W;
        ///Field `BKPEN` writer - Backup interface clock enable
        pub use TIM2EN_W as BKPEN_W;
        ///Field `PWREN` writer - Power interface clock enable
        pub use TIM2EN_W as PWREN_W;
        ///Field `DACEN` writer - DAC interface clock enable
        pub use TIM2EN_W as DACEN_W;
        impl R {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            pub fn tim2en(&self) -> TIM2EN_R {
                TIM2EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Timer 3 clock enable
            #[inline(always)]
            pub fn tim3en(&self) -> TIM3EN_R {
                TIM3EN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Timer 4 clock enable
            #[inline(always)]
            pub fn tim4en(&self) -> TIM4EN_R {
                TIM4EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            pub fn wwdgen(&self) -> WWDGEN_R {
                WWDGEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 14 - SPI 2 clock enable
            #[inline(always)]
            pub fn spi2en(&self) -> SPI2EN_R {
                SPI2EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 17 - USART 2 clock enable
            #[inline(always)]
            pub fn usart2en(&self) -> USART2EN_R {
                USART2EN_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - USART 3 clock enable
            #[inline(always)]
            pub fn usart3en(&self) -> USART3EN_R {
                USART3EN_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            pub fn i2c1en(&self) -> I2C1EN_R {
                I2C1EN_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - I2C 2 clock enable
            #[inline(always)]
            pub fn i2c2en(&self) -> I2C2EN_R {
                I2C2EN_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - USBD clock enable
            #[inline(always)]
            pub fn usbden(&self) -> USBDEN_R {
                USBDEN_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 25 - CAN clock enable
            #[inline(always)]
            pub fn canen(&self) -> CANEN_R {
                CANEN_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 27 - Backup interface clock enable
            #[inline(always)]
            pub fn bkpen(&self) -> BKPEN_R {
                BKPEN_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            pub fn pwren(&self) -> PWREN_R {
                PWREN_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - DAC interface clock enable
            #[inline(always)]
            pub fn dacen(&self) -> DACEN_R {
                DACEN_R::new(((self.bits >> 29) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim2en(&mut self) -> TIM2EN_W<0> {
                TIM2EN_W::new(self)
            }
            ///Bit 1 - Timer 3 clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim3en(&mut self) -> TIM3EN_W<1> {
                TIM3EN_W::new(self)
            }
            ///Bit 2 - Timer 4 clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim4en(&mut self) -> TIM4EN_W<2> {
                TIM4EN_W::new(self)
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            #[must_use]
            pub fn wwdgen(&mut self) -> WWDGEN_W<11> {
                WWDGEN_W::new(self)
            }
            ///Bit 14 - SPI 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn spi2en(&mut self) -> SPI2EN_W<14> {
                SPI2EN_W::new(self)
            }
            ///Bit 17 - USART 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn usart2en(&mut self) -> USART2EN_W<17> {
                USART2EN_W::new(self)
            }
            ///Bit 18 - USART 3 clock enable
            #[inline(always)]
            #[must_use]
            pub fn usart3en(&mut self) -> USART3EN_W<18> {
                USART3EN_W::new(self)
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn i2c1en(&mut self) -> I2C1EN_W<21> {
                I2C1EN_W::new(self)
            }
            ///Bit 22 - I2C 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn i2c2en(&mut self) -> I2C2EN_W<22> {
                I2C2EN_W::new(self)
            }
            ///Bit 23 - USBD clock enable
            #[inline(always)]
            #[must_use]
            pub fn usbden(&mut self) -> USBDEN_W<23> {
                USBDEN_W::new(self)
            }
            ///Bit 25 - CAN clock enable
            #[inline(always)]
            #[must_use]
            pub fn canen(&mut self) -> CANEN_W<25> {
                CANEN_W::new(self)
            }
            ///Bit 27 - Backup interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn bkpen(&mut self) -> BKPEN_W<27> {
                BKPEN_W::new(self)
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn pwren(&mut self) -> PWREN_W<28> {
                PWREN_W::new(self)
            }
            ///Bit 29 - DAC interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn dacen(&mut self) -> DACEN_W<29> {
                DACEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB1 peripheral clock enable register (RCC_APB1PCENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb1pcenr](index.html) module
        pub struct APB1PCENR_SPEC;
        impl crate::RegisterSpec for APB1PCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb1pcenr::R](R) reader structure
        impl crate::Readable for APB1PCENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb1pcenr::W](W) writer structure
        impl crate::Writable for APB1PCENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB1PCENR to value 0
        impl crate::Resettable for APB1PCENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BDCTLR (rw) register accessor: an alias for `Reg<BDCTLR_SPEC>`
    pub type BDCTLR = crate::Reg<bdctlr::BDCTLR_SPEC>;
    ///Backup domain control register(RCC_BDCTLR)
    pub mod bdctlr {
        ///Register `BDCTLR` reader
        pub struct R(crate::R<BDCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BDCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BDCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDCTLR` writer
        pub struct W(crate::W<BDCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BDCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BDCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LSEON` reader - External Low Speed oscillator enable
        pub type LSEON_R = crate::BitReader<LSEON_A>;
        ///External Low Speed oscillator enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSEON_A {
            ///0: Clock Off
            Off = 0,
            ///1: Clock On
            On = 1,
        }
        impl From<LSEON_A> for bool {
            #[inline(always)]
            fn from(variant: LSEON_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSEON_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSEON_A {
                match self.bits {
                    false => LSEON_A::Off,
                    true => LSEON_A::On,
                }
            }
            ///Checks if the value of the field is `Off`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == LSEON_A::Off
            }
            ///Checks if the value of the field is `On`
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == LSEON_A::On
            }
        }
        ///Field `LSEON` writer - External Low Speed oscillator enable
        pub type LSEON_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDCTLR_SPEC, LSEON_A, O>;
        impl<'a, const O: u8> LSEON_W<'a, O> {
            ///Clock Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(LSEON_A::Off)
            }
            ///Clock On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(LSEON_A::On)
            }
        }
        ///Field `LSERDY` reader - External Low Speed oscillator ready
        pub type LSERDY_R = crate::BitReader<LSERDYR_A>;
        ///External Low Speed oscillator ready
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSERDYR_A {
            ///0: Clock not ready
            NotReady = 0,
            ///1: Clock ready
            Ready = 1,
        }
        impl From<LSERDYR_A> for bool {
            #[inline(always)]
            fn from(variant: LSERDYR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSERDY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSERDYR_A {
                match self.bits {
                    false => LSERDYR_A::NotReady,
                    true => LSERDYR_A::Ready,
                }
            }
            ///Checks if the value of the field is `NotReady`
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == LSERDYR_A::NotReady
            }
            ///Checks if the value of the field is `Ready`
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == LSERDYR_A::Ready
            }
        }
        ///Field `LSEBYP` reader - External Low Speed oscillator bypass
        pub type LSEBYP_R = crate::BitReader<LSEBYP_A>;
        ///External Low Speed oscillator bypass
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSEBYP_A {
            ///0: LSE crystal oscillator not bypassed
            NotBypassed = 0,
            ///1: LSE crystal oscillator bypassed with external clock
            Bypassed = 1,
        }
        impl From<LSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: LSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSEBYP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSEBYP_A {
                match self.bits {
                    false => LSEBYP_A::NotBypassed,
                    true => LSEBYP_A::Bypassed,
                }
            }
            ///Checks if the value of the field is `NotBypassed`
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                *self == LSEBYP_A::NotBypassed
            }
            ///Checks if the value of the field is `Bypassed`
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                *self == LSEBYP_A::Bypassed
            }
        }
        ///Field `LSEBYP` writer - External Low Speed oscillator bypass
        pub type LSEBYP_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDCTLR_SPEC, LSEBYP_A, O>;
        impl<'a, const O: u8> LSEBYP_W<'a, O> {
            ///LSE crystal oscillator not bypassed
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::NotBypassed)
            }
            ///LSE crystal oscillator bypassed with external clock
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::Bypassed)
            }
        }
        ///Field `RTCSEL` reader - RTC clock source selection
        pub type RTCSEL_R = crate::FieldReader<u8, RTCSEL_A>;
        ///RTC clock source selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum RTCSEL_A {
            ///0: No clock as RTC clock source
            NoClock = 0,
            ///1: LSE as RTC clock source
            Lse = 1,
            ///2: LSI as RTC clock source
            Lsi = 2,
            ///3: HSE divided by 128 as RTC clock source
            Hse = 3,
        }
        impl From<RTCSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: RTCSEL_A) -> Self {
                variant as _
            }
        }
        impl RTCSEL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RTCSEL_A {
                match self.bits {
                    0 => RTCSEL_A::NoClock,
                    1 => RTCSEL_A::Lse,
                    2 => RTCSEL_A::Lsi,
                    3 => RTCSEL_A::Hse,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoClock`
            #[inline(always)]
            pub fn is_no_clock(&self) -> bool {
                *self == RTCSEL_A::NoClock
            }
            ///Checks if the value of the field is `Lse`
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                *self == RTCSEL_A::Lse
            }
            ///Checks if the value of the field is `Lsi`
            #[inline(always)]
            pub fn is_lsi(&self) -> bool {
                *self == RTCSEL_A::Lsi
            }
            ///Checks if the value of the field is `Hse`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                *self == RTCSEL_A::Hse
            }
        }
        ///Field `RTCSEL` writer - RTC clock source selection
        pub type RTCSEL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, BDCTLR_SPEC, u8, RTCSEL_A, 2, O>;
        impl<'a, const O: u8> RTCSEL_W<'a, O> {
            ///No clock as RTC clock source
            #[inline(always)]
            pub fn no_clock(self) -> &'a mut W {
                self.variant(RTCSEL_A::NoClock)
            }
            ///LSE as RTC clock source
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(RTCSEL_A::Lse)
            }
            ///LSI as RTC clock source
            #[inline(always)]
            pub fn lsi(self) -> &'a mut W {
                self.variant(RTCSEL_A::Lsi)
            }
            ///HSE divided by 128 as RTC clock source
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(RTCSEL_A::Hse)
            }
        }
        ///Field `RTCEN` reader - RTC clock enable
        pub type RTCEN_R = crate::BitReader<RTCEN_A>;
        ///RTC clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RTCEN_A {
            ///0: RTC disabled
            Disabled = 0,
            ///1: RTC enabled
            Enabled = 1,
        }
        impl From<RTCEN_A> for bool {
            #[inline(always)]
            fn from(variant: RTCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RTCEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RTCEN_A {
                match self.bits {
                    false => RTCEN_A::Disabled,
                    true => RTCEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTCEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTCEN_A::Enabled
            }
        }
        ///Field `RTCEN` writer - RTC clock enable
        pub type RTCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDCTLR_SPEC, RTCEN_A, O>;
        impl<'a, const O: u8> RTCEN_W<'a, O> {
            ///RTC disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTCEN_A::Disabled)
            }
            ///RTC enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTCEN_A::Enabled)
            }
        }
        ///Field `BDRST` reader - Backup domain software reset
        pub type BDRST_R = crate::BitReader<BDRST_A>;
        ///Backup domain software reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BDRST_A {
            ///0: Cancel back domain reset
            Cancel = 0,
            ///1: Reset back domain
            Reset = 1,
        }
        impl From<BDRST_A> for bool {
            #[inline(always)]
            fn from(variant: BDRST_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BDRST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BDRST_A {
                match self.bits {
                    false => BDRST_A::Cancel,
                    true => BDRST_A::Reset,
                }
            }
            ///Checks if the value of the field is `Cancel`
            #[inline(always)]
            pub fn is_cancel(&self) -> bool {
                *self == BDRST_A::Cancel
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == BDRST_A::Reset
            }
        }
        ///Field `BDRST` writer - Backup domain software reset
        pub type BDRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDCTLR_SPEC, BDRST_A, O>;
        impl<'a, const O: u8> BDRST_W<'a, O> {
            ///Cancel back domain reset
            #[inline(always)]
            pub fn cancel(self) -> &'a mut W {
                self.variant(BDRST_A::Cancel)
            }
            ///Reset back domain
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BDRST_A::Reset)
            }
        }
        impl R {
            ///Bit 0 - External Low Speed oscillator enable
            #[inline(always)]
            pub fn lseon(&self) -> LSEON_R {
                LSEON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - External Low Speed oscillator ready
            #[inline(always)]
            pub fn lserdy(&self) -> LSERDY_R {
                LSERDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - External Low Speed oscillator bypass
            #[inline(always)]
            pub fn lsebyp(&self) -> LSEBYP_R {
                LSEBYP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 8:9 - RTC clock source selection
            #[inline(always)]
            pub fn rtcsel(&self) -> RTCSEL_R {
                RTCSEL_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 15 - RTC clock enable
            #[inline(always)]
            pub fn rtcen(&self) -> RTCEN_R {
                RTCEN_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Backup domain software reset
            #[inline(always)]
            pub fn bdrst(&self) -> BDRST_R {
                BDRST_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - External Low Speed oscillator enable
            #[inline(always)]
            #[must_use]
            pub fn lseon(&mut self) -> LSEON_W<0> {
                LSEON_W::new(self)
            }
            ///Bit 2 - External Low Speed oscillator bypass
            #[inline(always)]
            #[must_use]
            pub fn lsebyp(&mut self) -> LSEBYP_W<2> {
                LSEBYP_W::new(self)
            }
            ///Bits 8:9 - RTC clock source selection
            #[inline(always)]
            #[must_use]
            pub fn rtcsel(&mut self) -> RTCSEL_W<8> {
                RTCSEL_W::new(self)
            }
            ///Bit 15 - RTC clock enable
            #[inline(always)]
            #[must_use]
            pub fn rtcen(&mut self) -> RTCEN_W<15> {
                RTCEN_W::new(self)
            }
            ///Bit 16 - Backup domain software reset
            #[inline(always)]
            #[must_use]
            pub fn bdrst(&mut self) -> BDRST_W<16> {
                BDRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup domain control register(RCC_BDCTLR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdctlr](index.html) module
        pub struct BDCTLR_SPEC;
        impl crate::RegisterSpec for BDCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bdctlr::R](R) reader structure
        impl crate::Readable for BDCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdctlr::W](W) writer structure
        impl crate::Writable for BDCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BDCTLR to value 0
        impl crate::Resettable for BDCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSTSCKR (rw) register accessor: an alias for `Reg<RSTSCKR_SPEC>`
    pub type RSTSCKR = crate::Reg<rstsckr::RSTSCKR_SPEC>;
    ///Control/status register(RCC_RSTSCKR)
    pub mod rstsckr {
        ///Register `RSTSCKR` reader
        pub struct R(crate::R<RSTSCKR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSTSCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSTSCKR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSTSCKR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSTSCKR` writer
        pub struct W(crate::W<RSTSCKR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSTSCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSTSCKR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSTSCKR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LSION` reader - Internal low speed oscillator enable
        pub type LSION_R = crate::BitReader<LSION_A>;
        ///Internal low speed oscillator enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSION_A {
            ///0: Clock Off
            Off = 0,
            ///1: Clock On
            On = 1,
        }
        impl From<LSION_A> for bool {
            #[inline(always)]
            fn from(variant: LSION_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSION_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSION_A {
                match self.bits {
                    false => LSION_A::Off,
                    true => LSION_A::On,
                }
            }
            ///Checks if the value of the field is `Off`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == LSION_A::Off
            }
            ///Checks if the value of the field is `On`
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                *self == LSION_A::On
            }
        }
        ///Field `LSION` writer - Internal low speed oscillator enable
        pub type LSION_W<'a, const O: u8> = crate::BitWriter<'a, u32, RSTSCKR_SPEC, LSION_A, O>;
        impl<'a, const O: u8> LSION_W<'a, O> {
            ///Clock Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(LSION_A::Off)
            }
            ///Clock On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(LSION_A::On)
            }
        }
        ///Field `LSIRDY` reader - Internal low speed oscillator ready
        pub type LSIRDY_R = crate::BitReader<LSIRDYR_A>;
        ///Internal low speed oscillator ready
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSIRDYR_A {
            ///0: Clock not ready
            NotReady = 0,
            ///1: Clock ready
            Ready = 1,
        }
        impl From<LSIRDYR_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSIRDY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSIRDYR_A {
                match self.bits {
                    false => LSIRDYR_A::NotReady,
                    true => LSIRDYR_A::Ready,
                }
            }
            ///Checks if the value of the field is `NotReady`
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                *self == LSIRDYR_A::NotReady
            }
            ///Checks if the value of the field is `Ready`
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == LSIRDYR_A::Ready
            }
        }
        ///Field `RMVF` reader - Remove reset flag
        pub type RMVF_R = crate::BitReader<RMVFR_A>;
        ///Remove reset flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RMVFR_A {
            ///0: No reset occurred
            Nothing = 0,
            ///1: Reset occurred
            HasReset = 1,
        }
        impl From<RMVFR_A> for bool {
            #[inline(always)]
            fn from(variant: RMVFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RMVF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RMVFR_A {
                match self.bits {
                    false => RMVFR_A::Nothing,
                    true => RMVFR_A::HasReset,
                }
            }
            ///Checks if the value of the field is `Nothing`
            #[inline(always)]
            pub fn is_nothing(&self) -> bool {
                *self == RMVFR_A::Nothing
            }
            ///Checks if the value of the field is `HasReset`
            #[inline(always)]
            pub fn is_has_reset(&self) -> bool {
                *self == RMVFR_A::HasReset
            }
        }
        ///Remove reset flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RMVFW_AW {
            ///1: Remove reset flags
            Clear = 1,
        }
        impl From<RMVFW_AW> for bool {
            #[inline(always)]
            fn from(variant: RMVFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RMVF` writer - Remove reset flag
        pub type RMVF_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, RSTSCKR_SPEC, RMVFW_AW, O>;
        impl<'a, const O: u8> RMVF_W<'a, O> {
            ///Remove reset flags
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RMVFW_AW::Clear)
            }
        }
        ///Field `PINRSTF` reader - PIN reset flag
        pub use RMVF_R as PINRSTF_R;
        ///Field `PORRSTF` reader - POR/PDR reset flag
        pub use RMVF_R as PORRSTF_R;
        ///Field `SFTRSTF` reader - Software reset flag
        pub use RMVF_R as SFTRSTF_R;
        ///Field `IWDGRSTF` reader - Independent watchdog reset flag
        pub use RMVF_R as IWDGRSTF_R;
        ///Field `WWDGRSTF` reader - Window watchdog reset flag
        pub use RMVF_R as WWDGRSTF_R;
        ///Field `LPWRRSTF` reader - Low-power reset flag
        pub use RMVF_R as LPWRRSTF_R;
        ///Field `PINRSTF` writer - PIN reset flag
        pub use RMVF_W as PINRSTF_W;
        ///Field `PORRSTF` writer - POR/PDR reset flag
        pub use RMVF_W as PORRSTF_W;
        ///Field `SFTRSTF` writer - Software reset flag
        pub use RMVF_W as SFTRSTF_W;
        ///Field `IWDGRSTF` writer - Independent watchdog reset flag
        pub use RMVF_W as IWDGRSTF_W;
        ///Field `WWDGRSTF` writer - Window watchdog reset flag
        pub use RMVF_W as WWDGRSTF_W;
        ///Field `LPWRRSTF` writer - Low-power reset flag
        pub use RMVF_W as LPWRRSTF_W;
        impl R {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            pub fn lsion(&self) -> LSION_R {
                LSION_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Internal low speed oscillator ready
            #[inline(always)]
            pub fn lsirdy(&self) -> LSIRDY_R {
                LSIRDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            pub fn rmvf(&self) -> RMVF_R {
                RMVF_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 26 - PIN reset flag
            #[inline(always)]
            pub fn pinrstf(&self) -> PINRSTF_R {
                PINRSTF_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - POR/PDR reset flag
            #[inline(always)]
            pub fn porrstf(&self) -> PORRSTF_R {
                PORRSTF_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Software reset flag
            #[inline(always)]
            pub fn sftrstf(&self) -> SFTRSTF_R {
                SFTRSTF_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Independent watchdog reset flag
            #[inline(always)]
            pub fn iwdgrstf(&self) -> IWDGRSTF_R {
                IWDGRSTF_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Window watchdog reset flag
            #[inline(always)]
            pub fn wwdgrstf(&self) -> WWDGRSTF_R {
                WWDGRSTF_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Low-power reset flag
            #[inline(always)]
            pub fn lpwrrstf(&self) -> LPWRRSTF_R {
                LPWRRSTF_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            #[must_use]
            pub fn lsion(&mut self) -> LSION_W<0> {
                LSION_W::new(self)
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            #[must_use]
            pub fn rmvf(&mut self) -> RMVF_W<24> {
                RMVF_W::new(self)
            }
            ///Bit 26 - PIN reset flag
            #[inline(always)]
            #[must_use]
            pub fn pinrstf(&mut self) -> PINRSTF_W<26> {
                PINRSTF_W::new(self)
            }
            ///Bit 27 - POR/PDR reset flag
            #[inline(always)]
            #[must_use]
            pub fn porrstf(&mut self) -> PORRSTF_W<27> {
                PORRSTF_W::new(self)
            }
            ///Bit 28 - Software reset flag
            #[inline(always)]
            #[must_use]
            pub fn sftrstf(&mut self) -> SFTRSTF_W<28> {
                SFTRSTF_W::new(self)
            }
            ///Bit 29 - Independent watchdog reset flag
            #[inline(always)]
            #[must_use]
            pub fn iwdgrstf(&mut self) -> IWDGRSTF_W<29> {
                IWDGRSTF_W::new(self)
            }
            ///Bit 30 - Window watchdog reset flag
            #[inline(always)]
            #[must_use]
            pub fn wwdgrstf(&mut self) -> WWDGRSTF_W<30> {
                WWDGRSTF_W::new(self)
            }
            ///Bit 31 - Low-power reset flag
            #[inline(always)]
            #[must_use]
            pub fn lpwrrstf(&mut self) -> LPWRRSTF_W<31> {
                LPWRRSTF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control/status register(RCC_RSTSCKR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rstsckr](index.html) module
        pub struct RSTSCKR_SPEC;
        impl crate::RegisterSpec for RSTSCKR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rstsckr::R](R) reader structure
        impl crate::Readable for RSTSCKR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rstsckr::W](W) writer structure
        impl crate::Writable for RSTSCKR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0100_0000;
        }
        ///`reset()` method sets RSTSCKR to value 0x0c00_0000
        impl crate::Resettable for RSTSCKR_SPEC {
            const RESET_VALUE: Self::Ux = 0x0c00_0000;
        }
    }
    ///AHBRSTR (rw) register accessor: an alias for `Reg<AHBRSTR_SPEC>`
    pub type AHBRSTR = crate::Reg<ahbrstr::AHBRSTR_SPEC>;
    ///AHB reset register(RCC_APHBRSTR)
    pub mod ahbrstr {
        ///Register `AHBRSTR` reader
        pub struct R(crate::R<AHBRSTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AHBRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AHBRSTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AHBRSTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AHBRSTR` writer
        pub struct W(crate::W<AHBRSTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AHBRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AHBRSTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AHBRSTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `USBHDRST` reader - USBHD reset
        pub type USBHDRST_R = crate::BitReader<USBHDRSTW_A>;
        ///USBHD reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum USBHDRSTW_A {
            ///1: Reset peripheral
            Reset = 1,
        }
        impl From<USBHDRSTW_A> for bool {
            #[inline(always)]
            fn from(variant: USBHDRSTW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl USBHDRST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<USBHDRSTW_A> {
                match self.bits {
                    true => Some(USBHDRSTW_A::Reset),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == USBHDRSTW_A::Reset
            }
        }
        ///Field `USBHDRST` writer - USBHD reset
        pub type USBHDRST_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, AHBRSTR_SPEC, USBHDRSTW_A, O>;
        impl<'a, const O: u8> USBHDRST_W<'a, O> {
            ///Reset peripheral
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(USBHDRSTW_A::Reset)
            }
        }
        impl R {
            ///Bit 12 - USBHD reset
            #[inline(always)]
            pub fn usbhdrst(&self) -> USBHDRST_R {
                USBHDRST_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 12 - USBHD reset
            #[inline(always)]
            #[must_use]
            pub fn usbhdrst(&mut self) -> USBHDRST_W<12> {
                USBHDRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AHB reset register(RCC_APHBRSTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ahbrstr](index.html) module
        pub struct AHBRSTR_SPEC;
        impl crate::RegisterSpec for AHBRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ahbrstr::R](R) reader structure
        impl crate::Readable for AHBRSTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ahbrstr::W](W) writer structure
        impl crate::Writable for AHBRSTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AHBRSTR to value 0
        impl crate::Resettable for AHBRSTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///extension configuration
pub struct EXTEND {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTEND {}
impl EXTEND {
    ///Pointer to the register block
    pub const PTR: *const extend::RegisterBlock = 0x4002_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const extend::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EXTEND {
    type Target = extend::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTEND {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTEND").finish()
    }
}
///extension configuration
pub mod extend {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - EXTEND register
        pub extend_ctr: EXTEND_CTR,
    }
    ///EXTEND_CTR (rw) register accessor: an alias for `Reg<EXTEND_CTR_SPEC>`
    pub type EXTEND_CTR = crate::Reg<extend_ctr::EXTEND_CTR_SPEC>;
    ///EXTEND register
    pub mod extend_ctr {
        ///Register `EXTEND_CTR` reader
        pub struct R(crate::R<EXTEND_CTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTEND_CTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EXTEND_CTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EXTEND_CTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTEND_CTR` writer
        pub struct W(crate::W<EXTEND_CTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTEND_CTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTEND_CTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTEND_CTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `USBDLS` reader - USBD Lowspeed Enable
        pub type USBDLS_R = crate::BitReader<USBDLS_A>;
        ///USBD Lowspeed Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum USBDLS_A {
            ///0: USBD full speed
            FullSpeed = 0,
            ///1: USBD low speed
            LowSpeed = 1,
        }
        impl From<USBDLS_A> for bool {
            #[inline(always)]
            fn from(variant: USBDLS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl USBDLS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> USBDLS_A {
                match self.bits {
                    false => USBDLS_A::FullSpeed,
                    true => USBDLS_A::LowSpeed,
                }
            }
            ///Checks if the value of the field is `FullSpeed`
            #[inline(always)]
            pub fn is_full_speed(&self) -> bool {
                *self == USBDLS_A::FullSpeed
            }
            ///Checks if the value of the field is `LowSpeed`
            #[inline(always)]
            pub fn is_low_speed(&self) -> bool {
                *self == USBDLS_A::LowSpeed
            }
        }
        ///Field `USBDLS` writer - USBD Lowspeed Enable
        pub type USBDLS_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, USBDLS_A, O>;
        impl<'a, const O: u8> USBDLS_W<'a, O> {
            ///USBD full speed
            #[inline(always)]
            pub fn full_speed(self) -> &'a mut W {
                self.variant(USBDLS_A::FullSpeed)
            }
            ///USBD low speed
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(USBDLS_A::LowSpeed)
            }
        }
        ///Field `USBDPU` reader - USBD pullup Enable
        pub type USBDPU_R = crate::BitReader<USBDPU_A>;
        ///USBD pullup Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum USBDPU_A {
            ///0: USBD internal pull-up resistor disabled
            Disabled = 0,
            ///1: USBD internal pull-up resistor enabled
            Enabled = 1,
        }
        impl From<USBDPU_A> for bool {
            #[inline(always)]
            fn from(variant: USBDPU_A) -> Self {
                variant as u8 != 0
            }
        }
        impl USBDPU_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> USBDPU_A {
                match self.bits {
                    false => USBDPU_A::Disabled,
                    true => USBDPU_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == USBDPU_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == USBDPU_A::Enabled
            }
        }
        ///Field `USBDPU` writer - USBD pullup Enable
        pub type USBDPU_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, USBDPU_A, O>;
        impl<'a, const O: u8> USBDPU_W<'a, O> {
            ///USBD internal pull-up resistor disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USBDPU_A::Disabled)
            }
            ///USBD internal pull-up resistor enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USBDPU_A::Enabled)
            }
        }
        ///Field `USBHDIO` reader - USBHD IO(PB6/PB7) Enable
        pub type USBHDIO_R = crate::BitReader<USBHDIO_A>;
        ///USBHD IO(PB6/PB7) Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum USBHDIO_A {
            ///0: Use PB6/PB7 as other functions
            Other = 0,
            ///1: Use PB6/PB7 as USBHD function
            Usbhd = 1,
        }
        impl From<USBHDIO_A> for bool {
            #[inline(always)]
            fn from(variant: USBHDIO_A) -> Self {
                variant as u8 != 0
            }
        }
        impl USBHDIO_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> USBHDIO_A {
                match self.bits {
                    false => USBHDIO_A::Other,
                    true => USBHDIO_A::Usbhd,
                }
            }
            ///Checks if the value of the field is `Other`
            #[inline(always)]
            pub fn is_other(&self) -> bool {
                *self == USBHDIO_A::Other
            }
            ///Checks if the value of the field is `Usbhd`
            #[inline(always)]
            pub fn is_usbhd(&self) -> bool {
                *self == USBHDIO_A::Usbhd
            }
        }
        ///Field `USBHDIO` writer - USBHD IO(PB6/PB7) Enable
        pub type USBHDIO_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, USBHDIO_A, O>;
        impl<'a, const O: u8> USBHDIO_W<'a, O> {
            ///Use PB6/PB7 as other functions
            #[inline(always)]
            pub fn other(self) -> &'a mut W {
                self.variant(USBHDIO_A::Other)
            }
            ///Use PB6/PB7 as USBHD function
            #[inline(always)]
            pub fn usbhd(self) -> &'a mut W {
                self.variant(USBHDIO_A::Usbhd)
            }
        }
        ///Field `USB5VSEL` reader - USB 5V Enable
        pub type USB5VSEL_R = crate::BitReader<USB5VSEL_A>;
        ///USB 5V Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum USB5VSEL_A {
            ///0: VDD is 3.3V
            Vdd3v3 = 0,
            ///1: VDD is 5V
            Vdd5v = 1,
        }
        impl From<USB5VSEL_A> for bool {
            #[inline(always)]
            fn from(variant: USB5VSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl USB5VSEL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> USB5VSEL_A {
                match self.bits {
                    false => USB5VSEL_A::Vdd3v3,
                    true => USB5VSEL_A::Vdd5v,
                }
            }
            ///Checks if the value of the field is `Vdd3v3`
            #[inline(always)]
            pub fn is_vdd3v3(&self) -> bool {
                *self == USB5VSEL_A::Vdd3v3
            }
            ///Checks if the value of the field is `Vdd5v`
            #[inline(always)]
            pub fn is_vdd5v(&self) -> bool {
                *self == USB5VSEL_A::Vdd5v
            }
        }
        ///Field `USB5VSEL` writer - USB 5V Enable
        pub type USB5VSEL_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, USB5VSEL_A, O>;
        impl<'a, const O: u8> USB5VSEL_W<'a, O> {
            ///VDD is 3.3V
            #[inline(always)]
            pub fn vdd3v3(self) -> &'a mut W {
                self.variant(USB5VSEL_A::Vdd3v3)
            }
            ///VDD is 5V
            #[inline(always)]
            pub fn vdd5v(self) -> &'a mut W {
                self.variant(USB5VSEL_A::Vdd5v)
            }
        }
        ///Field `HSIPRE` reader - Whether HSI is divided
        pub type HSIPRE_R = crate::BitReader<HSIPRE_A>;
        ///Whether HSI is divided
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HSIPRE_A {
            ///0: HSI divided by 2 as PLL clock source
            Div2 = 0,
            ///1: HSI directly as PLL clock source
            NoDiv = 1,
        }
        impl From<HSIPRE_A> for bool {
            #[inline(always)]
            fn from(variant: HSIPRE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HSIPRE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HSIPRE_A {
                match self.bits {
                    false => HSIPRE_A::Div2,
                    true => HSIPRE_A::NoDiv,
                }
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == HSIPRE_A::Div2
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == HSIPRE_A::NoDiv
            }
        }
        ///Field `HSIPRE` writer - Whether HSI is divided
        pub type HSIPRE_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, HSIPRE_A, O>;
        impl<'a, const O: u8> HSIPRE_W<'a, O> {
            ///HSI divided by 2 as PLL clock source
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(HSIPRE_A::Div2)
            }
            ///HSI directly as PLL clock source
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(HSIPRE_A::NoDiv)
            }
        }
        ///Field `LKUPEN` reader - LOCKUP
        pub type LKUPEN_R = crate::BitReader<LKUPEN_A>;
        ///LOCKUP
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LKUPEN_A {
            ///0: Lock-up reset disabled
            Disabled = 0,
            ///1: Lock-up reset enabled
            Enabled = 1,
        }
        impl From<LKUPEN_A> for bool {
            #[inline(always)]
            fn from(variant: LKUPEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LKUPEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LKUPEN_A {
                match self.bits {
                    false => LKUPEN_A::Disabled,
                    true => LKUPEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LKUPEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LKUPEN_A::Enabled
            }
        }
        ///Field `LKUPEN` writer - LOCKUP
        pub type LKUPEN_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, LKUPEN_A, O>;
        impl<'a, const O: u8> LKUPEN_W<'a, O> {
            ///Lock-up reset disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LKUPEN_A::Disabled)
            }
            ///Lock-up reset enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LKUPEN_A::Enabled)
            }
        }
        ///Field `LKUPRESET` reader - LOCKUP RESET
        pub type LKUPRESET_R = crate::BitReader<LKUPRESETR_A>;
        ///LOCKUP RESET
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LKUPRESETR_A {
            ///0: No lock-up reset occurred
            Normal = 0,
            ///1: Lock-up reset occurred
            Reset = 1,
        }
        impl From<LKUPRESETR_A> for bool {
            #[inline(always)]
            fn from(variant: LKUPRESETR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LKUPRESET_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LKUPRESETR_A {
                match self.bits {
                    false => LKUPRESETR_A::Normal,
                    true => LKUPRESETR_A::Reset,
                }
            }
            ///Checks if the value of the field is `Normal`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == LKUPRESETR_A::Normal
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == LKUPRESETR_A::Reset
            }
        }
        ///LOCKUP RESET
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LKUPRESETW_AW {
            ///1: Clear reset flag
            Clear = 1,
        }
        impl From<LKUPRESETW_AW> for bool {
            #[inline(always)]
            fn from(variant: LKUPRESETW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LKUPRESET` writer - LOCKUP RESET
        pub type LKUPRESET_W<'a, const O: u8> =
            crate::BitWriter1C<'a, u32, EXTEND_CTR_SPEC, LKUPRESETW_AW, O>;
        impl<'a, const O: u8> LKUPRESET_W<'a, O> {
            ///Clear reset flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LKUPRESETW_AW::Clear)
            }
        }
        ///Field `ULLDOTRIM` reader - ULLDOTRIM
        pub type ULLDOTRIM_R = crate::FieldReader<u8, u8>;
        ///Field `ULLDOTRIM` writer - ULLDOTRIM
        pub type ULLDOTRIM_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTEND_CTR_SPEC, u8, u8, 2, O>;
        ///Field `LDOTRIM` reader - LDOTRIM
        pub type LDOTRIM_R = crate::BitReader<LDOTRIM_A>;
        ///LDOTRIM
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LDOTRIM_A {
            ///0: LDO output 1.5V
            Ldo1v5 = 0,
            ///1: LDO output 1.62V
            Ldo1v62 = 1,
        }
        impl From<LDOTRIM_A> for bool {
            #[inline(always)]
            fn from(variant: LDOTRIM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LDOTRIM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LDOTRIM_A {
                match self.bits {
                    false => LDOTRIM_A::Ldo1v5,
                    true => LDOTRIM_A::Ldo1v62,
                }
            }
            ///Checks if the value of the field is `Ldo1v5`
            #[inline(always)]
            pub fn is_ldo1v5(&self) -> bool {
                *self == LDOTRIM_A::Ldo1v5
            }
            ///Checks if the value of the field is `Ldo1v62`
            #[inline(always)]
            pub fn is_ldo1v62(&self) -> bool {
                *self == LDOTRIM_A::Ldo1v62
            }
        }
        ///Field `LDOTRIM` writer - LDOTRIM
        pub type LDOTRIM_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, LDOTRIM_A, O>;
        impl<'a, const O: u8> LDOTRIM_W<'a, O> {
            ///LDO output 1.5V
            #[inline(always)]
            pub fn ldo1v5(self) -> &'a mut W {
                self.variant(LDOTRIM_A::Ldo1v5)
            }
            ///LDO output 1.62V
            #[inline(always)]
            pub fn ldo1v62(self) -> &'a mut W {
                self.variant(LDOTRIM_A::Ldo1v62)
            }
        }
        impl R {
            ///Bit 0 - USBD Lowspeed Enable
            #[inline(always)]
            pub fn usbdls(&self) -> USBDLS_R {
                USBDLS_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - USBD pullup Enable
            #[inline(always)]
            pub fn usbdpu(&self) -> USBDPU_R {
                USBDPU_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USBHD IO(PB6/PB7) Enable
            #[inline(always)]
            pub fn usbhdio(&self) -> USBHDIO_R {
                USBHDIO_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - USB 5V Enable
            #[inline(always)]
            pub fn usb5vsel(&self) -> USB5VSEL_R {
                USB5VSEL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Whether HSI is divided
            #[inline(always)]
            pub fn hsipre(&self) -> HSIPRE_R {
                HSIPRE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - LOCKUP
            #[inline(always)]
            pub fn lkupen(&self) -> LKUPEN_R {
                LKUPEN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - LOCKUP RESET
            #[inline(always)]
            pub fn lkupreset(&self) -> LKUPRESET_R {
                LKUPRESET_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - ULLDOTRIM
            #[inline(always)]
            pub fn ulldotrim(&self) -> ULLDOTRIM_R {
                ULLDOTRIM_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - LDOTRIM
            #[inline(always)]
            pub fn ldotrim(&self) -> LDOTRIM_R {
                LDOTRIM_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - USBD Lowspeed Enable
            #[inline(always)]
            #[must_use]
            pub fn usbdls(&mut self) -> USBDLS_W<0> {
                USBDLS_W::new(self)
            }
            ///Bit 1 - USBD pullup Enable
            #[inline(always)]
            #[must_use]
            pub fn usbdpu(&mut self) -> USBDPU_W<1> {
                USBDPU_W::new(self)
            }
            ///Bit 2 - USBHD IO(PB6/PB7) Enable
            #[inline(always)]
            #[must_use]
            pub fn usbhdio(&mut self) -> USBHDIO_W<2> {
                USBHDIO_W::new(self)
            }
            ///Bit 3 - USB 5V Enable
            #[inline(always)]
            #[must_use]
            pub fn usb5vsel(&mut self) -> USB5VSEL_W<3> {
                USB5VSEL_W::new(self)
            }
            ///Bit 4 - Whether HSI is divided
            #[inline(always)]
            #[must_use]
            pub fn hsipre(&mut self) -> HSIPRE_W<4> {
                HSIPRE_W::new(self)
            }
            ///Bit 6 - LOCKUP
            #[inline(always)]
            #[must_use]
            pub fn lkupen(&mut self) -> LKUPEN_W<6> {
                LKUPEN_W::new(self)
            }
            ///Bit 7 - LOCKUP RESET
            #[inline(always)]
            #[must_use]
            pub fn lkupreset(&mut self) -> LKUPRESET_W<7> {
                LKUPRESET_W::new(self)
            }
            ///Bits 8:9 - ULLDOTRIM
            #[inline(always)]
            #[must_use]
            pub fn ulldotrim(&mut self) -> ULLDOTRIM_W<8> {
                ULLDOTRIM_W::new(self)
            }
            ///Bit 10 - LDOTRIM
            #[inline(always)]
            #[must_use]
            pub fn ldotrim(&mut self) -> LDOTRIM_W<10> {
                LDOTRIM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///EXTEND register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [extend_ctr](index.html) module
        pub struct EXTEND_CTR_SPEC;
        impl crate::RegisterSpec for EXTEND_CTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [extend_ctr::R](R) reader structure
        impl crate::Readable for EXTEND_CTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [extend_ctr::W](W) writer structure
        impl crate::Writable for EXTEND_CTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x80;
        }
        ///`reset()` method sets EXTEND_CTR to value 0x20
        impl crate::Resettable for EXTEND_CTR_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
}
///General purpose I/O
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_0800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA").finish()
    }
}
///General purpose I/O
pub mod gpioa {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Port configuration register low(GPIOn_CFGLR)
        pub cfglr: CFGLR,
        ///0x04 - Port configuration register high (GPIOn_CFGHR)
        pub cfghr: CFGHR,
        ///0x08 - Port input data register (GPIOn_INDR)
        pub indr: INDR,
        ///0x0c - Port output data register (GPIOn_OUTDR)
        pub outdr: OUTDR,
        ///0x10 - Port bit set/reset register (GPIOn_BSHR)
        pub bshr: BSHR,
        ///0x14 - Port bit reset register (GPIOn_BCR)
        pub bcr: BCR,
        ///0x18 - Port configuration lock register
        pub lckr: LCKR,
    }
    ///CFGLR (rw) register accessor: an alias for `Reg<CFGLR_SPEC>`
    pub type CFGLR = crate::Reg<cfglr::CFGLR_SPEC>;
    ///Port configuration register low(GPIOn_CFGLR)
    pub mod cfglr {
        ///Register `CFGLR` reader
        pub struct R(crate::R<CFGLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGLR` writer
        pub struct W(crate::W<CFGLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MODE0` reader - Port n.0 mode bits
        pub type MODE0_R = crate::FieldReader<u8, MODE0_A>;
        ///Port n.0 mode bits
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MODE0_A {
            ///0: Pin used as input
            Input = 0,
            ///1: Pin used as output with max speed 10MHz
            Output = 1,
            ///2: Pin used as output with max speed 2MHz
            LowSpeed = 2,
            ///3: Pin used as output with max speed 50MHz
            HighSpeed = 3,
        }
        impl From<MODE0_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE0_A) -> Self {
                variant as _
            }
        }
        impl MODE0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MODE0_A {
                match self.bits {
                    0 => MODE0_A::Input,
                    1 => MODE0_A::Output,
                    2 => MODE0_A::LowSpeed,
                    3 => MODE0_A::HighSpeed,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == MODE0_A::Input
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == MODE0_A::Output
            }
            ///Checks if the value of the field is `LowSpeed`
            #[inline(always)]
            pub fn is_low_speed(&self) -> bool {
                *self == MODE0_A::LowSpeed
            }
            ///Checks if the value of the field is `HighSpeed`
            #[inline(always)]
            pub fn is_high_speed(&self) -> bool {
                *self == MODE0_A::HighSpeed
            }
        }
        ///Field `MODE0` writer - Port n.0 mode bits
        pub type MODE0_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGLR_SPEC, u8, MODE0_A, 2, O>;
        impl<'a, const O: u8> MODE0_W<'a, O> {
            ///Pin used as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::Input)
            }
            ///Pin used as output with max speed 10MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::Output)
            }
            ///Pin used as output with max speed 2MHz
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(MODE0_A::LowSpeed)
            }
            ///Pin used as output with max speed 50MHz
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(MODE0_A::HighSpeed)
            }
        }
        ///Field `CNF0` reader - Port n.0 configuration bits
        pub type CNF0_R = crate::FieldReader<u8, CNF0_A>;
        ///Port n.0 configuration bits
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CNF0_A {
            ///0: Analog input or general purpose push-pull output
            AinputPpoutput = 0,
            ///1: Float input or general purpose open drain output
            FinputOdoutput = 1,
            ///2: Pull up pull down input or alternate function push-pull output
            PudinputAlternatePpoutput = 2,
            ///3: Alternate function open drain output
            AlternateOdoutput = 3,
        }
        impl From<CNF0_A> for u8 {
            #[inline(always)]
            fn from(variant: CNF0_A) -> Self {
                variant as _
            }
        }
        impl CNF0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CNF0_A {
                match self.bits {
                    0 => CNF0_A::AinputPpoutput,
                    1 => CNF0_A::FinputOdoutput,
                    2 => CNF0_A::PudinputAlternatePpoutput,
                    3 => CNF0_A::AlternateOdoutput,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `AinputPpoutput`
            #[inline(always)]
            pub fn is_ainput_ppoutput(&self) -> bool {
                *self == CNF0_A::AinputPpoutput
            }
            ///Checks if the value of the field is `FinputOdoutput`
            #[inline(always)]
            pub fn is_finput_odoutput(&self) -> bool {
                *self == CNF0_A::FinputOdoutput
            }
            ///Checks if the value of the field is `PudinputAlternatePpoutput`
            #[inline(always)]
            pub fn is_pudinput_alternate_ppoutput(&self) -> bool {
                *self == CNF0_A::PudinputAlternatePpoutput
            }
            ///Checks if the value of the field is `AlternateOdoutput`
            #[inline(always)]
            pub fn is_alternate_odoutput(&self) -> bool {
                *self == CNF0_A::AlternateOdoutput
            }
        }
        ///Field `CNF0` writer - Port n.0 configuration bits
        pub type CNF0_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGLR_SPEC, u8, CNF0_A, 2, O>;
        impl<'a, const O: u8> CNF0_W<'a, O> {
            ///Analog input or general purpose push-pull output
            #[inline(always)]
            pub fn ainput_ppoutput(self) -> &'a mut W {
                self.variant(CNF0_A::AinputPpoutput)
            }
            ///Float input or general purpose open drain output
            #[inline(always)]
            pub fn finput_odoutput(self) -> &'a mut W {
                self.variant(CNF0_A::FinputOdoutput)
            }
            ///Pull up pull down input or alternate function push-pull output
            #[inline(always)]
            pub fn pudinput_alternate_ppoutput(self) -> &'a mut W {
                self.variant(CNF0_A::PudinputAlternatePpoutput)
            }
            ///Alternate function open drain output
            #[inline(always)]
            pub fn alternate_odoutput(self) -> &'a mut W {
                self.variant(CNF0_A::AlternateOdoutput)
            }
        }
        ///Field `CNF1` reader - Port n.1 configuration bits
        pub use CNF0_R as CNF1_R;
        ///Field `CNF2` reader - Port n.2 configuration bits
        pub use CNF0_R as CNF2_R;
        ///Field `CNF3` reader - Port n.3 configuration bits
        pub use CNF0_R as CNF3_R;
        ///Field `CNF4` reader - Port n.4 configuration bits
        pub use CNF0_R as CNF4_R;
        ///Field `CNF5` reader - Port n.5 configuration bits
        pub use CNF0_R as CNF5_R;
        ///Field `CNF6` reader - Port n.6 configuration bits
        pub use CNF0_R as CNF6_R;
        ///Field `CNF7` reader - Port n.7 configuration bits
        pub use CNF0_R as CNF7_R;
        ///Field `CNF1` writer - Port n.1 configuration bits
        pub use CNF0_W as CNF1_W;
        ///Field `CNF2` writer - Port n.2 configuration bits
        pub use CNF0_W as CNF2_W;
        ///Field `CNF3` writer - Port n.3 configuration bits
        pub use CNF0_W as CNF3_W;
        ///Field `CNF4` writer - Port n.4 configuration bits
        pub use CNF0_W as CNF4_W;
        ///Field `CNF5` writer - Port n.5 configuration bits
        pub use CNF0_W as CNF5_W;
        ///Field `CNF6` writer - Port n.6 configuration bits
        pub use CNF0_W as CNF6_W;
        ///Field `CNF7` writer - Port n.7 configuration bits
        pub use CNF0_W as CNF7_W;
        ///Field `MODE1` reader - Port n.1 mode bits
        pub use MODE0_R as MODE1_R;
        ///Field `MODE2` reader - Port n.2 mode bits
        pub use MODE0_R as MODE2_R;
        ///Field `MODE3` reader - Port n.3 mode bits
        pub use MODE0_R as MODE3_R;
        ///Field `MODE4` reader - Port n.4 mode bits
        pub use MODE0_R as MODE4_R;
        ///Field `MODE5` reader - Port n.5 mode bits
        pub use MODE0_R as MODE5_R;
        ///Field `MODE6` reader - Port n.6 mode bits
        pub use MODE0_R as MODE6_R;
        ///Field `MODE7` reader - Port n.7 mode bits
        pub use MODE0_R as MODE7_R;
        ///Field `MODE1` writer - Port n.1 mode bits
        pub use MODE0_W as MODE1_W;
        ///Field `MODE2` writer - Port n.2 mode bits
        pub use MODE0_W as MODE2_W;
        ///Field `MODE3` writer - Port n.3 mode bits
        pub use MODE0_W as MODE3_W;
        ///Field `MODE4` writer - Port n.4 mode bits
        pub use MODE0_W as MODE4_W;
        ///Field `MODE5` writer - Port n.5 mode bits
        pub use MODE0_W as MODE5_W;
        ///Field `MODE6` writer - Port n.6 mode bits
        pub use MODE0_W as MODE6_W;
        ///Field `MODE7` writer - Port n.7 mode bits
        pub use MODE0_W as MODE7_W;
        impl R {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            pub fn mode0(&self) -> MODE0_R {
                MODE0_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            pub fn cnf0(&self) -> CNF0_R {
                CNF0_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            pub fn cnf1(&self) -> CNF1_R {
                CNF1_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            pub fn cnf2(&self) -> CNF2_R {
                CNF2_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            pub fn cnf3(&self) -> CNF3_R {
                CNF3_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            pub fn mode4(&self) -> MODE4_R {
                MODE4_R::new(((self.bits >> 16) & 3) as u8)
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            pub fn cnf4(&self) -> CNF4_R {
                CNF4_R::new(((self.bits >> 18) & 3) as u8)
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            pub fn mode5(&self) -> MODE5_R {
                MODE5_R::new(((self.bits >> 20) & 3) as u8)
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            pub fn cnf5(&self) -> CNF5_R {
                CNF5_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            pub fn mode6(&self) -> MODE6_R {
                MODE6_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            pub fn cnf6(&self) -> CNF6_R {
                CNF6_R::new(((self.bits >> 26) & 3) as u8)
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            pub fn mode7(&self) -> MODE7_R {
                MODE7_R::new(((self.bits >> 28) & 3) as u8)
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            pub fn cnf7(&self) -> CNF7_R {
                CNF7_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode0(&mut self) -> MODE0_W<0> {
                MODE0_W::new(self)
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf0(&mut self) -> CNF0_W<2> {
                CNF0_W::new(self)
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode1(&mut self) -> MODE1_W<4> {
                MODE1_W::new(self)
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf1(&mut self) -> CNF1_W<6> {
                CNF1_W::new(self)
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode2(&mut self) -> MODE2_W<8> {
                MODE2_W::new(self)
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf2(&mut self) -> CNF2_W<10> {
                CNF2_W::new(self)
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode3(&mut self) -> MODE3_W<12> {
                MODE3_W::new(self)
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf3(&mut self) -> CNF3_W<14> {
                CNF3_W::new(self)
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode4(&mut self) -> MODE4_W<16> {
                MODE4_W::new(self)
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf4(&mut self) -> CNF4_W<18> {
                CNF4_W::new(self)
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode5(&mut self) -> MODE5_W<20> {
                MODE5_W::new(self)
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf5(&mut self) -> CNF5_W<22> {
                CNF5_W::new(self)
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode6(&mut self) -> MODE6_W<24> {
                MODE6_W::new(self)
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf6(&mut self) -> CNF6_W<26> {
                CNF6_W::new(self)
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode7(&mut self) -> MODE7_W<28> {
                MODE7_W::new(self)
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf7(&mut self) -> CNF7_W<30> {
                CNF7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration register low(GPIOn_CFGLR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfglr](index.html) module
        pub struct CFGLR_SPEC;
        impl crate::RegisterSpec for CFGLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfglr::R](R) reader structure
        impl crate::Readable for CFGLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfglr::W](W) writer structure
        impl crate::Writable for CFGLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGLR to value 0x4444_4444
        impl crate::Resettable for CFGLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x4444_4444;
        }
    }
    ///CFGHR (rw) register accessor: an alias for `Reg<CFGHR_SPEC>`
    pub type CFGHR = crate::Reg<cfghr::CFGHR_SPEC>;
    ///Port configuration register high (GPIOn_CFGHR)
    pub mod cfghr {
        ///Register `CFGHR` reader
        pub struct R(crate::R<CFGHR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGHR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGHR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGHR` writer
        pub struct W(crate::W<CFGHR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGHR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGHR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MODE8` reader - Port n.8 mode bits
        pub type MODE8_R = crate::FieldReader<u8, MODE8_A>;
        ///Port n.8 mode bits
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MODE8_A {
            ///0: Pin used as input
            Input = 0,
            ///1: Pin used as output with max speed 10MHz
            Output = 1,
            ///2: Pin used as output with max speed 2MHz
            LowSpeed = 2,
            ///3: Pin used as output with max speed 50MHz
            HighSpeed = 3,
        }
        impl From<MODE8_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE8_A) -> Self {
                variant as _
            }
        }
        impl MODE8_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MODE8_A {
                match self.bits {
                    0 => MODE8_A::Input,
                    1 => MODE8_A::Output,
                    2 => MODE8_A::LowSpeed,
                    3 => MODE8_A::HighSpeed,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == MODE8_A::Input
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == MODE8_A::Output
            }
            ///Checks if the value of the field is `LowSpeed`
            #[inline(always)]
            pub fn is_low_speed(&self) -> bool {
                *self == MODE8_A::LowSpeed
            }
            ///Checks if the value of the field is `HighSpeed`
            #[inline(always)]
            pub fn is_high_speed(&self) -> bool {
                *self == MODE8_A::HighSpeed
            }
        }
        ///Field `MODE8` writer - Port n.8 mode bits
        pub type MODE8_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGHR_SPEC, u8, MODE8_A, 2, O>;
        impl<'a, const O: u8> MODE8_W<'a, O> {
            ///Pin used as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::Input)
            }
            ///Pin used as output with max speed 10MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::Output)
            }
            ///Pin used as output with max speed 2MHz
            #[inline(always)]
            pub fn low_speed(self) -> &'a mut W {
                self.variant(MODE8_A::LowSpeed)
            }
            ///Pin used as output with max speed 50MHz
            #[inline(always)]
            pub fn high_speed(self) -> &'a mut W {
                self.variant(MODE8_A::HighSpeed)
            }
        }
        ///Field `CNF8` reader - Port n.8 configuration bits
        pub type CNF8_R = crate::FieldReader<u8, CNF8_A>;
        ///Port n.8 configuration bits
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CNF8_A {
            ///0: Analog input or general purpose push-pull output
            AinputPpoutput = 0,
            ///1: Float input or general purpose open drain output
            FinputOdoutput = 1,
            ///2: Pull up pull down input or alternate function push-pull output
            PudinputAlternatePpoutput = 2,
            ///3: Alternate function open drain output
            AlternateOdoutput = 3,
        }
        impl From<CNF8_A> for u8 {
            #[inline(always)]
            fn from(variant: CNF8_A) -> Self {
                variant as _
            }
        }
        impl CNF8_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CNF8_A {
                match self.bits {
                    0 => CNF8_A::AinputPpoutput,
                    1 => CNF8_A::FinputOdoutput,
                    2 => CNF8_A::PudinputAlternatePpoutput,
                    3 => CNF8_A::AlternateOdoutput,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `AinputPpoutput`
            #[inline(always)]
            pub fn is_ainput_ppoutput(&self) -> bool {
                *self == CNF8_A::AinputPpoutput
            }
            ///Checks if the value of the field is `FinputOdoutput`
            #[inline(always)]
            pub fn is_finput_odoutput(&self) -> bool {
                *self == CNF8_A::FinputOdoutput
            }
            ///Checks if the value of the field is `PudinputAlternatePpoutput`
            #[inline(always)]
            pub fn is_pudinput_alternate_ppoutput(&self) -> bool {
                *self == CNF8_A::PudinputAlternatePpoutput
            }
            ///Checks if the value of the field is `AlternateOdoutput`
            #[inline(always)]
            pub fn is_alternate_odoutput(&self) -> bool {
                *self == CNF8_A::AlternateOdoutput
            }
        }
        ///Field `CNF8` writer - Port n.8 configuration bits
        pub type CNF8_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGHR_SPEC, u8, CNF8_A, 2, O>;
        impl<'a, const O: u8> CNF8_W<'a, O> {
            ///Analog input or general purpose push-pull output
            #[inline(always)]
            pub fn ainput_ppoutput(self) -> &'a mut W {
                self.variant(CNF8_A::AinputPpoutput)
            }
            ///Float input or general purpose open drain output
            #[inline(always)]
            pub fn finput_odoutput(self) -> &'a mut W {
                self.variant(CNF8_A::FinputOdoutput)
            }
            ///Pull up pull down input or alternate function push-pull output
            #[inline(always)]
            pub fn pudinput_alternate_ppoutput(self) -> &'a mut W {
                self.variant(CNF8_A::PudinputAlternatePpoutput)
            }
            ///Alternate function open drain output
            #[inline(always)]
            pub fn alternate_odoutput(self) -> &'a mut W {
                self.variant(CNF8_A::AlternateOdoutput)
            }
        }
        ///Field `CNF9` reader - Port n.9 configuration bits
        pub use CNF8_R as CNF9_R;
        ///Field `CNF9` writer - Port n.9 configuration bits
        pub use CNF8_W as CNF9_W;
        ///Field `MODE9` reader - Port n.9 mode bits
        pub use MODE8_R as MODE9_R;
        ///Field `MODE9` writer - Port n.9 mode bits
        pub use MODE8_W as MODE9_W;
        ///Field `MODE10` reader - Port n.10 mode bits
        pub type MODE10_R = crate::FieldReader<u8, u8>;
        ///Field `MODE10` writer - Port n.10 mode bits
        pub type MODE10_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `CNF10` reader - Port n.10 configuration bits
        pub type CNF10_R = crate::FieldReader<u8, u8>;
        ///Field `CNF10` writer - Port n.10 configuration bits
        pub type CNF10_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `MODE11` reader - Port n.11 mode bits
        pub type MODE11_R = crate::FieldReader<u8, u8>;
        ///Field `MODE11` writer - Port n.11 mode bits
        pub type MODE11_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `CNF11` reader - Port n.11 configuration bits
        pub type CNF11_R = crate::FieldReader<u8, u8>;
        ///Field `CNF11` writer - Port n.11 configuration bits
        pub type CNF11_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `MODE12` reader - Port n.12 mode bits
        pub type MODE12_R = crate::FieldReader<u8, u8>;
        ///Field `MODE12` writer - Port n.12 mode bits
        pub type MODE12_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `CNF12` reader - Port n.12 configuration bits
        pub type CNF12_R = crate::FieldReader<u8, u8>;
        ///Field `CNF12` writer - Port n.12 configuration bits
        pub type CNF12_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `MODE13` reader - Port n.13 mode bits
        pub type MODE13_R = crate::FieldReader<u8, u8>;
        ///Field `MODE13` writer - Port n.13 mode bits
        pub type MODE13_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `CNF13` reader - Port n.13 configuration bits
        pub type CNF13_R = crate::FieldReader<u8, u8>;
        ///Field `CNF13` writer - Port n.13 configuration bits
        pub type CNF13_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `MODE14` reader - Port n.14 mode bits
        pub type MODE14_R = crate::FieldReader<u8, u8>;
        ///Field `MODE14` writer - Port n.14 mode bits
        pub type MODE14_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `CNF14` reader - Port n.14 configuration bits
        pub type CNF14_R = crate::FieldReader<u8, u8>;
        ///Field `CNF14` writer - Port n.14 configuration bits
        pub type CNF14_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `MODE15` reader - Port n.15 mode bits
        pub type MODE15_R = crate::FieldReader<u8, u8>;
        ///Field `MODE15` writer - Port n.15 mode bits
        pub type MODE15_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        ///Field `CNF15` reader - Port n.15 configuration bits
        pub type CNF15_R = crate::FieldReader<u8, u8>;
        ///Field `CNF15` writer - Port n.15 configuration bits
        pub type CNF15_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGHR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:1 - Port n.8 mode bits
            #[inline(always)]
            pub fn mode8(&self) -> MODE8_R {
                MODE8_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Port n.8 configuration bits
            #[inline(always)]
            pub fn cnf8(&self) -> CNF8_R {
                CNF8_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:5 - Port n.9 mode bits
            #[inline(always)]
            pub fn mode9(&self) -> MODE9_R {
                MODE9_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - Port n.9 configuration bits
            #[inline(always)]
            pub fn cnf9(&self) -> CNF9_R {
                CNF9_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - Port n.10 mode bits
            #[inline(always)]
            pub fn mode10(&self) -> MODE10_R {
                MODE10_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Port n.10 configuration bits
            #[inline(always)]
            pub fn cnf10(&self) -> CNF10_R {
                CNF10_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Port n.11 mode bits
            #[inline(always)]
            pub fn mode11(&self) -> MODE11_R {
                MODE11_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bits 14:15 - Port n.11 configuration bits
            #[inline(always)]
            pub fn cnf11(&self) -> CNF11_R {
                CNF11_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bits 16:17 - Port n.12 mode bits
            #[inline(always)]
            pub fn mode12(&self) -> MODE12_R {
                MODE12_R::new(((self.bits >> 16) & 3) as u8)
            }
            ///Bits 18:19 - Port n.12 configuration bits
            #[inline(always)]
            pub fn cnf12(&self) -> CNF12_R {
                CNF12_R::new(((self.bits >> 18) & 3) as u8)
            }
            ///Bits 20:21 - Port n.13 mode bits
            #[inline(always)]
            pub fn mode13(&self) -> MODE13_R {
                MODE13_R::new(((self.bits >> 20) & 3) as u8)
            }
            ///Bits 22:23 - Port n.13 configuration bits
            #[inline(always)]
            pub fn cnf13(&self) -> CNF13_R {
                CNF13_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:25 - Port n.14 mode bits
            #[inline(always)]
            pub fn mode14(&self) -> MODE14_R {
                MODE14_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bits 26:27 - Port n.14 configuration bits
            #[inline(always)]
            pub fn cnf14(&self) -> CNF14_R {
                CNF14_R::new(((self.bits >> 26) & 3) as u8)
            }
            ///Bits 28:29 - Port n.15 mode bits
            #[inline(always)]
            pub fn mode15(&self) -> MODE15_R {
                MODE15_R::new(((self.bits >> 28) & 3) as u8)
            }
            ///Bits 30:31 - Port n.15 configuration bits
            #[inline(always)]
            pub fn cnf15(&self) -> CNF15_R {
                CNF15_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Port n.8 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode8(&mut self) -> MODE8_W<0> {
                MODE8_W::new(self)
            }
            ///Bits 2:3 - Port n.8 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf8(&mut self) -> CNF8_W<2> {
                CNF8_W::new(self)
            }
            ///Bits 4:5 - Port n.9 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode9(&mut self) -> MODE9_W<4> {
                MODE9_W::new(self)
            }
            ///Bits 6:7 - Port n.9 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf9(&mut self) -> CNF9_W<6> {
                CNF9_W::new(self)
            }
            ///Bits 8:9 - Port n.10 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode10(&mut self) -> MODE10_W<8> {
                MODE10_W::new(self)
            }
            ///Bits 10:11 - Port n.10 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf10(&mut self) -> CNF10_W<10> {
                CNF10_W::new(self)
            }
            ///Bits 12:13 - Port n.11 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode11(&mut self) -> MODE11_W<12> {
                MODE11_W::new(self)
            }
            ///Bits 14:15 - Port n.11 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf11(&mut self) -> CNF11_W<14> {
                CNF11_W::new(self)
            }
            ///Bits 16:17 - Port n.12 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode12(&mut self) -> MODE12_W<16> {
                MODE12_W::new(self)
            }
            ///Bits 18:19 - Port n.12 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf12(&mut self) -> CNF12_W<18> {
                CNF12_W::new(self)
            }
            ///Bits 20:21 - Port n.13 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode13(&mut self) -> MODE13_W<20> {
                MODE13_W::new(self)
            }
            ///Bits 22:23 - Port n.13 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf13(&mut self) -> CNF13_W<22> {
                CNF13_W::new(self)
            }
            ///Bits 24:25 - Port n.14 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode14(&mut self) -> MODE14_W<24> {
                MODE14_W::new(self)
            }
            ///Bits 26:27 - Port n.14 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf14(&mut self) -> CNF14_W<26> {
                CNF14_W::new(self)
            }
            ///Bits 28:29 - Port n.15 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode15(&mut self) -> MODE15_W<28> {
                MODE15_W::new(self)
            }
            ///Bits 30:31 - Port n.15 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf15(&mut self) -> CNF15_W<30> {
                CNF15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration register high (GPIOn_CFGHR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfghr](index.html) module
        pub struct CFGHR_SPEC;
        impl crate::RegisterSpec for CFGHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfghr::R](R) reader structure
        impl crate::Readable for CFGHR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfghr::W](W) writer structure
        impl crate::Writable for CFGHR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGHR to value 0x4444_4444
        impl crate::Resettable for CFGHR_SPEC {
            const RESET_VALUE: Self::Ux = 0x4444_4444;
        }
    }
    ///INDR (r) register accessor: an alias for `Reg<INDR_SPEC>`
    pub type INDR = crate::Reg<indr::INDR_SPEC>;
    ///Port input data register (GPIOn_INDR)
    pub mod indr {
        ///Register `INDR` reader
        pub struct R(crate::R<INDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDR0` reader - Port input data
        pub type IDR0_R = crate::BitReader<bool>;
        ///Field `IDR1` reader - Port input data
        pub type IDR1_R = crate::BitReader<bool>;
        ///Field `IDR2` reader - Port input data
        pub type IDR2_R = crate::BitReader<bool>;
        ///Field `IDR3` reader - Port input data
        pub type IDR3_R = crate::BitReader<bool>;
        ///Field `IDR4` reader - Port input data
        pub type IDR4_R = crate::BitReader<bool>;
        ///Field `IDR5` reader - Port input data
        pub type IDR5_R = crate::BitReader<bool>;
        ///Field `IDR6` reader - Port input data
        pub type IDR6_R = crate::BitReader<bool>;
        ///Field `IDR7` reader - Port input data
        pub type IDR7_R = crate::BitReader<bool>;
        ///Field `IDR8` reader - Port input data
        pub type IDR8_R = crate::BitReader<bool>;
        ///Field `IDR9` reader - Port input data
        pub type IDR9_R = crate::BitReader<bool>;
        ///Field `IDR10` reader - Port input data
        pub type IDR10_R = crate::BitReader<bool>;
        ///Field `IDR11` reader - Port input data
        pub type IDR11_R = crate::BitReader<bool>;
        ///Field `IDR12` reader - Port input data
        pub type IDR12_R = crate::BitReader<bool>;
        ///Field `IDR13` reader - Port input data
        pub type IDR13_R = crate::BitReader<bool>;
        ///Field `IDR14` reader - Port input data
        pub type IDR14_R = crate::BitReader<bool>;
        ///Field `IDR15` reader - Port input data
        pub type IDR15_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Port input data
            #[inline(always)]
            pub fn idr0(&self) -> IDR0_R {
                IDR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port input data
            #[inline(always)]
            pub fn idr1(&self) -> IDR1_R {
                IDR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port input data
            #[inline(always)]
            pub fn idr2(&self) -> IDR2_R {
                IDR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port input data
            #[inline(always)]
            pub fn idr3(&self) -> IDR3_R {
                IDR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port input data
            #[inline(always)]
            pub fn idr4(&self) -> IDR4_R {
                IDR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port input data
            #[inline(always)]
            pub fn idr5(&self) -> IDR5_R {
                IDR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port input data
            #[inline(always)]
            pub fn idr6(&self) -> IDR6_R {
                IDR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port input data
            #[inline(always)]
            pub fn idr7(&self) -> IDR7_R {
                IDR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Port input data
            #[inline(always)]
            pub fn idr8(&self) -> IDR8_R {
                IDR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Port input data
            #[inline(always)]
            pub fn idr9(&self) -> IDR9_R {
                IDR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Port input data
            #[inline(always)]
            pub fn idr10(&self) -> IDR10_R {
                IDR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Port input data
            #[inline(always)]
            pub fn idr11(&self) -> IDR11_R {
                IDR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Port input data
            #[inline(always)]
            pub fn idr12(&self) -> IDR12_R {
                IDR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Port input data
            #[inline(always)]
            pub fn idr13(&self) -> IDR13_R {
                IDR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Port input data
            #[inline(always)]
            pub fn idr14(&self) -> IDR14_R {
                IDR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Port input data
            #[inline(always)]
            pub fn idr15(&self) -> IDR15_R {
                IDR15_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///Port input data register (GPIOn_INDR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [indr](index.html) module
        pub struct INDR_SPEC;
        impl crate::RegisterSpec for INDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [indr::R](R) reader structure
        impl crate::Readable for INDR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets INDR to value 0
        impl crate::Resettable for INDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OUTDR (rw) register accessor: an alias for `Reg<OUTDR_SPEC>`
    pub type OUTDR = crate::Reg<outdr::OUTDR_SPEC>;
    ///Port output data register (GPIOn_OUTDR)
    pub mod outdr {
        ///Register `OUTDR` reader
        pub struct R(crate::R<OUTDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OUTDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OUTDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OUTDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OUTDR` writer
        pub struct W(crate::W<OUTDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OUTDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OUTDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OUTDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ODR0` reader - Port output data
        pub type ODR0_R = crate::BitReader<bool>;
        ///Field `ODR0` writer - Port output data
        pub type ODR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR1` reader - Port output data
        pub type ODR1_R = crate::BitReader<bool>;
        ///Field `ODR1` writer - Port output data
        pub type ODR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR2` reader - Port output data
        pub type ODR2_R = crate::BitReader<bool>;
        ///Field `ODR2` writer - Port output data
        pub type ODR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR3` reader - Port output data
        pub type ODR3_R = crate::BitReader<bool>;
        ///Field `ODR3` writer - Port output data
        pub type ODR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR4` reader - Port output data
        pub type ODR4_R = crate::BitReader<bool>;
        ///Field `ODR4` writer - Port output data
        pub type ODR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR5` reader - Port output data
        pub type ODR5_R = crate::BitReader<bool>;
        ///Field `ODR5` writer - Port output data
        pub type ODR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR6` reader - Port output data
        pub type ODR6_R = crate::BitReader<bool>;
        ///Field `ODR6` writer - Port output data
        pub type ODR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR7` reader - Port output data
        pub type ODR7_R = crate::BitReader<bool>;
        ///Field `ODR7` writer - Port output data
        pub type ODR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR8` reader - Port output data
        pub type ODR8_R = crate::BitReader<bool>;
        ///Field `ODR8` writer - Port output data
        pub type ODR8_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR9` reader - Port output data
        pub type ODR9_R = crate::BitReader<bool>;
        ///Field `ODR9` writer - Port output data
        pub type ODR9_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR10` reader - Port output data
        pub type ODR10_R = crate::BitReader<bool>;
        ///Field `ODR10` writer - Port output data
        pub type ODR10_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR11` reader - Port output data
        pub type ODR11_R = crate::BitReader<bool>;
        ///Field `ODR11` writer - Port output data
        pub type ODR11_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR12` reader - Port output data
        pub type ODR12_R = crate::BitReader<bool>;
        ///Field `ODR12` writer - Port output data
        pub type ODR12_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR13` reader - Port output data
        pub type ODR13_R = crate::BitReader<bool>;
        ///Field `ODR13` writer - Port output data
        pub type ODR13_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR14` reader - Port output data
        pub type ODR14_R = crate::BitReader<bool>;
        ///Field `ODR14` writer - Port output data
        pub type ODR14_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR15` reader - Port output data
        pub type ODR15_R = crate::BitReader<bool>;
        ///Field `ODR15` writer - Port output data
        pub type ODR15_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Port output data
            #[inline(always)]
            pub fn odr0(&self) -> ODR0_R {
                ODR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            pub fn odr1(&self) -> ODR1_R {
                ODR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            pub fn odr2(&self) -> ODR2_R {
                ODR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            pub fn odr3(&self) -> ODR3_R {
                ODR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            pub fn odr4(&self) -> ODR4_R {
                ODR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            pub fn odr5(&self) -> ODR5_R {
                ODR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            pub fn odr6(&self) -> ODR6_R {
                ODR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            pub fn odr7(&self) -> ODR7_R {
                ODR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Port output data
            #[inline(always)]
            pub fn odr8(&self) -> ODR8_R {
                ODR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Port output data
            #[inline(always)]
            pub fn odr9(&self) -> ODR9_R {
                ODR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Port output data
            #[inline(always)]
            pub fn odr10(&self) -> ODR10_R {
                ODR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Port output data
            #[inline(always)]
            pub fn odr11(&self) -> ODR11_R {
                ODR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Port output data
            #[inline(always)]
            pub fn odr12(&self) -> ODR12_R {
                ODR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Port output data
            #[inline(always)]
            pub fn odr13(&self) -> ODR13_R {
                ODR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Port output data
            #[inline(always)]
            pub fn odr14(&self) -> ODR14_R {
                ODR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Port output data
            #[inline(always)]
            pub fn odr15(&self) -> ODR15_R {
                ODR15_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr0(&mut self) -> ODR0_W<0> {
                ODR0_W::new(self)
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr1(&mut self) -> ODR1_W<1> {
                ODR1_W::new(self)
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr2(&mut self) -> ODR2_W<2> {
                ODR2_W::new(self)
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr3(&mut self) -> ODR3_W<3> {
                ODR3_W::new(self)
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr4(&mut self) -> ODR4_W<4> {
                ODR4_W::new(self)
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr5(&mut self) -> ODR5_W<5> {
                ODR5_W::new(self)
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr6(&mut self) -> ODR6_W<6> {
                ODR6_W::new(self)
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr7(&mut self) -> ODR7_W<7> {
                ODR7_W::new(self)
            }
            ///Bit 8 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr8(&mut self) -> ODR8_W<8> {
                ODR8_W::new(self)
            }
            ///Bit 9 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr9(&mut self) -> ODR9_W<9> {
                ODR9_W::new(self)
            }
            ///Bit 10 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr10(&mut self) -> ODR10_W<10> {
                ODR10_W::new(self)
            }
            ///Bit 11 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr11(&mut self) -> ODR11_W<11> {
                ODR11_W::new(self)
            }
            ///Bit 12 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr12(&mut self) -> ODR12_W<12> {
                ODR12_W::new(self)
            }
            ///Bit 13 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr13(&mut self) -> ODR13_W<13> {
                ODR13_W::new(self)
            }
            ///Bit 14 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr14(&mut self) -> ODR14_W<14> {
                ODR14_W::new(self)
            }
            ///Bit 15 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr15(&mut self) -> ODR15_W<15> {
                ODR15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port output data register (GPIOn_OUTDR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [outdr](index.html) module
        pub struct OUTDR_SPEC;
        impl crate::RegisterSpec for OUTDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [outdr::R](R) reader structure
        impl crate::Readable for OUTDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [outdr::W](W) writer structure
        impl crate::Writable for OUTDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OUTDR to value 0
        impl crate::Resettable for OUTDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BSHR (w) register accessor: an alias for `Reg<BSHR_SPEC>`
    pub type BSHR = crate::Reg<bshr::BSHR_SPEC>;
    ///Port bit set/reset register (GPIOn_BSHR)
    pub mod bshr {
        ///Register `BSHR` writer
        pub struct W(crate::W<BSHR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BSHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BSHR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BSHR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Set bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BS0W_AW {
            ///1: Set output bit
            Set = 1,
        }
        impl From<BS0W_AW> for bool {
            #[inline(always)]
            fn from(variant: BS0W_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BS0` writer - Set bit 0
        pub type BS0_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, BS0W_AW, O>;
        impl<'a, const O: u8> BS0_W<'a, O> {
            ///Set output bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W_AW::Set)
            }
        }
        ///Field `BS1` writer - Set bit 1
        pub use BS0_W as BS1_W;
        ///Field `BS2` writer - Set bit 1
        pub use BS0_W as BS2_W;
        ///Field `BS3` writer - Set bit 3
        pub use BS0_W as BS3_W;
        ///Field `BS4` writer - Set bit 4
        pub use BS0_W as BS4_W;
        ///Field `BS5` writer - Set bit 5
        pub use BS0_W as BS5_W;
        ///Field `BS6` writer - Set bit 6
        pub use BS0_W as BS6_W;
        ///Field `BS7` writer - Set bit 7
        pub use BS0_W as BS7_W;
        ///Field `BS8` writer - Set bit 8
        pub use BS0_W as BS8_W;
        ///Field `BS9` writer - Set bit 9
        pub use BS0_W as BS9_W;
        ///Field `BS10` writer - Set bit 10
        pub use BS0_W as BS10_W;
        ///Field `BS11` writer - Set bit 11
        pub use BS0_W as BS11_W;
        ///Field `BS12` writer - Set bit 12
        pub use BS0_W as BS12_W;
        ///Field `BS13` writer - Set bit 13
        pub use BS0_W as BS13_W;
        ///Field `BS14` writer - Set bit 14
        pub use BS0_W as BS14_W;
        ///Field `BS15` writer - Set bit 15
        pub use BS0_W as BS15_W;
        ///Reset bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BR0W_AW {
            ///1: Reset output bit
            Reset = 1,
        }
        impl From<BR0W_AW> for bool {
            #[inline(always)]
            fn from(variant: BR0W_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BR0` writer - Reset bit 0
        pub type BR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, BR0W_AW, O>;
        impl<'a, const O: u8> BR0_W<'a, O> {
            ///Reset output bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W_AW::Reset)
            }
        }
        ///Field `BR1` writer - Reset bit 1
        pub use BR0_W as BR1_W;
        ///Field `BR2` writer - Reset bit 2
        pub use BR0_W as BR2_W;
        ///Field `BR3` writer - Reset bit 3
        pub use BR0_W as BR3_W;
        ///Field `BR4` writer - Reset bit 4
        pub use BR0_W as BR4_W;
        ///Field `BR5` writer - Reset bit 5
        pub use BR0_W as BR5_W;
        ///Field `BR6` writer - Reset bit 6
        pub use BR0_W as BR6_W;
        ///Field `BR7` writer - Reset bit 7
        pub use BR0_W as BR7_W;
        ///Field `BR8` writer - Reset bit 8
        pub use BR0_W as BR8_W;
        ///Field `BR9` writer - Reset bit 9
        pub use BR0_W as BR9_W;
        ///Field `BR10` writer - Reset bit 10
        pub use BR0_W as BR10_W;
        ///Field `BR11` writer - Reset bit 11
        pub use BR0_W as BR11_W;
        ///Field `BR12` writer - Reset bit 12
        pub use BR0_W as BR12_W;
        ///Field `BR13` writer - Reset bit 13
        pub use BR0_W as BR13_W;
        ///Field `BR14` writer - Reset bit 14
        pub use BR0_W as BR14_W;
        ///Field `BR15` writer - Reset bit 15
        pub use BR0_W as BR15_W;
        impl W {
            ///Bit 0 - Set bit 0
            #[inline(always)]
            #[must_use]
            pub fn bs0(&mut self) -> BS0_W<0> {
                BS0_W::new(self)
            }
            ///Bit 1 - Set bit 1
            #[inline(always)]
            #[must_use]
            pub fn bs1(&mut self) -> BS1_W<1> {
                BS1_W::new(self)
            }
            ///Bit 2 - Set bit 1
            #[inline(always)]
            #[must_use]
            pub fn bs2(&mut self) -> BS2_W<2> {
                BS2_W::new(self)
            }
            ///Bit 3 - Set bit 3
            #[inline(always)]
            #[must_use]
            pub fn bs3(&mut self) -> BS3_W<3> {
                BS3_W::new(self)
            }
            ///Bit 4 - Set bit 4
            #[inline(always)]
            #[must_use]
            pub fn bs4(&mut self) -> BS4_W<4> {
                BS4_W::new(self)
            }
            ///Bit 5 - Set bit 5
            #[inline(always)]
            #[must_use]
            pub fn bs5(&mut self) -> BS5_W<5> {
                BS5_W::new(self)
            }
            ///Bit 6 - Set bit 6
            #[inline(always)]
            #[must_use]
            pub fn bs6(&mut self) -> BS6_W<6> {
                BS6_W::new(self)
            }
            ///Bit 7 - Set bit 7
            #[inline(always)]
            #[must_use]
            pub fn bs7(&mut self) -> BS7_W<7> {
                BS7_W::new(self)
            }
            ///Bit 8 - Set bit 8
            #[inline(always)]
            #[must_use]
            pub fn bs8(&mut self) -> BS8_W<8> {
                BS8_W::new(self)
            }
            ///Bit 9 - Set bit 9
            #[inline(always)]
            #[must_use]
            pub fn bs9(&mut self) -> BS9_W<9> {
                BS9_W::new(self)
            }
            ///Bit 10 - Set bit 10
            #[inline(always)]
            #[must_use]
            pub fn bs10(&mut self) -> BS10_W<10> {
                BS10_W::new(self)
            }
            ///Bit 11 - Set bit 11
            #[inline(always)]
            #[must_use]
            pub fn bs11(&mut self) -> BS11_W<11> {
                BS11_W::new(self)
            }
            ///Bit 12 - Set bit 12
            #[inline(always)]
            #[must_use]
            pub fn bs12(&mut self) -> BS12_W<12> {
                BS12_W::new(self)
            }
            ///Bit 13 - Set bit 13
            #[inline(always)]
            #[must_use]
            pub fn bs13(&mut self) -> BS13_W<13> {
                BS13_W::new(self)
            }
            ///Bit 14 - Set bit 14
            #[inline(always)]
            #[must_use]
            pub fn bs14(&mut self) -> BS14_W<14> {
                BS14_W::new(self)
            }
            ///Bit 15 - Set bit 15
            #[inline(always)]
            #[must_use]
            pub fn bs15(&mut self) -> BS15_W<15> {
                BS15_W::new(self)
            }
            ///Bit 16 - Reset bit 0
            #[inline(always)]
            #[must_use]
            pub fn br0(&mut self) -> BR0_W<16> {
                BR0_W::new(self)
            }
            ///Bit 17 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br1(&mut self) -> BR1_W<17> {
                BR1_W::new(self)
            }
            ///Bit 18 - Reset bit 2
            #[inline(always)]
            #[must_use]
            pub fn br2(&mut self) -> BR2_W<18> {
                BR2_W::new(self)
            }
            ///Bit 19 - Reset bit 3
            #[inline(always)]
            #[must_use]
            pub fn br3(&mut self) -> BR3_W<19> {
                BR3_W::new(self)
            }
            ///Bit 20 - Reset bit 4
            #[inline(always)]
            #[must_use]
            pub fn br4(&mut self) -> BR4_W<20> {
                BR4_W::new(self)
            }
            ///Bit 21 - Reset bit 5
            #[inline(always)]
            #[must_use]
            pub fn br5(&mut self) -> BR5_W<21> {
                BR5_W::new(self)
            }
            ///Bit 22 - Reset bit 6
            #[inline(always)]
            #[must_use]
            pub fn br6(&mut self) -> BR6_W<22> {
                BR6_W::new(self)
            }
            ///Bit 23 - Reset bit 7
            #[inline(always)]
            #[must_use]
            pub fn br7(&mut self) -> BR7_W<23> {
                BR7_W::new(self)
            }
            ///Bit 24 - Reset bit 8
            #[inline(always)]
            #[must_use]
            pub fn br8(&mut self) -> BR8_W<24> {
                BR8_W::new(self)
            }
            ///Bit 25 - Reset bit 9
            #[inline(always)]
            #[must_use]
            pub fn br9(&mut self) -> BR9_W<25> {
                BR9_W::new(self)
            }
            ///Bit 26 - Reset bit 10
            #[inline(always)]
            #[must_use]
            pub fn br10(&mut self) -> BR10_W<26> {
                BR10_W::new(self)
            }
            ///Bit 27 - Reset bit 11
            #[inline(always)]
            #[must_use]
            pub fn br11(&mut self) -> BR11_W<27> {
                BR11_W::new(self)
            }
            ///Bit 28 - Reset bit 12
            #[inline(always)]
            #[must_use]
            pub fn br12(&mut self) -> BR12_W<28> {
                BR12_W::new(self)
            }
            ///Bit 29 - Reset bit 13
            #[inline(always)]
            #[must_use]
            pub fn br13(&mut self) -> BR13_W<29> {
                BR13_W::new(self)
            }
            ///Bit 30 - Reset bit 14
            #[inline(always)]
            #[must_use]
            pub fn br14(&mut self) -> BR14_W<30> {
                BR14_W::new(self)
            }
            ///Bit 31 - Reset bit 15
            #[inline(always)]
            #[must_use]
            pub fn br15(&mut self) -> BR15_W<31> {
                BR15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port bit set/reset register (GPIOn_BSHR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bshr](index.html) module
        pub struct BSHR_SPEC;
        impl crate::RegisterSpec for BSHR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [bshr::W](W) writer structure
        impl crate::Writable for BSHR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BSHR to value 0
        impl crate::Resettable for BSHR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BCR (w) register accessor: an alias for `Reg<BCR_SPEC>`
    pub type BCR = crate::Reg<bcr::BCR_SPEC>;
    ///Port bit reset register (GPIOn_BCR)
    pub mod bcr {
        ///Register `BCR` writer
        pub struct W(crate::W<BCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Reset bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BR0W_AW {
            ///1: Reset output bit
            Reset = 1,
        }
        impl From<BR0W_AW> for bool {
            #[inline(always)]
            fn from(variant: BR0W_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BR0` writer - Reset bit 0
        pub type BR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, BR0W_AW, O>;
        impl<'a, const O: u8> BR0_W<'a, O> {
            ///Reset output bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W_AW::Reset)
            }
        }
        ///Field `BR1` writer - Reset bit 1
        pub use BR0_W as BR1_W;
        ///Field `BR2` writer - Reset bit 1
        pub use BR0_W as BR2_W;
        ///Field `BR3` writer - Reset bit 3
        pub use BR0_W as BR3_W;
        ///Field `BR4` writer - Reset bit 4
        pub use BR0_W as BR4_W;
        ///Field `BR5` writer - Reset bit 5
        pub use BR0_W as BR5_W;
        ///Field `BR6` writer - Reset bit 6
        pub use BR0_W as BR6_W;
        ///Field `BR7` writer - Reset bit 7
        pub use BR0_W as BR7_W;
        ///Field `BR8` writer - Reset bit 8
        pub use BR0_W as BR8_W;
        ///Field `BR9` writer - Reset bit 9
        pub use BR0_W as BR9_W;
        ///Field `BR10` writer - Reset bit 10
        pub use BR0_W as BR10_W;
        ///Field `BR11` writer - Reset bit 11
        pub use BR0_W as BR11_W;
        ///Field `BR12` writer - Reset bit 12
        pub use BR0_W as BR12_W;
        ///Field `BR13` writer - Reset bit 13
        pub use BR0_W as BR13_W;
        ///Field `BR14` writer - Reset bit 14
        pub use BR0_W as BR14_W;
        ///Field `BR15` writer - Reset bit 15
        pub use BR0_W as BR15_W;
        impl W {
            ///Bit 0 - Reset bit 0
            #[inline(always)]
            #[must_use]
            pub fn br0(&mut self) -> BR0_W<0> {
                BR0_W::new(self)
            }
            ///Bit 1 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br1(&mut self) -> BR1_W<1> {
                BR1_W::new(self)
            }
            ///Bit 2 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br2(&mut self) -> BR2_W<2> {
                BR2_W::new(self)
            }
            ///Bit 3 - Reset bit 3
            #[inline(always)]
            #[must_use]
            pub fn br3(&mut self) -> BR3_W<3> {
                BR3_W::new(self)
            }
            ///Bit 4 - Reset bit 4
            #[inline(always)]
            #[must_use]
            pub fn br4(&mut self) -> BR4_W<4> {
                BR4_W::new(self)
            }
            ///Bit 5 - Reset bit 5
            #[inline(always)]
            #[must_use]
            pub fn br5(&mut self) -> BR5_W<5> {
                BR5_W::new(self)
            }
            ///Bit 6 - Reset bit 6
            #[inline(always)]
            #[must_use]
            pub fn br6(&mut self) -> BR6_W<6> {
                BR6_W::new(self)
            }
            ///Bit 7 - Reset bit 7
            #[inline(always)]
            #[must_use]
            pub fn br7(&mut self) -> BR7_W<7> {
                BR7_W::new(self)
            }
            ///Bit 8 - Reset bit 8
            #[inline(always)]
            #[must_use]
            pub fn br8(&mut self) -> BR8_W<8> {
                BR8_W::new(self)
            }
            ///Bit 9 - Reset bit 9
            #[inline(always)]
            #[must_use]
            pub fn br9(&mut self) -> BR9_W<9> {
                BR9_W::new(self)
            }
            ///Bit 10 - Reset bit 10
            #[inline(always)]
            #[must_use]
            pub fn br10(&mut self) -> BR10_W<10> {
                BR10_W::new(self)
            }
            ///Bit 11 - Reset bit 11
            #[inline(always)]
            #[must_use]
            pub fn br11(&mut self) -> BR11_W<11> {
                BR11_W::new(self)
            }
            ///Bit 12 - Reset bit 12
            #[inline(always)]
            #[must_use]
            pub fn br12(&mut self) -> BR12_W<12> {
                BR12_W::new(self)
            }
            ///Bit 13 - Reset bit 13
            #[inline(always)]
            #[must_use]
            pub fn br13(&mut self) -> BR13_W<13> {
                BR13_W::new(self)
            }
            ///Bit 14 - Reset bit 14
            #[inline(always)]
            #[must_use]
            pub fn br14(&mut self) -> BR14_W<14> {
                BR14_W::new(self)
            }
            ///Bit 15 - Reset bit 15
            #[inline(always)]
            #[must_use]
            pub fn br15(&mut self) -> BR15_W<15> {
                BR15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port bit reset register (GPIOn_BCR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bcr](index.html) module
        pub struct BCR_SPEC;
        impl crate::RegisterSpec for BCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [bcr::W](W) writer structure
        impl crate::Writable for BCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BCR to value 0
        impl crate::Resettable for BCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///LCKR (rw) register accessor: an alias for `Reg<LCKR_SPEC>`
    pub type LCKR = crate::Reg<lckr::LCKR_SPEC>;
    ///Port configuration lock register
    pub mod lckr {
        ///Register `LCKR` reader
        pub struct R(crate::R<LCKR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LCKR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LCKR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `LCKR` writer
        pub struct W(crate::W<LCKR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<LCKR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<LCKR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LCK0` reader - Port A Lock bit 0
        pub type LCK0_R = crate::BitReader<LCK0W_A>;
        ///Port A Lock bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LCK0W_A {
            ///1: Lock the port
            Lock = 1,
        }
        impl From<LCK0W_A> for bool {
            #[inline(always)]
            fn from(variant: LCK0W_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LCK0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<LCK0W_A> {
                match self.bits {
                    true => Some(LCK0W_A::Lock),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Lock`
            #[inline(always)]
            pub fn is_lock(&self) -> bool {
                *self == LCK0W_A::Lock
            }
        }
        ///Field `LCK0` writer - Port A Lock bit 0
        pub type LCK0_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, LCK0W_A, O>;
        impl<'a, const O: u8> LCK0_W<'a, O> {
            ///Lock the port
            #[inline(always)]
            pub fn lock(self) -> &'a mut W {
                self.variant(LCK0W_A::Lock)
            }
        }
        ///Field `LCK1` reader - Port A Lock bit 1
        pub use LCK0_R as LCK1_R;
        ///Field `LCK2` reader - Port A Lock bit 2
        pub use LCK0_R as LCK2_R;
        ///Field `LCK3` reader - Port A Lock bit 3
        pub use LCK0_R as LCK3_R;
        ///Field `LCK4` reader - Port A Lock bit 4
        pub use LCK0_R as LCK4_R;
        ///Field `LCK5` reader - Port A Lock bit 5
        pub use LCK0_R as LCK5_R;
        ///Field `LCK6` reader - Port A Lock bit 6
        pub use LCK0_R as LCK6_R;
        ///Field `LCK7` reader - Port A Lock bit 7
        pub use LCK0_R as LCK7_R;
        ///Field `LCK8` reader - Port A Lock bit 8
        pub use LCK0_R as LCK8_R;
        ///Field `LCK9` reader - Port A Lock bit 9
        pub use LCK0_R as LCK9_R;
        ///Field `LCK10` reader - Port A Lock bit 10
        pub use LCK0_R as LCK10_R;
        ///Field `LCK11` reader - Port A Lock bit 11
        pub use LCK0_R as LCK11_R;
        ///Field `LCK12` reader - Port A Lock bit 12
        pub use LCK0_R as LCK12_R;
        ///Field `LCK13` reader - Port A Lock bit 13
        pub use LCK0_R as LCK13_R;
        ///Field `LCK14` reader - Port A Lock bit 14
        pub use LCK0_R as LCK14_R;
        ///Field `LCK15` reader - Port A Lock bit 15
        pub use LCK0_R as LCK15_R;
        ///Field `LCK1` writer - Port A Lock bit 1
        pub use LCK0_W as LCK1_W;
        ///Field `LCK2` writer - Port A Lock bit 2
        pub use LCK0_W as LCK2_W;
        ///Field `LCK3` writer - Port A Lock bit 3
        pub use LCK0_W as LCK3_W;
        ///Field `LCK4` writer - Port A Lock bit 4
        pub use LCK0_W as LCK4_W;
        ///Field `LCK5` writer - Port A Lock bit 5
        pub use LCK0_W as LCK5_W;
        ///Field `LCK6` writer - Port A Lock bit 6
        pub use LCK0_W as LCK6_W;
        ///Field `LCK7` writer - Port A Lock bit 7
        pub use LCK0_W as LCK7_W;
        ///Field `LCK8` writer - Port A Lock bit 8
        pub use LCK0_W as LCK8_W;
        ///Field `LCK9` writer - Port A Lock bit 9
        pub use LCK0_W as LCK9_W;
        ///Field `LCK10` writer - Port A Lock bit 10
        pub use LCK0_W as LCK10_W;
        ///Field `LCK11` writer - Port A Lock bit 11
        pub use LCK0_W as LCK11_W;
        ///Field `LCK12` writer - Port A Lock bit 12
        pub use LCK0_W as LCK12_W;
        ///Field `LCK13` writer - Port A Lock bit 13
        pub use LCK0_W as LCK13_W;
        ///Field `LCK14` writer - Port A Lock bit 14
        pub use LCK0_W as LCK14_W;
        ///Field `LCK15` writer - Port A Lock bit 15
        pub use LCK0_W as LCK15_W;
        ///Field `LCKK` reader - Lock key
        pub type LCKK_R = crate::BitReader<LCKKR_A>;
        ///Lock key
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LCKKR_A {
            ///0: Not locked
            Unlocked = 0,
            ///1: Locked
            Locked = 1,
        }
        impl From<LCKKR_A> for bool {
            #[inline(always)]
            fn from(variant: LCKKR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LCKK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LCKKR_A {
                match self.bits {
                    false => LCKKR_A::Unlocked,
                    true => LCKKR_A::Locked,
                }
            }
            ///Checks if the value of the field is `Unlocked`
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == LCKKR_A::Unlocked
            }
            ///Checks if the value of the field is `Locked`
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCKKR_A::Locked
            }
        }
        ///Field `LCKK` writer - Lock key
        pub type LCKK_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, LCKKR_A, O>;
        impl<'a, const O: u8> LCKK_W<'a, O> {
            ///Not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCKKR_A::Unlocked)
            }
            ///Locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCKKR_A::Locked)
            }
        }
        impl R {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            pub fn lck0(&self) -> LCK0_R {
                LCK0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            pub fn lck1(&self) -> LCK1_R {
                LCK1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            pub fn lck2(&self) -> LCK2_R {
                LCK2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            pub fn lck3(&self) -> LCK3_R {
                LCK3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            pub fn lck4(&self) -> LCK4_R {
                LCK4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            pub fn lck5(&self) -> LCK5_R {
                LCK5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            pub fn lck6(&self) -> LCK6_R {
                LCK6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            pub fn lck7(&self) -> LCK7_R {
                LCK7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Port A Lock bit 8
            #[inline(always)]
            pub fn lck8(&self) -> LCK8_R {
                LCK8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Port A Lock bit 9
            #[inline(always)]
            pub fn lck9(&self) -> LCK9_R {
                LCK9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Port A Lock bit 10
            #[inline(always)]
            pub fn lck10(&self) -> LCK10_R {
                LCK10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Port A Lock bit 11
            #[inline(always)]
            pub fn lck11(&self) -> LCK11_R {
                LCK11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Port A Lock bit 12
            #[inline(always)]
            pub fn lck12(&self) -> LCK12_R {
                LCK12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Port A Lock bit 13
            #[inline(always)]
            pub fn lck13(&self) -> LCK13_R {
                LCK13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Port A Lock bit 14
            #[inline(always)]
            pub fn lck14(&self) -> LCK14_R {
                LCK14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Port A Lock bit 15
            #[inline(always)]
            pub fn lck15(&self) -> LCK15_R {
                LCK15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Lock key
            #[inline(always)]
            pub fn lckk(&self) -> LCKK_R {
                LCKK_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            #[must_use]
            pub fn lck0(&mut self) -> LCK0_W<0> {
                LCK0_W::new(self)
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            #[must_use]
            pub fn lck1(&mut self) -> LCK1_W<1> {
                LCK1_W::new(self)
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            #[must_use]
            pub fn lck2(&mut self) -> LCK2_W<2> {
                LCK2_W::new(self)
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            #[must_use]
            pub fn lck3(&mut self) -> LCK3_W<3> {
                LCK3_W::new(self)
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            #[must_use]
            pub fn lck4(&mut self) -> LCK4_W<4> {
                LCK4_W::new(self)
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            #[must_use]
            pub fn lck5(&mut self) -> LCK5_W<5> {
                LCK5_W::new(self)
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            #[must_use]
            pub fn lck6(&mut self) -> LCK6_W<6> {
                LCK6_W::new(self)
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            #[must_use]
            pub fn lck7(&mut self) -> LCK7_W<7> {
                LCK7_W::new(self)
            }
            ///Bit 8 - Port A Lock bit 8
            #[inline(always)]
            #[must_use]
            pub fn lck8(&mut self) -> LCK8_W<8> {
                LCK8_W::new(self)
            }
            ///Bit 9 - Port A Lock bit 9
            #[inline(always)]
            #[must_use]
            pub fn lck9(&mut self) -> LCK9_W<9> {
                LCK9_W::new(self)
            }
            ///Bit 10 - Port A Lock bit 10
            #[inline(always)]
            #[must_use]
            pub fn lck10(&mut self) -> LCK10_W<10> {
                LCK10_W::new(self)
            }
            ///Bit 11 - Port A Lock bit 11
            #[inline(always)]
            #[must_use]
            pub fn lck11(&mut self) -> LCK11_W<11> {
                LCK11_W::new(self)
            }
            ///Bit 12 - Port A Lock bit 12
            #[inline(always)]
            #[must_use]
            pub fn lck12(&mut self) -> LCK12_W<12> {
                LCK12_W::new(self)
            }
            ///Bit 13 - Port A Lock bit 13
            #[inline(always)]
            #[must_use]
            pub fn lck13(&mut self) -> LCK13_W<13> {
                LCK13_W::new(self)
            }
            ///Bit 14 - Port A Lock bit 14
            #[inline(always)]
            #[must_use]
            pub fn lck14(&mut self) -> LCK14_W<14> {
                LCK14_W::new(self)
            }
            ///Bit 15 - Port A Lock bit 15
            #[inline(always)]
            #[must_use]
            pub fn lck15(&mut self) -> LCK15_W<15> {
                LCK15_W::new(self)
            }
            ///Bit 16 - Lock key
            #[inline(always)]
            #[must_use]
            pub fn lckk(&mut self) -> LCKK_W<16> {
                LCKK_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration lock register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [lckr](index.html) module
        pub struct LCKR_SPEC;
        impl crate::RegisterSpec for LCKR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [lckr::R](R) reader structure
        impl crate::Readable for LCKR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [lckr::W](W) writer structure
        impl crate::Writable for LCKR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets LCKR to value 0
        impl crate::Resettable for LCKR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///General purpose I/O
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOB {}
impl GPIOB {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_0c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOB {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOB").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpiob;
///General purpose I/O
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOC {}
impl GPIOC {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOC {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOC").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpioc;
///General purpose I/O
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOD {}
impl GPIOD {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOD {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOD").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpiod;
///Alternate function I/O
pub struct AFIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AFIO {}
impl AFIO {
    ///Pointer to the register block
    pub const PTR: *const afio::RegisterBlock = 0x4001_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const afio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AFIO {
    type Target = afio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AFIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AFIO").finish()
    }
}
///Alternate function I/O
pub mod afio {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Event Control Register (AFIO_ECR)
        pub ecr: ECR,
        ///0x04 - AF remap and debug I/O configuration register (AFIO_PCFR)
        pub pcfr: PCFR,
        ///0x08 - External interrupt configuration register 1 (AFIO_EXTICR1)
        pub exticr1: EXTICR1,
        ///0x0c - External interrupt configuration register 2 (AFIO_EXTICR2)
        pub exticr2: EXTICR2,
        ///0x10 - External interrupt configuration register 3 (AFIO_EXTICR3)
        pub exticr3: EXTICR3,
        ///0x14 - External interrupt configuration register 4 (AFIO_EXTICR4)
        pub exticr4: EXTICR4,
    }
    ///ECR (rw) register accessor: an alias for `Reg<ECR_SPEC>`
    pub type ECR = crate::Reg<ecr::ECR_SPEC>;
    ///Event Control Register (AFIO_ECR)
    pub mod ecr {
        ///Register `ECR` reader
        pub struct R(crate::R<ECR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ECR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ECR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ECR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ECR` writer
        pub struct W(crate::W<ECR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ECR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ECR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ECR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PIN` reader - Pin selection
        pub type PIN_R = crate::FieldReader<u8, u8>;
        ///Field `PIN` writer - Pin selection
        pub type PIN_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ECR_SPEC, u8, u8, 4, O>;
        ///Field `PORT` reader - Port selection
        pub type PORT_R = crate::FieldReader<u8, PORT_A>;
        ///Port selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PORT_A {
            ///0: Event out to PA port
            Pa = 0,
            ///1: Event out to PB port
            Pb = 1,
            ///2: Event out to PC port
            Pc = 2,
            ///3: Event out to PD port
            Pd = 3,
        }
        impl From<PORT_A> for u8 {
            #[inline(always)]
            fn from(variant: PORT_A) -> Self {
                variant as _
            }
        }
        impl PORT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PORT_A> {
                match self.bits {
                    0 => Some(PORT_A::Pa),
                    1 => Some(PORT_A::Pb),
                    2 => Some(PORT_A::Pc),
                    3 => Some(PORT_A::Pd),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Pa`
            #[inline(always)]
            pub fn is_pa(&self) -> bool {
                *self == PORT_A::Pa
            }
            ///Checks if the value of the field is `Pb`
            #[inline(always)]
            pub fn is_pb(&self) -> bool {
                *self == PORT_A::Pb
            }
            ///Checks if the value of the field is `Pc`
            #[inline(always)]
            pub fn is_pc(&self) -> bool {
                *self == PORT_A::Pc
            }
            ///Checks if the value of the field is `Pd`
            #[inline(always)]
            pub fn is_pd(&self) -> bool {
                *self == PORT_A::Pd
            }
        }
        ///Field `PORT` writer - Port selection
        pub type PORT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ECR_SPEC, u8, PORT_A, 3, O>;
        impl<'a, const O: u8> PORT_W<'a, O> {
            ///Event out to PA port
            #[inline(always)]
            pub fn pa(self) -> &'a mut W {
                self.variant(PORT_A::Pa)
            }
            ///Event out to PB port
            #[inline(always)]
            pub fn pb(self) -> &'a mut W {
                self.variant(PORT_A::Pb)
            }
            ///Event out to PC port
            #[inline(always)]
            pub fn pc(self) -> &'a mut W {
                self.variant(PORT_A::Pc)
            }
            ///Event out to PD port
            #[inline(always)]
            pub fn pd(self) -> &'a mut W {
                self.variant(PORT_A::Pd)
            }
        }
        ///Field `EVOE` reader - Event Output Enable
        pub type EVOE_R = crate::BitReader<EVOE_A>;
        ///Event Output Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EVOE_A {
            ///0: Event out disabled
            Disabled = 0,
            ///1: Event out enabled
            Enable = 1,
        }
        impl From<EVOE_A> for bool {
            #[inline(always)]
            fn from(variant: EVOE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EVOE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EVOE_A {
                match self.bits {
                    false => EVOE_A::Disabled,
                    true => EVOE_A::Enable,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EVOE_A::Disabled
            }
            ///Checks if the value of the field is `Enable`
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == EVOE_A::Enable
            }
        }
        ///Field `EVOE` writer - Event Output Enable
        pub type EVOE_W<'a, const O: u8> = crate::BitWriter<'a, u32, ECR_SPEC, EVOE_A, O>;
        impl<'a, const O: u8> EVOE_W<'a, O> {
            ///Event out disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EVOE_A::Disabled)
            }
            ///Event out enabled
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(EVOE_A::Enable)
            }
        }
        impl R {
            ///Bits 0:3 - Pin selection
            #[inline(always)]
            pub fn pin(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:6 - Port selection
            #[inline(always)]
            pub fn port(&self) -> PORT_R {
                PORT_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Event Output Enable
            #[inline(always)]
            pub fn evoe(&self) -> EVOE_R {
                EVOE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Pin selection
            #[inline(always)]
            #[must_use]
            pub fn pin(&mut self) -> PIN_W<0> {
                PIN_W::new(self)
            }
            ///Bits 4:6 - Port selection
            #[inline(always)]
            #[must_use]
            pub fn port(&mut self) -> PORT_W<4> {
                PORT_W::new(self)
            }
            ///Bit 7 - Event Output Enable
            #[inline(always)]
            #[must_use]
            pub fn evoe(&mut self) -> EVOE_W<7> {
                EVOE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Event Control Register (AFIO_ECR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ecr](index.html) module
        pub struct ECR_SPEC;
        impl crate::RegisterSpec for ECR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ecr::R](R) reader structure
        impl crate::Readable for ECR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ecr::W](W) writer structure
        impl crate::Writable for ECR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ECR to value 0
        impl crate::Resettable for ECR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EXTICR1 (rw) register accessor: an alias for `Reg<EXTICR1_SPEC>`
    pub type EXTICR1 = crate::Reg<exticr1::EXTICR1_SPEC>;
    ///External interrupt configuration register 1 (AFIO_EXTICR1)
    pub mod exticr1 {
        ///Register `EXTICR1` reader
        pub struct R(crate::R<EXTICR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EXTICR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EXTICR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR1` writer
        pub struct W(crate::W<EXTICR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTICR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTICR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI0` reader - EXTI0 configuration
        pub type EXTI0_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI0` writer - EXTI0 configuration
        pub type EXTI0_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR1_SPEC, u8, u8, 4, O>;
        ///Field `EXTI1` reader - EXTI1 configuration
        pub type EXTI1_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI1` writer - EXTI1 configuration
        pub type EXTI1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR1_SPEC, u8, u8, 4, O>;
        ///Field `EXTI2` reader - EXTI2 configuration
        pub type EXTI2_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI2` writer - EXTI2 configuration
        pub type EXTI2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR1_SPEC, u8, u8, 4, O>;
        ///Field `EXTI3` reader - EXTI3 configuration
        pub type EXTI3_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI3` writer - EXTI3 configuration
        pub type EXTI3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR1_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - EXTI0 configuration
            #[inline(always)]
            pub fn exti0(&self) -> EXTI0_R {
                EXTI0_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI1 configuration
            #[inline(always)]
            pub fn exti1(&self) -> EXTI1_R {
                EXTI1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI2 configuration
            #[inline(always)]
            pub fn exti2(&self) -> EXTI2_R {
                EXTI2_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI3 configuration
            #[inline(always)]
            pub fn exti3(&self) -> EXTI3_R {
                EXTI3_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI0 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti0(&mut self) -> EXTI0_W<0> {
                EXTI0_W::new(self)
            }
            ///Bits 4:7 - EXTI1 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti1(&mut self) -> EXTI1_W<4> {
                EXTI1_W::new(self)
            }
            ///Bits 8:11 - EXTI2 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti2(&mut self) -> EXTI2_W<8> {
                EXTI2_W::new(self)
            }
            ///Bits 12:15 - EXTI3 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti3(&mut self) -> EXTI3_W<12> {
                EXTI3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 1 (AFIO_EXTICR1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr1](index.html) module
        pub struct EXTICR1_SPEC;
        impl crate::RegisterSpec for EXTICR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr1::R](R) reader structure
        impl crate::Readable for EXTICR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr1::W](W) writer structure
        impl crate::Writable for EXTICR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EXTICR1 to value 0
        impl crate::Resettable for EXTICR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EXTICR2 (rw) register accessor: an alias for `Reg<EXTICR2_SPEC>`
    pub type EXTICR2 = crate::Reg<exticr2::EXTICR2_SPEC>;
    ///External interrupt configuration register 2 (AFIO_EXTICR2)
    pub mod exticr2 {
        ///Register `EXTICR2` reader
        pub struct R(crate::R<EXTICR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EXTICR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EXTICR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR2` writer
        pub struct W(crate::W<EXTICR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTICR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTICR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI4` reader - EXTI4 configuration
        pub type EXTI4_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI4` writer - EXTI4 configuration
        pub type EXTI4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR2_SPEC, u8, u8, 4, O>;
        ///Field `EXTI5` reader - EXTI5 configuration
        pub type EXTI5_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI5` writer - EXTI5 configuration
        pub type EXTI5_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR2_SPEC, u8, u8, 4, O>;
        ///Field `EXTI6` reader - EXTI6 configuration
        pub type EXTI6_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI6` writer - EXTI6 configuration
        pub type EXTI6_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR2_SPEC, u8, u8, 4, O>;
        ///Field `EXTI7` reader - EXTI7 configuration
        pub type EXTI7_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI7` writer - EXTI7 configuration
        pub type EXTI7_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR2_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - EXTI4 configuration
            #[inline(always)]
            pub fn exti4(&self) -> EXTI4_R {
                EXTI4_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI5 configuration
            #[inline(always)]
            pub fn exti5(&self) -> EXTI5_R {
                EXTI5_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI6 configuration
            #[inline(always)]
            pub fn exti6(&self) -> EXTI6_R {
                EXTI6_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI7 configuration
            #[inline(always)]
            pub fn exti7(&self) -> EXTI7_R {
                EXTI7_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI4 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti4(&mut self) -> EXTI4_W<0> {
                EXTI4_W::new(self)
            }
            ///Bits 4:7 - EXTI5 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti5(&mut self) -> EXTI5_W<4> {
                EXTI5_W::new(self)
            }
            ///Bits 8:11 - EXTI6 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti6(&mut self) -> EXTI6_W<8> {
                EXTI6_W::new(self)
            }
            ///Bits 12:15 - EXTI7 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti7(&mut self) -> EXTI7_W<12> {
                EXTI7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 2 (AFIO_EXTICR2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr2](index.html) module
        pub struct EXTICR2_SPEC;
        impl crate::RegisterSpec for EXTICR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr2::R](R) reader structure
        impl crate::Readable for EXTICR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr2::W](W) writer structure
        impl crate::Writable for EXTICR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EXTICR2 to value 0
        impl crate::Resettable for EXTICR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EXTICR3 (rw) register accessor: an alias for `Reg<EXTICR3_SPEC>`
    pub type EXTICR3 = crate::Reg<exticr3::EXTICR3_SPEC>;
    ///External interrupt configuration register 3 (AFIO_EXTICR3)
    pub mod exticr3 {
        ///Register `EXTICR3` reader
        pub struct R(crate::R<EXTICR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EXTICR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EXTICR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR3` writer
        pub struct W(crate::W<EXTICR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTICR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTICR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI8` reader - EXTI8 configuration
        pub type EXTI8_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI8` writer - EXTI8 configuration
        pub type EXTI8_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR3_SPEC, u8, u8, 4, O>;
        ///Field `EXTI9` reader - EXTI9 configuration
        pub type EXTI9_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI9` writer - EXTI9 configuration
        pub type EXTI9_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR3_SPEC, u8, u8, 4, O>;
        ///Field `EXTI10` reader - EXTI10 configuration
        pub type EXTI10_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI10` writer - EXTI10 configuration
        pub type EXTI10_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTICR3_SPEC, u8, u8, 4, O>;
        ///Field `EXTI11` reader - EXTI11 configuration
        pub type EXTI11_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI11` writer - EXTI11 configuration
        pub type EXTI11_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTICR3_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - EXTI8 configuration
            #[inline(always)]
            pub fn exti8(&self) -> EXTI8_R {
                EXTI8_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI9 configuration
            #[inline(always)]
            pub fn exti9(&self) -> EXTI9_R {
                EXTI9_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI10 configuration
            #[inline(always)]
            pub fn exti10(&self) -> EXTI10_R {
                EXTI10_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI11 configuration
            #[inline(always)]
            pub fn exti11(&self) -> EXTI11_R {
                EXTI11_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI8 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti8(&mut self) -> EXTI8_W<0> {
                EXTI8_W::new(self)
            }
            ///Bits 4:7 - EXTI9 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti9(&mut self) -> EXTI9_W<4> {
                EXTI9_W::new(self)
            }
            ///Bits 8:11 - EXTI10 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti10(&mut self) -> EXTI10_W<8> {
                EXTI10_W::new(self)
            }
            ///Bits 12:15 - EXTI11 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti11(&mut self) -> EXTI11_W<12> {
                EXTI11_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 3 (AFIO_EXTICR3)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr3](index.html) module
        pub struct EXTICR3_SPEC;
        impl crate::RegisterSpec for EXTICR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr3::R](R) reader structure
        impl crate::Readable for EXTICR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr3::W](W) writer structure
        impl crate::Writable for EXTICR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EXTICR3 to value 0
        impl crate::Resettable for EXTICR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EXTICR4 (rw) register accessor: an alias for `Reg<EXTICR4_SPEC>`
    pub type EXTICR4 = crate::Reg<exticr4::EXTICR4_SPEC>;
    ///External interrupt configuration register 4 (AFIO_EXTICR4)
    pub mod exticr4 {
        ///Register `EXTICR4` reader
        pub struct R(crate::R<EXTICR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EXTICR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EXTICR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR4` writer
        pub struct W(crate::W<EXTICR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTICR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTICR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI12` reader - EXTI12 configuration
        pub type EXTI12_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI12` writer - EXTI12 configuration
        pub type EXTI12_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTICR4_SPEC, u8, u8, 4, O>;
        ///Field `EXTI13` reader - EXTI13 configuration
        pub type EXTI13_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI13` writer - EXTI13 configuration
        pub type EXTI13_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTICR4_SPEC, u8, u8, 4, O>;
        ///Field `EXTI14` reader - EXTI14 configuration
        pub type EXTI14_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI14` writer - EXTI14 configuration
        pub type EXTI14_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTICR4_SPEC, u8, u8, 4, O>;
        ///Field `EXTI15` reader - EXTI15 configuration
        pub type EXTI15_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI15` writer - EXTI15 configuration
        pub type EXTI15_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTICR4_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - EXTI12 configuration
            #[inline(always)]
            pub fn exti12(&self) -> EXTI12_R {
                EXTI12_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI13 configuration
            #[inline(always)]
            pub fn exti13(&self) -> EXTI13_R {
                EXTI13_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI14 configuration
            #[inline(always)]
            pub fn exti14(&self) -> EXTI14_R {
                EXTI14_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI15 configuration
            #[inline(always)]
            pub fn exti15(&self) -> EXTI15_R {
                EXTI15_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI12 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti12(&mut self) -> EXTI12_W<0> {
                EXTI12_W::new(self)
            }
            ///Bits 4:7 - EXTI13 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti13(&mut self) -> EXTI13_W<4> {
                EXTI13_W::new(self)
            }
            ///Bits 8:11 - EXTI14 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti14(&mut self) -> EXTI14_W<8> {
                EXTI14_W::new(self)
            }
            ///Bits 12:15 - EXTI15 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti15(&mut self) -> EXTI15_W<12> {
                EXTI15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 4 (AFIO_EXTICR4)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr4](index.html) module
        pub struct EXTICR4_SPEC;
        impl crate::RegisterSpec for EXTICR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr4::R](R) reader structure
        impl crate::Readable for EXTICR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr4::W](W) writer structure
        impl crate::Writable for EXTICR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EXTICR4 to value 0
        impl crate::Resettable for EXTICR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PCFR (rw) register accessor: an alias for `Reg<PCFR_SPEC>`
    pub type PCFR = crate::Reg<pcfr::PCFR_SPEC>;
    ///AF remap and debug I/O configuration register (AFIO_PCFR)
    pub mod pcfr {
        ///Register `PCFR` reader
        pub struct R(crate::R<PCFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PCFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PCFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PCFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PCFR` writer
        pub struct W(crate::W<PCFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PCFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PCFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PCFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI1RM` reader - SPI1 remapping
        pub type SPI1RM_R = crate::BitReader<SPI1RM_A>;
        ///SPI1 remapping
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPI1RM_A {
            ///0: Default
            Default = 0,
            ///1: Remapped
            Remapped = 1,
        }
        impl From<SPI1RM_A> for bool {
            #[inline(always)]
            fn from(variant: SPI1RM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SPI1RM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SPI1RM_A {
                match self.bits {
                    false => SPI1RM_A::Default,
                    true => SPI1RM_A::Remapped,
                }
            }
            ///Checks if the value of the field is `Default`
            #[inline(always)]
            pub fn is_default(&self) -> bool {
                *self == SPI1RM_A::Default
            }
            ///Checks if the value of the field is `Remapped`
            #[inline(always)]
            pub fn is_remapped(&self) -> bool {
                *self == SPI1RM_A::Remapped
            }
        }
        ///Field `SPI1RM` writer - SPI1 remapping
        pub type SPI1RM_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, SPI1RM_A, O>;
        impl<'a, const O: u8> SPI1RM_W<'a, O> {
            ///Default
            #[inline(always)]
            pub fn default(self) -> &'a mut W {
                self.variant(SPI1RM_A::Default)
            }
            ///Remapped
            #[inline(always)]
            pub fn remapped(self) -> &'a mut W {
                self.variant(SPI1RM_A::Remapped)
            }
        }
        ///Field `I2C1RM` reader - I2C1 remapping
        pub use SPI1RM_R as I2C1RM_R;
        ///Field `USART1RM` reader - USART1 remapping
        pub use SPI1RM_R as USART1RM_R;
        ///Field `USART2RM` reader - USART2 remapping
        pub use SPI1RM_R as USART2RM_R;
        ///Field `I2C1RM` writer - I2C1 remapping
        pub use SPI1RM_W as I2C1RM_W;
        ///Field `USART1RM` writer - USART1 remapping
        pub use SPI1RM_W as USART1RM_W;
        ///Field `USART2RM` writer - USART2 remapping
        pub use SPI1RM_W as USART2RM_W;
        ///Field `USART3RM` reader - USART3 remapping
        pub type USART3RM_R = crate::FieldReader<u8, USART3RM_A>;
        ///USART3 remapping
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum USART3RM_A {
            ///0: Default
            Default = 0,
            ///1: Partially remapped
            PartiallyRemapped = 1,
            ///3: Remapped
            Remapped = 3,
        }
        impl From<USART3RM_A> for u8 {
            #[inline(always)]
            fn from(variant: USART3RM_A) -> Self {
                variant as _
            }
        }
        impl USART3RM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<USART3RM_A> {
                match self.bits {
                    0 => Some(USART3RM_A::Default),
                    1 => Some(USART3RM_A::PartiallyRemapped),
                    3 => Some(USART3RM_A::Remapped),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Default`
            #[inline(always)]
            pub fn is_default(&self) -> bool {
                *self == USART3RM_A::Default
            }
            ///Checks if the value of the field is `PartiallyRemapped`
            #[inline(always)]
            pub fn is_partially_remapped(&self) -> bool {
                *self == USART3RM_A::PartiallyRemapped
            }
            ///Checks if the value of the field is `Remapped`
            #[inline(always)]
            pub fn is_remapped(&self) -> bool {
                *self == USART3RM_A::Remapped
            }
        }
        ///Field `USART3RM` writer - USART3 remapping
        pub type USART3RM_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PCFR_SPEC, u8, USART3RM_A, 2, O>;
        impl<'a, const O: u8> USART3RM_W<'a, O> {
            ///Default
            #[inline(always)]
            pub fn default(self) -> &'a mut W {
                self.variant(USART3RM_A::Default)
            }
            ///Partially remapped
            #[inline(always)]
            pub fn partially_remapped(self) -> &'a mut W {
                self.variant(USART3RM_A::PartiallyRemapped)
            }
            ///Remapped
            #[inline(always)]
            pub fn remapped(self) -> &'a mut W {
                self.variant(USART3RM_A::Remapped)
            }
        }
        ///Field `TIM1RM` reader - TIM1 remapping
        pub use USART3RM_R as TIM1RM_R;
        ///Field `TIM1RM` writer - TIM1 remapping
        pub use USART3RM_W as TIM1RM_W;
        ///Field `TIM2RM` reader - TIM2 remapping
        pub type TIM2RM_R = crate::FieldReader<u8, TIM2RM_A>;
        ///TIM2 remapping
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIM2RM_A {
            ///0: Default
            Default = 0,
            ///1: Partially remapping case 1
            PartiallyRemapping1 = 1,
            ///2: Partially remapping case 2
            PartiallyRemapping2 = 2,
            ///3: Remapped
            Remapped = 3,
        }
        impl From<TIM2RM_A> for u8 {
            #[inline(always)]
            fn from(variant: TIM2RM_A) -> Self {
                variant as _
            }
        }
        impl TIM2RM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIM2RM_A {
                match self.bits {
                    0 => TIM2RM_A::Default,
                    1 => TIM2RM_A::PartiallyRemapping1,
                    2 => TIM2RM_A::PartiallyRemapping2,
                    3 => TIM2RM_A::Remapped,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Default`
            #[inline(always)]
            pub fn is_default(&self) -> bool {
                *self == TIM2RM_A::Default
            }
            ///Checks if the value of the field is `PartiallyRemapping1`
            #[inline(always)]
            pub fn is_partially_remapping1(&self) -> bool {
                *self == TIM2RM_A::PartiallyRemapping1
            }
            ///Checks if the value of the field is `PartiallyRemapping2`
            #[inline(always)]
            pub fn is_partially_remapping2(&self) -> bool {
                *self == TIM2RM_A::PartiallyRemapping2
            }
            ///Checks if the value of the field is `Remapped`
            #[inline(always)]
            pub fn is_remapped(&self) -> bool {
                *self == TIM2RM_A::Remapped
            }
        }
        ///Field `TIM2RM` writer - TIM2 remapping
        pub type TIM2RM_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, PCFR_SPEC, u8, TIM2RM_A, 2, O>;
        impl<'a, const O: u8> TIM2RM_W<'a, O> {
            ///Default
            #[inline(always)]
            pub fn default(self) -> &'a mut W {
                self.variant(TIM2RM_A::Default)
            }
            ///Partially remapping case 1
            #[inline(always)]
            pub fn partially_remapping1(self) -> &'a mut W {
                self.variant(TIM2RM_A::PartiallyRemapping1)
            }
            ///Partially remapping case 2
            #[inline(always)]
            pub fn partially_remapping2(self) -> &'a mut W {
                self.variant(TIM2RM_A::PartiallyRemapping2)
            }
            ///Remapped
            #[inline(always)]
            pub fn remapped(self) -> &'a mut W {
                self.variant(TIM2RM_A::Remapped)
            }
        }
        ///Field `TIM3RM` reader - TIM3 remapping
        pub type TIM3RM_R = crate::FieldReader<u8, TIM3RM_A>;
        ///TIM3 remapping
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TIM3RM_A {
            ///0: Default
            Default = 0,
            ///2: Partially remapped
            PartiallyRemapped = 2,
            ///3: Remapped
            Remapped = 3,
        }
        impl From<TIM3RM_A> for u8 {
            #[inline(always)]
            fn from(variant: TIM3RM_A) -> Self {
                variant as _
            }
        }
        impl TIM3RM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<TIM3RM_A> {
                match self.bits {
                    0 => Some(TIM3RM_A::Default),
                    2 => Some(TIM3RM_A::PartiallyRemapped),
                    3 => Some(TIM3RM_A::Remapped),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Default`
            #[inline(always)]
            pub fn is_default(&self) -> bool {
                *self == TIM3RM_A::Default
            }
            ///Checks if the value of the field is `PartiallyRemapped`
            #[inline(always)]
            pub fn is_partially_remapped(&self) -> bool {
                *self == TIM3RM_A::PartiallyRemapped
            }
            ///Checks if the value of the field is `Remapped`
            #[inline(always)]
            pub fn is_remapped(&self) -> bool {
                *self == TIM3RM_A::Remapped
            }
        }
        ///Field `TIM3RM` writer - TIM3 remapping
        pub type TIM3RM_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PCFR_SPEC, u8, TIM3RM_A, 2, O>;
        impl<'a, const O: u8> TIM3RM_W<'a, O> {
            ///Default
            #[inline(always)]
            pub fn default(self) -> &'a mut W {
                self.variant(TIM3RM_A::Default)
            }
            ///Partially remapped
            #[inline(always)]
            pub fn partially_remapped(self) -> &'a mut W {
                self.variant(TIM3RM_A::PartiallyRemapped)
            }
            ///Remapped
            #[inline(always)]
            pub fn remapped(self) -> &'a mut W {
                self.variant(TIM3RM_A::Remapped)
            }
        }
        ///Field `CANRM` reader - CAN remapping
        pub type CANRM_R = crate::FieldReader<u8, CANRM_A>;
        ///CAN remapping
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CANRM_A {
            ///0: CAN mapped to port PA
            Pa = 0,
            ///1: CAN mapped to port PB
            Pb = 1,
        }
        impl From<CANRM_A> for u8 {
            #[inline(always)]
            fn from(variant: CANRM_A) -> Self {
                variant as _
            }
        }
        impl CANRM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CANRM_A> {
                match self.bits {
                    0 => Some(CANRM_A::Pa),
                    1 => Some(CANRM_A::Pb),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Pa`
            #[inline(always)]
            pub fn is_pa(&self) -> bool {
                *self == CANRM_A::Pa
            }
            ///Checks if the value of the field is `Pb`
            #[inline(always)]
            pub fn is_pb(&self) -> bool {
                *self == CANRM_A::Pb
            }
        }
        ///Field `CANRM` writer - CAN remapping
        pub type CANRM_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PCFR_SPEC, u8, CANRM_A, 2, O>;
        impl<'a, const O: u8> CANRM_W<'a, O> {
            ///CAN mapped to port PA
            #[inline(always)]
            pub fn pa(self) -> &'a mut W {
                self.variant(CANRM_A::Pa)
            }
            ///CAN mapped to port PB
            #[inline(always)]
            pub fn pb(self) -> &'a mut W {
                self.variant(CANRM_A::Pb)
            }
        }
        ///Field `PD01RM` reader - PD01 remapping
        pub use SPI1RM_R as PD01RM_R;
        ///Field `PD01RM` writer - PD01 remapping
        pub use SPI1RM_W as PD01RM_W;
        ///RVSWD configuration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SWCFGW_AW {
            ///0: SWD enabled
            Enabled = 0,
            ///4: SWD disabled
            Disabled = 4,
        }
        impl From<SWCFGW_AW> for u8 {
            #[inline(always)]
            fn from(variant: SWCFGW_AW) -> Self {
                variant as _
            }
        }
        ///Field `SWCFG` writer - RVSWD configuration
        pub type SWCFG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, PCFR_SPEC, u8, SWCFGW_AW, 3, O>;
        impl<'a, const O: u8> SWCFG_W<'a, O> {
            ///SWD enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SWCFGW_AW::Enabled)
            }
            ///SWD disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SWCFGW_AW::Disabled)
            }
        }
        impl R {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            pub fn spi1rm(&self) -> SPI1RM_R {
                SPI1RM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            pub fn i2c1rm(&self) -> I2C1RM_R {
                I2C1RM_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            pub fn usart1rm(&self) -> USART1RM_R {
                USART1RM_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - USART2 remapping
            #[inline(always)]
            pub fn usart2rm(&self) -> USART2RM_R {
                USART2RM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - USART3 remapping
            #[inline(always)]
            pub fn usart3rm(&self) -> USART3RM_R {
                USART3RM_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            pub fn tim1rm(&self) -> TIM1RM_R {
                TIM1RM_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            pub fn tim2rm(&self) -> TIM2RM_R {
                TIM2RM_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - TIM3 remapping
            #[inline(always)]
            pub fn tim3rm(&self) -> TIM3RM_R {
                TIM3RM_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 13:14 - CAN remapping
            #[inline(always)]
            pub fn canrm(&self) -> CANRM_R {
                CANRM_R::new(((self.bits >> 13) & 3) as u8)
            }
            ///Bit 15 - PD01 remapping
            #[inline(always)]
            pub fn pd01rm(&self) -> PD01RM_R {
                PD01RM_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            #[must_use]
            pub fn spi1rm(&mut self) -> SPI1RM_W<0> {
                SPI1RM_W::new(self)
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            #[must_use]
            pub fn i2c1rm(&mut self) -> I2C1RM_W<1> {
                I2C1RM_W::new(self)
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart1rm(&mut self) -> USART1RM_W<2> {
                USART1RM_W::new(self)
            }
            ///Bit 3 - USART2 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart2rm(&mut self) -> USART2RM_W<3> {
                USART2RM_W::new(self)
            }
            ///Bits 4:5 - USART3 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart3rm(&mut self) -> USART3RM_W<4> {
                USART3RM_W::new(self)
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim1rm(&mut self) -> TIM1RM_W<6> {
                TIM1RM_W::new(self)
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim2rm(&mut self) -> TIM2RM_W<8> {
                TIM2RM_W::new(self)
            }
            ///Bits 10:11 - TIM3 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim3rm(&mut self) -> TIM3RM_W<10> {
                TIM3RM_W::new(self)
            }
            ///Bits 13:14 - CAN remapping
            #[inline(always)]
            #[must_use]
            pub fn canrm(&mut self) -> CANRM_W<13> {
                CANRM_W::new(self)
            }
            ///Bit 15 - PD01 remapping
            #[inline(always)]
            #[must_use]
            pub fn pd01rm(&mut self) -> PD01RM_W<15> {
                PD01RM_W::new(self)
            }
            ///Bits 24:26 - RVSWD configuration
            #[inline(always)]
            #[must_use]
            pub fn swcfg(&mut self) -> SWCFG_W<24> {
                SWCFG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AF remap and debug I/O configuration register (AFIO_PCFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pcfr](index.html) module
        pub struct PCFR_SPEC;
        impl crate::RegisterSpec for PCFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pcfr::R](R) reader structure
        impl crate::Readable for PCFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pcfr::W](W) writer structure
        impl crate::Writable for PCFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PCFR to value 0
        impl crate::Resettable for PCFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///EXTI
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTI {}
impl EXTI {
    ///Pointer to the register block
    pub const PTR: *const exti::RegisterBlock = 0x4001_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const exti::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTI").finish()
    }
}
///EXTI
pub mod exti {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Interrupt mask register(EXTI_INTENR)
        pub intenr: INTENR,
        ///0x04 - Event mask register (EXTI_EVENR)
        pub evenr: EVENR,
        ///0x08 - Rising Trigger selection register(EXTI_RTENR)
        pub rtenr: RTENR,
        ///0x0c - Falling Trigger selection register(EXTI_FTENR)
        pub ftenr: FTENR,
        ///0x10 - Software interrupt event register(EXTI_SWIEVR)
        pub swievr: SWIEVR,
        ///0x14 - Interrupt flag register (EXTI_INTFR)
        pub intfr: INTFR,
    }
    ///INTENR (rw) register accessor: an alias for `Reg<INTENR_SPEC>`
    pub type INTENR = crate::Reg<intenr::INTENR_SPEC>;
    ///Interrupt mask register(EXTI_INTENR)
    pub mod intenr {
        ///Register `INTENR` reader
        pub struct R(crate::R<INTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTENR` writer
        pub struct W(crate::W<INTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MR0` reader - Interrupt Mask on line 0
        pub type MR0_R = crate::BitReader<MR0_A>;
        ///Interrupt Mask on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MR0_A {
            ///0: Interrupt on this line disabled
            Disable = 0,
            ///1: Interrupt on this line enabled
            Enabled = 1,
        }
        impl From<MR0_A> for bool {
            #[inline(always)]
            fn from(variant: MR0_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MR0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MR0_A {
                match self.bits {
                    false => MR0_A::Disable,
                    true => MR0_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disable`
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == MR0_A::Disable
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MR0_A::Enabled
            }
        }
        ///Field `MR0` writer - Interrupt Mask on line 0
        pub type MR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, MR0_A, O>;
        impl<'a, const O: u8> MR0_W<'a, O> {
            ///Interrupt on this line disabled
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(MR0_A::Disable)
            }
            ///Interrupt on this line enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0_A::Enabled)
            }
        }
        ///Field `MR1` reader - Interrupt Mask on line 1
        pub use MR0_R as MR1_R;
        ///Field `MR2` reader - Interrupt Mask on line 2
        pub use MR0_R as MR2_R;
        ///Field `MR3` reader - Interrupt Mask on line 3
        pub use MR0_R as MR3_R;
        ///Field `MR4` reader - Interrupt Mask on line 4
        pub use MR0_R as MR4_R;
        ///Field `MR5` reader - Interrupt Mask on line 5
        pub use MR0_R as MR5_R;
        ///Field `MR6` reader - Interrupt Mask on line 6
        pub use MR0_R as MR6_R;
        ///Field `MR7` reader - Interrupt Mask on line 7
        pub use MR0_R as MR7_R;
        ///Field `MR8` reader - Interrupt Mask on line 8
        pub use MR0_R as MR8_R;
        ///Field `MR9` reader - Interrupt Mask on line 9
        pub use MR0_R as MR9_R;
        ///Field `MR10` reader - Interrupt Mask on line 10
        pub use MR0_R as MR10_R;
        ///Field `MR11` reader - Interrupt Mask on line 11
        pub use MR0_R as MR11_R;
        ///Field `MR12` reader - Interrupt Mask on line 12
        pub use MR0_R as MR12_R;
        ///Field `MR13` reader - Interrupt Mask on line 13
        pub use MR0_R as MR13_R;
        ///Field `MR14` reader - Interrupt Mask on line 14
        pub use MR0_R as MR14_R;
        ///Field `MR15` reader - Interrupt Mask on line 15
        pub use MR0_R as MR15_R;
        ///Field `MR16` reader - Interrupt Mask on line 16
        pub use MR0_R as MR16_R;
        ///Field `MR17` reader - Interrupt Mask on line 17
        pub use MR0_R as MR17_R;
        ///Field `MR18` reader - Interrupt Mask on line 18
        pub use MR0_R as MR18_R;
        ///Field `MR1` writer - Interrupt Mask on line 1
        pub use MR0_W as MR1_W;
        ///Field `MR2` writer - Interrupt Mask on line 2
        pub use MR0_W as MR2_W;
        ///Field `MR3` writer - Interrupt Mask on line 3
        pub use MR0_W as MR3_W;
        ///Field `MR4` writer - Interrupt Mask on line 4
        pub use MR0_W as MR4_W;
        ///Field `MR5` writer - Interrupt Mask on line 5
        pub use MR0_W as MR5_W;
        ///Field `MR6` writer - Interrupt Mask on line 6
        pub use MR0_W as MR6_W;
        ///Field `MR7` writer - Interrupt Mask on line 7
        pub use MR0_W as MR7_W;
        ///Field `MR8` writer - Interrupt Mask on line 8
        pub use MR0_W as MR8_W;
        ///Field `MR9` writer - Interrupt Mask on line 9
        pub use MR0_W as MR9_W;
        ///Field `MR10` writer - Interrupt Mask on line 10
        pub use MR0_W as MR10_W;
        ///Field `MR11` writer - Interrupt Mask on line 11
        pub use MR0_W as MR11_W;
        ///Field `MR12` writer - Interrupt Mask on line 12
        pub use MR0_W as MR12_W;
        ///Field `MR13` writer - Interrupt Mask on line 13
        pub use MR0_W as MR13_W;
        ///Field `MR14` writer - Interrupt Mask on line 14
        pub use MR0_W as MR14_W;
        ///Field `MR15` writer - Interrupt Mask on line 15
        pub use MR0_W as MR15_W;
        ///Field `MR16` writer - Interrupt Mask on line 16
        pub use MR0_W as MR16_W;
        ///Field `MR17` writer - Interrupt Mask on line 17
        pub use MR0_W as MR17_W;
        ///Field `MR18` writer - Interrupt Mask on line 18
        pub use MR0_W as MR18_W;
        impl R {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Interrupt Mask on line 10
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Interrupt Mask on line 11
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Interrupt Mask on line 12
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Interrupt Mask on line 13
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Interrupt Mask on line 14
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Interrupt Mask on line 15
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Interrupt Mask on line 16
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Interrupt Mask on line 17
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Interrupt Mask on line 18
            #[inline(always)]
            pub fn mr18(&self) -> MR18_R {
                MR18_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            #[must_use]
            pub fn mr0(&mut self) -> MR0_W<0> {
                MR0_W::new(self)
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            #[must_use]
            pub fn mr1(&mut self) -> MR1_W<1> {
                MR1_W::new(self)
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            #[must_use]
            pub fn mr2(&mut self) -> MR2_W<2> {
                MR2_W::new(self)
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            #[must_use]
            pub fn mr3(&mut self) -> MR3_W<3> {
                MR3_W::new(self)
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            #[must_use]
            pub fn mr4(&mut self) -> MR4_W<4> {
                MR4_W::new(self)
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            #[must_use]
            pub fn mr5(&mut self) -> MR5_W<5> {
                MR5_W::new(self)
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            #[must_use]
            pub fn mr6(&mut self) -> MR6_W<6> {
                MR6_W::new(self)
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            #[must_use]
            pub fn mr7(&mut self) -> MR7_W<7> {
                MR7_W::new(self)
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            #[must_use]
            pub fn mr8(&mut self) -> MR8_W<8> {
                MR8_W::new(self)
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            #[must_use]
            pub fn mr9(&mut self) -> MR9_W<9> {
                MR9_W::new(self)
            }
            ///Bit 10 - Interrupt Mask on line 10
            #[inline(always)]
            #[must_use]
            pub fn mr10(&mut self) -> MR10_W<10> {
                MR10_W::new(self)
            }
            ///Bit 11 - Interrupt Mask on line 11
            #[inline(always)]
            #[must_use]
            pub fn mr11(&mut self) -> MR11_W<11> {
                MR11_W::new(self)
            }
            ///Bit 12 - Interrupt Mask on line 12
            #[inline(always)]
            #[must_use]
            pub fn mr12(&mut self) -> MR12_W<12> {
                MR12_W::new(self)
            }
            ///Bit 13 - Interrupt Mask on line 13
            #[inline(always)]
            #[must_use]
            pub fn mr13(&mut self) -> MR13_W<13> {
                MR13_W::new(self)
            }
            ///Bit 14 - Interrupt Mask on line 14
            #[inline(always)]
            #[must_use]
            pub fn mr14(&mut self) -> MR14_W<14> {
                MR14_W::new(self)
            }
            ///Bit 15 - Interrupt Mask on line 15
            #[inline(always)]
            #[must_use]
            pub fn mr15(&mut self) -> MR15_W<15> {
                MR15_W::new(self)
            }
            ///Bit 16 - Interrupt Mask on line 16
            #[inline(always)]
            #[must_use]
            pub fn mr16(&mut self) -> MR16_W<16> {
                MR16_W::new(self)
            }
            ///Bit 17 - Interrupt Mask on line 17
            #[inline(always)]
            #[must_use]
            pub fn mr17(&mut self) -> MR17_W<17> {
                MR17_W::new(self)
            }
            ///Bit 18 - Interrupt Mask on line 18
            #[inline(always)]
            #[must_use]
            pub fn mr18(&mut self) -> MR18_W<18> {
                MR18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt mask register(EXTI_INTENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intenr](index.html) module
        pub struct INTENR_SPEC;
        impl crate::RegisterSpec for INTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intenr::R](R) reader structure
        impl crate::Readable for INTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intenr::W](W) writer structure
        impl crate::Writable for INTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTENR to value 0
        impl crate::Resettable for INTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EVENR (rw) register accessor: an alias for `Reg<EVENR_SPEC>`
    pub type EVENR = crate::Reg<evenr::EVENR_SPEC>;
    ///Event mask register (EXTI_EVENR)
    pub mod evenr {
        ///Register `EVENR` reader
        pub struct R(crate::R<EVENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EVENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EVENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EVENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EVENR` writer
        pub struct W(crate::W<EVENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EVENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EVENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EVENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MR0` reader - Event Mask on line 0
        pub type MR0_R = crate::BitReader<MR0_A>;
        ///Event Mask on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MR0_A {
            ///0: Interrupt event on this line disabled
            Disabled = 0,
            ///1: Interrupt event on this line enabled
            Enabled = 1,
        }
        impl From<MR0_A> for bool {
            #[inline(always)]
            fn from(variant: MR0_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MR0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MR0_A {
                match self.bits {
                    false => MR0_A::Disabled,
                    true => MR0_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MR0_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MR0_A::Enabled
            }
        }
        ///Field `MR0` writer - Event Mask on line 0
        pub type MR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, MR0_A, O>;
        impl<'a, const O: u8> MR0_W<'a, O> {
            ///Interrupt event on this line disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR0_A::Disabled)
            }
            ///Interrupt event on this line enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0_A::Enabled)
            }
        }
        ///Field `MR1` reader - Event Mask on line 1
        pub use MR0_R as MR1_R;
        ///Field `MR2` reader - Event Mask on line 2
        pub use MR0_R as MR2_R;
        ///Field `MR3` reader - Event Mask on line 3
        pub use MR0_R as MR3_R;
        ///Field `MR4` reader - Event Mask on line 4
        pub use MR0_R as MR4_R;
        ///Field `MR5` reader - Event Mask on line 5
        pub use MR0_R as MR5_R;
        ///Field `MR6` reader - Event Mask on line 6
        pub use MR0_R as MR6_R;
        ///Field `MR7` reader - Event Mask on line 7
        pub use MR0_R as MR7_R;
        ///Field `MR8` reader - Event Mask on line 8
        pub use MR0_R as MR8_R;
        ///Field `MR9` reader - Event Mask on line 9
        pub use MR0_R as MR9_R;
        ///Field `MR10` reader - Event Mask on line 10
        pub use MR0_R as MR10_R;
        ///Field `MR11` reader - Event Mask on line 11
        pub use MR0_R as MR11_R;
        ///Field `MR12` reader - Event Mask on line 12
        pub use MR0_R as MR12_R;
        ///Field `MR13` reader - Event Mask on line 13
        pub use MR0_R as MR13_R;
        ///Field `MR14` reader - Event Mask on line 14
        pub use MR0_R as MR14_R;
        ///Field `MR15` reader - Event Mask on line 15
        pub use MR0_R as MR15_R;
        ///Field `MR16` reader - Event Mask on line 16
        pub use MR0_R as MR16_R;
        ///Field `MR17` reader - Event Mask on line 17
        pub use MR0_R as MR17_R;
        ///Field `MR18` reader - Event Mask on line 18
        pub use MR0_R as MR18_R;
        ///Field `MR1` writer - Event Mask on line 1
        pub use MR0_W as MR1_W;
        ///Field `MR2` writer - Event Mask on line 2
        pub use MR0_W as MR2_W;
        ///Field `MR3` writer - Event Mask on line 3
        pub use MR0_W as MR3_W;
        ///Field `MR4` writer - Event Mask on line 4
        pub use MR0_W as MR4_W;
        ///Field `MR5` writer - Event Mask on line 5
        pub use MR0_W as MR5_W;
        ///Field `MR6` writer - Event Mask on line 6
        pub use MR0_W as MR6_W;
        ///Field `MR7` writer - Event Mask on line 7
        pub use MR0_W as MR7_W;
        ///Field `MR8` writer - Event Mask on line 8
        pub use MR0_W as MR8_W;
        ///Field `MR9` writer - Event Mask on line 9
        pub use MR0_W as MR9_W;
        ///Field `MR10` writer - Event Mask on line 10
        pub use MR0_W as MR10_W;
        ///Field `MR11` writer - Event Mask on line 11
        pub use MR0_W as MR11_W;
        ///Field `MR12` writer - Event Mask on line 12
        pub use MR0_W as MR12_W;
        ///Field `MR13` writer - Event Mask on line 13
        pub use MR0_W as MR13_W;
        ///Field `MR14` writer - Event Mask on line 14
        pub use MR0_W as MR14_W;
        ///Field `MR15` writer - Event Mask on line 15
        pub use MR0_W as MR15_W;
        ///Field `MR16` writer - Event Mask on line 16
        pub use MR0_W as MR16_W;
        ///Field `MR17` writer - Event Mask on line 17
        pub use MR0_W as MR17_W;
        ///Field `MR18` writer - Event Mask on line 18
        pub use MR0_W as MR18_W;
        impl R {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Event Mask on line 10
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Event Mask on line 11
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Event Mask on line 12
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Event Mask on line 13
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Event Mask on line 14
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Event Mask on line 15
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Event Mask on line 16
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Event Mask on line 17
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Event Mask on line 18
            #[inline(always)]
            pub fn mr18(&self) -> MR18_R {
                MR18_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            #[must_use]
            pub fn mr0(&mut self) -> MR0_W<0> {
                MR0_W::new(self)
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            #[must_use]
            pub fn mr1(&mut self) -> MR1_W<1> {
                MR1_W::new(self)
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            #[must_use]
            pub fn mr2(&mut self) -> MR2_W<2> {
                MR2_W::new(self)
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            #[must_use]
            pub fn mr3(&mut self) -> MR3_W<3> {
                MR3_W::new(self)
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            #[must_use]
            pub fn mr4(&mut self) -> MR4_W<4> {
                MR4_W::new(self)
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            #[must_use]
            pub fn mr5(&mut self) -> MR5_W<5> {
                MR5_W::new(self)
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            #[must_use]
            pub fn mr6(&mut self) -> MR6_W<6> {
                MR6_W::new(self)
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            #[must_use]
            pub fn mr7(&mut self) -> MR7_W<7> {
                MR7_W::new(self)
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            #[must_use]
            pub fn mr8(&mut self) -> MR8_W<8> {
                MR8_W::new(self)
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            #[must_use]
            pub fn mr9(&mut self) -> MR9_W<9> {
                MR9_W::new(self)
            }
            ///Bit 10 - Event Mask on line 10
            #[inline(always)]
            #[must_use]
            pub fn mr10(&mut self) -> MR10_W<10> {
                MR10_W::new(self)
            }
            ///Bit 11 - Event Mask on line 11
            #[inline(always)]
            #[must_use]
            pub fn mr11(&mut self) -> MR11_W<11> {
                MR11_W::new(self)
            }
            ///Bit 12 - Event Mask on line 12
            #[inline(always)]
            #[must_use]
            pub fn mr12(&mut self) -> MR12_W<12> {
                MR12_W::new(self)
            }
            ///Bit 13 - Event Mask on line 13
            #[inline(always)]
            #[must_use]
            pub fn mr13(&mut self) -> MR13_W<13> {
                MR13_W::new(self)
            }
            ///Bit 14 - Event Mask on line 14
            #[inline(always)]
            #[must_use]
            pub fn mr14(&mut self) -> MR14_W<14> {
                MR14_W::new(self)
            }
            ///Bit 15 - Event Mask on line 15
            #[inline(always)]
            #[must_use]
            pub fn mr15(&mut self) -> MR15_W<15> {
                MR15_W::new(self)
            }
            ///Bit 16 - Event Mask on line 16
            #[inline(always)]
            #[must_use]
            pub fn mr16(&mut self) -> MR16_W<16> {
                MR16_W::new(self)
            }
            ///Bit 17 - Event Mask on line 17
            #[inline(always)]
            #[must_use]
            pub fn mr17(&mut self) -> MR17_W<17> {
                MR17_W::new(self)
            }
            ///Bit 18 - Event Mask on line 18
            #[inline(always)]
            #[must_use]
            pub fn mr18(&mut self) -> MR18_W<18> {
                MR18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Event mask register (EXTI_EVENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [evenr](index.html) module
        pub struct EVENR_SPEC;
        impl crate::RegisterSpec for EVENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [evenr::R](R) reader structure
        impl crate::Readable for EVENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [evenr::W](W) writer structure
        impl crate::Writable for EVENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EVENR to value 0
        impl crate::Resettable for EVENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RTENR (rw) register accessor: an alias for `Reg<RTENR_SPEC>`
    pub type RTENR = crate::Reg<rtenr::RTENR_SPEC>;
    ///Rising Trigger selection register(EXTI_RTENR)
    pub mod rtenr {
        ///Register `RTENR` reader
        pub struct R(crate::R<RTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTENR` writer
        pub struct W(crate::W<RTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TR0` reader - Rising trigger event configuration of line 0
        pub type TR0_R = crate::BitReader<TR0_A>;
        ///Rising trigger event configuration of line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TR0_A {
            ///0: Rising edge trigger on this line disabled
            Disabled = 0,
            ///1: Rising edge trigger on this line enabled
            Enabled = 1,
        }
        impl From<TR0_A> for bool {
            #[inline(always)]
            fn from(variant: TR0_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TR0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TR0_A {
                match self.bits {
                    false => TR0_A::Disabled,
                    true => TR0_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TR0_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TR0_A::Enabled
            }
        }
        ///Field `TR0` writer - Rising trigger event configuration of line 0
        pub type TR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, TR0_A, O>;
        impl<'a, const O: u8> TR0_W<'a, O> {
            ///Rising edge trigger on this line disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::Disabled)
            }
            ///Rising edge trigger on this line enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::Enabled)
            }
        }
        ///Field `TR1` reader - Rising trigger event configuration of line 1
        pub use TR0_R as TR1_R;
        ///Field `TR2` reader - Rising trigger event configuration of line 2
        pub use TR0_R as TR2_R;
        ///Field `TR3` reader - Rising trigger event configuration of line 3
        pub use TR0_R as TR3_R;
        ///Field `TR4` reader - Rising trigger event configuration of line 4
        pub use TR0_R as TR4_R;
        ///Field `TR5` reader - Rising trigger event configuration of line 5
        pub use TR0_R as TR5_R;
        ///Field `TR6` reader - Rising trigger event configuration of line 6
        pub use TR0_R as TR6_R;
        ///Field `TR7` reader - Rising trigger event configuration of line 7
        pub use TR0_R as TR7_R;
        ///Field `TR8` reader - Rising trigger event configuration of line 8
        pub use TR0_R as TR8_R;
        ///Field `TR9` reader - Rising trigger event configuration of line 9
        pub use TR0_R as TR9_R;
        ///Field `TR10` reader - Rising trigger event configuration of line 10
        pub use TR0_R as TR10_R;
        ///Field `TR11` reader - Rising trigger event configuration of line 11
        pub use TR0_R as TR11_R;
        ///Field `TR12` reader - Rising trigger event configuration of line 12
        pub use TR0_R as TR12_R;
        ///Field `TR13` reader - Rising trigger event configuration of line 13
        pub use TR0_R as TR13_R;
        ///Field `TR14` reader - Rising trigger event configuration of line 14
        pub use TR0_R as TR14_R;
        ///Field `TR15` reader - Rising trigger event configuration of line 15
        pub use TR0_R as TR15_R;
        ///Field `TR16` reader - Rising trigger event configuration of line 16
        pub use TR0_R as TR16_R;
        ///Field `TR17` reader - Rising trigger event configuration of line 17
        pub use TR0_R as TR17_R;
        ///Field `TR18` reader - Rising trigger event configuration of line 18
        pub use TR0_R as TR18_R;
        ///Field `TR1` writer - Rising trigger event configuration of line 1
        pub use TR0_W as TR1_W;
        ///Field `TR2` writer - Rising trigger event configuration of line 2
        pub use TR0_W as TR2_W;
        ///Field `TR3` writer - Rising trigger event configuration of line 3
        pub use TR0_W as TR3_W;
        ///Field `TR4` writer - Rising trigger event configuration of line 4
        pub use TR0_W as TR4_W;
        ///Field `TR5` writer - Rising trigger event configuration of line 5
        pub use TR0_W as TR5_W;
        ///Field `TR6` writer - Rising trigger event configuration of line 6
        pub use TR0_W as TR6_W;
        ///Field `TR7` writer - Rising trigger event configuration of line 7
        pub use TR0_W as TR7_W;
        ///Field `TR8` writer - Rising trigger event configuration of line 8
        pub use TR0_W as TR8_W;
        ///Field `TR9` writer - Rising trigger event configuration of line 9
        pub use TR0_W as TR9_W;
        ///Field `TR10` writer - Rising trigger event configuration of line 10
        pub use TR0_W as TR10_W;
        ///Field `TR11` writer - Rising trigger event configuration of line 11
        pub use TR0_W as TR11_W;
        ///Field `TR12` writer - Rising trigger event configuration of line 12
        pub use TR0_W as TR12_W;
        ///Field `TR13` writer - Rising trigger event configuration of line 13
        pub use TR0_W as TR13_W;
        ///Field `TR14` writer - Rising trigger event configuration of line 14
        pub use TR0_W as TR14_W;
        ///Field `TR15` writer - Rising trigger event configuration of line 15
        pub use TR0_W as TR15_W;
        ///Field `TR16` writer - Rising trigger event configuration of line 16
        pub use TR0_W as TR16_W;
        ///Field `TR17` writer - Rising trigger event configuration of line 17
        pub use TR0_W as TR17_W;
        ///Field `TR18` writer - Rising trigger event configuration of line 18
        pub use TR0_W as TR18_W;
        impl R {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Rising trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Rising trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Rising trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Rising trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Rising trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Rising trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Rising trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Rising trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Rising trigger event configuration of line 18
            #[inline(always)]
            pub fn tr18(&self) -> TR18_R {
                TR18_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            #[must_use]
            pub fn tr0(&mut self) -> TR0_W<0> {
                TR0_W::new(self)
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            #[must_use]
            pub fn tr1(&mut self) -> TR1_W<1> {
                TR1_W::new(self)
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            #[must_use]
            pub fn tr2(&mut self) -> TR2_W<2> {
                TR2_W::new(self)
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            #[must_use]
            pub fn tr3(&mut self) -> TR3_W<3> {
                TR3_W::new(self)
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            #[must_use]
            pub fn tr4(&mut self) -> TR4_W<4> {
                TR4_W::new(self)
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            #[must_use]
            pub fn tr5(&mut self) -> TR5_W<5> {
                TR5_W::new(self)
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            #[must_use]
            pub fn tr6(&mut self) -> TR6_W<6> {
                TR6_W::new(self)
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            #[must_use]
            pub fn tr7(&mut self) -> TR7_W<7> {
                TR7_W::new(self)
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            #[must_use]
            pub fn tr8(&mut self) -> TR8_W<8> {
                TR8_W::new(self)
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            #[must_use]
            pub fn tr9(&mut self) -> TR9_W<9> {
                TR9_W::new(self)
            }
            ///Bit 10 - Rising trigger event configuration of line 10
            #[inline(always)]
            #[must_use]
            pub fn tr10(&mut self) -> TR10_W<10> {
                TR10_W::new(self)
            }
            ///Bit 11 - Rising trigger event configuration of line 11
            #[inline(always)]
            #[must_use]
            pub fn tr11(&mut self) -> TR11_W<11> {
                TR11_W::new(self)
            }
            ///Bit 12 - Rising trigger event configuration of line 12
            #[inline(always)]
            #[must_use]
            pub fn tr12(&mut self) -> TR12_W<12> {
                TR12_W::new(self)
            }
            ///Bit 13 - Rising trigger event configuration of line 13
            #[inline(always)]
            #[must_use]
            pub fn tr13(&mut self) -> TR13_W<13> {
                TR13_W::new(self)
            }
            ///Bit 14 - Rising trigger event configuration of line 14
            #[inline(always)]
            #[must_use]
            pub fn tr14(&mut self) -> TR14_W<14> {
                TR14_W::new(self)
            }
            ///Bit 15 - Rising trigger event configuration of line 15
            #[inline(always)]
            #[must_use]
            pub fn tr15(&mut self) -> TR15_W<15> {
                TR15_W::new(self)
            }
            ///Bit 16 - Rising trigger event configuration of line 16
            #[inline(always)]
            #[must_use]
            pub fn tr16(&mut self) -> TR16_W<16> {
                TR16_W::new(self)
            }
            ///Bit 17 - Rising trigger event configuration of line 17
            #[inline(always)]
            #[must_use]
            pub fn tr17(&mut self) -> TR17_W<17> {
                TR17_W::new(self)
            }
            ///Bit 18 - Rising trigger event configuration of line 18
            #[inline(always)]
            #[must_use]
            pub fn tr18(&mut self) -> TR18_W<18> {
                TR18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Rising Trigger selection register(EXTI_RTENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtenr](index.html) module
        pub struct RTENR_SPEC;
        impl crate::RegisterSpec for RTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rtenr::R](R) reader structure
        impl crate::Readable for RTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtenr::W](W) writer structure
        impl crate::Writable for RTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RTENR to value 0
        impl crate::Resettable for RTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FTENR (rw) register accessor: an alias for `Reg<FTENR_SPEC>`
    pub type FTENR = crate::Reg<ftenr::FTENR_SPEC>;
    ///Falling Trigger selection register(EXTI_FTENR)
    pub mod ftenr {
        ///Register `FTENR` reader
        pub struct R(crate::R<FTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FTENR` writer
        pub struct W(crate::W<FTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TR0` reader - Falling trigger event configuration of line 0
        pub type TR0_R = crate::BitReader<TR0_A>;
        ///Falling trigger event configuration of line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TR0_A {
            ///0: Falling edge trigger on this line disabled
            Disabled = 0,
            ///1: Falling edge trigger on this line enabled
            Enabled = 1,
        }
        impl From<TR0_A> for bool {
            #[inline(always)]
            fn from(variant: TR0_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TR0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TR0_A {
                match self.bits {
                    false => TR0_A::Disabled,
                    true => TR0_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TR0_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TR0_A::Enabled
            }
        }
        ///Field `TR0` writer - Falling trigger event configuration of line 0
        pub type TR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, TR0_A, O>;
        impl<'a, const O: u8> TR0_W<'a, O> {
            ///Falling edge trigger on this line disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::Disabled)
            }
            ///Falling edge trigger on this line enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::Enabled)
            }
        }
        ///Field `TR1` reader - Falling trigger event configuration of line 1
        pub use TR0_R as TR1_R;
        ///Field `TR2` reader - Falling trigger event configuration of line 2
        pub use TR0_R as TR2_R;
        ///Field `TR3` reader - Falling trigger event configuration of line 3
        pub use TR0_R as TR3_R;
        ///Field `TR4` reader - Falling trigger event configuration of line 4
        pub use TR0_R as TR4_R;
        ///Field `TR5` reader - Falling trigger event configuration of line 5
        pub use TR0_R as TR5_R;
        ///Field `TR6` reader - Falling trigger event configuration of line 6
        pub use TR0_R as TR6_R;
        ///Field `TR7` reader - Falling trigger event configuration of line 7
        pub use TR0_R as TR7_R;
        ///Field `TR8` reader - Falling trigger event configuration of line 8
        pub use TR0_R as TR8_R;
        ///Field `TR9` reader - Falling trigger event configuration of line 9
        pub use TR0_R as TR9_R;
        ///Field `TR10` reader - Falling trigger event configuration of line 10
        pub use TR0_R as TR10_R;
        ///Field `TR11` reader - Falling trigger event configuration of line 11
        pub use TR0_R as TR11_R;
        ///Field `TR12` reader - Falling trigger event configuration of line 12
        pub use TR0_R as TR12_R;
        ///Field `TR13` reader - Falling trigger event configuration of line 13
        pub use TR0_R as TR13_R;
        ///Field `TR14` reader - Falling trigger event configuration of line 14
        pub use TR0_R as TR14_R;
        ///Field `TR15` reader - Falling trigger event configuration of line 15
        pub use TR0_R as TR15_R;
        ///Field `TR16` reader - Falling trigger event configuration of line 16
        pub use TR0_R as TR16_R;
        ///Field `TR17` reader - Falling trigger event configuration of line 17
        pub use TR0_R as TR17_R;
        ///Field `TR18` reader - Falling trigger event configuration of line 18
        pub use TR0_R as TR18_R;
        ///Field `TR1` writer - Falling trigger event configuration of line 1
        pub use TR0_W as TR1_W;
        ///Field `TR2` writer - Falling trigger event configuration of line 2
        pub use TR0_W as TR2_W;
        ///Field `TR3` writer - Falling trigger event configuration of line 3
        pub use TR0_W as TR3_W;
        ///Field `TR4` writer - Falling trigger event configuration of line 4
        pub use TR0_W as TR4_W;
        ///Field `TR5` writer - Falling trigger event configuration of line 5
        pub use TR0_W as TR5_W;
        ///Field `TR6` writer - Falling trigger event configuration of line 6
        pub use TR0_W as TR6_W;
        ///Field `TR7` writer - Falling trigger event configuration of line 7
        pub use TR0_W as TR7_W;
        ///Field `TR8` writer - Falling trigger event configuration of line 8
        pub use TR0_W as TR8_W;
        ///Field `TR9` writer - Falling trigger event configuration of line 9
        pub use TR0_W as TR9_W;
        ///Field `TR10` writer - Falling trigger event configuration of line 10
        pub use TR0_W as TR10_W;
        ///Field `TR11` writer - Falling trigger event configuration of line 11
        pub use TR0_W as TR11_W;
        ///Field `TR12` writer - Falling trigger event configuration of line 12
        pub use TR0_W as TR12_W;
        ///Field `TR13` writer - Falling trigger event configuration of line 13
        pub use TR0_W as TR13_W;
        ///Field `TR14` writer - Falling trigger event configuration of line 14
        pub use TR0_W as TR14_W;
        ///Field `TR15` writer - Falling trigger event configuration of line 15
        pub use TR0_W as TR15_W;
        ///Field `TR16` writer - Falling trigger event configuration of line 16
        pub use TR0_W as TR16_W;
        ///Field `TR17` writer - Falling trigger event configuration of line 17
        pub use TR0_W as TR17_W;
        ///Field `TR18` writer - Falling trigger event configuration of line 18
        pub use TR0_W as TR18_W;
        impl R {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Falling trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Falling trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Falling trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Falling trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Falling trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Falling trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Falling trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Falling trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Falling trigger event configuration of line 18
            #[inline(always)]
            pub fn tr18(&self) -> TR18_R {
                TR18_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            #[must_use]
            pub fn tr0(&mut self) -> TR0_W<0> {
                TR0_W::new(self)
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            #[must_use]
            pub fn tr1(&mut self) -> TR1_W<1> {
                TR1_W::new(self)
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            #[must_use]
            pub fn tr2(&mut self) -> TR2_W<2> {
                TR2_W::new(self)
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            #[must_use]
            pub fn tr3(&mut self) -> TR3_W<3> {
                TR3_W::new(self)
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            #[must_use]
            pub fn tr4(&mut self) -> TR4_W<4> {
                TR4_W::new(self)
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            #[must_use]
            pub fn tr5(&mut self) -> TR5_W<5> {
                TR5_W::new(self)
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            #[must_use]
            pub fn tr6(&mut self) -> TR6_W<6> {
                TR6_W::new(self)
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            #[must_use]
            pub fn tr7(&mut self) -> TR7_W<7> {
                TR7_W::new(self)
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            #[must_use]
            pub fn tr8(&mut self) -> TR8_W<8> {
                TR8_W::new(self)
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            #[must_use]
            pub fn tr9(&mut self) -> TR9_W<9> {
                TR9_W::new(self)
            }
            ///Bit 10 - Falling trigger event configuration of line 10
            #[inline(always)]
            #[must_use]
            pub fn tr10(&mut self) -> TR10_W<10> {
                TR10_W::new(self)
            }
            ///Bit 11 - Falling trigger event configuration of line 11
            #[inline(always)]
            #[must_use]
            pub fn tr11(&mut self) -> TR11_W<11> {
                TR11_W::new(self)
            }
            ///Bit 12 - Falling trigger event configuration of line 12
            #[inline(always)]
            #[must_use]
            pub fn tr12(&mut self) -> TR12_W<12> {
                TR12_W::new(self)
            }
            ///Bit 13 - Falling trigger event configuration of line 13
            #[inline(always)]
            #[must_use]
            pub fn tr13(&mut self) -> TR13_W<13> {
                TR13_W::new(self)
            }
            ///Bit 14 - Falling trigger event configuration of line 14
            #[inline(always)]
            #[must_use]
            pub fn tr14(&mut self) -> TR14_W<14> {
                TR14_W::new(self)
            }
            ///Bit 15 - Falling trigger event configuration of line 15
            #[inline(always)]
            #[must_use]
            pub fn tr15(&mut self) -> TR15_W<15> {
                TR15_W::new(self)
            }
            ///Bit 16 - Falling trigger event configuration of line 16
            #[inline(always)]
            #[must_use]
            pub fn tr16(&mut self) -> TR16_W<16> {
                TR16_W::new(self)
            }
            ///Bit 17 - Falling trigger event configuration of line 17
            #[inline(always)]
            #[must_use]
            pub fn tr17(&mut self) -> TR17_W<17> {
                TR17_W::new(self)
            }
            ///Bit 18 - Falling trigger event configuration of line 18
            #[inline(always)]
            #[must_use]
            pub fn tr18(&mut self) -> TR18_W<18> {
                TR18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Falling Trigger selection register(EXTI_FTENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ftenr](index.html) module
        pub struct FTENR_SPEC;
        impl crate::RegisterSpec for FTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ftenr::R](R) reader structure
        impl crate::Readable for FTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ftenr::W](W) writer structure
        impl crate::Writable for FTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FTENR to value 0
        impl crate::Resettable for FTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SWIEVR (rw) register accessor: an alias for `Reg<SWIEVR_SPEC>`
    pub type SWIEVR = crate::Reg<swievr::SWIEVR_SPEC>;
    ///Software interrupt event register(EXTI_SWIEVR)
    pub mod swievr {
        ///Register `SWIEVR` reader
        pub struct R(crate::R<SWIEVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SWIEVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SWIEVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SWIEVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SWIEVR` writer
        pub struct W(crate::W<SWIEVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWIEVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SWIEVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SWIEVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SWIER0` reader - Software Interrupt on line 0
        pub type SWIER0_R = crate::BitReader<SWIER0_A>;
        ///Software Interrupt on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SWIER0_A {
            ///0: Software interrupt on this line reset
            Reset = 0,
            ///1: Software interrupt on this line triggerred
            Triggerred = 1,
        }
        impl From<SWIER0_A> for bool {
            #[inline(always)]
            fn from(variant: SWIER0_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SWIER0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SWIER0_A {
                match self.bits {
                    false => SWIER0_A::Reset,
                    true => SWIER0_A::Triggerred,
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == SWIER0_A::Reset
            }
            ///Checks if the value of the field is `Triggerred`
            #[inline(always)]
            pub fn is_triggerred(&self) -> bool {
                *self == SWIER0_A::Triggerred
            }
        }
        ///Field `SWIER0` writer - Software Interrupt on line 0
        pub type SWIER0_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, SWIER0_A, O>;
        impl<'a, const O: u8> SWIER0_W<'a, O> {
            ///Software interrupt on this line reset
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SWIER0_A::Reset)
            }
            ///Software interrupt on this line triggerred
            #[inline(always)]
            pub fn triggerred(self) -> &'a mut W {
                self.variant(SWIER0_A::Triggerred)
            }
        }
        ///Field `SWIER1` reader - Software Interrupt on line 1
        pub use SWIER0_R as SWIER1_R;
        ///Field `SWIER2` reader - Software Interrupt on line 2
        pub use SWIER0_R as SWIER2_R;
        ///Field `SWIER3` reader - Software Interrupt on line 3
        pub use SWIER0_R as SWIER3_R;
        ///Field `SWIER4` reader - Software Interrupt on line 4
        pub use SWIER0_R as SWIER4_R;
        ///Field `SWIER5` reader - Software Interrupt on line 5
        pub use SWIER0_R as SWIER5_R;
        ///Field `SWIER6` reader - Software Interrupt on line 6
        pub use SWIER0_R as SWIER6_R;
        ///Field `SWIER7` reader - Software Interrupt on line 7
        pub use SWIER0_R as SWIER7_R;
        ///Field `SWIER8` reader - Software Interrupt on line 8
        pub use SWIER0_R as SWIER8_R;
        ///Field `SWIER9` reader - Software Interrupt on line 9
        pub use SWIER0_R as SWIER9_R;
        ///Field `SWIER10` reader - Software Interrupt on line 10
        pub use SWIER0_R as SWIER10_R;
        ///Field `SWIER11` reader - Software Interrupt on line 11
        pub use SWIER0_R as SWIER11_R;
        ///Field `SWIER12` reader - Software Interrupt on line 12
        pub use SWIER0_R as SWIER12_R;
        ///Field `SWIER13` reader - Software Interrupt on line 13
        pub use SWIER0_R as SWIER13_R;
        ///Field `SWIER14` reader - Software Interrupt on line 14
        pub use SWIER0_R as SWIER14_R;
        ///Field `SWIER15` reader - Software Interrupt on line 15
        pub use SWIER0_R as SWIER15_R;
        ///Field `SWIER16` reader - Software Interrupt on line 16
        pub use SWIER0_R as SWIER16_R;
        ///Field `SWIER17` reader - Software Interrupt on line 17
        pub use SWIER0_R as SWIER17_R;
        ///Field `SWIER18` reader - Software Interrupt on line 18
        pub use SWIER0_R as SWIER18_R;
        ///Field `SWIER1` writer - Software Interrupt on line 1
        pub use SWIER0_W as SWIER1_W;
        ///Field `SWIER2` writer - Software Interrupt on line 2
        pub use SWIER0_W as SWIER2_W;
        ///Field `SWIER3` writer - Software Interrupt on line 3
        pub use SWIER0_W as SWIER3_W;
        ///Field `SWIER4` writer - Software Interrupt on line 4
        pub use SWIER0_W as SWIER4_W;
        ///Field `SWIER5` writer - Software Interrupt on line 5
        pub use SWIER0_W as SWIER5_W;
        ///Field `SWIER6` writer - Software Interrupt on line 6
        pub use SWIER0_W as SWIER6_W;
        ///Field `SWIER7` writer - Software Interrupt on line 7
        pub use SWIER0_W as SWIER7_W;
        ///Field `SWIER8` writer - Software Interrupt on line 8
        pub use SWIER0_W as SWIER8_W;
        ///Field `SWIER9` writer - Software Interrupt on line 9
        pub use SWIER0_W as SWIER9_W;
        ///Field `SWIER10` writer - Software Interrupt on line 10
        pub use SWIER0_W as SWIER10_W;
        ///Field `SWIER11` writer - Software Interrupt on line 11
        pub use SWIER0_W as SWIER11_W;
        ///Field `SWIER12` writer - Software Interrupt on line 12
        pub use SWIER0_W as SWIER12_W;
        ///Field `SWIER13` writer - Software Interrupt on line 13
        pub use SWIER0_W as SWIER13_W;
        ///Field `SWIER14` writer - Software Interrupt on line 14
        pub use SWIER0_W as SWIER14_W;
        ///Field `SWIER15` writer - Software Interrupt on line 15
        pub use SWIER0_W as SWIER15_W;
        ///Field `SWIER16` writer - Software Interrupt on line 16
        pub use SWIER0_W as SWIER16_W;
        ///Field `SWIER17` writer - Software Interrupt on line 17
        pub use SWIER0_W as SWIER17_W;
        ///Field `SWIER18` writer - Software Interrupt on line 18
        pub use SWIER0_W as SWIER18_W;
        impl R {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            pub fn swier0(&self) -> SWIER0_R {
                SWIER0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            pub fn swier1(&self) -> SWIER1_R {
                SWIER1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            pub fn swier2(&self) -> SWIER2_R {
                SWIER2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            pub fn swier3(&self) -> SWIER3_R {
                SWIER3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            pub fn swier4(&self) -> SWIER4_R {
                SWIER4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            pub fn swier5(&self) -> SWIER5_R {
                SWIER5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            pub fn swier6(&self) -> SWIER6_R {
                SWIER6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            pub fn swier7(&self) -> SWIER7_R {
                SWIER7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            pub fn swier8(&self) -> SWIER8_R {
                SWIER8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            pub fn swier9(&self) -> SWIER9_R {
                SWIER9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Software Interrupt on line 10
            #[inline(always)]
            pub fn swier10(&self) -> SWIER10_R {
                SWIER10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Software Interrupt on line 11
            #[inline(always)]
            pub fn swier11(&self) -> SWIER11_R {
                SWIER11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Software Interrupt on line 12
            #[inline(always)]
            pub fn swier12(&self) -> SWIER12_R {
                SWIER12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Software Interrupt on line 13
            #[inline(always)]
            pub fn swier13(&self) -> SWIER13_R {
                SWIER13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Software Interrupt on line 14
            #[inline(always)]
            pub fn swier14(&self) -> SWIER14_R {
                SWIER14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Software Interrupt on line 15
            #[inline(always)]
            pub fn swier15(&self) -> SWIER15_R {
                SWIER15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Software Interrupt on line 16
            #[inline(always)]
            pub fn swier16(&self) -> SWIER16_R {
                SWIER16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Software Interrupt on line 17
            #[inline(always)]
            pub fn swier17(&self) -> SWIER17_R {
                SWIER17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Software Interrupt on line 18
            #[inline(always)]
            pub fn swier18(&self) -> SWIER18_R {
                SWIER18_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            #[must_use]
            pub fn swier0(&mut self) -> SWIER0_W<0> {
                SWIER0_W::new(self)
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            #[must_use]
            pub fn swier1(&mut self) -> SWIER1_W<1> {
                SWIER1_W::new(self)
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            #[must_use]
            pub fn swier2(&mut self) -> SWIER2_W<2> {
                SWIER2_W::new(self)
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            #[must_use]
            pub fn swier3(&mut self) -> SWIER3_W<3> {
                SWIER3_W::new(self)
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            #[must_use]
            pub fn swier4(&mut self) -> SWIER4_W<4> {
                SWIER4_W::new(self)
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            #[must_use]
            pub fn swier5(&mut self) -> SWIER5_W<5> {
                SWIER5_W::new(self)
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            #[must_use]
            pub fn swier6(&mut self) -> SWIER6_W<6> {
                SWIER6_W::new(self)
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            #[must_use]
            pub fn swier7(&mut self) -> SWIER7_W<7> {
                SWIER7_W::new(self)
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            #[must_use]
            pub fn swier8(&mut self) -> SWIER8_W<8> {
                SWIER8_W::new(self)
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            #[must_use]
            pub fn swier9(&mut self) -> SWIER9_W<9> {
                SWIER9_W::new(self)
            }
            ///Bit 10 - Software Interrupt on line 10
            #[inline(always)]
            #[must_use]
            pub fn swier10(&mut self) -> SWIER10_W<10> {
                SWIER10_W::new(self)
            }
            ///Bit 11 - Software Interrupt on line 11
            #[inline(always)]
            #[must_use]
            pub fn swier11(&mut self) -> SWIER11_W<11> {
                SWIER11_W::new(self)
            }
            ///Bit 12 - Software Interrupt on line 12
            #[inline(always)]
            #[must_use]
            pub fn swier12(&mut self) -> SWIER12_W<12> {
                SWIER12_W::new(self)
            }
            ///Bit 13 - Software Interrupt on line 13
            #[inline(always)]
            #[must_use]
            pub fn swier13(&mut self) -> SWIER13_W<13> {
                SWIER13_W::new(self)
            }
            ///Bit 14 - Software Interrupt on line 14
            #[inline(always)]
            #[must_use]
            pub fn swier14(&mut self) -> SWIER14_W<14> {
                SWIER14_W::new(self)
            }
            ///Bit 15 - Software Interrupt on line 15
            #[inline(always)]
            #[must_use]
            pub fn swier15(&mut self) -> SWIER15_W<15> {
                SWIER15_W::new(self)
            }
            ///Bit 16 - Software Interrupt on line 16
            #[inline(always)]
            #[must_use]
            pub fn swier16(&mut self) -> SWIER16_W<16> {
                SWIER16_W::new(self)
            }
            ///Bit 17 - Software Interrupt on line 17
            #[inline(always)]
            #[must_use]
            pub fn swier17(&mut self) -> SWIER17_W<17> {
                SWIER17_W::new(self)
            }
            ///Bit 18 - Software Interrupt on line 18
            #[inline(always)]
            #[must_use]
            pub fn swier18(&mut self) -> SWIER18_W<18> {
                SWIER18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Software interrupt event register(EXTI_SWIEVR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swievr](index.html) module
        pub struct SWIEVR_SPEC;
        impl crate::RegisterSpec for SWIEVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [swievr::R](R) reader structure
        impl crate::Readable for SWIEVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [swievr::W](W) writer structure
        impl crate::Writable for SWIEVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SWIEVR to value 0
        impl crate::Resettable for SWIEVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFR (rw) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///Interrupt flag register (EXTI_INTFR)
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTFR` writer
        pub struct W(crate::W<INTFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IF0` reader - Interrupt flag on line 0
        pub type IF0_R = crate::BitReader<IF0R_A>;
        ///Interrupt flag on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IF0R_A {
            ///0: This line is not interrupted
            NotInterrupted = 0,
            ///1: This line is interrupted
            Interrupted = 1,
        }
        impl From<IF0R_A> for bool {
            #[inline(always)]
            fn from(variant: IF0R_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IF0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IF0R_A {
                match self.bits {
                    false => IF0R_A::NotInterrupted,
                    true => IF0R_A::Interrupted,
                }
            }
            ///Checks if the value of the field is `NotInterrupted`
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == IF0R_A::NotInterrupted
            }
            ///Checks if the value of the field is `Interrupted`
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == IF0R_A::Interrupted
            }
        }
        ///Interrupt flag on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IF0W_AW {
            ///1: Reset interrupt flag on this line
            Reset = 1,
        }
        impl From<IF0W_AW> for bool {
            #[inline(always)]
            fn from(variant: IF0W_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IF0` writer - Interrupt flag on line 0
        pub type IF0_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, INTFR_SPEC, IF0W_AW, O>;
        impl<'a, const O: u8> IF0_W<'a, O> {
            ///Reset interrupt flag on this line
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IF0W_AW::Reset)
            }
        }
        ///Field `IF1` reader - Interrupt flag on line 1
        pub use IF0_R as IF1_R;
        ///Field `IF2` reader - Interrupt flag on line 2
        pub use IF0_R as IF2_R;
        ///Field `IF3` reader - Interrupt flag on line 3
        pub use IF0_R as IF3_R;
        ///Field `IF4` reader - Interrupt flag on line 4
        pub use IF0_R as IF4_R;
        ///Field `IF5` reader - Interrupt flag on line 5
        pub use IF0_R as IF5_R;
        ///Field `IF6` reader - Interrupt flag on line 6
        pub use IF0_R as IF6_R;
        ///Field `IF7` reader - Interrupt flag on line 7
        pub use IF0_R as IF7_R;
        ///Field `IF8` reader - Interrupt flag on line 8
        pub use IF0_R as IF8_R;
        ///Field `IF9` reader - Interrupt flag on line 9
        pub use IF0_R as IF9_R;
        ///Field `IF10` reader - Interrupt flag on line 10
        pub use IF0_R as IF10_R;
        ///Field `IF11` reader - Interrupt flag on line 11
        pub use IF0_R as IF11_R;
        ///Field `IF12` reader - Interrupt flag on line 12
        pub use IF0_R as IF12_R;
        ///Field `IF13` reader - Interrupt flag on line 13
        pub use IF0_R as IF13_R;
        ///Field `IF14` reader - Interrupt flag on line 14
        pub use IF0_R as IF14_R;
        ///Field `IF15` reader - Interrupt flag on line 15
        pub use IF0_R as IF15_R;
        ///Field `IF16` reader - Interrupt flag on line 16
        pub use IF0_R as IF16_R;
        ///Field `IF17` reader - Interrupt flag on line 17
        pub use IF0_R as IF17_R;
        ///Field `IF18` reader - Interrupt flag on line 18
        pub use IF0_R as IF18_R;
        ///Field `IF1` writer - Interrupt flag on line 1
        pub use IF0_W as IF1_W;
        ///Field `IF2` writer - Interrupt flag on line 2
        pub use IF0_W as IF2_W;
        ///Field `IF3` writer - Interrupt flag on line 3
        pub use IF0_W as IF3_W;
        ///Field `IF4` writer - Interrupt flag on line 4
        pub use IF0_W as IF4_W;
        ///Field `IF5` writer - Interrupt flag on line 5
        pub use IF0_W as IF5_W;
        ///Field `IF6` writer - Interrupt flag on line 6
        pub use IF0_W as IF6_W;
        ///Field `IF7` writer - Interrupt flag on line 7
        pub use IF0_W as IF7_W;
        ///Field `IF8` writer - Interrupt flag on line 8
        pub use IF0_W as IF8_W;
        ///Field `IF9` writer - Interrupt flag on line 9
        pub use IF0_W as IF9_W;
        ///Field `IF10` writer - Interrupt flag on line 10
        pub use IF0_W as IF10_W;
        ///Field `IF11` writer - Interrupt flag on line 11
        pub use IF0_W as IF11_W;
        ///Field `IF12` writer - Interrupt flag on line 12
        pub use IF0_W as IF12_W;
        ///Field `IF13` writer - Interrupt flag on line 13
        pub use IF0_W as IF13_W;
        ///Field `IF14` writer - Interrupt flag on line 14
        pub use IF0_W as IF14_W;
        ///Field `IF15` writer - Interrupt flag on line 15
        pub use IF0_W as IF15_W;
        ///Field `IF16` writer - Interrupt flag on line 16
        pub use IF0_W as IF16_W;
        ///Field `IF17` writer - Interrupt flag on line 17
        pub use IF0_W as IF17_W;
        ///Field `IF18` writer - Interrupt flag on line 18
        pub use IF0_W as IF18_W;
        impl R {
            ///Bit 0 - Interrupt flag on line 0
            #[inline(always)]
            pub fn if0(&self) -> IF0_R {
                IF0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Interrupt flag on line 1
            #[inline(always)]
            pub fn if1(&self) -> IF1_R {
                IF1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Interrupt flag on line 2
            #[inline(always)]
            pub fn if2(&self) -> IF2_R {
                IF2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Interrupt flag on line 3
            #[inline(always)]
            pub fn if3(&self) -> IF3_R {
                IF3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Interrupt flag on line 4
            #[inline(always)]
            pub fn if4(&self) -> IF4_R {
                IF4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Interrupt flag on line 5
            #[inline(always)]
            pub fn if5(&self) -> IF5_R {
                IF5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Interrupt flag on line 6
            #[inline(always)]
            pub fn if6(&self) -> IF6_R {
                IF6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Interrupt flag on line 7
            #[inline(always)]
            pub fn if7(&self) -> IF7_R {
                IF7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Interrupt flag on line 8
            #[inline(always)]
            pub fn if8(&self) -> IF8_R {
                IF8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Interrupt flag on line 9
            #[inline(always)]
            pub fn if9(&self) -> IF9_R {
                IF9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Interrupt flag on line 10
            #[inline(always)]
            pub fn if10(&self) -> IF10_R {
                IF10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Interrupt flag on line 11
            #[inline(always)]
            pub fn if11(&self) -> IF11_R {
                IF11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Interrupt flag on line 12
            #[inline(always)]
            pub fn if12(&self) -> IF12_R {
                IF12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Interrupt flag on line 13
            #[inline(always)]
            pub fn if13(&self) -> IF13_R {
                IF13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Interrupt flag on line 14
            #[inline(always)]
            pub fn if14(&self) -> IF14_R {
                IF14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Interrupt flag on line 15
            #[inline(always)]
            pub fn if15(&self) -> IF15_R {
                IF15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Interrupt flag on line 16
            #[inline(always)]
            pub fn if16(&self) -> IF16_R {
                IF16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Interrupt flag on line 17
            #[inline(always)]
            pub fn if17(&self) -> IF17_R {
                IF17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Interrupt flag on line 18
            #[inline(always)]
            pub fn if18(&self) -> IF18_R {
                IF18_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interrupt flag on line 0
            #[inline(always)]
            #[must_use]
            pub fn if0(&mut self) -> IF0_W<0> {
                IF0_W::new(self)
            }
            ///Bit 1 - Interrupt flag on line 1
            #[inline(always)]
            #[must_use]
            pub fn if1(&mut self) -> IF1_W<1> {
                IF1_W::new(self)
            }
            ///Bit 2 - Interrupt flag on line 2
            #[inline(always)]
            #[must_use]
            pub fn if2(&mut self) -> IF2_W<2> {
                IF2_W::new(self)
            }
            ///Bit 3 - Interrupt flag on line 3
            #[inline(always)]
            #[must_use]
            pub fn if3(&mut self) -> IF3_W<3> {
                IF3_W::new(self)
            }
            ///Bit 4 - Interrupt flag on line 4
            #[inline(always)]
            #[must_use]
            pub fn if4(&mut self) -> IF4_W<4> {
                IF4_W::new(self)
            }
            ///Bit 5 - Interrupt flag on line 5
            #[inline(always)]
            #[must_use]
            pub fn if5(&mut self) -> IF5_W<5> {
                IF5_W::new(self)
            }
            ///Bit 6 - Interrupt flag on line 6
            #[inline(always)]
            #[must_use]
            pub fn if6(&mut self) -> IF6_W<6> {
                IF6_W::new(self)
            }
            ///Bit 7 - Interrupt flag on line 7
            #[inline(always)]
            #[must_use]
            pub fn if7(&mut self) -> IF7_W<7> {
                IF7_W::new(self)
            }
            ///Bit 8 - Interrupt flag on line 8
            #[inline(always)]
            #[must_use]
            pub fn if8(&mut self) -> IF8_W<8> {
                IF8_W::new(self)
            }
            ///Bit 9 - Interrupt flag on line 9
            #[inline(always)]
            #[must_use]
            pub fn if9(&mut self) -> IF9_W<9> {
                IF9_W::new(self)
            }
            ///Bit 10 - Interrupt flag on line 10
            #[inline(always)]
            #[must_use]
            pub fn if10(&mut self) -> IF10_W<10> {
                IF10_W::new(self)
            }
            ///Bit 11 - Interrupt flag on line 11
            #[inline(always)]
            #[must_use]
            pub fn if11(&mut self) -> IF11_W<11> {
                IF11_W::new(self)
            }
            ///Bit 12 - Interrupt flag on line 12
            #[inline(always)]
            #[must_use]
            pub fn if12(&mut self) -> IF12_W<12> {
                IF12_W::new(self)
            }
            ///Bit 13 - Interrupt flag on line 13
            #[inline(always)]
            #[must_use]
            pub fn if13(&mut self) -> IF13_W<13> {
                IF13_W::new(self)
            }
            ///Bit 14 - Interrupt flag on line 14
            #[inline(always)]
            #[must_use]
            pub fn if14(&mut self) -> IF14_W<14> {
                IF14_W::new(self)
            }
            ///Bit 15 - Interrupt flag on line 15
            #[inline(always)]
            #[must_use]
            pub fn if15(&mut self) -> IF15_W<15> {
                IF15_W::new(self)
            }
            ///Bit 16 - Interrupt flag on line 16
            #[inline(always)]
            #[must_use]
            pub fn if16(&mut self) -> IF16_W<16> {
                IF16_W::new(self)
            }
            ///Bit 17 - Interrupt flag on line 17
            #[inline(always)]
            #[must_use]
            pub fn if17(&mut self) -> IF17_W<17> {
                IF17_W::new(self)
            }
            ///Bit 18 - Interrupt flag on line 18
            #[inline(always)]
            #[must_use]
            pub fn if18(&mut self) -> IF18_W<18> {
                IF18_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt flag register (EXTI_INTFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intfr::W](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0007_ffff;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///DMA controller
pub struct DMA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA {}
impl DMA {
    ///Pointer to the register block
    pub const PTR: *const dma::RegisterBlock = 0x4002_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dma::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA {
    type Target = dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA").finish()
    }
}
///DMA controller
pub mod dma {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - DMA interrupt status register (DMA_INTFR)
        pub intfr: INTFR,
        ///0x04 - DMA interrupt flag clear register (DMA_INTFCR)
        pub intfcr: INTFCR,
        ///0x08 - DMA channel configuration register (DMA_CFGR)
        pub cfgr1: CFGR1,
        ///0x0c - DMA channel 1 number of data register
        pub cntr1: CNTR1,
        ///0x10 - DMA channel 1 peripheral address register
        pub paddr1: PADDR1,
        ///0x14 - DMA channel 1 memory address register
        pub maddr1: MADDR1,
        _reserved6: [u8; 0x04],
        ///0x1c - DMA channel configuration register (DMA_CFGR)
        pub cfgr2: CFGR2,
        ///0x20 - DMA channel 2 number of data register
        pub cntr2: CNTR2,
        ///0x24 - DMA channel 2 peripheral address register
        pub paddr2: PADDR2,
        ///0x28 - DMA channel 2 memory address register
        pub maddr2: MADDR2,
        _reserved10: [u8; 0x04],
        ///0x30 - DMA channel configuration register (DMA_CFGR)
        pub cfgr3: CFGR3,
        ///0x34 - DMA channel 3 number of data register
        pub cntr3: CNTR3,
        ///0x38 - DMA channel 3 peripheral address register
        pub paddr3: PADDR3,
        ///0x3c - DMA channel 3 memory address register
        pub maddr3: MADDR3,
        _reserved14: [u8; 0x04],
        ///0x44 - DMA channel configuration register (DMA_CFGR)
        pub cfgr4: CFGR4,
        ///0x48 - DMA channel 4 number of data register
        pub cntr4: CNTR4,
        ///0x4c - DMA channel 4 peripheral address register
        pub paddr4: PADDR4,
        ///0x50 - DMA channel 4 memory address register
        pub maddr4: MADDR4,
        _reserved18: [u8; 0x04],
        ///0x58 - DMA channel configuration register (DMA_CFGR)
        pub cfgr5: CFGR5,
        ///0x5c - DMA channel 5 number of data register
        pub cntr5: CNTR5,
        ///0x60 - DMA channel 5 peripheral address register
        pub paddr5: PADDR5,
        ///0x64 - DMA channel 5 memory address register
        pub maddr5: MADDR5,
        _reserved22: [u8; 0x04],
        ///0x6c - DMA channel configuration register (DMA_CFGR)
        pub cfgr6: CFGR6,
        ///0x70 - DMA channel 6 number of data register
        pub cntr6: CNTR6,
        ///0x74 - DMA channel 6 peripheral address register
        pub paddr6: PADDR6,
        ///0x78 - DMA channel 6 memory address register
        pub maddr6: MADDR6,
        _reserved26: [u8; 0x04],
        ///0x80 - DMA channel configuration register (DMA_CFGR)
        pub cfgr7: CFGR7,
        ///0x84 - DMA channel 7 number of data register
        pub cntr7: CNTR7,
        ///0x88 - DMA channel 7 peripheral address register
        pub paddr7: PADDR7,
        ///0x8c - DMA channel 7 memory address register
        pub maddr7: MADDR7,
    }
    ///INTFR (r) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///DMA interrupt status register (DMA_INTFR)
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `GIF1` reader - Channel 1 Global interrupt flag
        pub type GIF1_R = crate::BitReader<GIF1R_A>;
        ///Channel 1 Global interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GIF1R_A {
            ///0: No TEI HTI or TCI occurred
            NoInterrupt = 0,
            ///1: TEI HTI or TCI occurred
            HasInterrupt = 1,
        }
        impl From<GIF1R_A> for bool {
            #[inline(always)]
            fn from(variant: GIF1R_A) -> Self {
                variant as u8 != 0
            }
        }
        impl GIF1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> GIF1R_A {
                match self.bits {
                    false => GIF1R_A::NoInterrupt,
                    true => GIF1R_A::HasInterrupt,
                }
            }
            ///Checks if the value of the field is `NoInterrupt`
            #[inline(always)]
            pub fn is_no_interrupt(&self) -> bool {
                *self == GIF1R_A::NoInterrupt
            }
            ///Checks if the value of the field is `HasInterrupt`
            #[inline(always)]
            pub fn is_has_interrupt(&self) -> bool {
                *self == GIF1R_A::HasInterrupt
            }
        }
        ///Field `TCIF1` reader - Channel 1 Transfer Complete flag
        pub type TCIF1_R = crate::BitReader<TCIF1R_A>;
        ///Channel 1 Transfer Complete flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIF1R_A {
            ///0: No transfer complete event occurred
            NoEvent = 0,
            ///1: Transfer complete event occurred
            HasEvent = 1,
        }
        impl From<TCIF1R_A> for bool {
            #[inline(always)]
            fn from(variant: TCIF1R_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIF1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIF1R_A {
                match self.bits {
                    false => TCIF1R_A::NoEvent,
                    true => TCIF1R_A::HasEvent,
                }
            }
            ///Checks if the value of the field is `NoEvent`
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == TCIF1R_A::NoEvent
            }
            ///Checks if the value of the field is `HasEvent`
            #[inline(always)]
            pub fn is_has_event(&self) -> bool {
                *self == TCIF1R_A::HasEvent
            }
        }
        ///Field `HTIF1` reader - Channel 1 Half Transfer Complete flag
        pub type HTIF1_R = crate::BitReader<HTIF1R_A>;
        ///Channel 1 Half Transfer Complete flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HTIF1R_A {
            ///0: No transfer half event occurred
            NoEvent = 0,
            ///1: Transfer half event occurred
            HasEvent = 1,
        }
        impl From<HTIF1R_A> for bool {
            #[inline(always)]
            fn from(variant: HTIF1R_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HTIF1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HTIF1R_A {
                match self.bits {
                    false => HTIF1R_A::NoEvent,
                    true => HTIF1R_A::HasEvent,
                }
            }
            ///Checks if the value of the field is `NoEvent`
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == HTIF1R_A::NoEvent
            }
            ///Checks if the value of the field is `HasEvent`
            #[inline(always)]
            pub fn is_has_event(&self) -> bool {
                *self == HTIF1R_A::HasEvent
            }
        }
        ///Field `TEIF1` reader - Channel 1 Transfer Error flag
        pub type TEIF1_R = crate::BitReader<TEIF1R_A>;
        ///Channel 1 Transfer Error flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TEIF1R_A {
            ///0: No transfer error event occurred
            NoEvent = 0,
            ///1: Transfer error event occurred
            HasEvent = 1,
        }
        impl From<TEIF1R_A> for bool {
            #[inline(always)]
            fn from(variant: TEIF1R_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TEIF1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TEIF1R_A {
                match self.bits {
                    false => TEIF1R_A::NoEvent,
                    true => TEIF1R_A::HasEvent,
                }
            }
            ///Checks if the value of the field is `NoEvent`
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == TEIF1R_A::NoEvent
            }
            ///Checks if the value of the field is `HasEvent`
            #[inline(always)]
            pub fn is_has_event(&self) -> bool {
                *self == TEIF1R_A::HasEvent
            }
        }
        ///Field `GIF2` reader - Channel 2 Global interrupt flag
        pub use GIF1_R as GIF2_R;
        ///Field `GIF3` reader - Channel 3 Global interrupt flag
        pub use GIF1_R as GIF3_R;
        ///Field `GIF4` reader - Channel 4 Global interrupt flag
        pub use GIF1_R as GIF4_R;
        ///Field `GIF5` reader - Channel 5 Global interrupt flag
        pub use GIF1_R as GIF5_R;
        ///Field `GIF6` reader - Channel 6 Global interrupt flag
        pub use GIF1_R as GIF6_R;
        ///Field `GIF7` reader - Channel 7 Global interrupt flag
        pub use GIF1_R as GIF7_R;
        ///Field `HTIF2` reader - Channel 2 Half Transfer Complete flag
        pub use HTIF1_R as HTIF2_R;
        ///Field `HTIF3` reader - Channel 3 Half Transfer Complete flag
        pub use HTIF1_R as HTIF3_R;
        ///Field `HTIF4` reader - Channel 4 Half Transfer Complete flag
        pub use HTIF1_R as HTIF4_R;
        ///Field `HTIF5` reader - Channel 5 Half Transfer Complete flag
        pub use HTIF1_R as HTIF5_R;
        ///Field `HTIF6` reader - Channel 6 Half Transfer Complete flag
        pub use HTIF1_R as HTIF6_R;
        ///Field `HTIF7` reader - Channel 7 Half Transfer Complete flag
        pub use HTIF1_R as HTIF7_R;
        ///Field `TCIF2` reader - Channel 2 Transfer Complete flag
        pub use TCIF1_R as TCIF2_R;
        ///Field `TCIF3` reader - Channel 3 Transfer Complete flag
        pub use TCIF1_R as TCIF3_R;
        ///Field `TCIF4` reader - Channel 4 Transfer Complete flag
        pub use TCIF1_R as TCIF4_R;
        ///Field `TCIF5` reader - Channel 5 Transfer Complete flag
        pub use TCIF1_R as TCIF5_R;
        ///Field `TCIF6` reader - Channel 6 Transfer Complete flag
        pub use TCIF1_R as TCIF6_R;
        ///Field `TCIF7` reader - Channel 7 Transfer Complete flag
        pub use TCIF1_R as TCIF7_R;
        ///Field `TEIF2` reader - Channel 2 Transfer Error flag
        pub use TEIF1_R as TEIF2_R;
        ///Field `TEIF3` reader - Channel 3 Transfer Error flag
        pub use TEIF1_R as TEIF3_R;
        ///Field `TEIF4` reader - Channel 4 Transfer Error flag
        pub use TEIF1_R as TEIF4_R;
        ///Field `TEIF5` reader - Channel 5 Transfer Error flag
        pub use TEIF1_R as TEIF5_R;
        ///Field `TEIF6` reader - Channel 6 Transfer Error flag
        pub use TEIF1_R as TEIF6_R;
        ///Field `TEIF7` reader - Channel 7 Transfer Error flag
        pub use TEIF1_R as TEIF7_R;
        impl R {
            ///Bit 0 - Channel 1 Global interrupt flag
            #[inline(always)]
            pub fn gif1(&self) -> GIF1_R {
                GIF1_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Channel 1 Transfer Complete flag
            #[inline(always)]
            pub fn tcif1(&self) -> TCIF1_R {
                TCIF1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Channel 1 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif1(&self) -> HTIF1_R {
                HTIF1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Channel 1 Transfer Error flag
            #[inline(always)]
            pub fn teif1(&self) -> TEIF1_R {
                TEIF1_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Channel 2 Global interrupt flag
            #[inline(always)]
            pub fn gif2(&self) -> GIF2_R {
                GIF2_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Channel 2 Transfer Complete flag
            #[inline(always)]
            pub fn tcif2(&self) -> TCIF2_R {
                TCIF2_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Channel 2 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif2(&self) -> HTIF2_R {
                HTIF2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Channel 2 Transfer Error flag
            #[inline(always)]
            pub fn teif2(&self) -> TEIF2_R {
                TEIF2_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Channel 3 Global interrupt flag
            #[inline(always)]
            pub fn gif3(&self) -> GIF3_R {
                GIF3_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Channel 3 Transfer Complete flag
            #[inline(always)]
            pub fn tcif3(&self) -> TCIF3_R {
                TCIF3_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Channel 3 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif3(&self) -> HTIF3_R {
                HTIF3_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Channel 3 Transfer Error flag
            #[inline(always)]
            pub fn teif3(&self) -> TEIF3_R {
                TEIF3_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Channel 4 Global interrupt flag
            #[inline(always)]
            pub fn gif4(&self) -> GIF4_R {
                GIF4_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Channel 4 Transfer Complete flag
            #[inline(always)]
            pub fn tcif4(&self) -> TCIF4_R {
                TCIF4_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Channel 4 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif4(&self) -> HTIF4_R {
                HTIF4_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Channel 4 Transfer Error flag
            #[inline(always)]
            pub fn teif4(&self) -> TEIF4_R {
                TEIF4_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Channel 5 Global interrupt flag
            #[inline(always)]
            pub fn gif5(&self) -> GIF5_R {
                GIF5_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Channel 5 Transfer Complete flag
            #[inline(always)]
            pub fn tcif5(&self) -> TCIF5_R {
                TCIF5_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Channel 5 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif5(&self) -> HTIF5_R {
                HTIF5_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Channel 5 Transfer Error flag
            #[inline(always)]
            pub fn teif5(&self) -> TEIF5_R {
                TEIF5_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Channel 6 Global interrupt flag
            #[inline(always)]
            pub fn gif6(&self) -> GIF6_R {
                GIF6_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Channel 6 Transfer Complete flag
            #[inline(always)]
            pub fn tcif6(&self) -> TCIF6_R {
                TCIF6_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Channel 6 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif6(&self) -> HTIF6_R {
                HTIF6_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Channel 6 Transfer Error flag
            #[inline(always)]
            pub fn teif6(&self) -> TEIF6_R {
                TEIF6_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Channel 7 Global interrupt flag
            #[inline(always)]
            pub fn gif7(&self) -> GIF7_R {
                GIF7_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Channel 7 Transfer Complete flag
            #[inline(always)]
            pub fn tcif7(&self) -> TCIF7_R {
                TCIF7_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Channel 7 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif7(&self) -> HTIF7_R {
                HTIF7_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Channel 7 Transfer Error flag
            #[inline(always)]
            pub fn teif7(&self) -> TEIF7_R {
                TEIF7_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        ///DMA interrupt status register (DMA_INTFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFCR (w) register accessor: an alias for `Reg<INTFCR_SPEC>`
    pub type INTFCR = crate::Reg<intfcr::INTFCR_SPEC>;
    ///DMA interrupt flag clear register (DMA_INTFCR)
    pub mod intfcr {
        ///Register `INTFCR` writer
        pub struct W(crate::W<INTFCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Channel 1 Global interrupt clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CGIF1W_AW {
            ///1: Clear the flag
            Clear = 1,
        }
        impl From<CGIF1W_AW> for bool {
            #[inline(always)]
            fn from(variant: CGIF1W_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CGIF1` writer - Channel 1 Global interrupt clear
        pub type CGIF1_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, INTFCR_SPEC, CGIF1W_AW, O>;
        impl<'a, const O: u8> CGIF1_W<'a, O> {
            ///Clear the flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W_AW::Clear)
            }
        }
        ///Field `CTCIF1` writer - Channel 1 Transfer Complete clear
        pub use CGIF1_W as CTCIF1_W;
        ///Field `CHTIF1` writer - Channel 1 Half Transfer clear
        pub use CGIF1_W as CHTIF1_W;
        ///Field `CTEIF1` writer - Channel 1 Transfer Error clear
        pub use CGIF1_W as CTEIF1_W;
        ///Field `CGIF2` writer - Channel 2 Global interrupt clear
        pub use CGIF1_W as CGIF2_W;
        ///Field `CTCIF2` writer - Channel 2 Transfer Complete clear
        pub use CGIF1_W as CTCIF2_W;
        ///Field `CHTIF2` writer - Channel 2 Half Transfer clear
        pub use CGIF1_W as CHTIF2_W;
        ///Field `CTEIF2` writer - Channel 2 Transfer Error clear
        pub use CGIF1_W as CTEIF2_W;
        ///Field `CGIF3` writer - Channel 3 Global interrupt clear
        pub use CGIF1_W as CGIF3_W;
        ///Field `CTCIF3` writer - Channel 3 Transfer Complete clear
        pub use CGIF1_W as CTCIF3_W;
        ///Field `CHTIF3` writer - Channel 3 Half Transfer clear
        pub use CGIF1_W as CHTIF3_W;
        ///Field `CTEIF3` writer - Channel 3 Transfer Error clear
        pub use CGIF1_W as CTEIF3_W;
        ///Field `CGIF4` writer - Channel 4 Global interrupt clear
        pub use CGIF1_W as CGIF4_W;
        ///Field `CTCIF4` writer - Channel 4 Transfer Complete clear
        pub use CGIF1_W as CTCIF4_W;
        ///Field `CHTIF4` writer - Channel 4 Half Transfer clear
        pub use CGIF1_W as CHTIF4_W;
        ///Field `CTEIF4` writer - Channel 4 Transfer Error clear
        pub use CGIF1_W as CTEIF4_W;
        ///Field `CGIF5` writer - Channel 5 Global interrupt clear
        pub use CGIF1_W as CGIF5_W;
        ///Field `CTCIF5` writer - Channel 5 Transfer Complete clear
        pub use CGIF1_W as CTCIF5_W;
        ///Field `CHTIF5` writer - Channel 5 Half Transfer clear
        pub use CGIF1_W as CHTIF5_W;
        ///Field `CTEIF5` writer - Channel 5 Transfer Error clear
        pub use CGIF1_W as CTEIF5_W;
        ///Field `CGIF6` writer - Channel 6 Global interrupt clear
        pub use CGIF1_W as CGIF6_W;
        ///Field `CTCIF6` writer - Channel 6 Transfer Complete clear
        pub use CGIF1_W as CTCIF6_W;
        ///Field `CHTIF6` writer - Channel 6 Half Transfer clear
        pub use CGIF1_W as CHTIF6_W;
        ///Field `CTEIF6` writer - Channel 6 Transfer Error clear
        pub use CGIF1_W as CTEIF6_W;
        ///Field `CGIF7` writer - Channel 7 Global interrupt clear
        pub use CGIF1_W as CGIF7_W;
        ///Field `CTCIF7` writer - Channel 7 Transfer Complete clear
        pub use CGIF1_W as CTCIF7_W;
        ///Field `CHTIF7` writer - Channel 7 Half Transfer clear
        pub use CGIF1_W as CHTIF7_W;
        ///Field `CTEIF7` writer - Channel 7 Transfer Error clear
        pub use CGIF1_W as CTEIF7_W;
        impl W {
            ///Bit 0 - Channel 1 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif1(&mut self) -> CGIF1_W<0> {
                CGIF1_W::new(self)
            }
            ///Bit 1 - Channel 1 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif1(&mut self) -> CTCIF1_W<1> {
                CTCIF1_W::new(self)
            }
            ///Bit 2 - Channel 1 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif1(&mut self) -> CHTIF1_W<2> {
                CHTIF1_W::new(self)
            }
            ///Bit 3 - Channel 1 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif1(&mut self) -> CTEIF1_W<3> {
                CTEIF1_W::new(self)
            }
            ///Bit 4 - Channel 2 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif2(&mut self) -> CGIF2_W<4> {
                CGIF2_W::new(self)
            }
            ///Bit 5 - Channel 2 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif2(&mut self) -> CTCIF2_W<5> {
                CTCIF2_W::new(self)
            }
            ///Bit 6 - Channel 2 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif2(&mut self) -> CHTIF2_W<6> {
                CHTIF2_W::new(self)
            }
            ///Bit 7 - Channel 2 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif2(&mut self) -> CTEIF2_W<7> {
                CTEIF2_W::new(self)
            }
            ///Bit 8 - Channel 3 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif3(&mut self) -> CGIF3_W<8> {
                CGIF3_W::new(self)
            }
            ///Bit 9 - Channel 3 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif3(&mut self) -> CTCIF3_W<9> {
                CTCIF3_W::new(self)
            }
            ///Bit 10 - Channel 3 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif3(&mut self) -> CHTIF3_W<10> {
                CHTIF3_W::new(self)
            }
            ///Bit 11 - Channel 3 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif3(&mut self) -> CTEIF3_W<11> {
                CTEIF3_W::new(self)
            }
            ///Bit 12 - Channel 4 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif4(&mut self) -> CGIF4_W<12> {
                CGIF4_W::new(self)
            }
            ///Bit 13 - Channel 4 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif4(&mut self) -> CTCIF4_W<13> {
                CTCIF4_W::new(self)
            }
            ///Bit 14 - Channel 4 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif4(&mut self) -> CHTIF4_W<14> {
                CHTIF4_W::new(self)
            }
            ///Bit 15 - Channel 4 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif4(&mut self) -> CTEIF4_W<15> {
                CTEIF4_W::new(self)
            }
            ///Bit 16 - Channel 5 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif5(&mut self) -> CGIF5_W<16> {
                CGIF5_W::new(self)
            }
            ///Bit 17 - Channel 5 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif5(&mut self) -> CTCIF5_W<17> {
                CTCIF5_W::new(self)
            }
            ///Bit 18 - Channel 5 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif5(&mut self) -> CHTIF5_W<18> {
                CHTIF5_W::new(self)
            }
            ///Bit 19 - Channel 5 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif5(&mut self) -> CTEIF5_W<19> {
                CTEIF5_W::new(self)
            }
            ///Bit 20 - Channel 6 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif6(&mut self) -> CGIF6_W<20> {
                CGIF6_W::new(self)
            }
            ///Bit 21 - Channel 6 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif6(&mut self) -> CTCIF6_W<21> {
                CTCIF6_W::new(self)
            }
            ///Bit 22 - Channel 6 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif6(&mut self) -> CHTIF6_W<22> {
                CHTIF6_W::new(self)
            }
            ///Bit 23 - Channel 6 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif6(&mut self) -> CTEIF6_W<23> {
                CTEIF6_W::new(self)
            }
            ///Bit 24 - Channel 7 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif7(&mut self) -> CGIF7_W<24> {
                CGIF7_W::new(self)
            }
            ///Bit 25 - Channel 7 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif7(&mut self) -> CTCIF7_W<25> {
                CTCIF7_W::new(self)
            }
            ///Bit 26 - Channel 7 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif7(&mut self) -> CHTIF7_W<26> {
                CHTIF7_W::new(self)
            }
            ///Bit 27 - Channel 7 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif7(&mut self) -> CTEIF7_W<27> {
                CTEIF7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA interrupt flag clear register (DMA_INTFCR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfcr](index.html) module
        pub struct INTFCR_SPEC;
        impl crate::RegisterSpec for INTFCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [intfcr::W](W) writer structure
        impl crate::Writable for INTFCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0fff_ffff;
        }
        ///`reset()` method sets INTFCR to value 0
        impl crate::Resettable for INTFCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR1 (rw) register accessor: an alias for `Reg<CFGR1_SPEC>`
    pub type CFGR1 = crate::Reg<cfgr1::CFGR1_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr1 {
        ///Register `CFGR1` reader
        pub struct R(crate::R<CFGR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR1` writer
        pub struct W(crate::W<CFGR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<EN_A>;
        ///Channel enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN_A {
            ///0: DMA channel disabled
            Disabled = 0,
            ///1: DMA channel enabled
            Enabled = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::Disabled,
                    true => EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::Enabled
            }
        }
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, EN_A, O>;
        impl<'a, const O: u8> EN_W<'a, O> {
            ///DMA channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::Disabled)
            }
            ///DMA channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::Enabled)
            }
        }
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<TCIE_A>;
        ///Transfer complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::Disabled,
                    true => TCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::Enabled
            }
        }
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, TCIE_A, O>;
        impl<'a, const O: u8> TCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::Enabled)
            }
        }
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub use TCIE_R as HTIE_R;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub use TCIE_R as TEIE_R;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub use TCIE_W as HTIE_W;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub use TCIE_W as TEIE_W;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Data transfer direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Read from peripheral
            Peripheral = 0,
            ///1: Read from memory
            Memory = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Peripheral,
                    true => DIR_A::Memory,
                }
            }
            ///Checks if the value of the field is `Peripheral`
            #[inline(always)]
            pub fn is_peripheral(&self) -> bool {
                *self == DIR_A::Peripheral
            }
            ///Checks if the value of the field is `Memory`
            #[inline(always)]
            pub fn is_memory(&self) -> bool {
                *self == DIR_A::Memory
            }
        }
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Read from peripheral
            #[inline(always)]
            pub fn peripheral(self) -> &'a mut W {
                self.variant(DIR_A::Peripheral)
            }
            ///Read from memory
            #[inline(always)]
            pub fn memory(self) -> &'a mut W {
                self.variant(DIR_A::Memory)
            }
        }
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<CIRC_A>;
        ///Circular mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CIRC_A {
            ///0: Only execute once
            Once = 0,
            ///1: Circulation enabled
            Circulate = 1,
        }
        impl From<CIRC_A> for bool {
            #[inline(always)]
            fn from(variant: CIRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CIRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CIRC_A {
                match self.bits {
                    false => CIRC_A::Once,
                    true => CIRC_A::Circulate,
                }
            }
            ///Checks if the value of the field is `Once`
            #[inline(always)]
            pub fn is_once(&self) -> bool {
                *self == CIRC_A::Once
            }
            ///Checks if the value of the field is `Circulate`
            #[inline(always)]
            pub fn is_circulate(&self) -> bool {
                *self == CIRC_A::Circulate
            }
        }
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, CIRC_A, O>;
        impl<'a, const O: u8> CIRC_W<'a, O> {
            ///Only execute once
            #[inline(always)]
            pub fn once(self) -> &'a mut W {
                self.variant(CIRC_A::Once)
            }
            ///Circulation enabled
            #[inline(always)]
            pub fn circulate(self) -> &'a mut W {
                self.variant(CIRC_A::Circulate)
            }
        }
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<PINC_A>;
        ///Peripheral increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINC_A {
            ///0: Peripheral address increment disabled
            Disabled = 0,
            ///1: Peripheral address increment enabled
            Enabled = 1,
        }
        impl From<PINC_A> for bool {
            #[inline(always)]
            fn from(variant: PINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINC_A {
                match self.bits {
                    false => PINC_A::Disabled,
                    true => PINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINC_A::Enabled
            }
        }
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, PINC_A, O>;
        impl<'a, const O: u8> PINC_W<'a, O> {
            ///Peripheral address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINC_A::Disabled)
            }
            ///Peripheral address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINC_A::Enabled)
            }
        }
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<MINC_A>;
        ///Memory increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MINC_A {
            ///0: Memory address increment disabled
            Disabled = 0,
            ///1: Memory address increment enabled
            Enabled = 1,
        }
        impl From<MINC_A> for bool {
            #[inline(always)]
            fn from(variant: MINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MINC_A {
                match self.bits {
                    false => MINC_A::Disabled,
                    true => MINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MINC_A::Enabled
            }
        }
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, MINC_A, O>;
        impl<'a, const O: u8> MINC_W<'a, O> {
            ///Memory address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MINC_A::Disabled)
            }
            ///Memory address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MINC_A::Enabled)
            }
        }
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, PSIZE_A>;
        ///Peripheral size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSIZE_A {
            ///0: Peripheral address width is 8-bit
            B8 = 0,
            ///1: Peripheral address width is 16-bit
            B16 = 1,
            ///2: Peripheral address width is 32-bit
            B32 = 2,
        }
        impl From<PSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: PSIZE_A) -> Self {
                variant as _
            }
        }
        impl PSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSIZE_A> {
                match self.bits {
                    0 => Some(PSIZE_A::B8),
                    1 => Some(PSIZE_A::B16),
                    2 => Some(PSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == PSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == PSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == PSIZE_A::B32
            }
        }
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR1_SPEC, u8, PSIZE_A, 2, O>;
        impl<'a, const O: u8> PSIZE_W<'a, O> {
            ///Peripheral address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(PSIZE_A::B8)
            }
            ///Peripheral address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(PSIZE_A::B16)
            }
            ///Peripheral address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(PSIZE_A::B32)
            }
        }
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, MSIZE_A>;
        ///Memory size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MSIZE_A {
            ///0: Memory address width is 8-bit
            B8 = 0,
            ///1: Memory address width is 16-bit
            B16 = 1,
            ///2: Memory address width is 32-bit
            B32 = 2,
        }
        impl From<MSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIZE_A) -> Self {
                variant as _
            }
        }
        impl MSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MSIZE_A> {
                match self.bits {
                    0 => Some(MSIZE_A::B8),
                    1 => Some(MSIZE_A::B16),
                    2 => Some(MSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == MSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == MSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == MSIZE_A::B32
            }
        }
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR1_SPEC, u8, MSIZE_A, 2, O>;
        impl<'a, const O: u8> MSIZE_W<'a, O> {
            ///Memory address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(MSIZE_A::B8)
            }
            ///Memory address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(MSIZE_A::B16)
            }
            ///Memory address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(MSIZE_A::B32)
            }
        }
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, PL_A>;
        ///Channel Priority level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PL_A {
            ///0: Channel priority low
            Low = 0,
            ///1: Channel priority mid
            Mid = 1,
            ///2: Channel priority high
            High = 2,
            ///3: Channel priority highest
            Highest = 3,
        }
        impl From<PL_A> for u8 {
            #[inline(always)]
            fn from(variant: PL_A) -> Self {
                variant as _
            }
        }
        impl PL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PL_A {
                match self.bits {
                    0 => PL_A::Low,
                    1 => PL_A::Mid,
                    2 => PL_A::High,
                    3 => PL_A::Highest,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == PL_A::Low
            }
            ///Checks if the value of the field is `Mid`
            #[inline(always)]
            pub fn is_mid(&self) -> bool {
                *self == PL_A::Mid
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == PL_A::High
            }
            ///Checks if the value of the field is `Highest`
            #[inline(always)]
            pub fn is_highest(&self) -> bool {
                *self == PL_A::Highest
            }
        }
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR1_SPEC, u8, PL_A, 2, O>;
        impl<'a, const O: u8> PL_W<'a, O> {
            ///Channel priority low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(PL_A::Low)
            }
            ///Channel priority mid
            #[inline(always)]
            pub fn mid(self) -> &'a mut W {
                self.variant(PL_A::Mid)
            }
            ///Channel priority high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(PL_A::High)
            }
            ///Channel priority highest
            #[inline(always)]
            pub fn highest(self) -> &'a mut W {
                self.variant(PL_A::Highest)
            }
        }
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<MEM2MEM_A>;
        ///Memory to memory mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MEM2MEM_A {
            ///0: Memory to memory transfer disabled
            Disabled = 0,
            ///1: Memory to memory transfer enabled
            Enabled = 1,
        }
        impl From<MEM2MEM_A> for bool {
            #[inline(always)]
            fn from(variant: MEM2MEM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MEM2MEM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MEM2MEM_A {
                match self.bits {
                    false => MEM2MEM_A::Disabled,
                    true => MEM2MEM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MEM2MEM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MEM2MEM_A::Enabled
            }
        }
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, MEM2MEM_A, O>;
        impl<'a, const O: u8> MEM2MEM_W<'a, O> {
            ///Memory to memory transfer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Disabled)
            }
            ///Memory to memory transfer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr1](index.html) module
        pub struct CFGR1_SPEC;
        impl crate::RegisterSpec for CFGR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr1::R](R) reader structure
        impl crate::Readable for CFGR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr1::W](W) writer structure
        impl crate::Writable for CFGR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR1 to value 0
        impl crate::Resettable for CFGR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR1 (rw) register accessor: an alias for `Reg<CNTR1_SPEC>`
    pub type CNTR1 = crate::Reg<cntr1::CNTR1_SPEC>;
    ///DMA channel 1 number of data register
    pub mod cntr1 {
        ///Register `CNTR1` reader
        pub struct R(crate::R<CNTR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR1` writer
        pub struct W(crate::W<CNTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR1_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 1 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr1](index.html) module
        pub struct CNTR1_SPEC;
        impl crate::RegisterSpec for CNTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr1::R](R) reader structure
        impl crate::Readable for CNTR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr1::W](W) writer structure
        impl crate::Writable for CNTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR1 to value 0
        impl crate::Resettable for CNTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR1 (rw) register accessor: an alias for `Reg<PADDR1_SPEC>`
    pub type PADDR1 = crate::Reg<paddr1::PADDR1_SPEC>;
    ///DMA channel 1 peripheral address register
    pub mod paddr1 {
        ///Register `PADDR1` reader
        pub struct R(crate::R<PADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR1` writer
        pub struct W(crate::W<PADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR1_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 1 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr1](index.html) module
        pub struct PADDR1_SPEC;
        impl crate::RegisterSpec for PADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr1::R](R) reader structure
        impl crate::Readable for PADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr1::W](W) writer structure
        impl crate::Writable for PADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR1 to value 0
        impl crate::Resettable for PADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR1 (rw) register accessor: an alias for `Reg<MADDR1_SPEC>`
    pub type MADDR1 = crate::Reg<maddr1::MADDR1_SPEC>;
    ///DMA channel 1 memory address register
    pub mod maddr1 {
        ///Register `MADDR1` reader
        pub struct R(crate::R<MADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR1` writer
        pub struct W(crate::W<MADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR1_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 1 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr1](index.html) module
        pub struct MADDR1_SPEC;
        impl crate::RegisterSpec for MADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr1::R](R) reader structure
        impl crate::Readable for MADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr1::W](W) writer structure
        impl crate::Writable for MADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR1 to value 0
        impl crate::Resettable for MADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR2 (rw) register accessor: an alias for `Reg<CFGR2_SPEC>`
    pub type CFGR2 = crate::Reg<cfgr2::CFGR2_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr2 {
        ///Register `CFGR2` reader
        pub struct R(crate::R<CFGR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR2` writer
        pub struct W(crate::W<CFGR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<EN_A>;
        ///Channel enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN_A {
            ///0: DMA channel disabled
            Disabled = 0,
            ///1: DMA channel enabled
            Enabled = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::Disabled,
                    true => EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::Enabled
            }
        }
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, EN_A, O>;
        impl<'a, const O: u8> EN_W<'a, O> {
            ///DMA channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::Disabled)
            }
            ///DMA channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::Enabled)
            }
        }
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<TCIE_A>;
        ///Transfer complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::Disabled,
                    true => TCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::Enabled
            }
        }
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, TCIE_A, O>;
        impl<'a, const O: u8> TCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::Enabled)
            }
        }
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub use TCIE_R as HTIE_R;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub use TCIE_R as TEIE_R;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub use TCIE_W as HTIE_W;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub use TCIE_W as TEIE_W;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Data transfer direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Read from peripheral
            Peripheral = 0,
            ///1: Read from memory
            Memory = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Peripheral,
                    true => DIR_A::Memory,
                }
            }
            ///Checks if the value of the field is `Peripheral`
            #[inline(always)]
            pub fn is_peripheral(&self) -> bool {
                *self == DIR_A::Peripheral
            }
            ///Checks if the value of the field is `Memory`
            #[inline(always)]
            pub fn is_memory(&self) -> bool {
                *self == DIR_A::Memory
            }
        }
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Read from peripheral
            #[inline(always)]
            pub fn peripheral(self) -> &'a mut W {
                self.variant(DIR_A::Peripheral)
            }
            ///Read from memory
            #[inline(always)]
            pub fn memory(self) -> &'a mut W {
                self.variant(DIR_A::Memory)
            }
        }
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<CIRC_A>;
        ///Circular mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CIRC_A {
            ///0: Only execute once
            Once = 0,
            ///1: Circulation enabled
            Circulate = 1,
        }
        impl From<CIRC_A> for bool {
            #[inline(always)]
            fn from(variant: CIRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CIRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CIRC_A {
                match self.bits {
                    false => CIRC_A::Once,
                    true => CIRC_A::Circulate,
                }
            }
            ///Checks if the value of the field is `Once`
            #[inline(always)]
            pub fn is_once(&self) -> bool {
                *self == CIRC_A::Once
            }
            ///Checks if the value of the field is `Circulate`
            #[inline(always)]
            pub fn is_circulate(&self) -> bool {
                *self == CIRC_A::Circulate
            }
        }
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, CIRC_A, O>;
        impl<'a, const O: u8> CIRC_W<'a, O> {
            ///Only execute once
            #[inline(always)]
            pub fn once(self) -> &'a mut W {
                self.variant(CIRC_A::Once)
            }
            ///Circulation enabled
            #[inline(always)]
            pub fn circulate(self) -> &'a mut W {
                self.variant(CIRC_A::Circulate)
            }
        }
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<PINC_A>;
        ///Peripheral increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINC_A {
            ///0: Peripheral address increment disabled
            Disabled = 0,
            ///1: Peripheral address increment enabled
            Enabled = 1,
        }
        impl From<PINC_A> for bool {
            #[inline(always)]
            fn from(variant: PINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINC_A {
                match self.bits {
                    false => PINC_A::Disabled,
                    true => PINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINC_A::Enabled
            }
        }
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, PINC_A, O>;
        impl<'a, const O: u8> PINC_W<'a, O> {
            ///Peripheral address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINC_A::Disabled)
            }
            ///Peripheral address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINC_A::Enabled)
            }
        }
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<MINC_A>;
        ///Memory increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MINC_A {
            ///0: Memory address increment disabled
            Disabled = 0,
            ///1: Memory address increment enabled
            Enabled = 1,
        }
        impl From<MINC_A> for bool {
            #[inline(always)]
            fn from(variant: MINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MINC_A {
                match self.bits {
                    false => MINC_A::Disabled,
                    true => MINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MINC_A::Enabled
            }
        }
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, MINC_A, O>;
        impl<'a, const O: u8> MINC_W<'a, O> {
            ///Memory address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MINC_A::Disabled)
            }
            ///Memory address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MINC_A::Enabled)
            }
        }
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, PSIZE_A>;
        ///Peripheral size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSIZE_A {
            ///0: Peripheral address width is 8-bit
            B8 = 0,
            ///1: Peripheral address width is 16-bit
            B16 = 1,
            ///2: Peripheral address width is 32-bit
            B32 = 2,
        }
        impl From<PSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: PSIZE_A) -> Self {
                variant as _
            }
        }
        impl PSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSIZE_A> {
                match self.bits {
                    0 => Some(PSIZE_A::B8),
                    1 => Some(PSIZE_A::B16),
                    2 => Some(PSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == PSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == PSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == PSIZE_A::B32
            }
        }
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR2_SPEC, u8, PSIZE_A, 2, O>;
        impl<'a, const O: u8> PSIZE_W<'a, O> {
            ///Peripheral address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(PSIZE_A::B8)
            }
            ///Peripheral address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(PSIZE_A::B16)
            }
            ///Peripheral address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(PSIZE_A::B32)
            }
        }
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, MSIZE_A>;
        ///Memory size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MSIZE_A {
            ///0: Memory address width is 8-bit
            B8 = 0,
            ///1: Memory address width is 16-bit
            B16 = 1,
            ///2: Memory address width is 32-bit
            B32 = 2,
        }
        impl From<MSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIZE_A) -> Self {
                variant as _
            }
        }
        impl MSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MSIZE_A> {
                match self.bits {
                    0 => Some(MSIZE_A::B8),
                    1 => Some(MSIZE_A::B16),
                    2 => Some(MSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == MSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == MSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == MSIZE_A::B32
            }
        }
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR2_SPEC, u8, MSIZE_A, 2, O>;
        impl<'a, const O: u8> MSIZE_W<'a, O> {
            ///Memory address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(MSIZE_A::B8)
            }
            ///Memory address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(MSIZE_A::B16)
            }
            ///Memory address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(MSIZE_A::B32)
            }
        }
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, PL_A>;
        ///Channel Priority level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PL_A {
            ///0: Channel priority low
            Low = 0,
            ///1: Channel priority mid
            Mid = 1,
            ///2: Channel priority high
            High = 2,
            ///3: Channel priority highest
            Highest = 3,
        }
        impl From<PL_A> for u8 {
            #[inline(always)]
            fn from(variant: PL_A) -> Self {
                variant as _
            }
        }
        impl PL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PL_A {
                match self.bits {
                    0 => PL_A::Low,
                    1 => PL_A::Mid,
                    2 => PL_A::High,
                    3 => PL_A::Highest,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == PL_A::Low
            }
            ///Checks if the value of the field is `Mid`
            #[inline(always)]
            pub fn is_mid(&self) -> bool {
                *self == PL_A::Mid
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == PL_A::High
            }
            ///Checks if the value of the field is `Highest`
            #[inline(always)]
            pub fn is_highest(&self) -> bool {
                *self == PL_A::Highest
            }
        }
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR2_SPEC, u8, PL_A, 2, O>;
        impl<'a, const O: u8> PL_W<'a, O> {
            ///Channel priority low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(PL_A::Low)
            }
            ///Channel priority mid
            #[inline(always)]
            pub fn mid(self) -> &'a mut W {
                self.variant(PL_A::Mid)
            }
            ///Channel priority high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(PL_A::High)
            }
            ///Channel priority highest
            #[inline(always)]
            pub fn highest(self) -> &'a mut W {
                self.variant(PL_A::Highest)
            }
        }
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<MEM2MEM_A>;
        ///Memory to memory mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MEM2MEM_A {
            ///0: Memory to memory transfer disabled
            Disabled = 0,
            ///1: Memory to memory transfer enabled
            Enabled = 1,
        }
        impl From<MEM2MEM_A> for bool {
            #[inline(always)]
            fn from(variant: MEM2MEM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MEM2MEM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MEM2MEM_A {
                match self.bits {
                    false => MEM2MEM_A::Disabled,
                    true => MEM2MEM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MEM2MEM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MEM2MEM_A::Enabled
            }
        }
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, MEM2MEM_A, O>;
        impl<'a, const O: u8> MEM2MEM_W<'a, O> {
            ///Memory to memory transfer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Disabled)
            }
            ///Memory to memory transfer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr2](index.html) module
        pub struct CFGR2_SPEC;
        impl crate::RegisterSpec for CFGR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr2::R](R) reader structure
        impl crate::Readable for CFGR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr2::W](W) writer structure
        impl crate::Writable for CFGR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR2 to value 0
        impl crate::Resettable for CFGR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR2 (rw) register accessor: an alias for `Reg<CNTR2_SPEC>`
    pub type CNTR2 = crate::Reg<cntr2::CNTR2_SPEC>;
    ///DMA channel 2 number of data register
    pub mod cntr2 {
        ///Register `CNTR2` reader
        pub struct R(crate::R<CNTR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR2` writer
        pub struct W(crate::W<CNTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR2_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 2 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr2](index.html) module
        pub struct CNTR2_SPEC;
        impl crate::RegisterSpec for CNTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr2::R](R) reader structure
        impl crate::Readable for CNTR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr2::W](W) writer structure
        impl crate::Writable for CNTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR2 to value 0
        impl crate::Resettable for CNTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR2 (rw) register accessor: an alias for `Reg<PADDR2_SPEC>`
    pub type PADDR2 = crate::Reg<paddr2::PADDR2_SPEC>;
    ///DMA channel 2 peripheral address register
    pub mod paddr2 {
        ///Register `PADDR2` reader
        pub struct R(crate::R<PADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR2` writer
        pub struct W(crate::W<PADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR2_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 2 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr2](index.html) module
        pub struct PADDR2_SPEC;
        impl crate::RegisterSpec for PADDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr2::R](R) reader structure
        impl crate::Readable for PADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr2::W](W) writer structure
        impl crate::Writable for PADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR2 to value 0
        impl crate::Resettable for PADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR2 (rw) register accessor: an alias for `Reg<MADDR2_SPEC>`
    pub type MADDR2 = crate::Reg<maddr2::MADDR2_SPEC>;
    ///DMA channel 2 memory address register
    pub mod maddr2 {
        ///Register `MADDR2` reader
        pub struct R(crate::R<MADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR2` writer
        pub struct W(crate::W<MADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR2_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 2 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr2](index.html) module
        pub struct MADDR2_SPEC;
        impl crate::RegisterSpec for MADDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr2::R](R) reader structure
        impl crate::Readable for MADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr2::W](W) writer structure
        impl crate::Writable for MADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR2 to value 0
        impl crate::Resettable for MADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR3 (rw) register accessor: an alias for `Reg<CFGR3_SPEC>`
    pub type CFGR3 = crate::Reg<cfgr3::CFGR3_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr3 {
        ///Register `CFGR3` reader
        pub struct R(crate::R<CFGR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR3` writer
        pub struct W(crate::W<CFGR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<EN_A>;
        ///Channel enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN_A {
            ///0: DMA channel disabled
            Disabled = 0,
            ///1: DMA channel enabled
            Enabled = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::Disabled,
                    true => EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::Enabled
            }
        }
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, EN_A, O>;
        impl<'a, const O: u8> EN_W<'a, O> {
            ///DMA channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::Disabled)
            }
            ///DMA channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::Enabled)
            }
        }
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<TCIE_A>;
        ///Transfer complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::Disabled,
                    true => TCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::Enabled
            }
        }
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, TCIE_A, O>;
        impl<'a, const O: u8> TCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::Enabled)
            }
        }
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub use TCIE_R as HTIE_R;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub use TCIE_R as TEIE_R;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub use TCIE_W as HTIE_W;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub use TCIE_W as TEIE_W;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Data transfer direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Read from peripheral
            Peripheral = 0,
            ///1: Read from memory
            Memory = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Peripheral,
                    true => DIR_A::Memory,
                }
            }
            ///Checks if the value of the field is `Peripheral`
            #[inline(always)]
            pub fn is_peripheral(&self) -> bool {
                *self == DIR_A::Peripheral
            }
            ///Checks if the value of the field is `Memory`
            #[inline(always)]
            pub fn is_memory(&self) -> bool {
                *self == DIR_A::Memory
            }
        }
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Read from peripheral
            #[inline(always)]
            pub fn peripheral(self) -> &'a mut W {
                self.variant(DIR_A::Peripheral)
            }
            ///Read from memory
            #[inline(always)]
            pub fn memory(self) -> &'a mut W {
                self.variant(DIR_A::Memory)
            }
        }
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<CIRC_A>;
        ///Circular mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CIRC_A {
            ///0: Only execute once
            Once = 0,
            ///1: Circulation enabled
            Circulate = 1,
        }
        impl From<CIRC_A> for bool {
            #[inline(always)]
            fn from(variant: CIRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CIRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CIRC_A {
                match self.bits {
                    false => CIRC_A::Once,
                    true => CIRC_A::Circulate,
                }
            }
            ///Checks if the value of the field is `Once`
            #[inline(always)]
            pub fn is_once(&self) -> bool {
                *self == CIRC_A::Once
            }
            ///Checks if the value of the field is `Circulate`
            #[inline(always)]
            pub fn is_circulate(&self) -> bool {
                *self == CIRC_A::Circulate
            }
        }
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, CIRC_A, O>;
        impl<'a, const O: u8> CIRC_W<'a, O> {
            ///Only execute once
            #[inline(always)]
            pub fn once(self) -> &'a mut W {
                self.variant(CIRC_A::Once)
            }
            ///Circulation enabled
            #[inline(always)]
            pub fn circulate(self) -> &'a mut W {
                self.variant(CIRC_A::Circulate)
            }
        }
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<PINC_A>;
        ///Peripheral increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINC_A {
            ///0: Peripheral address increment disabled
            Disabled = 0,
            ///1: Peripheral address increment enabled
            Enabled = 1,
        }
        impl From<PINC_A> for bool {
            #[inline(always)]
            fn from(variant: PINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINC_A {
                match self.bits {
                    false => PINC_A::Disabled,
                    true => PINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINC_A::Enabled
            }
        }
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, PINC_A, O>;
        impl<'a, const O: u8> PINC_W<'a, O> {
            ///Peripheral address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINC_A::Disabled)
            }
            ///Peripheral address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINC_A::Enabled)
            }
        }
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<MINC_A>;
        ///Memory increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MINC_A {
            ///0: Memory address increment disabled
            Disabled = 0,
            ///1: Memory address increment enabled
            Enabled = 1,
        }
        impl From<MINC_A> for bool {
            #[inline(always)]
            fn from(variant: MINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MINC_A {
                match self.bits {
                    false => MINC_A::Disabled,
                    true => MINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MINC_A::Enabled
            }
        }
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, MINC_A, O>;
        impl<'a, const O: u8> MINC_W<'a, O> {
            ///Memory address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MINC_A::Disabled)
            }
            ///Memory address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MINC_A::Enabled)
            }
        }
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, PSIZE_A>;
        ///Peripheral size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSIZE_A {
            ///0: Peripheral address width is 8-bit
            B8 = 0,
            ///1: Peripheral address width is 16-bit
            B16 = 1,
            ///2: Peripheral address width is 32-bit
            B32 = 2,
        }
        impl From<PSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: PSIZE_A) -> Self {
                variant as _
            }
        }
        impl PSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSIZE_A> {
                match self.bits {
                    0 => Some(PSIZE_A::B8),
                    1 => Some(PSIZE_A::B16),
                    2 => Some(PSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == PSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == PSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == PSIZE_A::B32
            }
        }
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR3_SPEC, u8, PSIZE_A, 2, O>;
        impl<'a, const O: u8> PSIZE_W<'a, O> {
            ///Peripheral address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(PSIZE_A::B8)
            }
            ///Peripheral address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(PSIZE_A::B16)
            }
            ///Peripheral address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(PSIZE_A::B32)
            }
        }
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, MSIZE_A>;
        ///Memory size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MSIZE_A {
            ///0: Memory address width is 8-bit
            B8 = 0,
            ///1: Memory address width is 16-bit
            B16 = 1,
            ///2: Memory address width is 32-bit
            B32 = 2,
        }
        impl From<MSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIZE_A) -> Self {
                variant as _
            }
        }
        impl MSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MSIZE_A> {
                match self.bits {
                    0 => Some(MSIZE_A::B8),
                    1 => Some(MSIZE_A::B16),
                    2 => Some(MSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == MSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == MSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == MSIZE_A::B32
            }
        }
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR3_SPEC, u8, MSIZE_A, 2, O>;
        impl<'a, const O: u8> MSIZE_W<'a, O> {
            ///Memory address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(MSIZE_A::B8)
            }
            ///Memory address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(MSIZE_A::B16)
            }
            ///Memory address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(MSIZE_A::B32)
            }
        }
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, PL_A>;
        ///Channel Priority level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PL_A {
            ///0: Channel priority low
            Low = 0,
            ///1: Channel priority mid
            Mid = 1,
            ///2: Channel priority high
            High = 2,
            ///3: Channel priority highest
            Highest = 3,
        }
        impl From<PL_A> for u8 {
            #[inline(always)]
            fn from(variant: PL_A) -> Self {
                variant as _
            }
        }
        impl PL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PL_A {
                match self.bits {
                    0 => PL_A::Low,
                    1 => PL_A::Mid,
                    2 => PL_A::High,
                    3 => PL_A::Highest,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == PL_A::Low
            }
            ///Checks if the value of the field is `Mid`
            #[inline(always)]
            pub fn is_mid(&self) -> bool {
                *self == PL_A::Mid
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == PL_A::High
            }
            ///Checks if the value of the field is `Highest`
            #[inline(always)]
            pub fn is_highest(&self) -> bool {
                *self == PL_A::Highest
            }
        }
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR3_SPEC, u8, PL_A, 2, O>;
        impl<'a, const O: u8> PL_W<'a, O> {
            ///Channel priority low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(PL_A::Low)
            }
            ///Channel priority mid
            #[inline(always)]
            pub fn mid(self) -> &'a mut W {
                self.variant(PL_A::Mid)
            }
            ///Channel priority high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(PL_A::High)
            }
            ///Channel priority highest
            #[inline(always)]
            pub fn highest(self) -> &'a mut W {
                self.variant(PL_A::Highest)
            }
        }
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<MEM2MEM_A>;
        ///Memory to memory mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MEM2MEM_A {
            ///0: Memory to memory transfer disabled
            Disabled = 0,
            ///1: Memory to memory transfer enabled
            Enabled = 1,
        }
        impl From<MEM2MEM_A> for bool {
            #[inline(always)]
            fn from(variant: MEM2MEM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MEM2MEM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MEM2MEM_A {
                match self.bits {
                    false => MEM2MEM_A::Disabled,
                    true => MEM2MEM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MEM2MEM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MEM2MEM_A::Enabled
            }
        }
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, MEM2MEM_A, O>;
        impl<'a, const O: u8> MEM2MEM_W<'a, O> {
            ///Memory to memory transfer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Disabled)
            }
            ///Memory to memory transfer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr3](index.html) module
        pub struct CFGR3_SPEC;
        impl crate::RegisterSpec for CFGR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr3::R](R) reader structure
        impl crate::Readable for CFGR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr3::W](W) writer structure
        impl crate::Writable for CFGR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR3 to value 0
        impl crate::Resettable for CFGR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR3 (rw) register accessor: an alias for `Reg<CNTR3_SPEC>`
    pub type CNTR3 = crate::Reg<cntr3::CNTR3_SPEC>;
    ///DMA channel 3 number of data register
    pub mod cntr3 {
        ///Register `CNTR3` reader
        pub struct R(crate::R<CNTR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR3` writer
        pub struct W(crate::W<CNTR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR3_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 3 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr3](index.html) module
        pub struct CNTR3_SPEC;
        impl crate::RegisterSpec for CNTR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr3::R](R) reader structure
        impl crate::Readable for CNTR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr3::W](W) writer structure
        impl crate::Writable for CNTR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR3 to value 0
        impl crate::Resettable for CNTR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR3 (rw) register accessor: an alias for `Reg<PADDR3_SPEC>`
    pub type PADDR3 = crate::Reg<paddr3::PADDR3_SPEC>;
    ///DMA channel 3 peripheral address register
    pub mod paddr3 {
        ///Register `PADDR3` reader
        pub struct R(crate::R<PADDR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR3` writer
        pub struct W(crate::W<PADDR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR3_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 3 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr3](index.html) module
        pub struct PADDR3_SPEC;
        impl crate::RegisterSpec for PADDR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr3::R](R) reader structure
        impl crate::Readable for PADDR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr3::W](W) writer structure
        impl crate::Writable for PADDR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR3 to value 0
        impl crate::Resettable for PADDR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR3 (rw) register accessor: an alias for `Reg<MADDR3_SPEC>`
    pub type MADDR3 = crate::Reg<maddr3::MADDR3_SPEC>;
    ///DMA channel 3 memory address register
    pub mod maddr3 {
        ///Register `MADDR3` reader
        pub struct R(crate::R<MADDR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR3` writer
        pub struct W(crate::W<MADDR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR3_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 3 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr3](index.html) module
        pub struct MADDR3_SPEC;
        impl crate::RegisterSpec for MADDR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr3::R](R) reader structure
        impl crate::Readable for MADDR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr3::W](W) writer structure
        impl crate::Writable for MADDR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR3 to value 0
        impl crate::Resettable for MADDR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR4 (rw) register accessor: an alias for `Reg<CFGR4_SPEC>`
    pub type CFGR4 = crate::Reg<cfgr4::CFGR4_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr4 {
        ///Register `CFGR4` reader
        pub struct R(crate::R<CFGR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR4` writer
        pub struct W(crate::W<CFGR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<EN_A>;
        ///Channel enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN_A {
            ///0: DMA channel disabled
            Disabled = 0,
            ///1: DMA channel enabled
            Enabled = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::Disabled,
                    true => EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::Enabled
            }
        }
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, EN_A, O>;
        impl<'a, const O: u8> EN_W<'a, O> {
            ///DMA channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::Disabled)
            }
            ///DMA channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::Enabled)
            }
        }
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<TCIE_A>;
        ///Transfer complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::Disabled,
                    true => TCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::Enabled
            }
        }
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, TCIE_A, O>;
        impl<'a, const O: u8> TCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::Enabled)
            }
        }
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub use TCIE_R as HTIE_R;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub use TCIE_R as TEIE_R;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub use TCIE_W as HTIE_W;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub use TCIE_W as TEIE_W;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Data transfer direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Read from peripheral
            Peripheral = 0,
            ///1: Read from memory
            Memory = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Peripheral,
                    true => DIR_A::Memory,
                }
            }
            ///Checks if the value of the field is `Peripheral`
            #[inline(always)]
            pub fn is_peripheral(&self) -> bool {
                *self == DIR_A::Peripheral
            }
            ///Checks if the value of the field is `Memory`
            #[inline(always)]
            pub fn is_memory(&self) -> bool {
                *self == DIR_A::Memory
            }
        }
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Read from peripheral
            #[inline(always)]
            pub fn peripheral(self) -> &'a mut W {
                self.variant(DIR_A::Peripheral)
            }
            ///Read from memory
            #[inline(always)]
            pub fn memory(self) -> &'a mut W {
                self.variant(DIR_A::Memory)
            }
        }
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<CIRC_A>;
        ///Circular mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CIRC_A {
            ///0: Only execute once
            Once = 0,
            ///1: Circulation enabled
            Circulate = 1,
        }
        impl From<CIRC_A> for bool {
            #[inline(always)]
            fn from(variant: CIRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CIRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CIRC_A {
                match self.bits {
                    false => CIRC_A::Once,
                    true => CIRC_A::Circulate,
                }
            }
            ///Checks if the value of the field is `Once`
            #[inline(always)]
            pub fn is_once(&self) -> bool {
                *self == CIRC_A::Once
            }
            ///Checks if the value of the field is `Circulate`
            #[inline(always)]
            pub fn is_circulate(&self) -> bool {
                *self == CIRC_A::Circulate
            }
        }
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, CIRC_A, O>;
        impl<'a, const O: u8> CIRC_W<'a, O> {
            ///Only execute once
            #[inline(always)]
            pub fn once(self) -> &'a mut W {
                self.variant(CIRC_A::Once)
            }
            ///Circulation enabled
            #[inline(always)]
            pub fn circulate(self) -> &'a mut W {
                self.variant(CIRC_A::Circulate)
            }
        }
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<PINC_A>;
        ///Peripheral increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINC_A {
            ///0: Peripheral address increment disabled
            Disabled = 0,
            ///1: Peripheral address increment enabled
            Enabled = 1,
        }
        impl From<PINC_A> for bool {
            #[inline(always)]
            fn from(variant: PINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINC_A {
                match self.bits {
                    false => PINC_A::Disabled,
                    true => PINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINC_A::Enabled
            }
        }
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, PINC_A, O>;
        impl<'a, const O: u8> PINC_W<'a, O> {
            ///Peripheral address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINC_A::Disabled)
            }
            ///Peripheral address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINC_A::Enabled)
            }
        }
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<MINC_A>;
        ///Memory increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MINC_A {
            ///0: Memory address increment disabled
            Disabled = 0,
            ///1: Memory address increment enabled
            Enabled = 1,
        }
        impl From<MINC_A> for bool {
            #[inline(always)]
            fn from(variant: MINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MINC_A {
                match self.bits {
                    false => MINC_A::Disabled,
                    true => MINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MINC_A::Enabled
            }
        }
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, MINC_A, O>;
        impl<'a, const O: u8> MINC_W<'a, O> {
            ///Memory address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MINC_A::Disabled)
            }
            ///Memory address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MINC_A::Enabled)
            }
        }
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, PSIZE_A>;
        ///Peripheral size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSIZE_A {
            ///0: Peripheral address width is 8-bit
            B8 = 0,
            ///1: Peripheral address width is 16-bit
            B16 = 1,
            ///2: Peripheral address width is 32-bit
            B32 = 2,
        }
        impl From<PSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: PSIZE_A) -> Self {
                variant as _
            }
        }
        impl PSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSIZE_A> {
                match self.bits {
                    0 => Some(PSIZE_A::B8),
                    1 => Some(PSIZE_A::B16),
                    2 => Some(PSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == PSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == PSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == PSIZE_A::B32
            }
        }
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR4_SPEC, u8, PSIZE_A, 2, O>;
        impl<'a, const O: u8> PSIZE_W<'a, O> {
            ///Peripheral address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(PSIZE_A::B8)
            }
            ///Peripheral address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(PSIZE_A::B16)
            }
            ///Peripheral address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(PSIZE_A::B32)
            }
        }
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, MSIZE_A>;
        ///Memory size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MSIZE_A {
            ///0: Memory address width is 8-bit
            B8 = 0,
            ///1: Memory address width is 16-bit
            B16 = 1,
            ///2: Memory address width is 32-bit
            B32 = 2,
        }
        impl From<MSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIZE_A) -> Self {
                variant as _
            }
        }
        impl MSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MSIZE_A> {
                match self.bits {
                    0 => Some(MSIZE_A::B8),
                    1 => Some(MSIZE_A::B16),
                    2 => Some(MSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == MSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == MSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == MSIZE_A::B32
            }
        }
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR4_SPEC, u8, MSIZE_A, 2, O>;
        impl<'a, const O: u8> MSIZE_W<'a, O> {
            ///Memory address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(MSIZE_A::B8)
            }
            ///Memory address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(MSIZE_A::B16)
            }
            ///Memory address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(MSIZE_A::B32)
            }
        }
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, PL_A>;
        ///Channel Priority level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PL_A {
            ///0: Channel priority low
            Low = 0,
            ///1: Channel priority mid
            Mid = 1,
            ///2: Channel priority high
            High = 2,
            ///3: Channel priority highest
            Highest = 3,
        }
        impl From<PL_A> for u8 {
            #[inline(always)]
            fn from(variant: PL_A) -> Self {
                variant as _
            }
        }
        impl PL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PL_A {
                match self.bits {
                    0 => PL_A::Low,
                    1 => PL_A::Mid,
                    2 => PL_A::High,
                    3 => PL_A::Highest,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == PL_A::Low
            }
            ///Checks if the value of the field is `Mid`
            #[inline(always)]
            pub fn is_mid(&self) -> bool {
                *self == PL_A::Mid
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == PL_A::High
            }
            ///Checks if the value of the field is `Highest`
            #[inline(always)]
            pub fn is_highest(&self) -> bool {
                *self == PL_A::Highest
            }
        }
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR4_SPEC, u8, PL_A, 2, O>;
        impl<'a, const O: u8> PL_W<'a, O> {
            ///Channel priority low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(PL_A::Low)
            }
            ///Channel priority mid
            #[inline(always)]
            pub fn mid(self) -> &'a mut W {
                self.variant(PL_A::Mid)
            }
            ///Channel priority high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(PL_A::High)
            }
            ///Channel priority highest
            #[inline(always)]
            pub fn highest(self) -> &'a mut W {
                self.variant(PL_A::Highest)
            }
        }
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<MEM2MEM_A>;
        ///Memory to memory mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MEM2MEM_A {
            ///0: Memory to memory transfer disabled
            Disabled = 0,
            ///1: Memory to memory transfer enabled
            Enabled = 1,
        }
        impl From<MEM2MEM_A> for bool {
            #[inline(always)]
            fn from(variant: MEM2MEM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MEM2MEM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MEM2MEM_A {
                match self.bits {
                    false => MEM2MEM_A::Disabled,
                    true => MEM2MEM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MEM2MEM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MEM2MEM_A::Enabled
            }
        }
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, MEM2MEM_A, O>;
        impl<'a, const O: u8> MEM2MEM_W<'a, O> {
            ///Memory to memory transfer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Disabled)
            }
            ///Memory to memory transfer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr4](index.html) module
        pub struct CFGR4_SPEC;
        impl crate::RegisterSpec for CFGR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr4::R](R) reader structure
        impl crate::Readable for CFGR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr4::W](W) writer structure
        impl crate::Writable for CFGR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR4 to value 0
        impl crate::Resettable for CFGR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR4 (rw) register accessor: an alias for `Reg<CNTR4_SPEC>`
    pub type CNTR4 = crate::Reg<cntr4::CNTR4_SPEC>;
    ///DMA channel 4 number of data register
    pub mod cntr4 {
        ///Register `CNTR4` reader
        pub struct R(crate::R<CNTR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR4` writer
        pub struct W(crate::W<CNTR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR4_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 4 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr4](index.html) module
        pub struct CNTR4_SPEC;
        impl crate::RegisterSpec for CNTR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr4::R](R) reader structure
        impl crate::Readable for CNTR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr4::W](W) writer structure
        impl crate::Writable for CNTR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR4 to value 0
        impl crate::Resettable for CNTR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR4 (rw) register accessor: an alias for `Reg<PADDR4_SPEC>`
    pub type PADDR4 = crate::Reg<paddr4::PADDR4_SPEC>;
    ///DMA channel 4 peripheral address register
    pub mod paddr4 {
        ///Register `PADDR4` reader
        pub struct R(crate::R<PADDR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR4` writer
        pub struct W(crate::W<PADDR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR4_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 4 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr4](index.html) module
        pub struct PADDR4_SPEC;
        impl crate::RegisterSpec for PADDR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr4::R](R) reader structure
        impl crate::Readable for PADDR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr4::W](W) writer structure
        impl crate::Writable for PADDR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR4 to value 0
        impl crate::Resettable for PADDR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR4 (rw) register accessor: an alias for `Reg<MADDR4_SPEC>`
    pub type MADDR4 = crate::Reg<maddr4::MADDR4_SPEC>;
    ///DMA channel 4 memory address register
    pub mod maddr4 {
        ///Register `MADDR4` reader
        pub struct R(crate::R<MADDR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR4` writer
        pub struct W(crate::W<MADDR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR4_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 4 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr4](index.html) module
        pub struct MADDR4_SPEC;
        impl crate::RegisterSpec for MADDR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr4::R](R) reader structure
        impl crate::Readable for MADDR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr4::W](W) writer structure
        impl crate::Writable for MADDR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR4 to value 0
        impl crate::Resettable for MADDR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR5 (rw) register accessor: an alias for `Reg<CFGR5_SPEC>`
    pub type CFGR5 = crate::Reg<cfgr5::CFGR5_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr5 {
        ///Register `CFGR5` reader
        pub struct R(crate::R<CFGR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR5` writer
        pub struct W(crate::W<CFGR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<EN_A>;
        ///Channel enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN_A {
            ///0: DMA channel disabled
            Disabled = 0,
            ///1: DMA channel enabled
            Enabled = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::Disabled,
                    true => EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::Enabled
            }
        }
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, EN_A, O>;
        impl<'a, const O: u8> EN_W<'a, O> {
            ///DMA channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::Disabled)
            }
            ///DMA channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::Enabled)
            }
        }
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<TCIE_A>;
        ///Transfer complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::Disabled,
                    true => TCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::Enabled
            }
        }
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, TCIE_A, O>;
        impl<'a, const O: u8> TCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::Enabled)
            }
        }
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub use TCIE_R as HTIE_R;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub use TCIE_R as TEIE_R;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub use TCIE_W as HTIE_W;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub use TCIE_W as TEIE_W;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Data transfer direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Read from peripheral
            Peripheral = 0,
            ///1: Read from memory
            Memory = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Peripheral,
                    true => DIR_A::Memory,
                }
            }
            ///Checks if the value of the field is `Peripheral`
            #[inline(always)]
            pub fn is_peripheral(&self) -> bool {
                *self == DIR_A::Peripheral
            }
            ///Checks if the value of the field is `Memory`
            #[inline(always)]
            pub fn is_memory(&self) -> bool {
                *self == DIR_A::Memory
            }
        }
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Read from peripheral
            #[inline(always)]
            pub fn peripheral(self) -> &'a mut W {
                self.variant(DIR_A::Peripheral)
            }
            ///Read from memory
            #[inline(always)]
            pub fn memory(self) -> &'a mut W {
                self.variant(DIR_A::Memory)
            }
        }
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<CIRC_A>;
        ///Circular mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CIRC_A {
            ///0: Only execute once
            Once = 0,
            ///1: Circulation enabled
            Circulate = 1,
        }
        impl From<CIRC_A> for bool {
            #[inline(always)]
            fn from(variant: CIRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CIRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CIRC_A {
                match self.bits {
                    false => CIRC_A::Once,
                    true => CIRC_A::Circulate,
                }
            }
            ///Checks if the value of the field is `Once`
            #[inline(always)]
            pub fn is_once(&self) -> bool {
                *self == CIRC_A::Once
            }
            ///Checks if the value of the field is `Circulate`
            #[inline(always)]
            pub fn is_circulate(&self) -> bool {
                *self == CIRC_A::Circulate
            }
        }
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, CIRC_A, O>;
        impl<'a, const O: u8> CIRC_W<'a, O> {
            ///Only execute once
            #[inline(always)]
            pub fn once(self) -> &'a mut W {
                self.variant(CIRC_A::Once)
            }
            ///Circulation enabled
            #[inline(always)]
            pub fn circulate(self) -> &'a mut W {
                self.variant(CIRC_A::Circulate)
            }
        }
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<PINC_A>;
        ///Peripheral increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINC_A {
            ///0: Peripheral address increment disabled
            Disabled = 0,
            ///1: Peripheral address increment enabled
            Enabled = 1,
        }
        impl From<PINC_A> for bool {
            #[inline(always)]
            fn from(variant: PINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINC_A {
                match self.bits {
                    false => PINC_A::Disabled,
                    true => PINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINC_A::Enabled
            }
        }
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, PINC_A, O>;
        impl<'a, const O: u8> PINC_W<'a, O> {
            ///Peripheral address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINC_A::Disabled)
            }
            ///Peripheral address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINC_A::Enabled)
            }
        }
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<MINC_A>;
        ///Memory increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MINC_A {
            ///0: Memory address increment disabled
            Disabled = 0,
            ///1: Memory address increment enabled
            Enabled = 1,
        }
        impl From<MINC_A> for bool {
            #[inline(always)]
            fn from(variant: MINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MINC_A {
                match self.bits {
                    false => MINC_A::Disabled,
                    true => MINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MINC_A::Enabled
            }
        }
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, MINC_A, O>;
        impl<'a, const O: u8> MINC_W<'a, O> {
            ///Memory address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MINC_A::Disabled)
            }
            ///Memory address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MINC_A::Enabled)
            }
        }
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, PSIZE_A>;
        ///Peripheral size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSIZE_A {
            ///0: Peripheral address width is 8-bit
            B8 = 0,
            ///1: Peripheral address width is 16-bit
            B16 = 1,
            ///2: Peripheral address width is 32-bit
            B32 = 2,
        }
        impl From<PSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: PSIZE_A) -> Self {
                variant as _
            }
        }
        impl PSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSIZE_A> {
                match self.bits {
                    0 => Some(PSIZE_A::B8),
                    1 => Some(PSIZE_A::B16),
                    2 => Some(PSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == PSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == PSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == PSIZE_A::B32
            }
        }
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR5_SPEC, u8, PSIZE_A, 2, O>;
        impl<'a, const O: u8> PSIZE_W<'a, O> {
            ///Peripheral address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(PSIZE_A::B8)
            }
            ///Peripheral address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(PSIZE_A::B16)
            }
            ///Peripheral address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(PSIZE_A::B32)
            }
        }
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, MSIZE_A>;
        ///Memory size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MSIZE_A {
            ///0: Memory address width is 8-bit
            B8 = 0,
            ///1: Memory address width is 16-bit
            B16 = 1,
            ///2: Memory address width is 32-bit
            B32 = 2,
        }
        impl From<MSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIZE_A) -> Self {
                variant as _
            }
        }
        impl MSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MSIZE_A> {
                match self.bits {
                    0 => Some(MSIZE_A::B8),
                    1 => Some(MSIZE_A::B16),
                    2 => Some(MSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == MSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == MSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == MSIZE_A::B32
            }
        }
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR5_SPEC, u8, MSIZE_A, 2, O>;
        impl<'a, const O: u8> MSIZE_W<'a, O> {
            ///Memory address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(MSIZE_A::B8)
            }
            ///Memory address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(MSIZE_A::B16)
            }
            ///Memory address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(MSIZE_A::B32)
            }
        }
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, PL_A>;
        ///Channel Priority level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PL_A {
            ///0: Channel priority low
            Low = 0,
            ///1: Channel priority mid
            Mid = 1,
            ///2: Channel priority high
            High = 2,
            ///3: Channel priority highest
            Highest = 3,
        }
        impl From<PL_A> for u8 {
            #[inline(always)]
            fn from(variant: PL_A) -> Self {
                variant as _
            }
        }
        impl PL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PL_A {
                match self.bits {
                    0 => PL_A::Low,
                    1 => PL_A::Mid,
                    2 => PL_A::High,
                    3 => PL_A::Highest,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == PL_A::Low
            }
            ///Checks if the value of the field is `Mid`
            #[inline(always)]
            pub fn is_mid(&self) -> bool {
                *self == PL_A::Mid
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == PL_A::High
            }
            ///Checks if the value of the field is `Highest`
            #[inline(always)]
            pub fn is_highest(&self) -> bool {
                *self == PL_A::Highest
            }
        }
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR5_SPEC, u8, PL_A, 2, O>;
        impl<'a, const O: u8> PL_W<'a, O> {
            ///Channel priority low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(PL_A::Low)
            }
            ///Channel priority mid
            #[inline(always)]
            pub fn mid(self) -> &'a mut W {
                self.variant(PL_A::Mid)
            }
            ///Channel priority high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(PL_A::High)
            }
            ///Channel priority highest
            #[inline(always)]
            pub fn highest(self) -> &'a mut W {
                self.variant(PL_A::Highest)
            }
        }
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<MEM2MEM_A>;
        ///Memory to memory mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MEM2MEM_A {
            ///0: Memory to memory transfer disabled
            Disabled = 0,
            ///1: Memory to memory transfer enabled
            Enabled = 1,
        }
        impl From<MEM2MEM_A> for bool {
            #[inline(always)]
            fn from(variant: MEM2MEM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MEM2MEM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MEM2MEM_A {
                match self.bits {
                    false => MEM2MEM_A::Disabled,
                    true => MEM2MEM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MEM2MEM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MEM2MEM_A::Enabled
            }
        }
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, MEM2MEM_A, O>;
        impl<'a, const O: u8> MEM2MEM_W<'a, O> {
            ///Memory to memory transfer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Disabled)
            }
            ///Memory to memory transfer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr5](index.html) module
        pub struct CFGR5_SPEC;
        impl crate::RegisterSpec for CFGR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr5::R](R) reader structure
        impl crate::Readable for CFGR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr5::W](W) writer structure
        impl crate::Writable for CFGR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR5 to value 0
        impl crate::Resettable for CFGR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR5 (rw) register accessor: an alias for `Reg<CNTR5_SPEC>`
    pub type CNTR5 = crate::Reg<cntr5::CNTR5_SPEC>;
    ///DMA channel 5 number of data register
    pub mod cntr5 {
        ///Register `CNTR5` reader
        pub struct R(crate::R<CNTR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR5` writer
        pub struct W(crate::W<CNTR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR5_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 5 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr5](index.html) module
        pub struct CNTR5_SPEC;
        impl crate::RegisterSpec for CNTR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr5::R](R) reader structure
        impl crate::Readable for CNTR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr5::W](W) writer structure
        impl crate::Writable for CNTR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR5 to value 0
        impl crate::Resettable for CNTR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR5 (rw) register accessor: an alias for `Reg<PADDR5_SPEC>`
    pub type PADDR5 = crate::Reg<paddr5::PADDR5_SPEC>;
    ///DMA channel 5 peripheral address register
    pub mod paddr5 {
        ///Register `PADDR5` reader
        pub struct R(crate::R<PADDR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR5` writer
        pub struct W(crate::W<PADDR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR5_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 5 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr5](index.html) module
        pub struct PADDR5_SPEC;
        impl crate::RegisterSpec for PADDR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr5::R](R) reader structure
        impl crate::Readable for PADDR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr5::W](W) writer structure
        impl crate::Writable for PADDR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR5 to value 0
        impl crate::Resettable for PADDR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR5 (rw) register accessor: an alias for `Reg<MADDR5_SPEC>`
    pub type MADDR5 = crate::Reg<maddr5::MADDR5_SPEC>;
    ///DMA channel 5 memory address register
    pub mod maddr5 {
        ///Register `MADDR5` reader
        pub struct R(crate::R<MADDR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR5` writer
        pub struct W(crate::W<MADDR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR5_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 5 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr5](index.html) module
        pub struct MADDR5_SPEC;
        impl crate::RegisterSpec for MADDR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr5::R](R) reader structure
        impl crate::Readable for MADDR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr5::W](W) writer structure
        impl crate::Writable for MADDR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR5 to value 0
        impl crate::Resettable for MADDR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR6 (rw) register accessor: an alias for `Reg<CFGR6_SPEC>`
    pub type CFGR6 = crate::Reg<cfgr6::CFGR6_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr6 {
        ///Register `CFGR6` reader
        pub struct R(crate::R<CFGR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR6` writer
        pub struct W(crate::W<CFGR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<EN_A>;
        ///Channel enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN_A {
            ///0: DMA channel disabled
            Disabled = 0,
            ///1: DMA channel enabled
            Enabled = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::Disabled,
                    true => EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::Enabled
            }
        }
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, EN_A, O>;
        impl<'a, const O: u8> EN_W<'a, O> {
            ///DMA channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::Disabled)
            }
            ///DMA channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::Enabled)
            }
        }
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<TCIE_A>;
        ///Transfer complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::Disabled,
                    true => TCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::Enabled
            }
        }
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, TCIE_A, O>;
        impl<'a, const O: u8> TCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::Enabled)
            }
        }
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub use TCIE_R as HTIE_R;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub use TCIE_R as TEIE_R;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub use TCIE_W as HTIE_W;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub use TCIE_W as TEIE_W;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Data transfer direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Read from peripheral
            Peripheral = 0,
            ///1: Read from memory
            Memory = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Peripheral,
                    true => DIR_A::Memory,
                }
            }
            ///Checks if the value of the field is `Peripheral`
            #[inline(always)]
            pub fn is_peripheral(&self) -> bool {
                *self == DIR_A::Peripheral
            }
            ///Checks if the value of the field is `Memory`
            #[inline(always)]
            pub fn is_memory(&self) -> bool {
                *self == DIR_A::Memory
            }
        }
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Read from peripheral
            #[inline(always)]
            pub fn peripheral(self) -> &'a mut W {
                self.variant(DIR_A::Peripheral)
            }
            ///Read from memory
            #[inline(always)]
            pub fn memory(self) -> &'a mut W {
                self.variant(DIR_A::Memory)
            }
        }
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<CIRC_A>;
        ///Circular mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CIRC_A {
            ///0: Only execute once
            Once = 0,
            ///1: Circulation enabled
            Circulate = 1,
        }
        impl From<CIRC_A> for bool {
            #[inline(always)]
            fn from(variant: CIRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CIRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CIRC_A {
                match self.bits {
                    false => CIRC_A::Once,
                    true => CIRC_A::Circulate,
                }
            }
            ///Checks if the value of the field is `Once`
            #[inline(always)]
            pub fn is_once(&self) -> bool {
                *self == CIRC_A::Once
            }
            ///Checks if the value of the field is `Circulate`
            #[inline(always)]
            pub fn is_circulate(&self) -> bool {
                *self == CIRC_A::Circulate
            }
        }
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, CIRC_A, O>;
        impl<'a, const O: u8> CIRC_W<'a, O> {
            ///Only execute once
            #[inline(always)]
            pub fn once(self) -> &'a mut W {
                self.variant(CIRC_A::Once)
            }
            ///Circulation enabled
            #[inline(always)]
            pub fn circulate(self) -> &'a mut W {
                self.variant(CIRC_A::Circulate)
            }
        }
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<PINC_A>;
        ///Peripheral increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINC_A {
            ///0: Peripheral address increment disabled
            Disabled = 0,
            ///1: Peripheral address increment enabled
            Enabled = 1,
        }
        impl From<PINC_A> for bool {
            #[inline(always)]
            fn from(variant: PINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINC_A {
                match self.bits {
                    false => PINC_A::Disabled,
                    true => PINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINC_A::Enabled
            }
        }
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, PINC_A, O>;
        impl<'a, const O: u8> PINC_W<'a, O> {
            ///Peripheral address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINC_A::Disabled)
            }
            ///Peripheral address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINC_A::Enabled)
            }
        }
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<MINC_A>;
        ///Memory increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MINC_A {
            ///0: Memory address increment disabled
            Disabled = 0,
            ///1: Memory address increment enabled
            Enabled = 1,
        }
        impl From<MINC_A> for bool {
            #[inline(always)]
            fn from(variant: MINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MINC_A {
                match self.bits {
                    false => MINC_A::Disabled,
                    true => MINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MINC_A::Enabled
            }
        }
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, MINC_A, O>;
        impl<'a, const O: u8> MINC_W<'a, O> {
            ///Memory address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MINC_A::Disabled)
            }
            ///Memory address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MINC_A::Enabled)
            }
        }
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, PSIZE_A>;
        ///Peripheral size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSIZE_A {
            ///0: Peripheral address width is 8-bit
            B8 = 0,
            ///1: Peripheral address width is 16-bit
            B16 = 1,
            ///2: Peripheral address width is 32-bit
            B32 = 2,
        }
        impl From<PSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: PSIZE_A) -> Self {
                variant as _
            }
        }
        impl PSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSIZE_A> {
                match self.bits {
                    0 => Some(PSIZE_A::B8),
                    1 => Some(PSIZE_A::B16),
                    2 => Some(PSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == PSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == PSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == PSIZE_A::B32
            }
        }
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR6_SPEC, u8, PSIZE_A, 2, O>;
        impl<'a, const O: u8> PSIZE_W<'a, O> {
            ///Peripheral address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(PSIZE_A::B8)
            }
            ///Peripheral address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(PSIZE_A::B16)
            }
            ///Peripheral address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(PSIZE_A::B32)
            }
        }
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, MSIZE_A>;
        ///Memory size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MSIZE_A {
            ///0: Memory address width is 8-bit
            B8 = 0,
            ///1: Memory address width is 16-bit
            B16 = 1,
            ///2: Memory address width is 32-bit
            B32 = 2,
        }
        impl From<MSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIZE_A) -> Self {
                variant as _
            }
        }
        impl MSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MSIZE_A> {
                match self.bits {
                    0 => Some(MSIZE_A::B8),
                    1 => Some(MSIZE_A::B16),
                    2 => Some(MSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == MSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == MSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == MSIZE_A::B32
            }
        }
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR6_SPEC, u8, MSIZE_A, 2, O>;
        impl<'a, const O: u8> MSIZE_W<'a, O> {
            ///Memory address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(MSIZE_A::B8)
            }
            ///Memory address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(MSIZE_A::B16)
            }
            ///Memory address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(MSIZE_A::B32)
            }
        }
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, PL_A>;
        ///Channel Priority level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PL_A {
            ///0: Channel priority low
            Low = 0,
            ///1: Channel priority mid
            Mid = 1,
            ///2: Channel priority high
            High = 2,
            ///3: Channel priority highest
            Highest = 3,
        }
        impl From<PL_A> for u8 {
            #[inline(always)]
            fn from(variant: PL_A) -> Self {
                variant as _
            }
        }
        impl PL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PL_A {
                match self.bits {
                    0 => PL_A::Low,
                    1 => PL_A::Mid,
                    2 => PL_A::High,
                    3 => PL_A::Highest,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == PL_A::Low
            }
            ///Checks if the value of the field is `Mid`
            #[inline(always)]
            pub fn is_mid(&self) -> bool {
                *self == PL_A::Mid
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == PL_A::High
            }
            ///Checks if the value of the field is `Highest`
            #[inline(always)]
            pub fn is_highest(&self) -> bool {
                *self == PL_A::Highest
            }
        }
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR6_SPEC, u8, PL_A, 2, O>;
        impl<'a, const O: u8> PL_W<'a, O> {
            ///Channel priority low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(PL_A::Low)
            }
            ///Channel priority mid
            #[inline(always)]
            pub fn mid(self) -> &'a mut W {
                self.variant(PL_A::Mid)
            }
            ///Channel priority high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(PL_A::High)
            }
            ///Channel priority highest
            #[inline(always)]
            pub fn highest(self) -> &'a mut W {
                self.variant(PL_A::Highest)
            }
        }
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<MEM2MEM_A>;
        ///Memory to memory mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MEM2MEM_A {
            ///0: Memory to memory transfer disabled
            Disabled = 0,
            ///1: Memory to memory transfer enabled
            Enabled = 1,
        }
        impl From<MEM2MEM_A> for bool {
            #[inline(always)]
            fn from(variant: MEM2MEM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MEM2MEM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MEM2MEM_A {
                match self.bits {
                    false => MEM2MEM_A::Disabled,
                    true => MEM2MEM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MEM2MEM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MEM2MEM_A::Enabled
            }
        }
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, MEM2MEM_A, O>;
        impl<'a, const O: u8> MEM2MEM_W<'a, O> {
            ///Memory to memory transfer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Disabled)
            }
            ///Memory to memory transfer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr6](index.html) module
        pub struct CFGR6_SPEC;
        impl crate::RegisterSpec for CFGR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr6::R](R) reader structure
        impl crate::Readable for CFGR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr6::W](W) writer structure
        impl crate::Writable for CFGR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR6 to value 0
        impl crate::Resettable for CFGR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR6 (rw) register accessor: an alias for `Reg<CNTR6_SPEC>`
    pub type CNTR6 = crate::Reg<cntr6::CNTR6_SPEC>;
    ///DMA channel 6 number of data register
    pub mod cntr6 {
        ///Register `CNTR6` reader
        pub struct R(crate::R<CNTR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR6` writer
        pub struct W(crate::W<CNTR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR6_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 6 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr6](index.html) module
        pub struct CNTR6_SPEC;
        impl crate::RegisterSpec for CNTR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr6::R](R) reader structure
        impl crate::Readable for CNTR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr6::W](W) writer structure
        impl crate::Writable for CNTR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR6 to value 0
        impl crate::Resettable for CNTR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR6 (rw) register accessor: an alias for `Reg<PADDR6_SPEC>`
    pub type PADDR6 = crate::Reg<paddr6::PADDR6_SPEC>;
    ///DMA channel 6 peripheral address register
    pub mod paddr6 {
        ///Register `PADDR6` reader
        pub struct R(crate::R<PADDR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR6` writer
        pub struct W(crate::W<PADDR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR6_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 6 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr6](index.html) module
        pub struct PADDR6_SPEC;
        impl crate::RegisterSpec for PADDR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr6::R](R) reader structure
        impl crate::Readable for PADDR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr6::W](W) writer structure
        impl crate::Writable for PADDR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR6 to value 0
        impl crate::Resettable for PADDR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR6 (rw) register accessor: an alias for `Reg<MADDR6_SPEC>`
    pub type MADDR6 = crate::Reg<maddr6::MADDR6_SPEC>;
    ///DMA channel 6 memory address register
    pub mod maddr6 {
        ///Register `MADDR6` reader
        pub struct R(crate::R<MADDR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR6` writer
        pub struct W(crate::W<MADDR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR6_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 6 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr6](index.html) module
        pub struct MADDR6_SPEC;
        impl crate::RegisterSpec for MADDR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr6::R](R) reader structure
        impl crate::Readable for MADDR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr6::W](W) writer structure
        impl crate::Writable for MADDR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR6 to value 0
        impl crate::Resettable for MADDR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR7 (rw) register accessor: an alias for `Reg<CFGR7_SPEC>`
    pub type CFGR7 = crate::Reg<cfgr7::CFGR7_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr7 {
        ///Register `CFGR7` reader
        pub struct R(crate::R<CFGR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR7` writer
        pub struct W(crate::W<CFGR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<EN_A>;
        ///Channel enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN_A {
            ///0: DMA channel disabled
            Disabled = 0,
            ///1: DMA channel enabled
            Enabled = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::Disabled,
                    true => EN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN_A::Enabled
            }
        }
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, EN_A, O>;
        impl<'a, const O: u8> EN_W<'a, O> {
            ///DMA channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN_A::Disabled)
            }
            ///DMA channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN_A::Enabled)
            }
        }
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<TCIE_A>;
        ///Transfer complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::Disabled,
                    true => TCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TCIE_A::Enabled
            }
        }
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, TCIE_A, O>;
        impl<'a, const O: u8> TCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::Enabled)
            }
        }
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub use TCIE_R as HTIE_R;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub use TCIE_R as TEIE_R;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub use TCIE_W as HTIE_W;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub use TCIE_W as TEIE_W;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Data transfer direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Read from peripheral
            Peripheral = 0,
            ///1: Read from memory
            Memory = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Peripheral,
                    true => DIR_A::Memory,
                }
            }
            ///Checks if the value of the field is `Peripheral`
            #[inline(always)]
            pub fn is_peripheral(&self) -> bool {
                *self == DIR_A::Peripheral
            }
            ///Checks if the value of the field is `Memory`
            #[inline(always)]
            pub fn is_memory(&self) -> bool {
                *self == DIR_A::Memory
            }
        }
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Read from peripheral
            #[inline(always)]
            pub fn peripheral(self) -> &'a mut W {
                self.variant(DIR_A::Peripheral)
            }
            ///Read from memory
            #[inline(always)]
            pub fn memory(self) -> &'a mut W {
                self.variant(DIR_A::Memory)
            }
        }
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<CIRC_A>;
        ///Circular mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CIRC_A {
            ///0: Only execute once
            Once = 0,
            ///1: Circulation enabled
            Circulate = 1,
        }
        impl From<CIRC_A> for bool {
            #[inline(always)]
            fn from(variant: CIRC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CIRC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CIRC_A {
                match self.bits {
                    false => CIRC_A::Once,
                    true => CIRC_A::Circulate,
                }
            }
            ///Checks if the value of the field is `Once`
            #[inline(always)]
            pub fn is_once(&self) -> bool {
                *self == CIRC_A::Once
            }
            ///Checks if the value of the field is `Circulate`
            #[inline(always)]
            pub fn is_circulate(&self) -> bool {
                *self == CIRC_A::Circulate
            }
        }
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, CIRC_A, O>;
        impl<'a, const O: u8> CIRC_W<'a, O> {
            ///Only execute once
            #[inline(always)]
            pub fn once(self) -> &'a mut W {
                self.variant(CIRC_A::Once)
            }
            ///Circulation enabled
            #[inline(always)]
            pub fn circulate(self) -> &'a mut W {
                self.variant(CIRC_A::Circulate)
            }
        }
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<PINC_A>;
        ///Peripheral increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PINC_A {
            ///0: Peripheral address increment disabled
            Disabled = 0,
            ///1: Peripheral address increment enabled
            Enabled = 1,
        }
        impl From<PINC_A> for bool {
            #[inline(always)]
            fn from(variant: PINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINC_A {
                match self.bits {
                    false => PINC_A::Disabled,
                    true => PINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINC_A::Enabled
            }
        }
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, PINC_A, O>;
        impl<'a, const O: u8> PINC_W<'a, O> {
            ///Peripheral address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINC_A::Disabled)
            }
            ///Peripheral address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINC_A::Enabled)
            }
        }
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<MINC_A>;
        ///Memory increment mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MINC_A {
            ///0: Memory address increment disabled
            Disabled = 0,
            ///1: Memory address increment enabled
            Enabled = 1,
        }
        impl From<MINC_A> for bool {
            #[inline(always)]
            fn from(variant: MINC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MINC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MINC_A {
                match self.bits {
                    false => MINC_A::Disabled,
                    true => MINC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MINC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MINC_A::Enabled
            }
        }
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, MINC_A, O>;
        impl<'a, const O: u8> MINC_W<'a, O> {
            ///Memory address increment disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MINC_A::Disabled)
            }
            ///Memory address increment enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MINC_A::Enabled)
            }
        }
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, PSIZE_A>;
        ///Peripheral size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSIZE_A {
            ///0: Peripheral address width is 8-bit
            B8 = 0,
            ///1: Peripheral address width is 16-bit
            B16 = 1,
            ///2: Peripheral address width is 32-bit
            B32 = 2,
        }
        impl From<PSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: PSIZE_A) -> Self {
                variant as _
            }
        }
        impl PSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSIZE_A> {
                match self.bits {
                    0 => Some(PSIZE_A::B8),
                    1 => Some(PSIZE_A::B16),
                    2 => Some(PSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == PSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == PSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == PSIZE_A::B32
            }
        }
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR7_SPEC, u8, PSIZE_A, 2, O>;
        impl<'a, const O: u8> PSIZE_W<'a, O> {
            ///Peripheral address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(PSIZE_A::B8)
            }
            ///Peripheral address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(PSIZE_A::B16)
            }
            ///Peripheral address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(PSIZE_A::B32)
            }
        }
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, MSIZE_A>;
        ///Memory size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MSIZE_A {
            ///0: Memory address width is 8-bit
            B8 = 0,
            ///1: Memory address width is 16-bit
            B16 = 1,
            ///2: Memory address width is 32-bit
            B32 = 2,
        }
        impl From<MSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: MSIZE_A) -> Self {
                variant as _
            }
        }
        impl MSIZE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MSIZE_A> {
                match self.bits {
                    0 => Some(MSIZE_A::B8),
                    1 => Some(MSIZE_A::B16),
                    2 => Some(MSIZE_A::B32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `B8`
            #[inline(always)]
            pub fn is_b8(&self) -> bool {
                *self == MSIZE_A::B8
            }
            ///Checks if the value of the field is `B16`
            #[inline(always)]
            pub fn is_b16(&self) -> bool {
                *self == MSIZE_A::B16
            }
            ///Checks if the value of the field is `B32`
            #[inline(always)]
            pub fn is_b32(&self) -> bool {
                *self == MSIZE_A::B32
            }
        }
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR7_SPEC, u8, MSIZE_A, 2, O>;
        impl<'a, const O: u8> MSIZE_W<'a, O> {
            ///Memory address width is 8-bit
            #[inline(always)]
            pub fn b8(self) -> &'a mut W {
                self.variant(MSIZE_A::B8)
            }
            ///Memory address width is 16-bit
            #[inline(always)]
            pub fn b16(self) -> &'a mut W {
                self.variant(MSIZE_A::B16)
            }
            ///Memory address width is 32-bit
            #[inline(always)]
            pub fn b32(self) -> &'a mut W {
                self.variant(MSIZE_A::B32)
            }
        }
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, PL_A>;
        ///Channel Priority level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PL_A {
            ///0: Channel priority low
            Low = 0,
            ///1: Channel priority mid
            Mid = 1,
            ///2: Channel priority high
            High = 2,
            ///3: Channel priority highest
            Highest = 3,
        }
        impl From<PL_A> for u8 {
            #[inline(always)]
            fn from(variant: PL_A) -> Self {
                variant as _
            }
        }
        impl PL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PL_A {
                match self.bits {
                    0 => PL_A::Low,
                    1 => PL_A::Mid,
                    2 => PL_A::High,
                    3 => PL_A::Highest,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == PL_A::Low
            }
            ///Checks if the value of the field is `Mid`
            #[inline(always)]
            pub fn is_mid(&self) -> bool {
                *self == PL_A::Mid
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == PL_A::High
            }
            ///Checks if the value of the field is `Highest`
            #[inline(always)]
            pub fn is_highest(&self) -> bool {
                *self == PL_A::Highest
            }
        }
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CFGR7_SPEC, u8, PL_A, 2, O>;
        impl<'a, const O: u8> PL_W<'a, O> {
            ///Channel priority low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(PL_A::Low)
            }
            ///Channel priority mid
            #[inline(always)]
            pub fn mid(self) -> &'a mut W {
                self.variant(PL_A::Mid)
            }
            ///Channel priority high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(PL_A::High)
            }
            ///Channel priority highest
            #[inline(always)]
            pub fn highest(self) -> &'a mut W {
                self.variant(PL_A::Highest)
            }
        }
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<MEM2MEM_A>;
        ///Memory to memory mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MEM2MEM_A {
            ///0: Memory to memory transfer disabled
            Disabled = 0,
            ///1: Memory to memory transfer enabled
            Enabled = 1,
        }
        impl From<MEM2MEM_A> for bool {
            #[inline(always)]
            fn from(variant: MEM2MEM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MEM2MEM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MEM2MEM_A {
                match self.bits {
                    false => MEM2MEM_A::Disabled,
                    true => MEM2MEM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MEM2MEM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MEM2MEM_A::Enabled
            }
        }
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, MEM2MEM_A, O>;
        impl<'a, const O: u8> MEM2MEM_W<'a, O> {
            ///Memory to memory transfer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Disabled)
            }
            ///Memory to memory transfer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MEM2MEM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr7](index.html) module
        pub struct CFGR7_SPEC;
        impl crate::RegisterSpec for CFGR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr7::R](R) reader structure
        impl crate::Readable for CFGR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr7::W](W) writer structure
        impl crate::Writable for CFGR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR7 to value 0
        impl crate::Resettable for CFGR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR7 (rw) register accessor: an alias for `Reg<CNTR7_SPEC>`
    pub type CNTR7 = crate::Reg<cntr7::CNTR7_SPEC>;
    ///DMA channel 7 number of data register
    pub mod cntr7 {
        ///Register `CNTR7` reader
        pub struct R(crate::R<CNTR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR7` writer
        pub struct W(crate::W<CNTR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR7_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 7 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr7](index.html) module
        pub struct CNTR7_SPEC;
        impl crate::RegisterSpec for CNTR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr7::R](R) reader structure
        impl crate::Readable for CNTR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr7::W](W) writer structure
        impl crate::Writable for CNTR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR7 to value 0
        impl crate::Resettable for CNTR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR7 (rw) register accessor: an alias for `Reg<PADDR7_SPEC>`
    pub type PADDR7 = crate::Reg<paddr7::PADDR7_SPEC>;
    ///DMA channel 7 peripheral address register
    pub mod paddr7 {
        ///Register `PADDR7` reader
        pub struct R(crate::R<PADDR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR7` writer
        pub struct W(crate::W<PADDR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR7_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 7 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr7](index.html) module
        pub struct PADDR7_SPEC;
        impl crate::RegisterSpec for PADDR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr7::R](R) reader structure
        impl crate::Readable for PADDR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr7::W](W) writer structure
        impl crate::Writable for PADDR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR7 to value 0
        impl crate::Resettable for PADDR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR7 (rw) register accessor: an alias for `Reg<MADDR7_SPEC>`
    pub type MADDR7 = crate::Reg<maddr7::MADDR7_SPEC>;
    ///DMA channel 7 memory address register
    pub mod maddr7 {
        ///Register `MADDR7` reader
        pub struct R(crate::R<MADDR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR7` writer
        pub struct W(crate::W<MADDR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR7_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 7 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr7](index.html) module
        pub struct MADDR7_SPEC;
        impl crate::RegisterSpec for MADDR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr7::R](R) reader structure
        impl crate::Readable for MADDR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr7::W](W) writer structure
        impl crate::Writable for MADDR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR7 to value 0
        impl crate::Resettable for MADDR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Real time clock
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    ///Pointer to the register block
    pub const PTR: *const rtc::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
///Real time clock
pub mod rtc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RTC Control Register High
        pub ctlrh: CTLRH,
        _reserved1: [u8; 0x02],
        ///0x04 - RTC Control Register Low
        pub ctlrl: CTLRL,
        _reserved2: [u8; 0x02],
        ///0x08 - RTC Prescaler Load Register High
        pub pscrh: PSCRH,
        _reserved3: [u8; 0x02],
        ///0x0c - RTC Prescaler Load Register Low
        pub pscrl: PSCRL,
        _reserved4: [u8; 0x02],
        ///0x10 - RTC Prescaler Divider Register High
        pub divh: DIVH,
        _reserved5: [u8; 0x02],
        ///0x14 - RTC Prescaler Divider Register Low
        pub divl: DIVL,
        _reserved6: [u8; 0x02],
        ///0x18 - RTC Counter Register High
        pub cnth: CNTH,
        _reserved7: [u8; 0x02],
        ///0x1c - RTC Counter Register Low
        pub cntl: CNTL,
        _reserved8: [u8; 0x02],
        ///0x20 - RTC Alarm Register High
        pub alrmh: ALRMH,
        _reserved9: [u8; 0x02],
        ///0x24 - RTC Alarm Register Low
        pub alrml: ALRML,
    }
    ///CTLRH (rw) register accessor: an alias for `Reg<CTLRH_SPEC>`
    pub type CTLRH = crate::Reg<ctlrh::CTLRH_SPEC>;
    ///RTC Control Register High
    pub mod ctlrh {
        ///Register `CTLRH` reader
        pub struct R(crate::R<CTLRH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLRH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLRH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLRH` writer
        pub struct W(crate::W<CTLRH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLRH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLRH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SECIE` reader - Second interrupt Enable
        pub type SECIE_R = crate::BitReader<SECIE_A>;
        ///Second interrupt Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SECIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<SECIE_A> for bool {
            #[inline(always)]
            fn from(variant: SECIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SECIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SECIE_A {
                match self.bits {
                    false => SECIE_A::Disabled,
                    true => SECIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SECIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SECIE_A::Enabled
            }
        }
        ///Field `SECIE` writer - Second interrupt Enable
        pub type SECIE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLRH_SPEC, SECIE_A, O>;
        impl<'a, const O: u8> SECIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SECIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SECIE_A::Enabled)
            }
        }
        ///Field `ALRIE` reader - Alarm interrupt Enable
        pub use SECIE_R as ALRIE_R;
        ///Field `OWIE` reader - Overflow interrupt Enable
        pub use SECIE_R as OWIE_R;
        ///Field `ALRIE` writer - Alarm interrupt Enable
        pub use SECIE_W as ALRIE_W;
        ///Field `OWIE` writer - Overflow interrupt Enable
        pub use SECIE_W as OWIE_W;
        impl R {
            ///Bit 0 - Second interrupt Enable
            #[inline(always)]
            pub fn secie(&self) -> SECIE_R {
                SECIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Alarm interrupt Enable
            #[inline(always)]
            pub fn alrie(&self) -> ALRIE_R {
                ALRIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Overflow interrupt Enable
            #[inline(always)]
            pub fn owie(&self) -> OWIE_R {
                OWIE_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Second interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn secie(&mut self) -> SECIE_W<0> {
                SECIE_W::new(self)
            }
            ///Bit 1 - Alarm interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn alrie(&mut self) -> ALRIE_W<1> {
                ALRIE_W::new(self)
            }
            ///Bit 2 - Overflow interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn owie(&mut self) -> OWIE_W<2> {
                OWIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Control Register High
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlrh](index.html) module
        pub struct CTLRH_SPEC;
        impl crate::RegisterSpec for CTLRH_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlrh::R](R) reader structure
        impl crate::Readable for CTLRH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlrh::W](W) writer structure
        impl crate::Writable for CTLRH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLRH to value 0
        impl crate::Resettable for CTLRH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLRL (rw) register accessor: an alias for `Reg<CTLRL_SPEC>`
    pub type CTLRL = crate::Reg<ctlrl::CTLRL_SPEC>;
    ///RTC Control Register Low
    pub mod ctlrl {
        ///Register `CTLRL` reader
        pub struct R(crate::R<CTLRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLRL` writer
        pub struct W(crate::W<CTLRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SECF` reader - Second Flag
        pub type SECF_R = crate::BitReader<SECFR_A>;
        ///Second Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SECFR_A {
            ///0: No event occurred
            NoEvent = 0,
            ///1: Event occurred
            HasEvent = 1,
        }
        impl From<SECFR_A> for bool {
            #[inline(always)]
            fn from(variant: SECFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SECF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SECFR_A {
                match self.bits {
                    false => SECFR_A::NoEvent,
                    true => SECFR_A::HasEvent,
                }
            }
            ///Checks if the value of the field is `NoEvent`
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == SECFR_A::NoEvent
            }
            ///Checks if the value of the field is `HasEvent`
            #[inline(always)]
            pub fn is_has_event(&self) -> bool {
                *self == SECFR_A::HasEvent
            }
        }
        ///Second Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SECFW_AW {
            ///0: Clear event flag
            Clear = 0,
        }
        impl From<SECFW_AW> for bool {
            #[inline(always)]
            fn from(variant: SECFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SECF` writer - Second Flag
        pub type SECF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, CTLRL_SPEC, SECFW_AW, O>;
        impl<'a, const O: u8> SECF_W<'a, O> {
            ///Clear event flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(SECFW_AW::Clear)
            }
        }
        ///Field `ALRF` reader - Alarm Flag
        pub use SECF_R as ALRF_R;
        ///Field `OWF` reader - Overflow Flag
        pub use SECF_R as OWF_R;
        ///Field `ALRF` writer - Alarm Flag
        pub use SECF_W as ALRF_W;
        ///Field `OWF` writer - Overflow Flag
        pub use SECF_W as OWF_W;
        ///Field `RSF` reader - Registers Synchronized Flag
        pub type RSF_R = crate::BitReader<RSFR_A>;
        ///Registers Synchronized Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RSFR_A {
            ///0: Registers not synchronized
            NotSynchronized = 0,
            ///1: Registers synchronized
            Synchronized = 1,
        }
        impl From<RSFR_A> for bool {
            #[inline(always)]
            fn from(variant: RSFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RSF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RSFR_A {
                match self.bits {
                    false => RSFR_A::NotSynchronized,
                    true => RSFR_A::Synchronized,
                }
            }
            ///Checks if the value of the field is `NotSynchronized`
            #[inline(always)]
            pub fn is_not_synchronized(&self) -> bool {
                *self == RSFR_A::NotSynchronized
            }
            ///Checks if the value of the field is `Synchronized`
            #[inline(always)]
            pub fn is_synchronized(&self) -> bool {
                *self == RSFR_A::Synchronized
            }
        }
        ///Registers Synchronized Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RSFW_AW {
            ///0: Reset synchronization state
            Reset = 0,
        }
        impl From<RSFW_AW> for bool {
            #[inline(always)]
            fn from(variant: RSFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RSF` writer - Registers Synchronized Flag
        pub type RSF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, CTLRL_SPEC, RSFW_AW, O>;
        impl<'a, const O: u8> RSF_W<'a, O> {
            ///Reset synchronization state
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RSFW_AW::Reset)
            }
        }
        ///Field `CNF` reader - Configuration Flag
        pub type CNF_R = crate::BitReader<CNF_A>;
        ///Configuration Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CNF_A {
            ///0: Exit configuration mode and write
            Exit = 0,
            ///1: Enter configuration mode
            Enter = 1,
        }
        impl From<CNF_A> for bool {
            #[inline(always)]
            fn from(variant: CNF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CNF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CNF_A {
                match self.bits {
                    false => CNF_A::Exit,
                    true => CNF_A::Enter,
                }
            }
            ///Checks if the value of the field is `Exit`
            #[inline(always)]
            pub fn is_exit(&self) -> bool {
                *self == CNF_A::Exit
            }
            ///Checks if the value of the field is `Enter`
            #[inline(always)]
            pub fn is_enter(&self) -> bool {
                *self == CNF_A::Enter
            }
        }
        ///Field `CNF` writer - Configuration Flag
        pub type CNF_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLRL_SPEC, CNF_A, O>;
        impl<'a, const O: u8> CNF_W<'a, O> {
            ///Exit configuration mode and write
            #[inline(always)]
            pub fn exit(self) -> &'a mut W {
                self.variant(CNF_A::Exit)
            }
            ///Enter configuration mode
            #[inline(always)]
            pub fn enter(self) -> &'a mut W {
                self.variant(CNF_A::Enter)
            }
        }
        ///Field `RTOFF` reader - RTC operation OFF
        pub type RTOFF_R = crate::BitReader<RTOFF_A>;
        ///RTC operation OFF
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RTOFF_A {
            ///0: RTC operation in progress
            InProgress = 0,
            ///1: RTC operation done
            Done = 1,
        }
        impl From<RTOFF_A> for bool {
            #[inline(always)]
            fn from(variant: RTOFF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RTOFF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RTOFF_A {
                match self.bits {
                    false => RTOFF_A::InProgress,
                    true => RTOFF_A::Done,
                }
            }
            ///Checks if the value of the field is `InProgress`
            #[inline(always)]
            pub fn is_in_progress(&self) -> bool {
                *self == RTOFF_A::InProgress
            }
            ///Checks if the value of the field is `Done`
            #[inline(always)]
            pub fn is_done(&self) -> bool {
                *self == RTOFF_A::Done
            }
        }
        impl R {
            ///Bit 0 - Second Flag
            #[inline(always)]
            pub fn secf(&self) -> SECF_R {
                SECF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Alarm Flag
            #[inline(always)]
            pub fn alrf(&self) -> ALRF_R {
                ALRF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Overflow Flag
            #[inline(always)]
            pub fn owf(&self) -> OWF_R {
                OWF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Registers Synchronized Flag
            #[inline(always)]
            pub fn rsf(&self) -> RSF_R {
                RSF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Configuration Flag
            #[inline(always)]
            pub fn cnf(&self) -> CNF_R {
                CNF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RTC operation OFF
            #[inline(always)]
            pub fn rtoff(&self) -> RTOFF_R {
                RTOFF_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Second Flag
            #[inline(always)]
            #[must_use]
            pub fn secf(&mut self) -> SECF_W<0> {
                SECF_W::new(self)
            }
            ///Bit 1 - Alarm Flag
            #[inline(always)]
            #[must_use]
            pub fn alrf(&mut self) -> ALRF_W<1> {
                ALRF_W::new(self)
            }
            ///Bit 2 - Overflow Flag
            #[inline(always)]
            #[must_use]
            pub fn owf(&mut self) -> OWF_W<2> {
                OWF_W::new(self)
            }
            ///Bit 3 - Registers Synchronized Flag
            #[inline(always)]
            #[must_use]
            pub fn rsf(&mut self) -> RSF_W<3> {
                RSF_W::new(self)
            }
            ///Bit 4 - Configuration Flag
            #[inline(always)]
            #[must_use]
            pub fn cnf(&mut self) -> CNF_W<4> {
                CNF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Control Register Low
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlrl](index.html) module
        pub struct CTLRL_SPEC;
        impl crate::RegisterSpec for CTLRL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlrl::R](R) reader structure
        impl crate::Readable for CTLRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlrl::W](W) writer structure
        impl crate::Writable for CTLRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0f;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLRL to value 0x20
        impl crate::Resettable for CTLRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x20;
        }
    }
    ///PSCRH (w) register accessor: an alias for `Reg<PSCRH_SPEC>`
    pub type PSCRH = crate::Reg<pscrh::PSCRH_SPEC>;
    ///RTC Prescaler Load Register High
    pub mod pscrh {
        ///Register `PSCRH` writer
        pub struct W(crate::W<PSCRH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSCRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSCRH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSCRH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PRLH` writer - RTC Prescaler Load Register High
        pub type PRLH_W<'a, const O: u8> = crate::FieldWriter<'a, u16, PSCRH_SPEC, u8, u8, 4, O>;
        impl W {
            ///Bits 0:3 - RTC Prescaler Load Register High
            #[inline(always)]
            #[must_use]
            pub fn prlh(&mut self) -> PRLH_W<0> {
                PRLH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Prescaler Load Register High
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pscrh](index.html) module
        pub struct PSCRH_SPEC;
        impl crate::RegisterSpec for PSCRH_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [pscrh::W](W) writer structure
        impl crate::Writable for PSCRH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSCRH to value 0
        impl crate::Resettable for PSCRH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PSCRL (w) register accessor: an alias for `Reg<PSCRL_SPEC>`
    pub type PSCRL = crate::Reg<pscrl::PSCRL_SPEC>;
    ///RTC Prescaler Load Register Low
    pub mod pscrl {
        ///Register `PSCRL` writer
        pub struct W(crate::W<PSCRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSCRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSCRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSCRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PRLL` writer - RTC Prescaler Divider Register Low
        pub type PRLL_W<'a, const O: u8> = crate::FieldWriter<'a, u16, PSCRL_SPEC, u16, u16, 16, O>;
        impl W {
            ///Bits 0:15 - RTC Prescaler Divider Register Low
            #[inline(always)]
            #[must_use]
            pub fn prll(&mut self) -> PRLL_W<0> {
                PRLL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Prescaler Load Register Low
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pscrl](index.html) module
        pub struct PSCRL_SPEC;
        impl crate::RegisterSpec for PSCRL_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [pscrl::W](W) writer structure
        impl crate::Writable for PSCRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSCRL to value 0x8000
        impl crate::Resettable for PSCRL_SPEC {
            const RESET_VALUE: Self::Ux = 0x8000;
        }
    }
    ///DIVH (r) register accessor: an alias for `Reg<DIVH_SPEC>`
    pub type DIVH = crate::Reg<divh::DIVH_SPEC>;
    ///RTC Prescaler Divider Register High
    pub mod divh {
        ///Register `DIVH` reader
        pub struct R(crate::R<DIVH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIVH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DIVH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DIVH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DIVH` reader - RTC prescaler divider register high
        pub type DIVH_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:3 - RTC prescaler divider register high
            #[inline(always)]
            pub fn divh(&self) -> DIVH_R {
                DIVH_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RTC Prescaler Divider Register High
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [divh](index.html) module
        pub struct DIVH_SPEC;
        impl crate::RegisterSpec for DIVH_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [divh::R](R) reader structure
        impl crate::Readable for DIVH_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DIVH to value 0
        impl crate::Resettable for DIVH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DIVL (r) register accessor: an alias for `Reg<DIVL_SPEC>`
    pub type DIVL = crate::Reg<divl::DIVL_SPEC>;
    ///RTC Prescaler Divider Register Low
    pub mod divl {
        ///Register `DIVL` reader
        pub struct R(crate::R<DIVL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIVL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DIVL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DIVL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DIVL` reader - RTC prescaler divider register Low
        pub type DIVL_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - RTC prescaler divider register Low
            #[inline(always)]
            pub fn divl(&self) -> DIVL_R {
                DIVL_R::new(self.bits)
            }
        }
        ///RTC Prescaler Divider Register Low
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [divl](index.html) module
        pub struct DIVL_SPEC;
        impl crate::RegisterSpec for DIVL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [divl::R](R) reader structure
        impl crate::Readable for DIVL_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DIVL to value 0x8000
        impl crate::Resettable for DIVL_SPEC {
            const RESET_VALUE: Self::Ux = 0x8000;
        }
    }
    ///CNTH (rw) register accessor: an alias for `Reg<CNTH_SPEC>`
    pub type CNTH = crate::Reg<cnth::CNTH_SPEC>;
    ///RTC Counter Register High
    pub mod cnth {
        ///Register `CNTH` reader
        pub struct R(crate::R<CNTH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTH` writer
        pub struct W(crate::W<CNTH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTH` reader - RTC counter register high
        pub type CNTH_R = crate::FieldReader<u16, u16>;
        ///Field `CNTH` writer - RTC counter register high
        pub type CNTH_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CNTH_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RTC counter register high
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RTC counter register high
            #[inline(always)]
            #[must_use]
            pub fn cnth(&mut self) -> CNTH_W<0> {
                CNTH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Counter Register High
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnth](index.html) module
        pub struct CNTH_SPEC;
        impl crate::RegisterSpec for CNTH_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cnth::R](R) reader structure
        impl crate::Readable for CNTH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnth::W](W) writer structure
        impl crate::Writable for CNTH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTH to value 0
        impl crate::Resettable for CNTH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTL (rw) register accessor: an alias for `Reg<CNTL_SPEC>`
    pub type CNTL = crate::Reg<cntl::CNTL_SPEC>;
    ///RTC Counter Register Low
    pub mod cntl {
        ///Register `CNTL` reader
        pub struct R(crate::R<CNTL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTL` writer
        pub struct W(crate::W<CNTL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - RTC counter register Low
        pub type CNTL_R = crate::FieldReader<u16, u16>;
        ///Field `CNTL` writer - RTC counter register Low
        pub type CNTL_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CNTL_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - RTC counter register Low
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - RTC counter register Low
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Counter Register Low
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntl](index.html) module
        pub struct CNTL_SPEC;
        impl crate::RegisterSpec for CNTL_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cntl::R](R) reader structure
        impl crate::Readable for CNTL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntl::W](W) writer structure
        impl crate::Writable for CNTL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTL to value 0
        impl crate::Resettable for CNTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ALRMH (w) register accessor: an alias for `Reg<ALRMH_SPEC>`
    pub type ALRMH = crate::Reg<alrmh::ALRMH_SPEC>;
    ///RTC Alarm Register High
    pub mod alrmh {
        ///Register `ALRMH` writer
        pub struct W(crate::W<ALRMH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ALRMH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ALRMH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ALRMH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ALRMH` writer - RTC alarm register high
        pub type ALRMH_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, ALRMH_SPEC, u16, u16, 16, O>;
        impl W {
            ///Bits 0:15 - RTC alarm register high
            #[inline(always)]
            #[must_use]
            pub fn alrmh(&mut self) -> ALRMH_W<0> {
                ALRMH_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Alarm Register High
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [alrmh](index.html) module
        pub struct ALRMH_SPEC;
        impl crate::RegisterSpec for ALRMH_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [alrmh::W](W) writer structure
        impl crate::Writable for ALRMH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ALRMH to value 0xffff
        impl crate::Resettable for ALRMH_SPEC {
            const RESET_VALUE: Self::Ux = 0xffff;
        }
    }
    ///ALRML (w) register accessor: an alias for `Reg<ALRML_SPEC>`
    pub type ALRML = crate::Reg<alrml::ALRML_SPEC>;
    ///RTC Alarm Register Low
    pub mod alrml {
        ///Register `ALRML` writer
        pub struct W(crate::W<ALRML_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ALRML_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ALRML_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ALRML_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ALRML` writer - RTC alarm register low
        pub type ALRML_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, ALRML_SPEC, u16, u16, 16, O>;
        impl W {
            ///Bits 0:15 - RTC alarm register low
            #[inline(always)]
            #[must_use]
            pub fn alrml(&mut self) -> ALRML_W<0> {
                ALRML_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Alarm Register Low
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [alrml](index.html) module
        pub struct ALRML_SPEC;
        impl crate::RegisterSpec for ALRML_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [alrml::W](W) writer structure
        impl crate::Writable for ALRML_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ALRML to value 0xffff
        impl crate::Resettable for ALRML_SPEC {
            const RESET_VALUE: Self::Ux = 0xffff;
        }
    }
}
///Backup registers
pub struct BKP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BKP {}
impl BKP {
    ///Pointer to the register block
    pub const PTR: *const bkp::RegisterBlock = 0x4000_6c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const bkp::RegisterBlock {
        Self::PTR
    }
}
impl Deref for BKP {
    type Target = bkp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BKP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BKP").finish()
    }
}
///Backup registers
pub mod bkp {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x04],
        ///0x04 - Backup data register (BKP_DR)
        pub datar1: DATAR1,
        _reserved1: [u8; 0x02],
        ///0x08 - Backup data register (BKP_DR)
        pub datar2: DATAR2,
        _reserved2: [u8; 0x02],
        ///0x0c - Backup data register (BKP_DR)
        pub datar3: DATAR3,
        _reserved3: [u8; 0x02],
        ///0x10 - Backup data register (BKP_DR)
        pub datar4: DATAR4,
        _reserved4: [u8; 0x02],
        ///0x14 - Backup data register (BKP_DR)
        pub datar5: DATAR5,
        _reserved5: [u8; 0x02],
        ///0x18 - Backup data register (BKP_DR)
        pub datar6: DATAR6,
        _reserved6: [u8; 0x02],
        ///0x1c - Backup data register (BKP_DR)
        pub datar7: DATAR7,
        _reserved7: [u8; 0x02],
        ///0x20 - Backup data register (BKP_DR)
        pub datar8: DATAR8,
        _reserved8: [u8; 0x02],
        ///0x24 - Backup data register (BKP_DR)
        pub datar9: DATAR9,
        _reserved9: [u8; 0x02],
        ///0x28 - Backup data register (BKP_DR)
        pub datar10: DATAR10,
        _reserved10: [u8; 0x02],
        ///0x2c - RTC clock calibration register (BKP_OCTLR)
        pub octlr: OCTLR,
        _reserved11: [u8; 0x02],
        ///0x30 - Backup control register (BKP_TPCTLR)
        pub tpctlr: TPCTLR,
        _reserved12: [u8; 0x02],
        ///0x34 - BKP_TPCSR control/status register (BKP_CSR)
        pub tpcsr: TPCSR,
    }
    ///DATAR1 (rw) register accessor: an alias for `Reg<DATAR1_SPEC>`
    pub type DATAR1 = crate::Reg<datar1::DATAR1_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar1 {
        ///Register `DATAR1` reader
        pub struct R(crate::R<DATAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR1` writer
        pub struct W(crate::W<DATAR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D1` reader - Backup data
        pub type D1_R = crate::FieldReader<u16, u16>;
        ///Field `D1` writer - Backup data
        pub type D1_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR1_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d1(&self) -> D1_R {
                D1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d1(&mut self) -> D1_W<0> {
                D1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar1](index.html) module
        pub struct DATAR1_SPEC;
        impl crate::RegisterSpec for DATAR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar1::R](R) reader structure
        impl crate::Readable for DATAR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar1::W](W) writer structure
        impl crate::Writable for DATAR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR1 to value 0
        impl crate::Resettable for DATAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR2 (rw) register accessor: an alias for `Reg<DATAR2_SPEC>`
    pub type DATAR2 = crate::Reg<datar2::DATAR2_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar2 {
        ///Register `DATAR2` reader
        pub struct R(crate::R<DATAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR2` writer
        pub struct W(crate::W<DATAR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D2` reader - Backup data
        pub type D2_R = crate::FieldReader<u16, u16>;
        ///Field `D2` writer - Backup data
        pub type D2_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR2_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d2(&self) -> D2_R {
                D2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d2(&mut self) -> D2_W<0> {
                D2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar2](index.html) module
        pub struct DATAR2_SPEC;
        impl crate::RegisterSpec for DATAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar2::R](R) reader structure
        impl crate::Readable for DATAR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar2::W](W) writer structure
        impl crate::Writable for DATAR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR2 to value 0
        impl crate::Resettable for DATAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR3 (rw) register accessor: an alias for `Reg<DATAR3_SPEC>`
    pub type DATAR3 = crate::Reg<datar3::DATAR3_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar3 {
        ///Register `DATAR3` reader
        pub struct R(crate::R<DATAR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR3` writer
        pub struct W(crate::W<DATAR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D3` reader - Backup data
        pub type D3_R = crate::FieldReader<u16, u16>;
        ///Field `D3` writer - Backup data
        pub type D3_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR3_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d3(&self) -> D3_R {
                D3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d3(&mut self) -> D3_W<0> {
                D3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar3](index.html) module
        pub struct DATAR3_SPEC;
        impl crate::RegisterSpec for DATAR3_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar3::R](R) reader structure
        impl crate::Readable for DATAR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar3::W](W) writer structure
        impl crate::Writable for DATAR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR3 to value 0
        impl crate::Resettable for DATAR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR4 (rw) register accessor: an alias for `Reg<DATAR4_SPEC>`
    pub type DATAR4 = crate::Reg<datar4::DATAR4_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar4 {
        ///Register `DATAR4` reader
        pub struct R(crate::R<DATAR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR4` writer
        pub struct W(crate::W<DATAR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D4` reader - Backup data
        pub type D4_R = crate::FieldReader<u16, u16>;
        ///Field `D4` writer - Backup data
        pub type D4_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR4_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d4(&self) -> D4_R {
                D4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d4(&mut self) -> D4_W<0> {
                D4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar4](index.html) module
        pub struct DATAR4_SPEC;
        impl crate::RegisterSpec for DATAR4_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar4::R](R) reader structure
        impl crate::Readable for DATAR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar4::W](W) writer structure
        impl crate::Writable for DATAR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR4 to value 0
        impl crate::Resettable for DATAR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR5 (rw) register accessor: an alias for `Reg<DATAR5_SPEC>`
    pub type DATAR5 = crate::Reg<datar5::DATAR5_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar5 {
        ///Register `DATAR5` reader
        pub struct R(crate::R<DATAR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR5` writer
        pub struct W(crate::W<DATAR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D5` reader - Backup data
        pub type D5_R = crate::FieldReader<u16, u16>;
        ///Field `D5` writer - Backup data
        pub type D5_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR5_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d5(&self) -> D5_R {
                D5_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d5(&mut self) -> D5_W<0> {
                D5_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar5](index.html) module
        pub struct DATAR5_SPEC;
        impl crate::RegisterSpec for DATAR5_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar5::R](R) reader structure
        impl crate::Readable for DATAR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar5::W](W) writer structure
        impl crate::Writable for DATAR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR5 to value 0
        impl crate::Resettable for DATAR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR6 (rw) register accessor: an alias for `Reg<DATAR6_SPEC>`
    pub type DATAR6 = crate::Reg<datar6::DATAR6_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar6 {
        ///Register `DATAR6` reader
        pub struct R(crate::R<DATAR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR6` writer
        pub struct W(crate::W<DATAR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D6` reader - Backup data
        pub type D6_R = crate::FieldReader<u16, u16>;
        ///Field `D6` writer - Backup data
        pub type D6_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR6_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d6(&self) -> D6_R {
                D6_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d6(&mut self) -> D6_W<0> {
                D6_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar6](index.html) module
        pub struct DATAR6_SPEC;
        impl crate::RegisterSpec for DATAR6_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar6::R](R) reader structure
        impl crate::Readable for DATAR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar6::W](W) writer structure
        impl crate::Writable for DATAR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR6 to value 0
        impl crate::Resettable for DATAR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR7 (rw) register accessor: an alias for `Reg<DATAR7_SPEC>`
    pub type DATAR7 = crate::Reg<datar7::DATAR7_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar7 {
        ///Register `DATAR7` reader
        pub struct R(crate::R<DATAR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR7` writer
        pub struct W(crate::W<DATAR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D7` reader - Backup data
        pub type D7_R = crate::FieldReader<u16, u16>;
        ///Field `D7` writer - Backup data
        pub type D7_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR7_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d7(&self) -> D7_R {
                D7_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d7(&mut self) -> D7_W<0> {
                D7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar7](index.html) module
        pub struct DATAR7_SPEC;
        impl crate::RegisterSpec for DATAR7_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar7::R](R) reader structure
        impl crate::Readable for DATAR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar7::W](W) writer structure
        impl crate::Writable for DATAR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR7 to value 0
        impl crate::Resettable for DATAR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR8 (rw) register accessor: an alias for `Reg<DATAR8_SPEC>`
    pub type DATAR8 = crate::Reg<datar8::DATAR8_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar8 {
        ///Register `DATAR8` reader
        pub struct R(crate::R<DATAR8_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR8_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR8_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR8` writer
        pub struct W(crate::W<DATAR8_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR8_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR8_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D8` reader - Backup data
        pub type D8_R = crate::FieldReader<u16, u16>;
        ///Field `D8` writer - Backup data
        pub type D8_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR8_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d8(&self) -> D8_R {
                D8_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d8(&mut self) -> D8_W<0> {
                D8_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar8](index.html) module
        pub struct DATAR8_SPEC;
        impl crate::RegisterSpec for DATAR8_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar8::R](R) reader structure
        impl crate::Readable for DATAR8_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar8::W](W) writer structure
        impl crate::Writable for DATAR8_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR8 to value 0
        impl crate::Resettable for DATAR8_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR9 (rw) register accessor: an alias for `Reg<DATAR9_SPEC>`
    pub type DATAR9 = crate::Reg<datar9::DATAR9_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar9 {
        ///Register `DATAR9` reader
        pub struct R(crate::R<DATAR9_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR9_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR9_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR9` writer
        pub struct W(crate::W<DATAR9_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR9_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR9_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D9` reader - Backup data
        pub type D9_R = crate::FieldReader<u16, u16>;
        ///Field `D9` writer - Backup data
        pub type D9_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR9_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d9(&self) -> D9_R {
                D9_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d9(&mut self) -> D9_W<0> {
                D9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar9](index.html) module
        pub struct DATAR9_SPEC;
        impl crate::RegisterSpec for DATAR9_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar9::R](R) reader structure
        impl crate::Readable for DATAR9_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar9::W](W) writer structure
        impl crate::Writable for DATAR9_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR9 to value 0
        impl crate::Resettable for DATAR9_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR10 (rw) register accessor: an alias for `Reg<DATAR10_SPEC>`
    pub type DATAR10 = crate::Reg<datar10::DATAR10_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod datar10 {
        ///Register `DATAR10` reader
        pub struct R(crate::R<DATAR10_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR10_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR10_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR10` writer
        pub struct W(crate::W<DATAR10_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR10_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR10_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D10` reader - Backup data
        pub type D10_R = crate::FieldReader<u16, u16>;
        ///Field `D10` writer - Backup data
        pub type D10_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, DATAR10_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d10(&self) -> D10_R {
                D10_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            #[must_use]
            pub fn d10(&mut self) -> D10_W<0> {
                D10_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar10](index.html) module
        pub struct DATAR10_SPEC;
        impl crate::RegisterSpec for DATAR10_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar10::R](R) reader structure
        impl crate::Readable for DATAR10_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar10::W](W) writer structure
        impl crate::Writable for DATAR10_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR10 to value 0
        impl crate::Resettable for DATAR10_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OCTLR (rw) register accessor: an alias for `Reg<OCTLR_SPEC>`
    pub type OCTLR = crate::Reg<octlr::OCTLR_SPEC>;
    ///RTC clock calibration register (BKP_OCTLR)
    pub mod octlr {
        ///Register `OCTLR` reader
        pub struct R(crate::R<OCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OCTLR` writer
        pub struct W(crate::W<OCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CAL` reader - Calibration value
        pub type CAL_R = crate::FieldReader<u8, u8>;
        ///Field `CAL` writer - Calibration value
        pub type CAL_W<'a, const O: u8> = crate::FieldWriter<'a, u16, OCTLR_SPEC, u8, u8, 7, O>;
        ///Field `CCO` reader - Calibration Clock Output
        pub type CCO_R = crate::BitReader<CCO_A>;
        ///Calibration Clock Output
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CCO_A {
            ///0: No calibration clock output
            Disable = 0,
            ///1: TAMPER output RTC divided by 64
            Rtcdiv64 = 1,
        }
        impl From<CCO_A> for bool {
            #[inline(always)]
            fn from(variant: CCO_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CCO_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCO_A {
                match self.bits {
                    false => CCO_A::Disable,
                    true => CCO_A::Rtcdiv64,
                }
            }
            ///Checks if the value of the field is `Disable`
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CCO_A::Disable
            }
            ///Checks if the value of the field is `Rtcdiv64`
            #[inline(always)]
            pub fn is_rtcdiv64(&self) -> bool {
                *self == CCO_A::Rtcdiv64
            }
        }
        ///Field `CCO` writer - Calibration Clock Output
        pub type CCO_W<'a, const O: u8> = crate::BitWriter<'a, u16, OCTLR_SPEC, CCO_A, O>;
        impl<'a, const O: u8> CCO_W<'a, O> {
            ///No calibration clock output
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(CCO_A::Disable)
            }
            ///TAMPER output RTC divided by 64
            #[inline(always)]
            pub fn rtcdiv64(self) -> &'a mut W {
                self.variant(CCO_A::Rtcdiv64)
            }
        }
        ///Field `ASOE` reader - Alarm or second output enable
        pub type ASOE_R = crate::BitReader<ASOE_A>;
        ///Alarm or second output enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ASOE_A {
            ///0: TAMPER pulse output enabled
            Enabled = 0,
            ///1: TAMPER pulse output disabled
            Disabled = 1,
        }
        impl From<ASOE_A> for bool {
            #[inline(always)]
            fn from(variant: ASOE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ASOE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ASOE_A {
                match self.bits {
                    false => ASOE_A::Enabled,
                    true => ASOE_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ASOE_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ASOE_A::Disabled
            }
        }
        ///Field `ASOE` writer - Alarm or second output enable
        pub type ASOE_W<'a, const O: u8> = crate::BitWriter<'a, u16, OCTLR_SPEC, ASOE_A, O>;
        impl<'a, const O: u8> ASOE_W<'a, O> {
            ///TAMPER pulse output enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ASOE_A::Enabled)
            }
            ///TAMPER pulse output disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ASOE_A::Disabled)
            }
        }
        ///Field `ASOS` reader - Alarm or second output selection
        pub type ASOS_R = crate::BitReader<ASOS_A>;
        ///Alarm or second output selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ASOS_A {
            ///0: Output alarm pulse
            Alarm = 0,
            ///1: Output second pulse
            Second = 1,
        }
        impl From<ASOS_A> for bool {
            #[inline(always)]
            fn from(variant: ASOS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ASOS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ASOS_A {
                match self.bits {
                    false => ASOS_A::Alarm,
                    true => ASOS_A::Second,
                }
            }
            ///Checks if the value of the field is `Alarm`
            #[inline(always)]
            pub fn is_alarm(&self) -> bool {
                *self == ASOS_A::Alarm
            }
            ///Checks if the value of the field is `Second`
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                *self == ASOS_A::Second
            }
        }
        ///Field `ASOS` writer - Alarm or second output selection
        pub type ASOS_W<'a, const O: u8> = crate::BitWriter<'a, u16, OCTLR_SPEC, ASOS_A, O>;
        impl<'a, const O: u8> ASOS_W<'a, O> {
            ///Output alarm pulse
            #[inline(always)]
            pub fn alarm(self) -> &'a mut W {
                self.variant(ASOS_A::Alarm)
            }
            ///Output second pulse
            #[inline(always)]
            pub fn second(self) -> &'a mut W {
                self.variant(ASOS_A::Second)
            }
        }
        impl R {
            ///Bits 0:6 - Calibration value
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Calibration Clock Output
            #[inline(always)]
            pub fn cco(&self) -> CCO_R {
                CCO_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Alarm or second output enable
            #[inline(always)]
            pub fn asoe(&self) -> ASOE_R {
                ASOE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Alarm or second output selection
            #[inline(always)]
            pub fn asos(&self) -> ASOS_R {
                ASOS_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - Calibration value
            #[inline(always)]
            #[must_use]
            pub fn cal(&mut self) -> CAL_W<0> {
                CAL_W::new(self)
            }
            ///Bit 7 - Calibration Clock Output
            #[inline(always)]
            #[must_use]
            pub fn cco(&mut self) -> CCO_W<7> {
                CCO_W::new(self)
            }
            ///Bit 8 - Alarm or second output enable
            #[inline(always)]
            #[must_use]
            pub fn asoe(&mut self) -> ASOE_W<8> {
                ASOE_W::new(self)
            }
            ///Bit 9 - Alarm or second output selection
            #[inline(always)]
            #[must_use]
            pub fn asos(&mut self) -> ASOS_W<9> {
                ASOS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC clock calibration register (BKP_OCTLR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [octlr](index.html) module
        pub struct OCTLR_SPEC;
        impl crate::RegisterSpec for OCTLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [octlr::R](R) reader structure
        impl crate::Readable for OCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [octlr::W](W) writer structure
        impl crate::Writable for OCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OCTLR to value 0
        impl crate::Resettable for OCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TPCTLR (rw) register accessor: an alias for `Reg<TPCTLR_SPEC>`
    pub type TPCTLR = crate::Reg<tpctlr::TPCTLR_SPEC>;
    ///Backup control register (BKP_TPCTLR)
    pub mod tpctlr {
        ///Register `TPCTLR` reader
        pub struct R(crate::R<TPCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TPCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TPCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TPCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TPCTLR` writer
        pub struct W(crate::W<TPCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TPCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TPCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TPCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TPE` reader - Tamper pin enable
        pub type TPE_R = crate::BitReader<TPE_A>;
        ///Tamper pin enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TPE_A {
            ///0: TAMPER pin as GPIO
            Gpio = 0,
            ///1: TAMPER pin as tamper detection
            Tamper = 1,
        }
        impl From<TPE_A> for bool {
            #[inline(always)]
            fn from(variant: TPE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TPE_A {
                match self.bits {
                    false => TPE_A::Gpio,
                    true => TPE_A::Tamper,
                }
            }
            ///Checks if the value of the field is `Gpio`
            #[inline(always)]
            pub fn is_gpio(&self) -> bool {
                *self == TPE_A::Gpio
            }
            ///Checks if the value of the field is `Tamper`
            #[inline(always)]
            pub fn is_tamper(&self) -> bool {
                *self == TPE_A::Tamper
            }
        }
        ///Field `TPE` writer - Tamper pin enable
        pub type TPE_W<'a, const O: u8> = crate::BitWriter<'a, u16, TPCTLR_SPEC, TPE_A, O>;
        impl<'a, const O: u8> TPE_W<'a, O> {
            ///TAMPER pin as GPIO
            #[inline(always)]
            pub fn gpio(self) -> &'a mut W {
                self.variant(TPE_A::Gpio)
            }
            ///TAMPER pin as tamper detection
            #[inline(always)]
            pub fn tamper(self) -> &'a mut W {
                self.variant(TPE_A::Tamper)
            }
        }
        ///Field `TPAL` reader - Tamper pin active level
        pub type TPAL_R = crate::BitReader<TPAL_A>;
        ///Tamper pin active level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TPAL_A {
            ///0: High voltage level will clear all backup registers
            High = 0,
            ///1: Low voltage level will clear all backup registers
            Low = 1,
        }
        impl From<TPAL_A> for bool {
            #[inline(always)]
            fn from(variant: TPAL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TPAL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TPAL_A {
                match self.bits {
                    false => TPAL_A::High,
                    true => TPAL_A::Low,
                }
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == TPAL_A::High
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == TPAL_A::Low
            }
        }
        ///Field `TPAL` writer - Tamper pin active level
        pub type TPAL_W<'a, const O: u8> = crate::BitWriter<'a, u16, TPCTLR_SPEC, TPAL_A, O>;
        impl<'a, const O: u8> TPAL_W<'a, O> {
            ///High voltage level will clear all backup registers
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(TPAL_A::High)
            }
            ///Low voltage level will clear all backup registers
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(TPAL_A::Low)
            }
        }
        impl R {
            ///Bit 0 - Tamper pin enable
            #[inline(always)]
            pub fn tpe(&self) -> TPE_R {
                TPE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Tamper pin active level
            #[inline(always)]
            pub fn tpal(&self) -> TPAL_R {
                TPAL_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Tamper pin enable
            #[inline(always)]
            #[must_use]
            pub fn tpe(&mut self) -> TPE_W<0> {
                TPE_W::new(self)
            }
            ///Bit 1 - Tamper pin active level
            #[inline(always)]
            #[must_use]
            pub fn tpal(&mut self) -> TPAL_W<1> {
                TPAL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup control register (BKP_TPCTLR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tpctlr](index.html) module
        pub struct TPCTLR_SPEC;
        impl crate::RegisterSpec for TPCTLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tpctlr::R](R) reader structure
        impl crate::Readable for TPCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tpctlr::W](W) writer structure
        impl crate::Writable for TPCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets TPCTLR to value 0
        impl crate::Resettable for TPCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TPCSR (rw) register accessor: an alias for `Reg<TPCSR_SPEC>`
    pub type TPCSR = crate::Reg<tpcsr::TPCSR_SPEC>;
    ///BKP_TPCSR control/status register (BKP_CSR)
    pub mod tpcsr {
        ///Register `TPCSR` reader
        pub struct R(crate::R<TPCSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TPCSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TPCSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TPCSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TPCSR` writer
        pub struct W(crate::W<TPCSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TPCSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<TPCSR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<TPCSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clear Tamper event
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTEW_AW {
            ///1: Clear tamper event flag
            Clear = 1,
        }
        impl From<CTEW_AW> for bool {
            #[inline(always)]
            fn from(variant: CTEW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTE` writer - Clear Tamper event
        pub type CTE_W<'a, const O: u8> = crate::BitWriter1C<'a, u16, TPCSR_SPEC, CTEW_AW, O>;
        impl<'a, const O: u8> CTE_W<'a, O> {
            ///Clear tamper event flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEW_AW::Clear)
            }
        }
        ///Clear Tamper Interrupt
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTIW_AW {
            ///1: Clear tamper interrupt flag
            Clear = 1,
        }
        impl From<CTIW_AW> for bool {
            #[inline(always)]
            fn from(variant: CTIW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTI` writer - Clear Tamper Interrupt
        pub type CTI_W<'a, const O: u8> = crate::BitWriter1C<'a, u16, TPCSR_SPEC, CTIW_AW, O>;
        impl<'a, const O: u8> CTI_W<'a, O> {
            ///Clear tamper interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTIW_AW::Clear)
            }
        }
        ///Field `TPIE` reader - Tamper Pin interrupt enable
        pub type TPIE_R = crate::BitReader<TPIE_A>;
        ///Tamper Pin interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TPIE_A {
            ///0: Tamper interrupt disabled
            Disabled = 0,
            ///1: Tamper interrupt enabled
            Enabled = 1,
        }
        impl From<TPIE_A> for bool {
            #[inline(always)]
            fn from(variant: TPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TPIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TPIE_A {
                match self.bits {
                    false => TPIE_A::Disabled,
                    true => TPIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TPIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TPIE_A::Enabled
            }
        }
        ///Field `TPIE` writer - Tamper Pin interrupt enable
        pub type TPIE_W<'a, const O: u8> = crate::BitWriter<'a, u16, TPCSR_SPEC, TPIE_A, O>;
        impl<'a, const O: u8> TPIE_W<'a, O> {
            ///Tamper interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TPIE_A::Disabled)
            }
            ///Tamper interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TPIE_A::Enabled)
            }
        }
        ///Field `TEF` reader - Tamper Event Flag
        pub type TEF_R = crate::BitReader<TEFR_A>;
        ///Tamper Event Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TEFR_A {
            ///0: Tamper event not occurred
            NotTampered = 0,
            ///1: Tamper event occurred
            Tampered = 1,
        }
        impl From<TEFR_A> for bool {
            #[inline(always)]
            fn from(variant: TEFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TEF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TEFR_A {
                match self.bits {
                    false => TEFR_A::NotTampered,
                    true => TEFR_A::Tampered,
                }
            }
            ///Checks if the value of the field is `NotTampered`
            #[inline(always)]
            pub fn is_not_tampered(&self) -> bool {
                *self == TEFR_A::NotTampered
            }
            ///Checks if the value of the field is `Tampered`
            #[inline(always)]
            pub fn is_tampered(&self) -> bool {
                *self == TEFR_A::Tampered
            }
        }
        ///Field `TIF` reader - Tamper Interrupt Flag
        pub type TIF_R = crate::BitReader<TIFR_A>;
        ///Tamper Interrupt Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIFR_A {
            ///0: Tamper not interrupted
            NotInterrupted = 0,
            ///1: Tamper interrupted
            Interrupted = 1,
        }
        impl From<TIFR_A> for bool {
            #[inline(always)]
            fn from(variant: TIFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TIF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIFR_A {
                match self.bits {
                    false => TIFR_A::NotInterrupted,
                    true => TIFR_A::Interrupted,
                }
            }
            ///Checks if the value of the field is `NotInterrupted`
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == TIFR_A::NotInterrupted
            }
            ///Checks if the value of the field is `Interrupted`
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == TIFR_A::Interrupted
            }
        }
        impl R {
            ///Bit 2 - Tamper Pin interrupt enable
            #[inline(always)]
            pub fn tpie(&self) -> TPIE_R {
                TPIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 8 - Tamper Event Flag
            #[inline(always)]
            pub fn tef(&self) -> TEF_R {
                TEF_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Tamper Interrupt Flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Clear Tamper event
            #[inline(always)]
            #[must_use]
            pub fn cte(&mut self) -> CTE_W<0> {
                CTE_W::new(self)
            }
            ///Bit 1 - Clear Tamper Interrupt
            #[inline(always)]
            #[must_use]
            pub fn cti(&mut self) -> CTI_W<1> {
                CTI_W::new(self)
            }
            ///Bit 2 - Tamper Pin interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tpie(&mut self) -> TPIE_W<2> {
                TPIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///BKP_TPCSR control/status register (BKP_CSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tpcsr](index.html) module
        pub struct TPCSR_SPEC;
        impl crate::RegisterSpec for TPCSR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tpcsr::R](R) reader structure
        impl crate::Readable for TPCSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [tpcsr::W](W) writer structure
        impl crate::Writable for TPCSR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x03;
        }
        ///`reset()` method sets TPCSR to value 0
        impl crate::Resettable for TPCSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Independent watchdog
pub struct IWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IWDG {}
impl IWDG {
    ///Pointer to the register block
    pub const PTR: *const iwdg::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const iwdg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for IWDG {
    type Target = iwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IWDG").finish()
    }
}
///Independent watchdog
pub mod iwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Key register (IWDG_CTLR)
        pub ctlr: CTLR,
        _reserved1: [u8; 0x02],
        ///0x04 - Prescaler register (IWDG_PSCR)
        pub pscr: PSCR,
        _reserved2: [u8; 0x02],
        ///0x08 - Reload register (IWDG_RLDR)
        pub rldr: RLDR,
        _reserved3: [u8; 0x02],
        ///0x0c - Status register (IWDG_SR)
        pub statr: STATR,
    }
    ///CTLR (w) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Key register (IWDG_CTLR)
    pub mod ctlr {
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Key value
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u16)]
        pub enum KEY_AW {
            ///43690: Load IWDG_RLDR register to IWDG counter
            Feed = 43690,
            ///21845: Enable modifying IWDG_PSCR and IWDG_RLDR
            Modify = 21845,
            ///52428: Launch watch dog
            Launch = 52428,
        }
        impl From<KEY_AW> for u16 {
            #[inline(always)]
            fn from(variant: KEY_AW) -> Self {
                variant as _
            }
        }
        ///Field `KEY` writer - Key value
        pub type KEY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CTLR_SPEC, u16, KEY_AW, 16, O>;
        impl<'a, const O: u8> KEY_W<'a, O> {
            ///Load IWDG_RLDR register to IWDG counter
            #[inline(always)]
            pub fn feed(self) -> &'a mut W {
                self.variant(KEY_AW::Feed)
            }
            ///Enable modifying IWDG_PSCR and IWDG_RLDR
            #[inline(always)]
            pub fn modify(self) -> &'a mut W {
                self.variant(KEY_AW::Modify)
            }
            ///Launch watch dog
            #[inline(always)]
            pub fn launch(self) -> &'a mut W {
                self.variant(KEY_AW::Launch)
            }
        }
        impl W {
            ///Bits 0:15 - Key value
            #[inline(always)]
            #[must_use]
            pub fn key(&mut self) -> KEY_W<0> {
                KEY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Key register (IWDG_CTLR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PSCR (rw) register accessor: an alias for `Reg<PSCR_SPEC>`
    pub type PSCR = crate::Reg<pscr::PSCR_SPEC>;
    ///Prescaler register (IWDG_PSCR)
    pub mod pscr {
        ///Register `PSCR` reader
        pub struct R(crate::R<PSCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PSCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PSCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSCR` writer
        pub struct W(crate::W<PSCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSCR` reader - Prescaler divider
        pub type PSCR_R = crate::FieldReader<u8, PSCR_A>;
        ///Prescaler divider
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum PSCR_A {
            ///0: IWDG Clock = LSI / 4
            Div4 = 0,
            ///1: IWDG Clock = LSI / 8
            Div8 = 1,
            ///2: IWDG Clock = LSI / 16
            Div16 = 2,
            ///3: IWDG Clock = LSI / 32
            Div32 = 3,
            ///4: IWDG Clock = LSI / 64
            Div64 = 4,
            ///5: IWDG Clock = LSI / 128
            Div128 = 5,
            ///6: IWDG Clock = LSI / 256
            Div256 = 6,
        }
        impl From<PSCR_A> for u8 {
            #[inline(always)]
            fn from(variant: PSCR_A) -> Self {
                variant as _
            }
        }
        impl PSCR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PSCR_A> {
                match self.bits {
                    0 => Some(PSCR_A::Div4),
                    1 => Some(PSCR_A::Div8),
                    2 => Some(PSCR_A::Div16),
                    3 => Some(PSCR_A::Div32),
                    4 => Some(PSCR_A::Div64),
                    5 => Some(PSCR_A::Div128),
                    6 => Some(PSCR_A::Div256),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == PSCR_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == PSCR_A::Div8
            }
            ///Checks if the value of the field is `Div16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == PSCR_A::Div16
            }
            ///Checks if the value of the field is `Div32`
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == PSCR_A::Div32
            }
            ///Checks if the value of the field is `Div64`
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == PSCR_A::Div64
            }
            ///Checks if the value of the field is `Div128`
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == PSCR_A::Div128
            }
            ///Checks if the value of the field is `Div256`
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == PSCR_A::Div256
            }
        }
        ///Field `PSCR` writer - Prescaler divider
        pub type PSCR_W<'a, const O: u8> = crate::FieldWriter<'a, u16, PSCR_SPEC, u8, PSCR_A, 3, O>;
        impl<'a, const O: u8> PSCR_W<'a, O> {
            ///IWDG Clock = LSI / 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PSCR_A::Div4)
            }
            ///IWDG Clock = LSI / 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PSCR_A::Div8)
            }
            ///IWDG Clock = LSI / 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PSCR_A::Div16)
            }
            ///IWDG Clock = LSI / 32
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(PSCR_A::Div32)
            }
            ///IWDG Clock = LSI / 64
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(PSCR_A::Div64)
            }
            ///IWDG Clock = LSI / 128
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(PSCR_A::Div128)
            }
            ///IWDG Clock = LSI / 256
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(PSCR_A::Div256)
            }
        }
        impl R {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            pub fn pscr(&self) -> PSCR_R {
                PSCR_R::new((self.bits & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            #[must_use]
            pub fn pscr(&mut self) -> PSCR_W<0> {
                PSCR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Prescaler register (IWDG_PSCR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pscr](index.html) module
        pub struct PSCR_SPEC;
        impl crate::RegisterSpec for PSCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [pscr::R](R) reader structure
        impl crate::Readable for PSCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pscr::W](W) writer structure
        impl crate::Writable for PSCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSCR to value 0
        impl crate::Resettable for PSCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RLDR (rw) register accessor: an alias for `Reg<RLDR_SPEC>`
    pub type RLDR = crate::Reg<rldr::RLDR_SPEC>;
    ///Reload register (IWDG_RLDR)
    pub mod rldr {
        ///Register `RLDR` reader
        pub struct R(crate::R<RLDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RLDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RLDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RLDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RLDR` writer
        pub struct W(crate::W<RLDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RLDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RLDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RLDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RL` reader - Watchdog counter reload value
        pub type RL_R = crate::FieldReader<u16, u16>;
        ///Field `RL` writer - Watchdog counter reload value
        pub type RL_W<'a, const O: u8> = crate::FieldWriter<'a, u16, RLDR_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            pub fn rl(&self) -> RL_R {
                RL_R::new(self.bits & 0x0fff)
            }
        }
        impl W {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            #[must_use]
            pub fn rl(&mut self) -> RL_W<0> {
                RL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Reload register (IWDG_RLDR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rldr](index.html) module
        pub struct RLDR_SPEC;
        impl crate::RegisterSpec for RLDR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [rldr::R](R) reader structure
        impl crate::Readable for RLDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rldr::W](W) writer structure
        impl crate::Writable for RLDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RLDR to value 0x0fff
        impl crate::Resettable for RLDR_SPEC {
            const RESET_VALUE: Self::Ux = 0x0fff;
        }
    }
    ///STATR (r) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register (IWDG_SR)
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PVU` reader - Watchdog prescaler value update
        pub type PVU_R = crate::BitReader<PVUR_A>;
        ///Watchdog prescaler value update
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PVUR_A {
            ///0: Update done
            Done = 0,
            ///1: Updating data
            Updating = 1,
        }
        impl From<PVUR_A> for bool {
            #[inline(always)]
            fn from(variant: PVUR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PVU_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PVUR_A {
                match self.bits {
                    false => PVUR_A::Done,
                    true => PVUR_A::Updating,
                }
            }
            ///Checks if the value of the field is `Done`
            #[inline(always)]
            pub fn is_done(&self) -> bool {
                *self == PVUR_A::Done
            }
            ///Checks if the value of the field is `Updating`
            #[inline(always)]
            pub fn is_updating(&self) -> bool {
                *self == PVUR_A::Updating
            }
        }
        ///Field `RVU` reader - Watchdog counter reload value update
        pub type RVU_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Watchdog prescaler value update
            #[inline(always)]
            pub fn pvu(&self) -> PVU_R {
                PVU_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Watchdog counter reload value update
            #[inline(always)]
            pub fn rvu(&self) -> RVU_R {
                RVU_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///Status register (IWDG_SR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Window watchdog
pub struct WWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDG {}
impl WWDG {
    ///Pointer to the register block
    pub const PTR: *const wwdg::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const wwdg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WWDG {
    type Target = wwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WWDG").finish()
    }
}
///Window watchdog
pub mod wwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register (WWDG_CR)
        pub ctlr: CTLR,
        _reserved1: [u8; 0x02],
        ///0x04 - Configuration register (WWDG_CFR)
        pub cfgr: CFGR,
        _reserved2: [u8; 0x02],
        ///0x08 - Status register (WWDG_SR)
        pub statr: STATR,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register (WWDG_CR)
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `T` reader - 7-bit counter (MSB to LSB)
        pub type T_R = crate::FieldReader<u8, u8>;
        ///Field `T` writer - 7-bit counter (MSB to LSB)
        pub type T_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CTLR_SPEC, u8, u8, 7, O>;
        ///Field `WDGA` reader - Activation bit
        pub type WDGA_R = crate::BitReader<WDGAR_A>;
        ///Activation bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WDGAR_A {
            ///0: WWDG disabled
            Disabled = 0,
            ///1: WWDG enabled
            Enabled = 1,
        }
        impl From<WDGAR_A> for bool {
            #[inline(always)]
            fn from(variant: WDGAR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WDGA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WDGAR_A {
                match self.bits {
                    false => WDGAR_A::Disabled,
                    true => WDGAR_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WDGAR_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WDGAR_A::Enabled
            }
        }
        ///Activation bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WDGAW_AW {
            ///1: Enable WWDG
            Enable = 1,
        }
        impl From<WDGAW_AW> for bool {
            #[inline(always)]
            fn from(variant: WDGAW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WDGA` writer - Activation bit
        pub type WDGA_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR_SPEC, WDGAW_AW, O>;
        impl<'a, const O: u8> WDGA_W<'a, O> {
            ///Enable WWDG
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(WDGAW_AW::Enable)
            }
        }
        impl R {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            pub fn t(&self) -> T_R {
                T_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            pub fn wdga(&self) -> WDGA_R {
                WDGA_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            #[must_use]
            pub fn t(&mut self) -> T_W<0> {
                T_W::new(self)
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            #[must_use]
            pub fn wdga(&mut self) -> WDGA_W<7> {
                WDGA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register (WWDG_CR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0x7f
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x7f;
        }
    }
    ///CFGR (rw) register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Configuration register (WWDG_CFR)
    pub mod cfgr {
        ///Register `CFGR` reader
        pub struct R(crate::R<CFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `W` reader - 7-bit window value
        pub type W_R = crate::FieldReader<u8, u8>;
        ///Field `W` writer - 7-bit window value
        pub type W_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CFGR_SPEC, u8, u8, 7, O>;
        ///Field `WDGTB` reader - Timer Base
        pub type WDGTB_R = crate::FieldReader<u8, WDGTB_A>;
        ///Timer Base
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum WDGTB_A {
            ///0: WWDG Clock = PCLK1 / 4096
            NoDiv = 0,
            ///1: WWDG Clock = PCLK1 / 4096 / 2
            Div2 = 1,
            ///2: WWDG Clock = PCLK1 / 4096 / 4
            Div4 = 2,
            ///3: WWDG Clock = PCLK1 / 4096 / 8
            Div8 = 3,
        }
        impl From<WDGTB_A> for u8 {
            #[inline(always)]
            fn from(variant: WDGTB_A) -> Self {
                variant as _
            }
        }
        impl WDGTB_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WDGTB_A {
                match self.bits {
                    0 => WDGTB_A::NoDiv,
                    1 => WDGTB_A::Div2,
                    2 => WDGTB_A::Div4,
                    3 => WDGTB_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == WDGTB_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == WDGTB_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == WDGTB_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == WDGTB_A::Div8
            }
        }
        ///Field `WDGTB` writer - Timer Base
        pub type WDGTB_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CFGR_SPEC, u8, WDGTB_A, 2, O>;
        impl<'a, const O: u8> WDGTB_W<'a, O> {
            ///WWDG Clock = PCLK1 / 4096
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(WDGTB_A::NoDiv)
            }
            ///WWDG Clock = PCLK1 / 4096 / 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(WDGTB_A::Div2)
            }
            ///WWDG Clock = PCLK1 / 4096 / 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(WDGTB_A::Div4)
            }
            ///WWDG Clock = PCLK1 / 4096 / 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(WDGTB_A::Div8)
            }
        }
        ///Field `EWI` reader - Early Wakeup Interrupt
        pub type EWI_R = crate::BitReader<EWIR_A>;
        ///Early Wakeup Interrupt
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EWIR_A {
            ///0: Early wake up interrupt disabled
            Disabled = 0,
            ///1: Early wake up interrupt enabled
            Enabled = 1,
        }
        impl From<EWIR_A> for bool {
            #[inline(always)]
            fn from(variant: EWIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EWI_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EWIR_A {
                match self.bits {
                    false => EWIR_A::Disabled,
                    true => EWIR_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EWIR_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EWIR_A::Enabled
            }
        }
        ///Early Wakeup Interrupt
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EWIW_AW {
            ///1: Enable early wake up interrupt
            Enable = 1,
        }
        impl From<EWIW_AW> for bool {
            #[inline(always)]
            fn from(variant: EWIW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EWI` writer - Early Wakeup Interrupt
        pub type EWI_W<'a, const O: u8> = crate::BitWriter<'a, u16, CFGR_SPEC, EWIW_AW, O>;
        impl<'a, const O: u8> EWI_W<'a, O> {
            ///Enable early wake up interrupt
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(EWIW_AW::Enable)
            }
        }
        impl R {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            pub fn w(&self) -> W_R {
                W_R::new((self.bits & 0x7f) as u8)
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            pub fn wdgtb(&self) -> WDGTB_R {
                WDGTB_R::new(((self.bits >> 7) & 3) as u8)
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            pub fn ewi(&self) -> EWI_R {
                EWI_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            #[must_use]
            pub fn w(&mut self) -> W_W<0> {
                W_W::new(self)
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            #[must_use]
            pub fn wdgtb(&mut self) -> WDGTB_W<7> {
                WDGTB_W::new(self)
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            #[must_use]
            pub fn ewi(&mut self) -> EWI_W<9> {
                EWI_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Configuration register (WWDG_CFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cfgr::R](R) reader structure
        impl crate::Readable for CFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR to value 0x7f
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0x7f;
        }
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register (WWDG_SR)
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WEIF` reader - Early Wakeup Interrupt Flag
        pub type WEIF_R = crate::BitReader<WEIFR_A>;
        ///Early Wakeup Interrupt Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WEIFR_A {
            ///0: No early wake up
            Normal = 0,
            ///1: Early wake up occurred
            WakenUp = 1,
        }
        impl From<WEIFR_A> for bool {
            #[inline(always)]
            fn from(variant: WEIFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WEIF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WEIFR_A {
                match self.bits {
                    false => WEIFR_A::Normal,
                    true => WEIFR_A::WakenUp,
                }
            }
            ///Checks if the value of the field is `Normal`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == WEIFR_A::Normal
            }
            ///Checks if the value of the field is `WakenUp`
            #[inline(always)]
            pub fn is_waken_up(&self) -> bool {
                *self == WEIFR_A::WakenUp
            }
        }
        ///Early Wakeup Interrupt Flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WEIFW_AW {
            ///0: Reset early wake up flag
            Reset = 0,
        }
        impl From<WEIFW_AW> for bool {
            #[inline(always)]
            fn from(variant: WEIFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WEIF` writer - Early Wakeup Interrupt Flag
        pub type WEIF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STATR_SPEC, WEIFW_AW, O>;
        impl<'a, const O: u8> WEIF_W<'a, O> {
            ///Reset early wake up flag
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(WEIFW_AW::Reset)
            }
        }
        impl R {
            ///Bit 0 - Early Wakeup Interrupt Flag
            #[inline(always)]
            pub fn weif(&self) -> WEIF_R {
                WEIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Early Wakeup Interrupt Flag
            #[inline(always)]
            #[must_use]
            pub fn weif(&mut self) -> WEIF_W<0> {
                WEIF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register (WWDG_SR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x01;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Advanced timer
pub struct TIM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM1 {}
impl TIM1 {
    ///Pointer to the register block
    pub const PTR: *const tim1::RegisterBlock = 0x4001_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM1 {
    type Target = tim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM1").finish()
    }
}
///Advanced timer
pub mod tim1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ///0x04 - control register 2
        pub ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        ///0x08 - slave mode control register
        pub smcfgr: SMCFGR,
        _reserved3: [u8; 0x02],
        ///0x0c - DMA/Interrupt enable register
        pub dmaintenr: DMAINTENR,
        _reserved4: [u8; 0x02],
        ///0x10 - status register
        pub intfr: INTFR,
        _reserved5: [u8; 0x02],
        ///0x14 - event generation register
        pub swevgr: SWEVGR,
        _reserved6: [u8; 0x02],
        _reserved_6_chctlr: [u8; 0x02],
        _reserved7: [u8; 0x02],
        _reserved_7_chctlr: [u8; 0x02],
        _reserved8: [u8; 0x02],
        ///0x20 - capture/compare enable register
        pub ccer: CCER,
        _reserved9: [u8; 0x02],
        ///0x24 - counter
        pub cnt: CNT,
        _reserved10: [u8; 0x02],
        ///0x28 - prescaler
        pub psc: PSC,
        _reserved11: [u8; 0x02],
        ///0x2c - auto-reload register
        pub atrlr: ATRLR,
        _reserved12: [u8; 0x02],
        ///0x30 - repetition counter register
        pub rptcr: RPTCR,
        _reserved13: [u8; 0x02],
        ///0x34 - capture/compare register 1
        pub ch1cvr: CH1CVR,
        _reserved14: [u8; 0x02],
        ///0x38 - capture/compare register 2
        pub ch2cvr: CH2CVR,
        _reserved15: [u8; 0x02],
        ///0x3c - capture/compare register 3
        pub ch3cvr: CH3CVR,
        _reserved16: [u8; 0x02],
        ///0x40 - capture/compare register 4
        pub ch4cvr: CH4CVR,
        _reserved17: [u8; 0x02],
        ///0x44 - break and dead-time register
        pub bdtr: BDTR,
        _reserved18: [u8; 0x02],
        ///0x48 - DMA control register
        pub dmacfgr: DMACFGR,
        _reserved19: [u8; 0x02],
        ///0x4c - DMA address for full transfer
        pub dmar: DMAR,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub const fn chctlr1i(&self) -> &CHCTLR1I {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr1o(&self) -> &CHCTLR1O {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub const fn chctlr2i(&self) -> &CHCTLR2I {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
        ///0x1c - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr2o(&self) -> &CHCTLR2O {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CEN` reader - Counter enable
        pub type CEN_R = crate::BitReader<CEN_A>;
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CEN_A {
            ///0: Counter disabled
            Disabled = 0,
            ///1: Counter enabled
            Enabled = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::Disabled,
                    true => CEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::Enabled
            }
        }
        ///Field `CEN` writer - Counter enable
        pub type CEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, CEN_A, O>;
        impl<'a, const O: u8> CEN_W<'a, O> {
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::Disabled)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::Enabled)
            }
        }
        ///Field `UDIS` reader - Update disable
        pub type UDIS_R = crate::BitReader<UDIS_A>;
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UDIS_A {
            ///0: UEV enabled
            Enabled = 0,
            ///1: UEV disabled
            Disabled = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UDIS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::Enabled,
                    true => UDIS_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::Disabled
            }
        }
        ///Field `UDIS` writer - Update disable
        pub type UDIS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, UDIS_A, O>;
        impl<'a, const O: u8> UDIS_W<'a, O> {
            ///UEV enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::Enabled)
            }
            ///UEV disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::Disabled)
            }
        }
        ///Field `URS` reader - Update request source
        pub type URS_R = crate::BitReader<URS_A>;
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum URS_A {
            ///0: Multiple source for update event
            Multiple = 0,
            ///1: Only overflow can trigger update event
            Overflow = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl URS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::Multiple,
                    true => URS_A::Overflow,
                }
            }
            ///Checks if the value of the field is `Multiple`
            #[inline(always)]
            pub fn is_multiple(&self) -> bool {
                *self == URS_A::Multiple
            }
            ///Checks if the value of the field is `Overflow`
            #[inline(always)]
            pub fn is_overflow(&self) -> bool {
                *self == URS_A::Overflow
            }
        }
        ///Field `URS` writer - Update request source
        pub type URS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, URS_A, O>;
        impl<'a, const O: u8> URS_W<'a, O> {
            ///Multiple source for update event
            #[inline(always)]
            pub fn multiple(self) -> &'a mut W {
                self.variant(URS_A::Multiple)
            }
            ///Only overflow can trigger update event
            #[inline(always)]
            pub fn overflow(self) -> &'a mut W {
                self.variant(URS_A::Overflow)
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub type OPM_R = crate::BitReader<OPM_A>;
        ///One-pulse mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OPM_A {
            ///0: One pulse mode disabled
            Disabled = 0,
            ///1: One pulse mode enabled
            Enabled = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OPM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::Disabled,
                    true => OPM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::Enabled
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub type OPM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, OPM_A, O>;
        impl<'a, const O: u8> OPM_W<'a, O> {
            ///One pulse mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::Disabled)
            }
            ///One pulse mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::Enabled)
            }
        }
        ///Field `DIR` reader - Direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Decrement counter
            Decrement = 0,
            ///1: Increment counter
            Increment = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Decrement,
                    true => DIR_A::Increment,
                }
            }
            ///Checks if the value of the field is `Decrement`
            #[inline(always)]
            pub fn is_decrement(&self) -> bool {
                *self == DIR_A::Decrement
            }
            ///Checks if the value of the field is `Increment`
            #[inline(always)]
            pub fn is_increment(&self) -> bool {
                *self == DIR_A::Increment
            }
        }
        ///Field `DIR` writer - Direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Decrement counter
            #[inline(always)]
            pub fn decrement(self) -> &'a mut W {
                self.variant(DIR_A::Decrement)
            }
            ///Increment counter
            #[inline(always)]
            pub fn increment(self) -> &'a mut W {
                self.variant(DIR_A::Increment)
            }
        }
        ///Field `CMS` reader - Center-aligned mode selection
        pub type CMS_R = crate::FieldReader<u8, CMS_A>;
        ///Center-aligned mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CMS_A {
            ///0: Counter increment or dicrement according to DIR
            Edge = 0,
            ///1: Center alignment mode 1
            Center1 = 1,
            ///2: Center alignment mode 2
            Center2 = 2,
            ///3: Center alignment mode 3
            Center3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        impl CMS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::Edge,
                    1 => CMS_A::Center1,
                    2 => CMS_A::Center2,
                    3 => CMS_A::Center3,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Edge`
            #[inline(always)]
            pub fn is_edge(&self) -> bool {
                *self == CMS_A::Edge
            }
            ///Checks if the value of the field is `Center1`
            #[inline(always)]
            pub fn is_center1(&self) -> bool {
                *self == CMS_A::Center1
            }
            ///Checks if the value of the field is `Center2`
            #[inline(always)]
            pub fn is_center2(&self) -> bool {
                *self == CMS_A::Center2
            }
            ///Checks if the value of the field is `Center3`
            #[inline(always)]
            pub fn is_center3(&self) -> bool {
                *self == CMS_A::Center3
            }
        }
        ///Field `CMS` writer - Center-aligned mode selection
        pub type CMS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CTLR1_SPEC, u8, CMS_A, 2, O>;
        impl<'a, const O: u8> CMS_W<'a, O> {
            ///Counter increment or dicrement according to DIR
            #[inline(always)]
            pub fn edge(self) -> &'a mut W {
                self.variant(CMS_A::Edge)
            }
            ///Center alignment mode 1
            #[inline(always)]
            pub fn center1(self) -> &'a mut W {
                self.variant(CMS_A::Center1)
            }
            ///Center alignment mode 2
            #[inline(always)]
            pub fn center2(self) -> &'a mut W {
                self.variant(CMS_A::Center2)
            }
            ///Center alignment mode 3
            #[inline(always)]
            pub fn center3(self) -> &'a mut W {
                self.variant(CMS_A::Center3)
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub type ARPE_R = crate::BitReader<ARPE_A>;
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ARPE_A {
            ///0: Auto reload preset disabled
            Disabled = 0,
            ///1: Auto reload preset enabled
            Enabled = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ARPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::Disabled,
                    true => ARPE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::Enabled
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub type ARPE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, ARPE_A, O>;
        impl<'a, const O: u8> ARPE_W<'a, O> {
            ///Auto reload preset disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::Disabled)
            }
            ///Auto reload preset enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::Enabled)
            }
        }
        ///Field `CKD` reader - Clock division
        pub type CKD_R = crate::FieldReader<u8, CKD_A>;
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: Tdts = Tck_int
            Tck = 0,
            ///1: Tdts = Tck_int * 2
            Tck2 = 1,
            ///2: Tdts = Tck_int * 4
            Tck4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        impl CKD_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::Tck),
                    1 => Some(CKD_A::Tck2),
                    2 => Some(CKD_A::Tck4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Tck`
            #[inline(always)]
            pub fn is_tck(&self) -> bool {
                *self == CKD_A::Tck
            }
            ///Checks if the value of the field is `Tck2`
            #[inline(always)]
            pub fn is_tck2(&self) -> bool {
                *self == CKD_A::Tck2
            }
            ///Checks if the value of the field is `Tck4`
            #[inline(always)]
            pub fn is_tck4(&self) -> bool {
                *self == CKD_A::Tck4
            }
        }
        ///Field `CKD` writer - Clock division
        pub type CKD_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CTLR1_SPEC, u8, CKD_A, 2, O>;
        impl<'a, const O: u8> CKD_W<'a, O> {
            ///Tdts = Tck_int
            #[inline(always)]
            pub fn tck(self) -> &'a mut W {
                self.variant(CKD_A::Tck)
            }
            ///Tdts = Tck_int * 2
            #[inline(always)]
            pub fn tck2(self) -> &'a mut W {
                self.variant(CKD_A::Tck2)
            }
            ///Tdts = Tck_int * 4
            #[inline(always)]
            pub fn tck4(self) -> &'a mut W {
                self.variant(CKD_A::Tck4)
            }
        }
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 3) as u8)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            #[must_use]
            pub fn cen(&mut self) -> CEN_W<0> {
                CEN_W::new(self)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            #[must_use]
            pub fn udis(&mut self) -> UDIS_W<1> {
                UDIS_W::new(self)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            #[must_use]
            pub fn urs(&mut self) -> URS_W<2> {
                URS_W::new(self)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            #[must_use]
            pub fn opm(&mut self) -> OPM_W<3> {
                OPM_W::new(self)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            #[must_use]
            pub fn cms(&mut self) -> CMS_W<5> {
                CMS_W::new(self)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn arpe(&mut self) -> ARPE_W<7> {
                ARPE_W::new(self)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            #[must_use]
            pub fn ckd(&mut self) -> CKD_W<8> {
                CKD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCPC` reader - Capture/compare preloaded control
        pub type CCPC_R = crate::BitReader<CCPC_A>;
        ///Capture/compare preloaded control
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CCPC_A {
            ///0: CCxE CCxNE OCxM not preloaded
            NotPreloaded = 0,
            ///1: CCxE CCxNE OCxM preloaded
            Preloaded = 1,
        }
        impl From<CCPC_A> for bool {
            #[inline(always)]
            fn from(variant: CCPC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CCPC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCPC_A {
                match self.bits {
                    false => CCPC_A::NotPreloaded,
                    true => CCPC_A::Preloaded,
                }
            }
            ///Checks if the value of the field is `NotPreloaded`
            #[inline(always)]
            pub fn is_not_preloaded(&self) -> bool {
                *self == CCPC_A::NotPreloaded
            }
            ///Checks if the value of the field is `Preloaded`
            #[inline(always)]
            pub fn is_preloaded(&self) -> bool {
                *self == CCPC_A::Preloaded
            }
        }
        ///Field `CCPC` writer - Capture/compare preloaded control
        pub type CCPC_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, CCPC_A, O>;
        impl<'a, const O: u8> CCPC_W<'a, O> {
            ///CCxE CCxNE OCxM not preloaded
            #[inline(always)]
            pub fn not_preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::NotPreloaded)
            }
            ///CCxE CCxNE OCxM preloaded
            #[inline(always)]
            pub fn preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::Preloaded)
            }
        }
        ///Field `CCUS` reader - Capture/compare control update selection
        pub type CCUS_R = crate::BitReader<CCUS_A>;
        ///Capture/compare control update selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CCUS_A {
            ///0: Only update on COM set
            Comonly = 0,
            ///1: Update on COM set or TRGI rising edge
            Multiple = 1,
        }
        impl From<CCUS_A> for bool {
            #[inline(always)]
            fn from(variant: CCUS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CCUS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCUS_A {
                match self.bits {
                    false => CCUS_A::Comonly,
                    true => CCUS_A::Multiple,
                }
            }
            ///Checks if the value of the field is `Comonly`
            #[inline(always)]
            pub fn is_comonly(&self) -> bool {
                *self == CCUS_A::Comonly
            }
            ///Checks if the value of the field is `Multiple`
            #[inline(always)]
            pub fn is_multiple(&self) -> bool {
                *self == CCUS_A::Multiple
            }
        }
        ///Field `CCUS` writer - Capture/compare control update selection
        pub type CCUS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, CCUS_A, O>;
        impl<'a, const O: u8> CCUS_W<'a, O> {
            ///Only update on COM set
            #[inline(always)]
            pub fn comonly(self) -> &'a mut W {
                self.variant(CCUS_A::Comonly)
            }
            ///Update on COM set or TRGI rising edge
            #[inline(always)]
            pub fn multiple(self) -> &'a mut W {
                self.variant(CCUS_A::Multiple)
            }
        }
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub type CCDS_R = crate::BitReader<CCDS_A>;
        ///Capture/compare DMA selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CCDS_A {
            ///0: Request DMA on CHxCVR
            ChxCvr = 0,
            ///1: Request DMA on update event
            Update = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CCDS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ChxCvr,
                    true => CCDS_A::Update,
                }
            }
            ///Checks if the value of the field is `ChxCvr`
            #[inline(always)]
            pub fn is_chx_cvr(&self) -> bool {
                *self == CCDS_A::ChxCvr
            }
            ///Checks if the value of the field is `Update`
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == CCDS_A::Update
            }
        }
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub type CCDS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, CCDS_A, O>;
        impl<'a, const O: u8> CCDS_W<'a, O> {
            ///Request DMA on CHxCVR
            #[inline(always)]
            pub fn chx_cvr(self) -> &'a mut W {
                self.variant(CCDS_A::ChxCvr)
            }
            ///Request DMA on update event
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(CCDS_A::Update)
            }
        }
        ///Field `MMS` reader - Master mode selection
        pub type MMS_R = crate::FieldReader<u8, MMS_A>;
        ///Master mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MMS_A {
            ///0: TIMx_EGR register UG bit used as trigger output(TRG0)
            Reset = 0,
            ///1: CNT_EN bit used as trigger output(TRG0)
            Enable = 1,
            ///2: Update event used as trigger input(TRG0)
            Update = 2,
            ///3: Trigger output(TRG0) on CC1IF set
            CmpCc1if = 3,
            ///4: OC1REF signal used as trigger output(TRG0)
            CmpOc1ref = 4,
            ///5: OC2REF signal used as trigger output(TRG0)
            CmpOc2ref = 5,
            ///6: OC3REF signal used as trigger output(TRG0)
            CmpOc3ref = 6,
            ///7: OC4REF signal used as trigger output(TRG0)
            CmpOc4ref = 7,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        impl MMS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MMS_A {
                match self.bits {
                    0 => MMS_A::Reset,
                    1 => MMS_A::Enable,
                    2 => MMS_A::Update,
                    3 => MMS_A::CmpCc1if,
                    4 => MMS_A::CmpOc1ref,
                    5 => MMS_A::CmpOc2ref,
                    6 => MMS_A::CmpOc3ref,
                    7 => MMS_A::CmpOc4ref,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::Reset
            }
            ///Checks if the value of the field is `Enable`
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::Enable
            }
            ///Checks if the value of the field is `Update`
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::Update
            }
            ///Checks if the value of the field is `CmpCc1if`
            #[inline(always)]
            pub fn is_cmp_cc1if(&self) -> bool {
                *self == MMS_A::CmpCc1if
            }
            ///Checks if the value of the field is `CmpOc1ref`
            #[inline(always)]
            pub fn is_cmp_oc1ref(&self) -> bool {
                *self == MMS_A::CmpOc1ref
            }
            ///Checks if the value of the field is `CmpOc2ref`
            #[inline(always)]
            pub fn is_cmp_oc2ref(&self) -> bool {
                *self == MMS_A::CmpOc2ref
            }
            ///Checks if the value of the field is `CmpOc3ref`
            #[inline(always)]
            pub fn is_cmp_oc3ref(&self) -> bool {
                *self == MMS_A::CmpOc3ref
            }
            ///Checks if the value of the field is `CmpOc4ref`
            #[inline(always)]
            pub fn is_cmp_oc4ref(&self) -> bool {
                *self == MMS_A::CmpOc4ref
            }
        }
        ///Field `MMS` writer - Master mode selection
        pub type MMS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CTLR2_SPEC, u8, MMS_A, 3, O>;
        impl<'a, const O: u8> MMS_W<'a, O> {
            ///TIMx_EGR register UG bit used as trigger output(TRG0)
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::Reset)
            }
            ///CNT_EN bit used as trigger output(TRG0)
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::Enable)
            }
            ///Update event used as trigger input(TRG0)
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::Update)
            }
            ///Trigger output(TRG0) on CC1IF set
            #[inline(always)]
            pub fn cmp_cc1if(self) -> &'a mut W {
                self.variant(MMS_A::CmpCc1if)
            }
            ///OC1REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc1ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc1ref)
            }
            ///OC2REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc2ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc2ref)
            }
            ///OC3REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc3ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc3ref)
            }
            ///OC4REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc4ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc4ref)
            }
        }
        ///Field `TI1S` reader - TI1 selection
        pub type TI1S_R = crate::BitReader<TI1S_A>;
        ///TI1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TI1S_A {
            ///0: TIMx_CH1 connected directly to TI1
            Direct = 0,
            ///1: TIMx_CH1/2/3 connected to TI1 after xor
            Xor = 1,
        }
        impl From<TI1S_A> for bool {
            #[inline(always)]
            fn from(variant: TI1S_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TI1S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TI1S_A {
                match self.bits {
                    false => TI1S_A::Direct,
                    true => TI1S_A::Xor,
                }
            }
            ///Checks if the value of the field is `Direct`
            #[inline(always)]
            pub fn is_direct(&self) -> bool {
                *self == TI1S_A::Direct
            }
            ///Checks if the value of the field is `Xor`
            #[inline(always)]
            pub fn is_xor(&self) -> bool {
                *self == TI1S_A::Xor
            }
        }
        ///Field `TI1S` writer - TI1 selection
        pub type TI1S_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, TI1S_A, O>;
        impl<'a, const O: u8> TI1S_W<'a, O> {
            ///TIMx_CH1 connected directly to TI1
            #[inline(always)]
            pub fn direct(self) -> &'a mut W {
                self.variant(TI1S_A::Direct)
            }
            ///TIMx_CH1/2/3 connected to TI1 after xor
            #[inline(always)]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1S_A::Xor)
            }
        }
        ///Field `OIS1` reader - Output Idle state 1
        pub type OIS1_R = crate::BitReader<bool>;
        ///Field `OIS1` writer - Output Idle state 1
        pub type OIS1_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS1N` reader - Output Idle state 1
        pub type OIS1N_R = crate::BitReader<bool>;
        ///Field `OIS1N` writer - Output Idle state 1
        pub type OIS1N_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS2` reader - Output Idle state 2
        pub type OIS2_R = crate::BitReader<bool>;
        ///Field `OIS2` writer - Output Idle state 2
        pub type OIS2_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS2N` reader - Output Idle state 2
        pub type OIS2N_R = crate::BitReader<bool>;
        ///Field `OIS2N` writer - Output Idle state 2
        pub type OIS2N_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS3` reader - Output Idle state 3
        pub type OIS3_R = crate::BitReader<bool>;
        ///Field `OIS3` writer - Output Idle state 3
        pub type OIS3_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS3N` reader - Output Idle state 3
        pub type OIS3N_R = crate::BitReader<bool>;
        ///Field `OIS3N` writer - Output Idle state 3
        pub type OIS3N_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS4` reader - Output Idle state 4
        pub type OIS4_R = crate::BitReader<bool>;
        ///Field `OIS4` writer - Output Idle state 4
        pub type OIS4_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            pub fn ois2n(&self) -> OIS2N_R {
                OIS2N_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            pub fn ois3(&self) -> OIS3_R {
                OIS3_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            pub fn ois3n(&self) -> OIS3N_R {
                OIS3N_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            pub fn ois4(&self) -> OIS4_R {
                OIS4_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            #[must_use]
            pub fn ccpc(&mut self) -> CCPC_W<0> {
                CCPC_W::new(self)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            #[must_use]
            pub fn ccus(&mut self) -> CCUS_W<2> {
                CCUS_W::new(self)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            #[must_use]
            pub fn ccds(&mut self) -> CCDS_W<3> {
                CCDS_W::new(self)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            #[must_use]
            pub fn mms(&mut self) -> MMS_W<4> {
                MMS_W::new(self)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            #[must_use]
            pub fn ti1s(&mut self) -> TI1S_W<7> {
                TI1S_W::new(self)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1(&mut self) -> OIS1_W<8> {
                OIS1_W::new(self)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1n(&mut self) -> OIS1N_W<9> {
                OIS1N_W::new(self)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2(&mut self) -> OIS2_W<10> {
                OIS2_W::new(self)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2n(&mut self) -> OIS2N_W<11> {
                OIS2N_W::new(self)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3(&mut self) -> OIS3_W<12> {
                OIS3_W::new(self)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3n(&mut self) -> OIS3N_W<13> {
                OIS3N_W::new(self)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            #[must_use]
            pub fn ois4(&mut self) -> OIS4_W<14> {
                OIS4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SMCFGR (rw) register accessor: an alias for `Reg<SMCFGR_SPEC>`
    pub type SMCFGR = crate::Reg<smcfgr::SMCFGR_SPEC>;
    ///slave mode control register
    pub mod smcfgr {
        ///Register `SMCFGR` reader
        pub struct R(crate::R<SMCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SMCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SMCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCFGR` writer
        pub struct W(crate::W<SMCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SMCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SMCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub type SMS_R = crate::FieldReader<u8, SMS_A>;
        ///Slave mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SMS_A {
            ///0: Core counter driven by CK_INT
            Internal = 0,
            ///1: Core counter increment or decrement on TI1FP1 edge with respect to TI2FP2
            Encoder1 = 1,
            ///2: Core counter increment or decrement on TI2FP2 edge with respect to TI1FP1
            Encoder2 = 2,
            ///3: Core counter increment or decrement on TI1FP1/TI2FP2 edge with respect to another signal
            Encoder3 = 3,
            ///4: Rising edge on TRGI will reset the counter
            Reset = 4,
            ///5: Counter clock start/stop with respect to TRGI
            Gate = 5,
            ///6: Counter start on TRGI rising edge
            Trigger = 6,
            ///7: Counter driven by TRGI rising edge
            External = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        impl SMS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::Internal,
                    1 => SMS_A::Encoder1,
                    2 => SMS_A::Encoder2,
                    3 => SMS_A::Encoder3,
                    4 => SMS_A::Reset,
                    5 => SMS_A::Gate,
                    6 => SMS_A::Trigger,
                    7 => SMS_A::External,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Internal`
            #[inline(always)]
            pub fn is_internal(&self) -> bool {
                *self == SMS_A::Internal
            }
            ///Checks if the value of the field is `Encoder1`
            #[inline(always)]
            pub fn is_encoder1(&self) -> bool {
                *self == SMS_A::Encoder1
            }
            ///Checks if the value of the field is `Encoder2`
            #[inline(always)]
            pub fn is_encoder2(&self) -> bool {
                *self == SMS_A::Encoder2
            }
            ///Checks if the value of the field is `Encoder3`
            #[inline(always)]
            pub fn is_encoder3(&self) -> bool {
                *self == SMS_A::Encoder3
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == SMS_A::Reset
            }
            ///Checks if the value of the field is `Gate`
            #[inline(always)]
            pub fn is_gate(&self) -> bool {
                *self == SMS_A::Gate
            }
            ///Checks if the value of the field is `Trigger`
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                *self == SMS_A::Trigger
            }
            ///Checks if the value of the field is `External`
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == SMS_A::External
            }
        }
        ///Field `SMS` writer - Slave mode selection
        pub type SMS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, SMS_A, 3, O>;
        impl<'a, const O: u8> SMS_W<'a, O> {
            ///Core counter driven by CK_INT
            #[inline(always)]
            pub fn internal(self) -> &'a mut W {
                self.variant(SMS_A::Internal)
            }
            ///Core counter increment or decrement on TI1FP1 edge with respect to TI2FP2
            #[inline(always)]
            pub fn encoder1(self) -> &'a mut W {
                self.variant(SMS_A::Encoder1)
            }
            ///Core counter increment or decrement on TI2FP2 edge with respect to TI1FP1
            #[inline(always)]
            pub fn encoder2(self) -> &'a mut W {
                self.variant(SMS_A::Encoder2)
            }
            ///Core counter increment or decrement on TI1FP1/TI2FP2 edge with respect to another signal
            #[inline(always)]
            pub fn encoder3(self) -> &'a mut W {
                self.variant(SMS_A::Encoder3)
            }
            ///Rising edge on TRGI will reset the counter
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SMS_A::Reset)
            }
            ///Counter clock start/stop with respect to TRGI
            #[inline(always)]
            pub fn gate(self) -> &'a mut W {
                self.variant(SMS_A::Gate)
            }
            ///Counter start on TRGI rising edge
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(SMS_A::Trigger)
            }
            ///Counter driven by TRGI rising edge
            #[inline(always)]
            pub fn external(self) -> &'a mut W {
                self.variant(SMS_A::External)
            }
        }
        ///Field `TS` reader - Trigger selection
        pub type TS_R = crate::FieldReader<u8, TS_A>;
        ///Trigger selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TS_A {
            ///0: ITR0 as trigger
            Internal0 = 0,
            ///1: ITR1 as trigger
            Internal1 = 1,
            ///2: ITR2 as trigger
            Internal2 = 2,
            ///3: ITR3 as trigger
            Internal3 = 3,
            ///4: TI1 edge dector
            Ti1edge = 4,
            ///5: Filtered timer input 1
            Ti1fp1 = 5,
            ///6: Filtered timer input 2
            Ti2fp2 = 6,
            ///7: External trigger input
            External = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        impl TS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TS_A {
                match self.bits {
                    0 => TS_A::Internal0,
                    1 => TS_A::Internal1,
                    2 => TS_A::Internal2,
                    3 => TS_A::Internal3,
                    4 => TS_A::Ti1edge,
                    5 => TS_A::Ti1fp1,
                    6 => TS_A::Ti2fp2,
                    7 => TS_A::External,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Internal0`
            #[inline(always)]
            pub fn is_internal0(&self) -> bool {
                *self == TS_A::Internal0
            }
            ///Checks if the value of the field is `Internal1`
            #[inline(always)]
            pub fn is_internal1(&self) -> bool {
                *self == TS_A::Internal1
            }
            ///Checks if the value of the field is `Internal2`
            #[inline(always)]
            pub fn is_internal2(&self) -> bool {
                *self == TS_A::Internal2
            }
            ///Checks if the value of the field is `Internal3`
            #[inline(always)]
            pub fn is_internal3(&self) -> bool {
                *self == TS_A::Internal3
            }
            ///Checks if the value of the field is `Ti1edge`
            #[inline(always)]
            pub fn is_ti1edge(&self) -> bool {
                *self == TS_A::Ti1edge
            }
            ///Checks if the value of the field is `Ti1fp1`
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TS_A::Ti1fp1
            }
            ///Checks if the value of the field is `Ti2fp2`
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TS_A::Ti2fp2
            }
            ///Checks if the value of the field is `External`
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == TS_A::External
            }
        }
        ///Field `TS` writer - Trigger selection
        pub type TS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, TS_A, 3, O>;
        impl<'a, const O: u8> TS_W<'a, O> {
            ///ITR0 as trigger
            #[inline(always)]
            pub fn internal0(self) -> &'a mut W {
                self.variant(TS_A::Internal0)
            }
            ///ITR1 as trigger
            #[inline(always)]
            pub fn internal1(self) -> &'a mut W {
                self.variant(TS_A::Internal1)
            }
            ///ITR2 as trigger
            #[inline(always)]
            pub fn internal2(self) -> &'a mut W {
                self.variant(TS_A::Internal2)
            }
            ///ITR3 as trigger
            #[inline(always)]
            pub fn internal3(self) -> &'a mut W {
                self.variant(TS_A::Internal3)
            }
            ///TI1 edge dector
            #[inline(always)]
            pub fn ti1edge(self) -> &'a mut W {
                self.variant(TS_A::Ti1edge)
            }
            ///Filtered timer input 1
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::Ti1fp1)
            }
            ///Filtered timer input 2
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::Ti2fp2)
            }
            ///External trigger input
            #[inline(always)]
            pub fn external(self) -> &'a mut W {
                self.variant(TS_A::External)
            }
        }
        ///Field `MSM` reader - Master/Slave mode
        pub type MSM_R = crate::BitReader<MSM_A>;
        ///Master/Slave mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MSM_A {
            ///0: No effect
            NoEffect = 0,
            ///1: Trigger event on TRGI delayed
            Trgidelayed = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MSM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NoEffect,
                    true => MSM_A::Trgidelayed,
                }
            }
            ///Checks if the value of the field is `NoEffect`
            #[inline(always)]
            pub fn is_no_effect(&self) -> bool {
                *self == MSM_A::NoEffect
            }
            ///Checks if the value of the field is `Trgidelayed`
            #[inline(always)]
            pub fn is_trgidelayed(&self) -> bool {
                *self == MSM_A::Trgidelayed
            }
        }
        ///Field `MSM` writer - Master/Slave mode
        pub type MSM_W<'a, const O: u8> = crate::BitWriter<'a, u16, SMCFGR_SPEC, MSM_A, O>;
        impl<'a, const O: u8> MSM_W<'a, O> {
            ///No effect
            #[inline(always)]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(MSM_A::NoEffect)
            }
            ///Trigger event on TRGI delayed
            #[inline(always)]
            pub fn trgidelayed(self) -> &'a mut W {
                self.variant(MSM_A::Trgidelayed)
            }
        }
        ///Field `ETF` reader - External trigger filter
        pub type ETF_R = crate::FieldReader<u8, ETF_A>;
        ///External trigger filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ETF_A {
            ///0: No filter applied, sampling using Fdts
            NoFilter = 0,
            ///1: Fsampling = Fck_int, N=2
            FckN2 = 1,
            ///2: Fsampling = Fck_int, N=4
            FckN4 = 2,
            ///3: Fsampling = Fck_int, N=8
            FckN8 = 3,
            ///4: Fsampling = Fdts / 2, N=6
            Fdts2n6 = 4,
            ///5: Fsampling = Fdts / 2, N=8
            Fdts2n8 = 5,
            ///6: Fsampling = Fdts / 4, N=6
            Fdts4n6 = 6,
            ///7: Fsampling = Fdts / 4, N=8
            Fdts4n8 = 7,
            ///8: Fsampling = Fdts / 8, N=6
            Fdts8n6 = 8,
            ///9: Fsampling = Fdts / 8, N=8
            Fdts8n8 = 9,
            ///10: Fsampling = Fdts / 16, N=5
            Fdts16n5 = 10,
            ///11: Fsampling = Fdts / 16, N=6
            Fdts16n6 = 11,
            ///12: Fsampling = Fdts / 16, N=8
            Fdts16n8 = 12,
            ///13: Fsampling = Fdts / 32, N=5
            Fdts32n5 = 13,
            ///14: Fsampling = Fdts / 32, N=6
            Fdts32n6 = 14,
            ///15: Fsampling = Fdts / 32, N=8
            Fdts32n8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        impl ETF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NoFilter,
                    1 => ETF_A::FckN2,
                    2 => ETF_A::FckN4,
                    3 => ETF_A::FckN8,
                    4 => ETF_A::Fdts2n6,
                    5 => ETF_A::Fdts2n8,
                    6 => ETF_A::Fdts4n6,
                    7 => ETF_A::Fdts4n8,
                    8 => ETF_A::Fdts8n6,
                    9 => ETF_A::Fdts8n8,
                    10 => ETF_A::Fdts16n5,
                    11 => ETF_A::Fdts16n6,
                    12 => ETF_A::Fdts16n8,
                    13 => ETF_A::Fdts32n5,
                    14 => ETF_A::Fdts32n6,
                    15 => ETF_A::Fdts32n8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoFilter`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == ETF_A::NoFilter
            }
            ///Checks if the value of the field is `FckN2`
            #[inline(always)]
            pub fn is_fck_n2(&self) -> bool {
                *self == ETF_A::FckN2
            }
            ///Checks if the value of the field is `FckN4`
            #[inline(always)]
            pub fn is_fck_n4(&self) -> bool {
                *self == ETF_A::FckN4
            }
            ///Checks if the value of the field is `FckN8`
            #[inline(always)]
            pub fn is_fck_n8(&self) -> bool {
                *self == ETF_A::FckN8
            }
            ///Checks if the value of the field is `Fdts2n6`
            #[inline(always)]
            pub fn is_fdts2n6(&self) -> bool {
                *self == ETF_A::Fdts2n6
            }
            ///Checks if the value of the field is `Fdts2n8`
            #[inline(always)]
            pub fn is_fdts2n8(&self) -> bool {
                *self == ETF_A::Fdts2n8
            }
            ///Checks if the value of the field is `Fdts4n6`
            #[inline(always)]
            pub fn is_fdts4n6(&self) -> bool {
                *self == ETF_A::Fdts4n6
            }
            ///Checks if the value of the field is `Fdts4n8`
            #[inline(always)]
            pub fn is_fdts4n8(&self) -> bool {
                *self == ETF_A::Fdts4n8
            }
            ///Checks if the value of the field is `Fdts8n6`
            #[inline(always)]
            pub fn is_fdts8n6(&self) -> bool {
                *self == ETF_A::Fdts8n6
            }
            ///Checks if the value of the field is `Fdts8n8`
            #[inline(always)]
            pub fn is_fdts8n8(&self) -> bool {
                *self == ETF_A::Fdts8n8
            }
            ///Checks if the value of the field is `Fdts16n5`
            #[inline(always)]
            pub fn is_fdts16n5(&self) -> bool {
                *self == ETF_A::Fdts16n5
            }
            ///Checks if the value of the field is `Fdts16n6`
            #[inline(always)]
            pub fn is_fdts16n6(&self) -> bool {
                *self == ETF_A::Fdts16n6
            }
            ///Checks if the value of the field is `Fdts16n8`
            #[inline(always)]
            pub fn is_fdts16n8(&self) -> bool {
                *self == ETF_A::Fdts16n8
            }
            ///Checks if the value of the field is `Fdts32n5`
            #[inline(always)]
            pub fn is_fdts32n5(&self) -> bool {
                *self == ETF_A::Fdts32n5
            }
            ///Checks if the value of the field is `Fdts32n6`
            #[inline(always)]
            pub fn is_fdts32n6(&self) -> bool {
                *self == ETF_A::Fdts32n6
            }
            ///Checks if the value of the field is `Fdts32n8`
            #[inline(always)]
            pub fn is_fdts32n8(&self) -> bool {
                *self == ETF_A::Fdts32n8
            }
        }
        ///Field `ETF` writer - External trigger filter
        pub type ETF_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, ETF_A, 4, O>;
        impl<'a, const O: u8> ETF_W<'a, O> {
            ///No filter applied, sampling using Fdts
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NoFilter)
            }
            ///Fsampling = Fck_int, N=2
            #[inline(always)]
            pub fn fck_n2(self) -> &'a mut W {
                self.variant(ETF_A::FckN2)
            }
            ///Fsampling = Fck_int, N=4
            #[inline(always)]
            pub fn fck_n4(self) -> &'a mut W {
                self.variant(ETF_A::FckN4)
            }
            ///Fsampling = Fck_int, N=8
            #[inline(always)]
            pub fn fck_n8(self) -> &'a mut W {
                self.variant(ETF_A::FckN8)
            }
            ///Fsampling = Fdts / 2, N=6
            #[inline(always)]
            pub fn fdts2n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts2n6)
            }
            ///Fsampling = Fdts / 2, N=8
            #[inline(always)]
            pub fn fdts2n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts2n8)
            }
            ///Fsampling = Fdts / 4, N=6
            #[inline(always)]
            pub fn fdts4n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts4n6)
            }
            ///Fsampling = Fdts / 4, N=8
            #[inline(always)]
            pub fn fdts4n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts4n8)
            }
            ///Fsampling = Fdts / 8, N=6
            #[inline(always)]
            pub fn fdts8n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts8n6)
            }
            ///Fsampling = Fdts / 8, N=8
            #[inline(always)]
            pub fn fdts8n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts8n8)
            }
            ///Fsampling = Fdts / 16, N=5
            #[inline(always)]
            pub fn fdts16n5(self) -> &'a mut W {
                self.variant(ETF_A::Fdts16n5)
            }
            ///Fsampling = Fdts / 16, N=6
            #[inline(always)]
            pub fn fdts16n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts16n6)
            }
            ///Fsampling = Fdts / 16, N=8
            #[inline(always)]
            pub fn fdts16n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts16n8)
            }
            ///Fsampling = Fdts / 32, N=5
            #[inline(always)]
            pub fn fdts32n5(self) -> &'a mut W {
                self.variant(ETF_A::Fdts32n5)
            }
            ///Fsampling = Fdts / 32, N=6
            #[inline(always)]
            pub fn fdts32n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts32n6)
            }
            ///Fsampling = Fdts / 32, N=8
            #[inline(always)]
            pub fn fdts32n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts32n8)
            }
        }
        ///Field `ETPS` reader - External trigger prescaler
        pub type ETPS_R = crate::FieldReader<u8, ETPS_A>;
        ///External trigger prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ETPS_A {
            ///0: Pre-division off
            Off = 0,
            ///1: ETRP / 2
            Div2 = 1,
            ///2: ETRP / 4
            Div4 = 2,
            ///3: ETRP / 8
            Div8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        impl ETPS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::Off,
                    1 => ETPS_A::Div2,
                    2 => ETPS_A::Div4,
                    3 => ETPS_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Off`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == ETPS_A::Off
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ETPS_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ETPS_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ETPS_A::Div8
            }
        }
        ///Field `ETPS` writer - External trigger prescaler
        pub type ETPS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, ETPS_A, 2, O>;
        impl<'a, const O: u8> ETPS_W<'a, O> {
            ///Pre-division off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(ETPS_A::Off)
            }
            ///ETRP / 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::Div2)
            }
            ///ETRP / 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::Div4)
            }
            ///ETRP / 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::Div8)
            }
        }
        ///Field `ECE` reader - External clock enable
        pub type ECE_R = crate::BitReader<ECE_A>;
        ///External clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ECE_A {
            ///0: External Clock Mode 2 disabled
            Disabled = 0,
            ///1: External Clock Mode 2 enabled
            Enabled = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ECE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::Disabled,
                    true => ECE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ECE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ECE_A::Enabled
            }
        }
        ///Field `ECE` writer - External clock enable
        pub type ECE_W<'a, const O: u8> = crate::BitWriter<'a, u16, SMCFGR_SPEC, ECE_A, O>;
        impl<'a, const O: u8> ECE_W<'a, O> {
            ///External Clock Mode 2 disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::Disabled)
            }
            ///External Clock Mode 2 enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::Enabled)
            }
        }
        ///Field `ETP` reader - External trigger polarity
        pub type ETP_R = crate::BitReader<ETP_A>;
        ///External trigger polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ETP_A {
            ///0: Trigger on ETR high voltage or rising edge
            Direct = 0,
            ///1: Trigger on ETR low voltage or falling edge
            Inversed = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ETP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::Direct,
                    true => ETP_A::Inversed,
                }
            }
            ///Checks if the value of the field is `Direct`
            #[inline(always)]
            pub fn is_direct(&self) -> bool {
                *self == ETP_A::Direct
            }
            ///Checks if the value of the field is `Inversed`
            #[inline(always)]
            pub fn is_inversed(&self) -> bool {
                *self == ETP_A::Inversed
            }
        }
        ///Field `ETP` writer - External trigger polarity
        pub type ETP_W<'a, const O: u8> = crate::BitWriter<'a, u16, SMCFGR_SPEC, ETP_A, O>;
        impl<'a, const O: u8> ETP_W<'a, O> {
            ///Trigger on ETR high voltage or rising edge
            #[inline(always)]
            pub fn direct(self) -> &'a mut W {
                self.variant(ETP_A::Direct)
            }
            ///Trigger on ETR low voltage or falling edge
            #[inline(always)]
            pub fn inversed(self) -> &'a mut W {
                self.variant(ETP_A::Inversed)
            }
        }
        impl R {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 7) as u8)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            #[must_use]
            pub fn sms(&mut self) -> SMS_W<0> {
                SMS_W::new(self)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            #[must_use]
            pub fn ts(&mut self) -> TS_W<4> {
                TS_W::new(self)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            #[must_use]
            pub fn msm(&mut self) -> MSM_W<7> {
                MSM_W::new(self)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            #[must_use]
            pub fn etf(&mut self) -> ETF_W<8> {
                ETF_W::new(self)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            #[must_use]
            pub fn etps(&mut self) -> ETPS_W<12> {
                ETPS_W::new(self)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            #[must_use]
            pub fn ece(&mut self) -> ECE_W<14> {
                ECE_W::new(self)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            #[must_use]
            pub fn etp(&mut self) -> ETP_W<15> {
                ETP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcfgr](index.html) module
        pub struct SMCFGR_SPEC;
        impl crate::RegisterSpec for SMCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [smcfgr::R](R) reader structure
        impl crate::Readable for SMCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcfgr::W](W) writer structure
        impl crate::Writable for SMCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SMCFGR to value 0
        impl crate::Resettable for SMCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAINTENR (rw) register accessor: an alias for `Reg<DMAINTENR_SPEC>`
    pub type DMAINTENR = crate::Reg<dmaintenr::DMAINTENR_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dmaintenr {
        ///Register `DMAINTENR` reader
        pub struct R(crate::R<DMAINTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAINTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAINTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAINTENR` writer
        pub struct W(crate::W<DMAINTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAINTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAINTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub type UIE_R = crate::BitReader<UIE_A>;
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::Disabled,
                    true => UIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::Enabled
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub type UIE_W<'a, const O: u8> = crate::BitWriter<'a, u16, DMAINTENR_SPEC, UIE_A, O>;
        impl<'a, const O: u8> UIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::Enabled)
            }
        }
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub use UIE_R as CC1IE_R;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub use UIE_R as CC2IE_R;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub use UIE_R as CC3IE_R;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub use UIE_R as CC4IE_R;
        ///Field `COMIE` reader - COM interrupt enable
        pub use UIE_R as COMIE_R;
        ///Field `TIE` reader - Trigger interrupt enable
        pub use UIE_R as TIE_R;
        ///Field `BIE` reader - Break interrupt enable
        pub use UIE_R as BIE_R;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub use UIE_W as CC1IE_W;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub use UIE_W as CC2IE_W;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub use UIE_W as CC3IE_W;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub use UIE_W as CC4IE_W;
        ///Field `COMIE` writer - COM interrupt enable
        pub use UIE_W as COMIE_W;
        ///Field `TIE` writer - Trigger interrupt enable
        pub use UIE_W as TIE_W;
        ///Field `BIE` writer - Break interrupt enable
        pub use UIE_W as BIE_W;
        ///Field `UDE` reader - Update DMA request enable
        pub type UDE_R = crate::BitReader<UDE_A>;
        ///Update DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UDE_A {
            ///0: DMA disabled
            Disabled = 0,
            ///1: DMA enabled
            Enabled = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UDE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::Disabled,
                    true => UDE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDE_A::Enabled
            }
        }
        ///Field `UDE` writer - Update DMA request enable
        pub type UDE_W<'a, const O: u8> = crate::BitWriter<'a, u16, DMAINTENR_SPEC, UDE_A, O>;
        impl<'a, const O: u8> UDE_W<'a, O> {
            ///DMA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::Disabled)
            }
            ///DMA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::Enabled)
            }
        }
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub use UDE_R as CC1DE_R;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub use UDE_R as CC2DE_R;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub use UDE_R as CC3DE_R;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub use UDE_R as CC4DE_R;
        ///Field `COMDE` reader - COM DMA request enable
        pub use UDE_R as COMDE_R;
        ///Field `TDE` reader - Trigger DMA request enable
        pub use UDE_R as TDE_R;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub use UDE_W as CC1DE_W;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub use UDE_W as CC2DE_W;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub use UDE_W as CC3DE_W;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub use UDE_W as CC4DE_W;
        ///Field `COMDE` writer - COM DMA request enable
        pub use UDE_W as COMDE_W;
        ///Field `TDE` writer - Trigger DMA request enable
        pub use UDE_W as TDE_W;
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            pub fn comde(&self) -> COMDE_R {
                COMDE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn uie(&mut self) -> UIE_W<0> {
                UIE_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ie(&mut self) -> CC1IE_W<1> {
                CC1IE_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ie(&mut self) -> CC2IE_W<2> {
                CC2IE_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ie(&mut self) -> CC3IE_W<3> {
                CC3IE_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc4ie(&mut self) -> CC4IE_W<4> {
                CC4IE_W::new(self)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn comie(&mut self) -> COMIE_W<5> {
                COMIE_W::new(self)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tie(&mut self) -> TIE_W<6> {
                TIE_W::new(self)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn bie(&mut self) -> BIE_W<7> {
                BIE_W::new(self)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn ude(&mut self) -> UDE_W<8> {
                UDE_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc1de(&mut self) -> CC1DE_W<9> {
                CC1DE_W::new(self)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc2de(&mut self) -> CC2DE_W<10> {
                CC2DE_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc3de(&mut self) -> CC3DE_W<11> {
                CC3DE_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc4de(&mut self) -> CC4DE_W<12> {
                CC4DE_W::new(self)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn comde(&mut self) -> COMDE_W<13> {
                COMDE_W::new(self)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn tde(&mut self) -> TDE_W<14> {
                TDE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmaintenr](index.html) module
        pub struct DMAINTENR_SPEC;
        impl crate::RegisterSpec for DMAINTENR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dmaintenr::R](R) reader structure
        impl crate::Readable for DMAINTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmaintenr::W](W) writer structure
        impl crate::Writable for DMAINTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAINTENR to value 0
        impl crate::Resettable for DMAINTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFR (rw) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///status register
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTFR` writer
        pub struct W(crate::W<INTFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub type UIF_R = crate::BitReader<UIFR_A>;
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UIFR_A {
            ///0: Not interrupted
            NotInterrupted = 0,
            ///1: Interrupted
            Interrupted = 1,
        }
        impl From<UIFR_A> for bool {
            #[inline(always)]
            fn from(variant: UIFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UIF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIFR_A {
                match self.bits {
                    false => UIFR_A::NotInterrupted,
                    true => UIFR_A::Interrupted,
                }
            }
            ///Checks if the value of the field is `NotInterrupted`
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == UIFR_A::NotInterrupted
            }
            ///Checks if the value of the field is `Interrupted`
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == UIFR_A::Interrupted
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UIFW_AW {
            ///0: Clear interrupt flag
            Clear = 0,
        }
        impl From<UIFW_AW> for bool {
            #[inline(always)]
            fn from(variant: UIFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub type UIF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, INTFR_SPEC, UIFW_AW, O>;
        impl<'a, const O: u8> UIF_W<'a, O> {
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW_AW::Clear)
            }
        }
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub use UIF_R as CC1IF_R;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub use UIF_R as CC2IF_R;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub use UIF_R as CC3IF_R;
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub use UIF_R as CC4IF_R;
        ///Field `COMIF` reader - COM interrupt flag
        pub use UIF_R as COMIF_R;
        ///Field `TIF` reader - Trigger interrupt flag
        pub use UIF_R as TIF_R;
        ///Field `BIF` reader - Break interrupt flag
        pub use UIF_R as BIF_R;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub use UIF_W as CC1IF_W;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub use UIF_W as CC2IF_W;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub use UIF_W as CC3IF_W;
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub use UIF_W as CC4IF_W;
        ///Field `COMIF` writer - COM interrupt flag
        pub use UIF_W as COMIF_W;
        ///Field `TIF` writer - Trigger interrupt flag
        pub use UIF_W as TIF_W;
        ///Field `BIF` writer - Break interrupt flag
        pub use UIF_W as BIF_W;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = crate::BitReader<CC1OFR_A>;
        ///Capture/Compare 1 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CC1OFR_A {
            ///0: Not overcaptured
            NotOvercaptured = 0,
            ///1: Overcaptured
            Overcaptured = 1,
        }
        impl From<CC1OFR_A> for bool {
            #[inline(always)]
            fn from(variant: CC1OFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CC1OF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1OFR_A {
                match self.bits {
                    false => CC1OFR_A::NotOvercaptured,
                    true => CC1OFR_A::Overcaptured,
                }
            }
            ///Checks if the value of the field is `NotOvercaptured`
            #[inline(always)]
            pub fn is_not_overcaptured(&self) -> bool {
                *self == CC1OFR_A::NotOvercaptured
            }
            ///Checks if the value of the field is `Overcaptured`
            #[inline(always)]
            pub fn is_overcaptured(&self) -> bool {
                *self == CC1OFR_A::Overcaptured
            }
        }
        ///Capture/Compare 1 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CC1OFW_AW {
            ///0: Clear overcapture flag
            Clear = 0,
        }
        impl From<CC1OFW_AW> for bool {
            #[inline(always)]
            fn from(variant: CC1OFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub type CC1OF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, INTFR_SPEC, CC1OFW_AW, O>;
        impl<'a, const O: u8> CC1OF_W<'a, O> {
            ///Clear overcapture flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC1OFW_AW::Clear)
            }
        }
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub use CC1OF_R as CC2OF_R;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub use CC1OF_R as CC3OF_R;
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub use CC1OF_R as CC4OF_R;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub use CC1OF_W as CC2OF_W;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub use CC1OF_W as CC3OF_W;
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub use CC1OF_W as CC4OF_W;
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif(&mut self) -> UIF_W<0> {
                UIF_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc1if(&mut self) -> CC1IF_W<1> {
                CC1IF_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc2if(&mut self) -> CC2IF_W<2> {
                CC2IF_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc3if(&mut self) -> CC3IF_W<3> {
                CC3IF_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc4if(&mut self) -> CC4IF_W<4> {
                CC4IF_W::new(self)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn comif(&mut self) -> COMIF_W<5> {
                COMIF_W::new(self)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn tif(&mut self) -> TIF_W<6> {
                TIF_W::new(self)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn bif(&mut self) -> BIF_W<7> {
                BIF_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc1of(&mut self) -> CC1OF_W<9> {
                CC1OF_W::new(self)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc2of(&mut self) -> CC2OF_W<10> {
                CC2OF_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc3of(&mut self) -> CC3OF_W<11> {
                CC3OF_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc4of(&mut self) -> CC4OF_W<12> {
                CC4OF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intfr::W](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x1eff;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SWEVGR (w) register accessor: an alias for `Reg<SWEVGR_SPEC>`
    pub type SWEVGR = crate::Reg<swevgr::SWEVGR_SPEC>;
    ///event generation register
    pub mod swevgr {
        ///Register `SWEVGR` writer
        pub struct W(crate::W<SWEVGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWEVGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SWEVGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SWEVGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UGW_AW {
            ///1: Generate event
            Generate = 1,
        }
        impl From<UGW_AW> for bool {
            #[inline(always)]
            fn from(variant: UGW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub type UG_W<'a, const O: u8> = crate::BitWriter<'a, u16, SWEVGR_SPEC, UGW_AW, O>;
        impl<'a, const O: u8> UG_W<'a, O> {
            ///Generate event
            #[inline(always)]
            pub fn generate(self) -> &'a mut W {
                self.variant(UGW_AW::Generate)
            }
        }
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub use UG_W as CC1G_W;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub use UG_W as CC2G_W;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub use UG_W as CC3G_W;
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub use UG_W as CC4G_W;
        ///Field `COMG` writer - Capture/Compare control update generation
        pub use UG_W as COMG_W;
        ///Field `TG` writer - Trigger generation
        pub use UG_W as TG_W;
        ///Field `BG` writer - Break generation
        pub use UG_W as BG_W;
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            #[must_use]
            pub fn ug(&mut self) -> UG_W<0> {
                UG_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            #[must_use]
            pub fn cc1g(&mut self) -> CC1G_W<1> {
                CC1G_W::new(self)
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            #[must_use]
            pub fn cc2g(&mut self) -> CC2G_W<2> {
                CC2G_W::new(self)
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            #[must_use]
            pub fn cc3g(&mut self) -> CC3G_W<3> {
                CC3G_W::new(self)
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            #[must_use]
            pub fn cc4g(&mut self) -> CC4G_W<4> {
                CC4G_W::new(self)
            }
            ///Bit 5 - Capture/Compare control update generation
            #[inline(always)]
            #[must_use]
            pub fn comg(&mut self) -> COMG_W<5> {
                COMG_W::new(self)
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            #[must_use]
            pub fn tg(&mut self) -> TG_W<6> {
                TG_W::new(self)
            }
            ///Bit 7 - Break generation
            #[inline(always)]
            #[must_use]
            pub fn bg(&mut self) -> BG_W<7> {
                BG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swevgr](index.html) module
        pub struct SWEVGR_SPEC;
        impl crate::RegisterSpec for SWEVGR_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [swevgr::W](W) writer structure
        impl crate::Writable for SWEVGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SWEVGR to value 0
        impl crate::Resettable for SWEVGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1O (rw) register accessor: an alias for `Reg<CHCTLR1O_SPEC>`
    pub type CHCTLR1O = crate::Reg<chctlr1o::CHCTLR1O_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr1o {
        ///Register `CHCTLR1O` reader
        pub struct R(crate::R<CHCTLR1O_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1O_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1O_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1O` writer
        pub struct W(crate::W<CHCTLR1O_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1O_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1O_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, CC1S_A>;
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///0: CC1 configured as input
            Input = 0,
            ///1: CC1 configured as output. IC1 mapped to TI1
            OutputTi1 = 1,
            ///2: CC1 configured as output. IC1 mapped to TI2
            OutputTi2 = 2,
            ///3: CC1 configured as output. IC1 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        impl CC1S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1S_A {
                match self.bits {
                    0 => CC1S_A::Input,
                    1 => CC1S_A::OutputTi1,
                    2 => CC1S_A::OutputTi2,
                    3 => CC1S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC1S_A::Input
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC1S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC1S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC1S_A::OutputTrc
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, CC1S_A, 2, O>;
        impl<'a, const O: u8> CC1S_W<'a, O> {
            ///CC1 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC1S_A::Input)
            }
            ///CC1 configured as output. IC1 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC1S_A::OutputTi1)
            }
            ///CC1 configured as output. IC1 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC1S_A::OutputTi2)
            }
            ///CC1 configured as output. IC1 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC1S_A::OutputTrc)
            }
        }
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub type OC1FE_R = crate::BitReader<OC1FE_A>;
        ///Output Compare 1 fast enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC1FE_A {
            ///0: Fast enabling disabled
            Disabled = 0,
            ///1: Fast enabling enabled
            Enabled = 1,
        }
        impl From<OC1FE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1FE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC1FE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1FE_A {
                match self.bits {
                    false => OC1FE_A::Disabled,
                    true => OC1FE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1FE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1FE_A::Enabled
            }
        }
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub type OC1FE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR1O_SPEC, OC1FE_A, O>;
        impl<'a, const O: u8> OC1FE_W<'a, O> {
            ///Fast enabling disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1FE_A::Disabled)
            }
            ///Fast enabling enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1FE_A::Enabled)
            }
        }
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub type OC1PE_R = crate::BitReader<OC1PE_A>;
        ///Output Compare 1 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC1PE_A {
            ///0: Preloading disabled
            Disabled = 0,
            ///1: Preloading enabled
            Enabled = 1,
        }
        impl From<OC1PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1PE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC1PE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1PE_A {
                match self.bits {
                    false => OC1PE_A::Disabled,
                    true => OC1PE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1PE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1PE_A::Enabled
            }
        }
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub type OC1PE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR1O_SPEC, OC1PE_A, O>;
        impl<'a, const O: u8> OC1PE_W<'a, O> {
            ///Preloading disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1PE_A::Disabled)
            }
            ///Preloading enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1PE_A::Enabled)
            }
        }
        ///Field `OC1M` reader - Output Compare 1 mode
        pub type OC1M_R = crate::FieldReader<u8, OC1M_A>;
        ///Output Compare 1 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC1M_A {
            ///0: No effect on OC1REF
            Frozen = 0,
            ///1: OC1REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC1REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC1REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC1REF set low
            ForceLow = 4,
            ///5: OC1REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC1M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC1M_A) -> Self {
                variant as _
            }
        }
        impl OC1M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1M_A {
                match self.bits {
                    0 => OC1M_A::Frozen,
                    1 => OC1M_A::ForceHighCmp,
                    2 => OC1M_A::ForceLowCmp,
                    3 => OC1M_A::FlipCmp,
                    4 => OC1M_A::ForceLow,
                    5 => OC1M_A::ForceHigh,
                    6 => OC1M_A::Pwm1,
                    7 => OC1M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC1M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC1M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC1M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC1M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC1M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC1M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC1M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC1M_A::Pwm2
            }
        }
        ///Field `OC1M` writer - Output Compare 1 mode
        pub type OC1M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, OC1M_A, 3, O>;
        impl<'a, const O: u8> OC1M_W<'a, O> {
            ///No effect on OC1REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC1M_A::Frozen)
            }
            ///OC1REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC1M_A::ForceHighCmp)
            }
            ///OC1REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC1M_A::ForceLowCmp)
            }
            ///OC1REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC1M_A::FlipCmp)
            }
            ///OC1REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC1M_A::ForceLow)
            }
            ///OC1REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC1M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC1M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC1M_A::Pwm2)
            }
        }
        ///Field `OC1CE` reader - Output Compare 1 clear enable
        pub type OC1CE_R = crate::BitReader<OC1CE_A>;
        ///Output Compare 1 clear enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC1CE_A {
            ///0: OCxREF reset on ETRF disabled
            Disabled = 0,
            ///1: OCxREF reset on ETRF enabled
            Enabled = 1,
        }
        impl From<OC1CE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1CE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC1CE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1CE_A {
                match self.bits {
                    false => OC1CE_A::Disabled,
                    true => OC1CE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1CE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1CE_A::Enabled
            }
        }
        ///Field `OC1CE` writer - Output Compare 1 clear enable
        pub type OC1CE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR1O_SPEC, OC1CE_A, O>;
        impl<'a, const O: u8> OC1CE_W<'a, O> {
            ///OCxREF reset on ETRF disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1CE_A::Disabled)
            }
            ///OCxREF reset on ETRF enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1CE_A::Enabled)
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, CC2S_A>;
        ///Capture/Compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///0: CC2 configured as input
            Input = 0,
            ///1: CC2 configured as output. IC2 mapped to TI2
            OutputTi2 = 1,
            ///2: CC2 configured as output. IC2 mapped to TI1
            OutputTi1 = 2,
            ///3: CC2 configured as output. IC2 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        impl CC2S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC2S_A {
                match self.bits {
                    0 => CC2S_A::Input,
                    1 => CC2S_A::OutputTi2,
                    2 => CC2S_A::OutputTi1,
                    3 => CC2S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC2S_A::Input
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC2S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC2S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC2S_A::OutputTrc
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, CC2S_A, 2, O>;
        impl<'a, const O: u8> CC2S_W<'a, O> {
            ///CC2 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC2S_A::Input)
            }
            ///CC2 configured as output. IC2 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC2S_A::OutputTi2)
            }
            ///CC2 configured as output. IC2 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC2S_A::OutputTi1)
            }
            ///CC2 configured as output. IC2 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC2S_A::OutputTrc)
            }
        }
        ///Field `OC2FE` reader - Output Compare 2 fast enable
        pub use OC1FE_R as OC2FE_R;
        ///Field `OC2FE` writer - Output Compare 2 fast enable
        pub use OC1FE_W as OC2FE_W;
        ///Field `OC2PE` reader - Output Compare 2 preload enable
        pub use OC1PE_R as OC2PE_R;
        ///Field `OC2PE` writer - Output Compare 2 preload enable
        pub use OC1PE_W as OC2PE_W;
        ///Field `OC2M` reader - Output Compare 2 mode
        pub type OC2M_R = crate::FieldReader<u8, OC2M_A>;
        ///Output Compare 2 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC2M_A {
            ///0: No effect on OC2REF
            Frozen = 0,
            ///1: OC2REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC2REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC2REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC2REF set low
            ForceLow = 4,
            ///5: OC2REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        impl OC2M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::Frozen,
                    1 => OC2M_A::ForceHighCmp,
                    2 => OC2M_A::ForceLowCmp,
                    3 => OC2M_A::FlipCmp,
                    4 => OC2M_A::ForceLow,
                    5 => OC2M_A::ForceHigh,
                    6 => OC2M_A::Pwm1,
                    7 => OC2M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC2M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC2M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC2M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC2M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC2M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC2M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC2M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC2M_A::Pwm2
            }
        }
        ///Field `OC2M` writer - Output Compare 2 mode
        pub type OC2M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, OC2M_A, 3, O>;
        impl<'a, const O: u8> OC2M_W<'a, O> {
            ///No effect on OC2REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::Frozen)
            }
            ///OC2REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC2M_A::ForceHighCmp)
            }
            ///OC2REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC2M_A::ForceLowCmp)
            }
            ///OC2REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC2M_A::FlipCmp)
            }
            ///OC2REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC2M_A::ForceLow)
            }
            ///OC2REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC2M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC2M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC2M_A::Pwm2)
            }
        }
        ///Field `OC2CE` reader - Output Compare 2 clear enable
        pub use OC1CE_R as OC2CE_R;
        ///Field `OC2CE` writer - Output Compare 2 clear enable
        pub use OC1CE_W as OC2CE_W;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc1fe(&mut self) -> OC1FE_W<2> {
                OC1FE_W::new(self)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc1pe(&mut self) -> OC1PE_W<3> {
                OC1PE_W::new(self)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            #[must_use]
            pub fn oc1m(&mut self) -> OC1M_W<4> {
                OC1M_W::new(self)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc1ce(&mut self) -> OC1CE_W<7> {
                OC1CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc2fe(&mut self) -> OC2FE_W<10> {
                OC2FE_W::new(self)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc2pe(&mut self) -> OC2PE_W<11> {
                OC2PE_W::new(self)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            #[must_use]
            pub fn oc2m(&mut self) -> OC2M_W<12> {
                OC2M_W::new(self)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc2ce(&mut self) -> OC2CE_W<15> {
                OC2CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1o](index.html) module
        pub struct CHCTLR1O_SPEC;
        impl crate::RegisterSpec for CHCTLR1O_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr1o::R](R) reader structure
        impl crate::Readable for CHCTLR1O_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1o::W](W) writer structure
        impl crate::Writable for CHCTLR1O_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1O to value 0
        impl crate::Resettable for CHCTLR1O_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1I (rw) register accessor: an alias for `Reg<CHCTLR1I_SPEC>`
    pub type CHCTLR1I = crate::Reg<chctlr1i::CHCTLR1I_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod chctlr1i {
        ///Register `CHCTLR1I` reader
        pub struct R(crate::R<CHCTLR1I_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1I_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1I_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1I` writer
        pub struct W(crate::W<CHCTLR1I_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1I_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1I_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, CC1S_A>;
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///0: CC1 configured as output
            Output = 0,
            ///1: CC1 configured as input. IC1 mapped to TI1
            InputTi1 = 1,
            ///2: CC1 configured as input. IC1 mapped to TI2
            InputTi2 = 2,
            ///3: CC1 configured as input. IC1 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        impl CC1S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1S_A {
                match self.bits {
                    0 => CC1S_A::Output,
                    1 => CC1S_A::InputTi1,
                    2 => CC1S_A::InputTi2,
                    3 => CC1S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC1S_A::Output
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC1S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC1S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC1S_A::InputTrc
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, CC1S_A, 2, O>;
        impl<'a, const O: u8> CC1S_W<'a, O> {
            ///CC1 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1S_A::Output)
            }
            ///CC1 configured as input. IC1 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC1S_A::InputTi1)
            }
            ///CC1 configured as input. IC1 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC1S_A::InputTi2)
            }
            ///CC1 configured as input. IC1 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC1S_A::InputTrc)
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub type IC1PSC_R = crate::FieldReader<u8, IC1PSC_A>;
        ///Input capture 1 prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC1PSC_A {
            ///0: Every capture input edge will trigger a capture
            NoDiv = 0,
            ///1: Every 2 capture input edges will trigger a capture
            Div2 = 1,
            ///2: Every 4 capture input edges will trigger a capture
            Div4 = 2,
            ///3: Every 8 capture input edges will trigger a capture
            Div8 = 3,
        }
        impl From<IC1PSC_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1PSC_A) -> Self {
                variant as _
            }
        }
        impl IC1PSC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC1PSC_A {
                match self.bits {
                    0 => IC1PSC_A::NoDiv,
                    1 => IC1PSC_A::Div2,
                    2 => IC1PSC_A::Div4,
                    3 => IC1PSC_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == IC1PSC_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == IC1PSC_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == IC1PSC_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == IC1PSC_A::Div8
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub type IC1PSC_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, IC1PSC_A, 2, O>;
        impl<'a, const O: u8> IC1PSC_W<'a, O> {
            ///Every capture input edge will trigger a capture
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(IC1PSC_A::NoDiv)
            }
            ///Every 2 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(IC1PSC_A::Div2)
            }
            ///Every 4 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(IC1PSC_A::Div4)
            }
            ///Every 8 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(IC1PSC_A::Div8)
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub type IC1F_R = crate::FieldReader<u8, IC1F_A>;
        ///Input capture 1 filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC1F_A {
            ///0: No filter applied. Sampling using Fdts
            NoFilter = 0,
            ///1: Fsampling = Fck_int, N=2
            FckN2 = 1,
            ///2: Fsampling = Fck_int, N=4
            FckN4 = 2,
            ///3: Fsampling = Fck_int, N=8
            FckN8 = 3,
            ///4: Fsampling = Fdts / 2, N=6
            Fdts2n6 = 4,
            ///5: Fsampling = Fdts / 2, N=8
            Fdts2n8 = 5,
            ///6: Fsampling = Fdts / 4, N=6
            Fdts4n6 = 6,
            ///7: Fsampling = Fdts / 4, N=8
            Fdts4n8 = 7,
            ///8: Fsampling = Fdts / 8, N=6
            Fdts8n6 = 8,
            ///9: Fsampling = Fdts / 8, N=8
            Fdts8n8 = 9,
            ///10: Fsampling = Fdts / 16, N=5
            Fdts16n5 = 10,
            ///11: Fsampling = Fdts / 16, N=6
            Fdts16n6 = 11,
            ///12: Fsampling = Fdts / 16, N=8
            Fdts16n8 = 12,
            ///13: Fsampling = Fdts / 32, N=5
            Fdts32n5 = 13,
            ///14: Fsampling = Fdts / 32, N=6
            Fdts32n6 = 14,
            ///15: Fsampling = Fdts / 32, N=8
            Fdts32n8 = 15,
        }
        impl From<IC1F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1F_A) -> Self {
                variant as _
            }
        }
        impl IC1F_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC1F_A {
                match self.bits {
                    0 => IC1F_A::NoFilter,
                    1 => IC1F_A::FckN2,
                    2 => IC1F_A::FckN4,
                    3 => IC1F_A::FckN8,
                    4 => IC1F_A::Fdts2n6,
                    5 => IC1F_A::Fdts2n8,
                    6 => IC1F_A::Fdts4n6,
                    7 => IC1F_A::Fdts4n8,
                    8 => IC1F_A::Fdts8n6,
                    9 => IC1F_A::Fdts8n8,
                    10 => IC1F_A::Fdts16n5,
                    11 => IC1F_A::Fdts16n6,
                    12 => IC1F_A::Fdts16n8,
                    13 => IC1F_A::Fdts32n5,
                    14 => IC1F_A::Fdts32n6,
                    15 => IC1F_A::Fdts32n8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoFilter`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC1F_A::NoFilter
            }
            ///Checks if the value of the field is `FckN2`
            #[inline(always)]
            pub fn is_fck_n2(&self) -> bool {
                *self == IC1F_A::FckN2
            }
            ///Checks if the value of the field is `FckN4`
            #[inline(always)]
            pub fn is_fck_n4(&self) -> bool {
                *self == IC1F_A::FckN4
            }
            ///Checks if the value of the field is `FckN8`
            #[inline(always)]
            pub fn is_fck_n8(&self) -> bool {
                *self == IC1F_A::FckN8
            }
            ///Checks if the value of the field is `Fdts2n6`
            #[inline(always)]
            pub fn is_fdts2n6(&self) -> bool {
                *self == IC1F_A::Fdts2n6
            }
            ///Checks if the value of the field is `Fdts2n8`
            #[inline(always)]
            pub fn is_fdts2n8(&self) -> bool {
                *self == IC1F_A::Fdts2n8
            }
            ///Checks if the value of the field is `Fdts4n6`
            #[inline(always)]
            pub fn is_fdts4n6(&self) -> bool {
                *self == IC1F_A::Fdts4n6
            }
            ///Checks if the value of the field is `Fdts4n8`
            #[inline(always)]
            pub fn is_fdts4n8(&self) -> bool {
                *self == IC1F_A::Fdts4n8
            }
            ///Checks if the value of the field is `Fdts8n6`
            #[inline(always)]
            pub fn is_fdts8n6(&self) -> bool {
                *self == IC1F_A::Fdts8n6
            }
            ///Checks if the value of the field is `Fdts8n8`
            #[inline(always)]
            pub fn is_fdts8n8(&self) -> bool {
                *self == IC1F_A::Fdts8n8
            }
            ///Checks if the value of the field is `Fdts16n5`
            #[inline(always)]
            pub fn is_fdts16n5(&self) -> bool {
                *self == IC1F_A::Fdts16n5
            }
            ///Checks if the value of the field is `Fdts16n6`
            #[inline(always)]
            pub fn is_fdts16n6(&self) -> bool {
                *self == IC1F_A::Fdts16n6
            }
            ///Checks if the value of the field is `Fdts16n8`
            #[inline(always)]
            pub fn is_fdts16n8(&self) -> bool {
                *self == IC1F_A::Fdts16n8
            }
            ///Checks if the value of the field is `Fdts32n5`
            #[inline(always)]
            pub fn is_fdts32n5(&self) -> bool {
                *self == IC1F_A::Fdts32n5
            }
            ///Checks if the value of the field is `Fdts32n6`
            #[inline(always)]
            pub fn is_fdts32n6(&self) -> bool {
                *self == IC1F_A::Fdts32n6
            }
            ///Checks if the value of the field is `Fdts32n8`
            #[inline(always)]
            pub fn is_fdts32n8(&self) -> bool {
                *self == IC1F_A::Fdts32n8
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub type IC1F_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, IC1F_A, 4, O>;
        impl<'a, const O: u8> IC1F_W<'a, O> {
            ///No filter applied. Sampling using Fdts
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1F_A::NoFilter)
            }
            ///Fsampling = Fck_int, N=2
            #[inline(always)]
            pub fn fck_n2(self) -> &'a mut W {
                self.variant(IC1F_A::FckN2)
            }
            ///Fsampling = Fck_int, N=4
            #[inline(always)]
            pub fn fck_n4(self) -> &'a mut W {
                self.variant(IC1F_A::FckN4)
            }
            ///Fsampling = Fck_int, N=8
            #[inline(always)]
            pub fn fck_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FckN8)
            }
            ///Fsampling = Fdts / 2, N=6
            #[inline(always)]
            pub fn fdts2n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts2n6)
            }
            ///Fsampling = Fdts / 2, N=8
            #[inline(always)]
            pub fn fdts2n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts2n8)
            }
            ///Fsampling = Fdts / 4, N=6
            #[inline(always)]
            pub fn fdts4n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts4n6)
            }
            ///Fsampling = Fdts / 4, N=8
            #[inline(always)]
            pub fn fdts4n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts4n8)
            }
            ///Fsampling = Fdts / 8, N=6
            #[inline(always)]
            pub fn fdts8n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts8n6)
            }
            ///Fsampling = Fdts / 8, N=8
            #[inline(always)]
            pub fn fdts8n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts8n8)
            }
            ///Fsampling = Fdts / 16, N=5
            #[inline(always)]
            pub fn fdts16n5(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts16n5)
            }
            ///Fsampling = Fdts / 16, N=6
            #[inline(always)]
            pub fn fdts16n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts16n6)
            }
            ///Fsampling = Fdts / 16, N=8
            #[inline(always)]
            pub fn fdts16n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts16n8)
            }
            ///Fsampling = Fdts / 32, N=5
            #[inline(always)]
            pub fn fdts32n5(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts32n5)
            }
            ///Fsampling = Fdts / 32, N=6
            #[inline(always)]
            pub fn fdts32n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts32n6)
            }
            ///Fsampling = Fdts / 32, N=8
            #[inline(always)]
            pub fn fdts32n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts32n8)
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, CC2S_A>;
        ///Capture/Compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///0: CC2 configured as output
            Output = 0,
            ///1: CC2 configured as input. IC2 mapped to TI2
            InputTi2 = 1,
            ///2: CC2 configured as input. IC2 mapped to TI1
            InputTi1 = 2,
            ///3: CC2 configured as input. IC2 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        impl CC2S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC2S_A {
                match self.bits {
                    0 => CC2S_A::Output,
                    1 => CC2S_A::InputTi2,
                    2 => CC2S_A::InputTi1,
                    3 => CC2S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::Output
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC2S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC2S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC2S_A::InputTrc
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, CC2S_A, 2, O>;
        impl<'a, const O: u8> CC2S_W<'a, O> {
            ///CC2 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::Output)
            }
            ///CC2 configured as input. IC2 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC2S_A::InputTi2)
            }
            ///CC2 configured as input. IC2 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC2S_A::InputTi1)
            }
            ///CC2 configured as input. IC2 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC2S_A::InputTrc)
            }
        }
        ///Field `IC2F` reader - Input capture 2 filter
        pub use IC1F_R as IC2F_R;
        ///Field `IC2F` writer - Input capture 2 filter
        pub use IC1F_W as IC2F_W;
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub use IC1PSC_R as IC2PSC_R;
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub use IC1PSC_W as IC2PSC_W;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic1psc(&mut self) -> IC1PSC_W<2> {
                IC1PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            #[must_use]
            pub fn ic1f(&mut self) -> IC1F_W<4> {
                IC1F_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic2psc(&mut self) -> IC2PSC_W<10> {
                IC2PSC_W::new(self)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            #[must_use]
            pub fn ic2f(&mut self) -> IC2F_W<12> {
                IC2F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1i](index.html) module
        pub struct CHCTLR1I_SPEC;
        impl crate::RegisterSpec for CHCTLR1I_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr1i::R](R) reader structure
        impl crate::Readable for CHCTLR1I_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1i::W](W) writer structure
        impl crate::Writable for CHCTLR1I_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1I to value 0
        impl crate::Resettable for CHCTLR1I_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2O (rw) register accessor: an alias for `Reg<CHCTLR2O_SPEC>`
    pub type CHCTLR2O = crate::Reg<chctlr2o::CHCTLR2O_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr2o {
        ///Register `CHCTLR2O` reader
        pub struct R(crate::R<CHCTLR2O_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2O_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2O_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2O` writer
        pub struct W(crate::W<CHCTLR2O_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2O_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2O_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, CC3S_A>;
        ///Capture/Compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///0: CC3 configured as input
            Input = 0,
            ///1: CC3 configured as output. IC3 mapped to TI1
            OutputTi1 = 1,
            ///2: CC3 configured as output. IC3 mapped to TI2
            OutputTi2 = 2,
            ///3: CC3 configured as output. IC3 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        impl CC3S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC3S_A {
                match self.bits {
                    0 => CC3S_A::Input,
                    1 => CC3S_A::OutputTi1,
                    2 => CC3S_A::OutputTi2,
                    3 => CC3S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC3S_A::Input
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC3S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC3S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC3S_A::OutputTrc
            }
        }
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, CC3S_A, 2, O>;
        impl<'a, const O: u8> CC3S_W<'a, O> {
            ///CC3 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC3S_A::Input)
            }
            ///CC3 configured as output. IC3 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC3S_A::OutputTi1)
            }
            ///CC3 configured as output. IC3 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC3S_A::OutputTi2)
            }
            ///CC3 configured as output. IC3 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC3S_A::OutputTrc)
            }
        }
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub type OC3FE_R = crate::BitReader<OC3FE_A>;
        ///Output compare 3 fast enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC3FE_A {
            ///0: Fast enabling disabled
            Disabled = 0,
            ///1: Fast enabling enabled
            Enabled = 1,
        }
        impl From<OC3FE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3FE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC3FE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3FE_A {
                match self.bits {
                    false => OC3FE_A::Disabled,
                    true => OC3FE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3FE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3FE_A::Enabled
            }
        }
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub type OC3FE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR2O_SPEC, OC3FE_A, O>;
        impl<'a, const O: u8> OC3FE_W<'a, O> {
            ///Fast enabling disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3FE_A::Disabled)
            }
            ///Fast enabling enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3FE_A::Enabled)
            }
        }
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub type OC3PE_R = crate::BitReader<OC3PE_A>;
        ///Output compare 3 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC3PE_A {
            ///0: Preloading disabled
            Disabled = 0,
            ///1: Preloading enabled
            Enabled = 1,
        }
        impl From<OC3PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3PE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC3PE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3PE_A {
                match self.bits {
                    false => OC3PE_A::Disabled,
                    true => OC3PE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3PE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3PE_A::Enabled
            }
        }
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub type OC3PE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR2O_SPEC, OC3PE_A, O>;
        impl<'a, const O: u8> OC3PE_W<'a, O> {
            ///Preloading disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3PE_A::Disabled)
            }
            ///Preloading enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3PE_A::Enabled)
            }
        }
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = crate::FieldReader<u8, OC3M_A>;
        ///Output compare 3 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC3M_A {
            ///0: No effect on OC3REF
            Frozen = 0,
            ///1: OC3REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC3REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC3REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC3REF set low
            ForceLow = 4,
            ///5: OC3REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC3M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC3M_A) -> Self {
                variant as _
            }
        }
        impl OC3M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3M_A {
                match self.bits {
                    0 => OC3M_A::Frozen,
                    1 => OC3M_A::ForceHighCmp,
                    2 => OC3M_A::ForceLowCmp,
                    3 => OC3M_A::FlipCmp,
                    4 => OC3M_A::ForceLow,
                    5 => OC3M_A::ForceHigh,
                    6 => OC3M_A::Pwm1,
                    7 => OC3M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC3M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC3M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC3M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC3M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC3M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC3M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC3M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC3M_A::Pwm2
            }
        }
        ///Field `OC3M` writer - Output compare 3 mode
        pub type OC3M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, OC3M_A, 3, O>;
        impl<'a, const O: u8> OC3M_W<'a, O> {
            ///No effect on OC3REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC3M_A::Frozen)
            }
            ///OC3REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC3M_A::ForceHighCmp)
            }
            ///OC3REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC3M_A::ForceLowCmp)
            }
            ///OC3REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC3M_A::FlipCmp)
            }
            ///OC3REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC3M_A::ForceLow)
            }
            ///OC3REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC3M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC3M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC3M_A::Pwm2)
            }
        }
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub type OC3CE_R = crate::BitReader<OC3CE_A>;
        ///Output compare 3 clear enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC3CE_A {
            ///0: OCxREF reset on ETRF disabled
            Disabled = 0,
            ///1: OCxREF reset on ETRF enabled
            Enabled = 1,
        }
        impl From<OC3CE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3CE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC3CE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3CE_A {
                match self.bits {
                    false => OC3CE_A::Disabled,
                    true => OC3CE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3CE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3CE_A::Enabled
            }
        }
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub type OC3CE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR2O_SPEC, OC3CE_A, O>;
        impl<'a, const O: u8> OC3CE_W<'a, O> {
            ///OCxREF reset on ETRF disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3CE_A::Disabled)
            }
            ///OCxREF reset on ETRF enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3CE_A::Enabled)
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, CC4S_A>;
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///0: CC4 configured as input
            Input = 0,
            ///1: CC4 configured as output. IC4 mapped to TI2
            OutputTi2 = 1,
            ///2: CC4 configured as output. IC4 mapped to TI1
            OutputTi1 = 2,
            ///3: CC4 configured as output. IC4 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        impl CC4S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC4S_A {
                match self.bits {
                    0 => CC4S_A::Input,
                    1 => CC4S_A::OutputTi2,
                    2 => CC4S_A::OutputTi1,
                    3 => CC4S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC4S_A::Input
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC4S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC4S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC4S_A::OutputTrc
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, CC4S_A, 2, O>;
        impl<'a, const O: u8> CC4S_W<'a, O> {
            ///CC4 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC4S_A::Input)
            }
            ///CC4 configured as output. IC4 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC4S_A::OutputTi2)
            }
            ///CC4 configured as output. IC4 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC4S_A::OutputTi1)
            }
            ///CC4 configured as output. IC4 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC4S_A::OutputTrc)
            }
        }
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub use OC3FE_R as OC4FE_R;
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub use OC3FE_W as OC4FE_W;
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub use OC3PE_R as OC4PE_R;
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub use OC3PE_W as OC4PE_W;
        ///Field `OC4M` reader - Output compare 4 mode
        pub type OC4M_R = crate::FieldReader<u8, OC4M_A>;
        ///Output compare 4 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC4M_A {
            ///0: No effect on OC4REF
            Frozen = 0,
            ///1: OC4REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC4REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC4REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC4REF set low
            ForceLow = 4,
            ///5: OC4REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC4M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC4M_A) -> Self {
                variant as _
            }
        }
        impl OC4M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC4M_A {
                match self.bits {
                    0 => OC4M_A::Frozen,
                    1 => OC4M_A::ForceHighCmp,
                    2 => OC4M_A::ForceLowCmp,
                    3 => OC4M_A::FlipCmp,
                    4 => OC4M_A::ForceLow,
                    5 => OC4M_A::ForceHigh,
                    6 => OC4M_A::Pwm1,
                    7 => OC4M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC4M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC4M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC4M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC4M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC4M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC4M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC4M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC4M_A::Pwm2
            }
        }
        ///Field `OC4M` writer - Output compare 4 mode
        pub type OC4M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, OC4M_A, 3, O>;
        impl<'a, const O: u8> OC4M_W<'a, O> {
            ///No effect on OC4REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::Frozen)
            }
            ///OC4REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC4M_A::ForceHighCmp)
            }
            ///OC4REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC4M_A::ForceLowCmp)
            }
            ///OC4REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC4M_A::FlipCmp)
            }
            ///OC4REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC4M_A::ForceLow)
            }
            ///OC4REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC4M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC4M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC4M_A::Pwm2)
            }
        }
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub use OC3CE_R as OC4CE_R;
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub use OC3CE_W as OC4CE_W;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc3fe(&mut self) -> OC3FE_W<2> {
                OC3FE_W::new(self)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc3pe(&mut self) -> OC3PE_W<3> {
                OC3PE_W::new(self)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            #[must_use]
            pub fn oc3m(&mut self) -> OC3M_W<4> {
                OC3M_W::new(self)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc3ce(&mut self) -> OC3CE_W<7> {
                OC3CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc4fe(&mut self) -> OC4FE_W<10> {
                OC4FE_W::new(self)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc4pe(&mut self) -> OC4PE_W<11> {
                OC4PE_W::new(self)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            #[must_use]
            pub fn oc4m(&mut self) -> OC4M_W<12> {
                OC4M_W::new(self)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc4ce(&mut self) -> OC4CE_W<15> {
                OC4CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2o](index.html) module
        pub struct CHCTLR2O_SPEC;
        impl crate::RegisterSpec for CHCTLR2O_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr2o::R](R) reader structure
        impl crate::Readable for CHCTLR2O_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2o::W](W) writer structure
        impl crate::Writable for CHCTLR2O_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2O to value 0
        impl crate::Resettable for CHCTLR2O_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2I (rw) register accessor: an alias for `Reg<CHCTLR2I_SPEC>`
    pub type CHCTLR2I = crate::Reg<chctlr2i::CHCTLR2I_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod chctlr2i {
        ///Register `CHCTLR2I` reader
        pub struct R(crate::R<CHCTLR2I_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2I_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2I_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2I` writer
        pub struct W(crate::W<CHCTLR2I_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2I_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2I_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, CC3S_A>;
        ///Capture/compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///0: CC3 configured as output
            Output = 0,
            ///1: CC3 configured as input. IC3 mapped to TI1
            InputTi1 = 1,
            ///2: CC3 configured as input. IC3 mapped to TI2
            InputTi2 = 2,
            ///3: CC3 configured as input. IC3 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        impl CC3S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC3S_A {
                match self.bits {
                    0 => CC3S_A::Output,
                    1 => CC3S_A::InputTi1,
                    2 => CC3S_A::InputTi2,
                    3 => CC3S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC3S_A::Output
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC3S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC3S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC3S_A::InputTrc
            }
        }
        ///Field `CC3S` writer - Capture/compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, CC3S_A, 2, O>;
        impl<'a, const O: u8> CC3S_W<'a, O> {
            ///CC3 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3S_A::Output)
            }
            ///CC3 configured as input. IC3 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC3S_A::InputTi1)
            }
            ///CC3 configured as input. IC3 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC3S_A::InputTi2)
            }
            ///CC3 configured as input. IC3 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC3S_A::InputTrc)
            }
        }
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub type IC3PSC_R = crate::FieldReader<u8, IC3PSC_A>;
        ///Input capture 3 prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC3PSC_A {
            ///0: Every capture input edge will trigger a capture
            NoDiv = 0,
            ///1: Every 2 capture input edges will trigger a capture
            Div2 = 1,
            ///2: Every 4 capture input edges will trigger a capture
            Div4 = 2,
            ///3: Every 8 capture input edges will trigger a capture
            Div8 = 3,
        }
        impl From<IC3PSC_A> for u8 {
            #[inline(always)]
            fn from(variant: IC3PSC_A) -> Self {
                variant as _
            }
        }
        impl IC3PSC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC3PSC_A {
                match self.bits {
                    0 => IC3PSC_A::NoDiv,
                    1 => IC3PSC_A::Div2,
                    2 => IC3PSC_A::Div4,
                    3 => IC3PSC_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == IC3PSC_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == IC3PSC_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == IC3PSC_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == IC3PSC_A::Div8
            }
        }
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub type IC3PSC_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, IC3PSC_A, 2, O>;
        impl<'a, const O: u8> IC3PSC_W<'a, O> {
            ///Every capture input edge will trigger a capture
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(IC3PSC_A::NoDiv)
            }
            ///Every 2 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(IC3PSC_A::Div2)
            }
            ///Every 4 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(IC3PSC_A::Div4)
            }
            ///Every 8 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(IC3PSC_A::Div8)
            }
        }
        ///Field `IC3F` reader - Input capture 3 filter
        pub type IC3F_R = crate::FieldReader<u8, IC3F_A>;
        ///Input capture 3 filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC3F_A {
            ///0: No filter applied. Sampling using Fdts
            NoFilter = 0,
            ///1: Fsampling = Fck_int, N=2
            FckN2 = 1,
            ///2: Fsampling = Fck_int, N=4
            FckN4 = 2,
            ///3: Fsampling = Fck_int, N=8
            FckN8 = 3,
            ///4: Fsampling = Fdts / 2, N=6
            Fdts2n6 = 4,
            ///5: Fsampling = Fdts / 2, N=8
            Fdts2n8 = 5,
            ///6: Fsampling = Fdts / 4, N=6
            Fdts4n6 = 6,
            ///7: Fsampling = Fdts / 4, N=8
            Fdts4n8 = 7,
            ///8: Fsampling = Fdts / 8, N=6
            Fdts8n6 = 8,
            ///9: Fsampling = Fdts / 8, N=8
            Fdts8n8 = 9,
            ///10: Fsampling = Fdts / 16, N=5
            Fdts16n5 = 10,
            ///11: Fsampling = Fdts / 16, N=6
            Fdts16n6 = 11,
            ///12: Fsampling = Fdts / 16, N=8
            Fdts16n8 = 12,
            ///13: Fsampling = Fdts / 32, N=5
            Fdts32n5 = 13,
            ///14: Fsampling = Fdts / 32, N=6
            Fdts32n6 = 14,
            ///15: Fsampling = Fdts / 32, N=8
            Fdts32n8 = 15,
        }
        impl From<IC3F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC3F_A) -> Self {
                variant as _
            }
        }
        impl IC3F_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC3F_A {
                match self.bits {
                    0 => IC3F_A::NoFilter,
                    1 => IC3F_A::FckN2,
                    2 => IC3F_A::FckN4,
                    3 => IC3F_A::FckN8,
                    4 => IC3F_A::Fdts2n6,
                    5 => IC3F_A::Fdts2n8,
                    6 => IC3F_A::Fdts4n6,
                    7 => IC3F_A::Fdts4n8,
                    8 => IC3F_A::Fdts8n6,
                    9 => IC3F_A::Fdts8n8,
                    10 => IC3F_A::Fdts16n5,
                    11 => IC3F_A::Fdts16n6,
                    12 => IC3F_A::Fdts16n8,
                    13 => IC3F_A::Fdts32n5,
                    14 => IC3F_A::Fdts32n6,
                    15 => IC3F_A::Fdts32n8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoFilter`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC3F_A::NoFilter
            }
            ///Checks if the value of the field is `FckN2`
            #[inline(always)]
            pub fn is_fck_n2(&self) -> bool {
                *self == IC3F_A::FckN2
            }
            ///Checks if the value of the field is `FckN4`
            #[inline(always)]
            pub fn is_fck_n4(&self) -> bool {
                *self == IC3F_A::FckN4
            }
            ///Checks if the value of the field is `FckN8`
            #[inline(always)]
            pub fn is_fck_n8(&self) -> bool {
                *self == IC3F_A::FckN8
            }
            ///Checks if the value of the field is `Fdts2n6`
            #[inline(always)]
            pub fn is_fdts2n6(&self) -> bool {
                *self == IC3F_A::Fdts2n6
            }
            ///Checks if the value of the field is `Fdts2n8`
            #[inline(always)]
            pub fn is_fdts2n8(&self) -> bool {
                *self == IC3F_A::Fdts2n8
            }
            ///Checks if the value of the field is `Fdts4n6`
            #[inline(always)]
            pub fn is_fdts4n6(&self) -> bool {
                *self == IC3F_A::Fdts4n6
            }
            ///Checks if the value of the field is `Fdts4n8`
            #[inline(always)]
            pub fn is_fdts4n8(&self) -> bool {
                *self == IC3F_A::Fdts4n8
            }
            ///Checks if the value of the field is `Fdts8n6`
            #[inline(always)]
            pub fn is_fdts8n6(&self) -> bool {
                *self == IC3F_A::Fdts8n6
            }
            ///Checks if the value of the field is `Fdts8n8`
            #[inline(always)]
            pub fn is_fdts8n8(&self) -> bool {
                *self == IC3F_A::Fdts8n8
            }
            ///Checks if the value of the field is `Fdts16n5`
            #[inline(always)]
            pub fn is_fdts16n5(&self) -> bool {
                *self == IC3F_A::Fdts16n5
            }
            ///Checks if the value of the field is `Fdts16n6`
            #[inline(always)]
            pub fn is_fdts16n6(&self) -> bool {
                *self == IC3F_A::Fdts16n6
            }
            ///Checks if the value of the field is `Fdts16n8`
            #[inline(always)]
            pub fn is_fdts16n8(&self) -> bool {
                *self == IC3F_A::Fdts16n8
            }
            ///Checks if the value of the field is `Fdts32n5`
            #[inline(always)]
            pub fn is_fdts32n5(&self) -> bool {
                *self == IC3F_A::Fdts32n5
            }
            ///Checks if the value of the field is `Fdts32n6`
            #[inline(always)]
            pub fn is_fdts32n6(&self) -> bool {
                *self == IC3F_A::Fdts32n6
            }
            ///Checks if the value of the field is `Fdts32n8`
            #[inline(always)]
            pub fn is_fdts32n8(&self) -> bool {
                *self == IC3F_A::Fdts32n8
            }
        }
        ///Field `IC3F` writer - Input capture 3 filter
        pub type IC3F_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, IC3F_A, 4, O>;
        impl<'a, const O: u8> IC3F_W<'a, O> {
            ///No filter applied. Sampling using Fdts
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC3F_A::NoFilter)
            }
            ///Fsampling = Fck_int, N=2
            #[inline(always)]
            pub fn fck_n2(self) -> &'a mut W {
                self.variant(IC3F_A::FckN2)
            }
            ///Fsampling = Fck_int, N=4
            #[inline(always)]
            pub fn fck_n4(self) -> &'a mut W {
                self.variant(IC3F_A::FckN4)
            }
            ///Fsampling = Fck_int, N=8
            #[inline(always)]
            pub fn fck_n8(self) -> &'a mut W {
                self.variant(IC3F_A::FckN8)
            }
            ///Fsampling = Fdts / 2, N=6
            #[inline(always)]
            pub fn fdts2n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts2n6)
            }
            ///Fsampling = Fdts / 2, N=8
            #[inline(always)]
            pub fn fdts2n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts2n8)
            }
            ///Fsampling = Fdts / 4, N=6
            #[inline(always)]
            pub fn fdts4n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts4n6)
            }
            ///Fsampling = Fdts / 4, N=8
            #[inline(always)]
            pub fn fdts4n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts4n8)
            }
            ///Fsampling = Fdts / 8, N=6
            #[inline(always)]
            pub fn fdts8n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts8n6)
            }
            ///Fsampling = Fdts / 8, N=8
            #[inline(always)]
            pub fn fdts8n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts8n8)
            }
            ///Fsampling = Fdts / 16, N=5
            #[inline(always)]
            pub fn fdts16n5(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts16n5)
            }
            ///Fsampling = Fdts / 16, N=6
            #[inline(always)]
            pub fn fdts16n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts16n6)
            }
            ///Fsampling = Fdts / 16, N=8
            #[inline(always)]
            pub fn fdts16n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts16n8)
            }
            ///Fsampling = Fdts / 32, N=5
            #[inline(always)]
            pub fn fdts32n5(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts32n5)
            }
            ///Fsampling = Fdts / 32, N=6
            #[inline(always)]
            pub fn fdts32n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts32n6)
            }
            ///Fsampling = Fdts / 32, N=8
            #[inline(always)]
            pub fn fdts32n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts32n8)
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, CC4S_A>;
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///0: CC4 configured as output
            Output = 0,
            ///1: CC4 configured as input. IC4 mapped to TI2
            InputTi2 = 1,
            ///2: CC4 configured as input. IC4 mapped to TI1
            InputTi1 = 2,
            ///3: CC4 configured as input. IC4 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        impl CC4S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC4S_A {
                match self.bits {
                    0 => CC4S_A::Output,
                    1 => CC4S_A::InputTi2,
                    2 => CC4S_A::InputTi1,
                    3 => CC4S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC4S_A::Output
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC4S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC4S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC4S_A::InputTrc
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, CC4S_A, 2, O>;
        impl<'a, const O: u8> CC4S_W<'a, O> {
            ///CC4 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4S_A::Output)
            }
            ///CC4 configured as input. IC4 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC4S_A::InputTi2)
            }
            ///CC4 configured as input. IC4 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC4S_A::InputTi1)
            }
            ///CC4 configured as input. IC4 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC4S_A::InputTrc)
            }
        }
        ///Field `IC4F` reader - Input capture 4 filter
        pub use IC3F_R as IC4F_R;
        ///Field `IC4F` writer - Input capture 4 filter
        pub use IC3F_W as IC4F_W;
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub use IC3PSC_R as IC4PSC_R;
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub use IC3PSC_W as IC4PSC_W;
        impl R {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic3psc(&mut self) -> IC3PSC_W<2> {
                IC3PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            #[must_use]
            pub fn ic3f(&mut self) -> IC3F_W<4> {
                IC3F_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic4psc(&mut self) -> IC4PSC_W<10> {
                IC4PSC_W::new(self)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            #[must_use]
            pub fn ic4f(&mut self) -> IC4F_W<12> {
                IC4F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2i](index.html) module
        pub struct CHCTLR2I_SPEC;
        impl crate::RegisterSpec for CHCTLR2I_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr2i::R](R) reader structure
        impl crate::Readable for CHCTLR2I_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2i::W](W) writer structure
        impl crate::Writable for CHCTLR2I_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2I to value 0
        impl crate::Resettable for CHCTLR2I_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CCER (rw) register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CCER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CCER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub type CC1E_R = crate::BitReader<bool>;
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub type CC1E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub type CC1P_R = crate::BitReader<bool>;
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub type CC1P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC1NE` reader - Capture/Compare 1 complementary output enable
        pub type CC1NE_R = crate::BitReader<bool>;
        ///Field `CC1NE` writer - Capture/Compare 1 complementary output enable
        pub type CC1NE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub type CC1NP_R = crate::BitReader<bool>;
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub type CC1NP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub type CC2E_R = crate::BitReader<bool>;
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub type CC2E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub type CC2P_R = crate::BitReader<bool>;
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub type CC2P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2NE` reader - Capture/Compare 2 complementary output enable
        pub type CC2NE_R = crate::BitReader<bool>;
        ///Field `CC2NE` writer - Capture/Compare 2 complementary output enable
        pub type CC2NE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2NP` reader - Capture/Compare 2 output Polarity
        pub type CC2NP_R = crate::BitReader<bool>;
        ///Field `CC2NP` writer - Capture/Compare 2 output Polarity
        pub type CC2NP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub type CC3E_R = crate::BitReader<bool>;
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub type CC3E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub type CC3P_R = crate::BitReader<bool>;
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub type CC3P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3NE` reader - Capture/Compare 3 complementary output enable
        pub type CC3NE_R = crate::BitReader<bool>;
        ///Field `CC3NE` writer - Capture/Compare 3 complementary output enable
        pub type CC3NE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3NP` reader - Capture/Compare 3 output Polarity
        pub type CC3NP_R = crate::BitReader<bool>;
        ///Field `CC3NP` writer - Capture/Compare 3 output Polarity
        pub type CC3NP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub type CC4E_R = crate::BitReader<bool>;
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub type CC4E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub type CC4P_R = crate::BitReader<bool>;
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub type CC4P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            pub fn cc2ne(&self) -> CC2NE_R {
                CC2NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            pub fn cc3ne(&self) -> CC3NE_R {
                CC3NE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3np(&self) -> CC3NP_R {
                CC3NP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1e(&mut self) -> CC1E_W<0> {
                CC1E_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1p(&mut self) -> CC1P_W<1> {
                CC1P_W::new(self)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ne(&mut self) -> CC1NE_W<2> {
                CC1NE_W::new(self)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1np(&mut self) -> CC1NP_W<3> {
                CC1NP_W::new(self)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2e(&mut self) -> CC2E_W<4> {
                CC2E_W::new(self)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2p(&mut self) -> CC2P_W<5> {
                CC2P_W::new(self)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ne(&mut self) -> CC2NE_W<6> {
                CC2NE_W::new(self)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2np(&mut self) -> CC2NP_W<7> {
                CC2NP_W::new(self)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3e(&mut self) -> CC3E_W<8> {
                CC3E_W::new(self)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3p(&mut self) -> CC3P_W<9> {
                CC3P_W::new(self)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ne(&mut self) -> CC3NE_W<10> {
                CC3NE_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3np(&mut self) -> CC3NP_W<11> {
                CC3NP_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc4e(&mut self) -> CC4E_W<12> {
                CC4E_W::new(self)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc4p(&mut self) -> CC4P_W<13> {
                CC4P_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub type CNT_R = crate::FieldReader<u16, u16>;
        ///Field `CNT` writer - counter value
        pub type CNT_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            #[must_use]
            pub fn cnt(&mut self) -> CNT_W<0> {
                CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PSC (rw) register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PSC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u16, u16>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, const O: u8> = crate::FieldWriter<'a, u16, PSC_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<0> {
                PSC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ATRLR (rw) register accessor: an alias for `Reg<ATRLR_SPEC>`
    pub type ATRLR = crate::Reg<atrlr::ATRLR_SPEC>;
    ///auto-reload register
    pub mod atrlr {
        ///Register `ATRLR` reader
        pub struct R(crate::R<ATRLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ATRLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ATRLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ATRLR` writer
        pub struct W(crate::W<ATRLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ATRLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ATRLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub type ARR_R = crate::FieldReader<u16, u16>;
        ///Field `ARR` writer - Auto-reload value
        pub type ARR_W<'a, const O: u8> = crate::FieldWriter<'a, u16, ATRLR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            #[must_use]
            pub fn arr(&mut self) -> ARR_W<0> {
                ARR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [atrlr](index.html) module
        pub struct ATRLR_SPEC;
        impl crate::RegisterSpec for ATRLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [atrlr::R](R) reader structure
        impl crate::Readable for ATRLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [atrlr::W](W) writer structure
        impl crate::Writable for ATRLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ATRLR to value 0
        impl crate::Resettable for ATRLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH1CVR (rw) register accessor: an alias for `Reg<CH1CVR_SPEC>`
    pub type CH1CVR = crate::Reg<ch1cvr::CH1CVR_SPEC>;
    ///capture/compare register 1
    pub mod ch1cvr {
        ///Register `CH1CVR` reader
        pub struct R(crate::R<CH1CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH1CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH1CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH1CVR` writer
        pub struct W(crate::W<CH1CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH1CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH1CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR1` reader - Capture/Compare 1 value
        pub type CCR1_R = crate::FieldReader<u16, u16>;
        ///Field `CCR1` writer - Capture/Compare 1 value
        pub type CCR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH1CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            #[must_use]
            pub fn ccr1(&mut self) -> CCR1_W<0> {
                CCR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch1cvr](index.html) module
        pub struct CH1CVR_SPEC;
        impl crate::RegisterSpec for CH1CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch1cvr::R](R) reader structure
        impl crate::Readable for CH1CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch1cvr::W](W) writer structure
        impl crate::Writable for CH1CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH1CVR to value 0
        impl crate::Resettable for CH1CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH2CVR (rw) register accessor: an alias for `Reg<CH2CVR_SPEC>`
    pub type CH2CVR = crate::Reg<ch2cvr::CH2CVR_SPEC>;
    ///capture/compare register 2
    pub mod ch2cvr {
        ///Register `CH2CVR` reader
        pub struct R(crate::R<CH2CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH2CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH2CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH2CVR` writer
        pub struct W(crate::W<CH2CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH2CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH2CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR2` reader - Capture/Compare 2 value
        pub type CCR2_R = crate::FieldReader<u16, u16>;
        ///Field `CCR2` writer - Capture/Compare 2 value
        pub type CCR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH2CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ccr2(&self) -> CCR2_R {
                CCR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            #[must_use]
            pub fn ccr2(&mut self) -> CCR2_W<0> {
                CCR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch2cvr](index.html) module
        pub struct CH2CVR_SPEC;
        impl crate::RegisterSpec for CH2CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch2cvr::R](R) reader structure
        impl crate::Readable for CH2CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch2cvr::W](W) writer structure
        impl crate::Writable for CH2CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH2CVR to value 0
        impl crate::Resettable for CH2CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH3CVR (rw) register accessor: an alias for `Reg<CH3CVR_SPEC>`
    pub type CH3CVR = crate::Reg<ch3cvr::CH3CVR_SPEC>;
    ///capture/compare register 3
    pub mod ch3cvr {
        ///Register `CH3CVR` reader
        pub struct R(crate::R<CH3CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH3CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH3CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH3CVR` writer
        pub struct W(crate::W<CH3CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH3CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH3CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR3` reader - Capture/Compare value
        pub type CCR3_R = crate::FieldReader<u16, u16>;
        ///Field `CCR3` writer - Capture/Compare value
        pub type CCR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH3CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr3(&self) -> CCR3_R {
                CCR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr3(&mut self) -> CCR3_W<0> {
                CCR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch3cvr](index.html) module
        pub struct CH3CVR_SPEC;
        impl crate::RegisterSpec for CH3CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch3cvr::R](R) reader structure
        impl crate::Readable for CH3CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch3cvr::W](W) writer structure
        impl crate::Writable for CH3CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH3CVR to value 0
        impl crate::Resettable for CH3CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH4CVR (rw) register accessor: an alias for `Reg<CH4CVR_SPEC>`
    pub type CH4CVR = crate::Reg<ch4cvr::CH4CVR_SPEC>;
    ///capture/compare register 4
    pub mod ch4cvr {
        ///Register `CH4CVR` reader
        pub struct R(crate::R<CH4CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH4CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH4CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH4CVR` writer
        pub struct W(crate::W<CH4CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH4CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH4CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR4` reader - Capture/Compare value
        pub type CCR4_R = crate::FieldReader<u16, u16>;
        ///Field `CCR4` writer - Capture/Compare value
        pub type CCR4_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH4CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr4(&self) -> CCR4_R {
                CCR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr4(&mut self) -> CCR4_W<0> {
                CCR4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch4cvr](index.html) module
        pub struct CH4CVR_SPEC;
        impl crate::RegisterSpec for CH4CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch4cvr::R](R) reader structure
        impl crate::Readable for CH4CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch4cvr::W](W) writer structure
        impl crate::Writable for CH4CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH4CVR to value 0
        impl crate::Resettable for CH4CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMACFGR (rw) register accessor: an alias for `Reg<DMACFGR_SPEC>`
    pub type DMACFGR = crate::Reg<dmacfgr::DMACFGR_SPEC>;
    ///DMA control register
    pub mod dmacfgr {
        ///Register `DMACFGR` reader
        pub struct R(crate::R<DMACFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMACFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMACFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMACFGR` writer
        pub struct W(crate::W<DMACFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMACFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMACFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBA` reader - DMA base address
        pub type DBA_R = crate::FieldReader<u8, u8>;
        ///Field `DBA` writer - DMA base address
        pub type DBA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DMACFGR_SPEC, u8, u8, 5, O>;
        ///Field `DBL` reader - DMA burst length
        pub type DBL_R = crate::FieldReader<u8, u8>;
        ///Field `DBL` writer - DMA burst length
        pub type DBL_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DMACFGR_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            #[must_use]
            pub fn dba(&mut self) -> DBA_W<0> {
                DBA_W::new(self)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            #[must_use]
            pub fn dbl(&mut self) -> DBL_W<8> {
                DBL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmacfgr](index.html) module
        pub struct DMACFGR_SPEC;
        impl crate::RegisterSpec for DMACFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dmacfgr::R](R) reader structure
        impl crate::Readable for DMACFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmacfgr::W](W) writer structure
        impl crate::Writable for DMACFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMACFGR to value 0
        impl crate::Resettable for DMACFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAR (rw) register accessor: an alias for `Reg<DMAR_SPEC>`
    pub type DMAR = crate::Reg<dmar::DMAR_SPEC>;
    ///DMA address for full transfer
    pub mod dmar {
        ///Register `DMAR` reader
        pub struct R(crate::R<DMAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAR` writer
        pub struct W(crate::W<DMAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAB` reader - DMA register for burst accesses
        pub type DMAB_R = crate::FieldReader<u16, u16>;
        ///Field `DMAB` writer - DMA register for burst accesses
        pub type DMAB_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DMAR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            #[must_use]
            pub fn dmab(&mut self) -> DMAB_W<0> {
                DMAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmar](index.html) module
        pub struct DMAR_SPEC;
        impl crate::RegisterSpec for DMAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dmar::R](R) reader structure
        impl crate::Readable for DMAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmar::W](W) writer structure
        impl crate::Writable for DMAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAR to value 0
        impl crate::Resettable for DMAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RPTCR (rw) register accessor: an alias for `Reg<RPTCR_SPEC>`
    pub type RPTCR = crate::Reg<rptcr::RPTCR_SPEC>;
    ///repetition counter register
    pub mod rptcr {
        ///Register `RPTCR` reader
        pub struct R(crate::R<RPTCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RPTCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RPTCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RPTCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RPTCR` writer
        pub struct W(crate::W<RPTCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RPTCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RPTCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RPTCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `REP` reader - Repetition counter value
        pub type REP_R = crate::FieldReader<u8, u8>;
        ///Field `REP` writer - Repetition counter value
        pub type REP_W<'a, const O: u8> = crate::FieldWriter<'a, u16, RPTCR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            #[must_use]
            pub fn rep(&mut self) -> REP_W<0> {
                REP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///repetition counter register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rptcr](index.html) module
        pub struct RPTCR_SPEC;
        impl crate::RegisterSpec for RPTCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [rptcr::R](R) reader structure
        impl crate::Readable for RPTCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rptcr::W](W) writer structure
        impl crate::Writable for RPTCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RPTCR to value 0
        impl crate::Resettable for RPTCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BDTR (rw) register accessor: an alias for `Reg<BDTR_SPEC>`
    pub type BDTR = crate::Reg<bdtr::BDTR_SPEC>;
    ///break and dead-time register
    pub mod bdtr {
        ///Register `BDTR` reader
        pub struct R(crate::R<BDTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BDTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BDTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDTR` writer
        pub struct W(crate::W<BDTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BDTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BDTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DTG` reader - Dead-time generator setup
        pub type DTG_R = crate::FieldReader<u8, u8>;
        ///Field `DTG` writer - Dead-time generator setup
        pub type DTG_W<'a, const O: u8> = crate::FieldWriter<'a, u16, BDTR_SPEC, u8, u8, 8, O>;
        ///Field `LOCK` reader - Lock configuration
        pub type LOCK_R = crate::FieldReader<u8, LOCK_A>;
        ///Lock configuration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum LOCK_A {
            ///0: Lock disabled
            Disabled = 0,
            ///1: DTG BKE BKP AOE OISx OISxN not writable
            LockLevel1 = 1,
            ///2: CC polarity + OSSR OSSI + Level1
            LockLevel2 = 2,
            ///3: CC control + Level2
            LockLevel3 = 3,
        }
        impl From<LOCK_A> for u8 {
            #[inline(always)]
            fn from(variant: LOCK_A) -> Self {
                variant as _
            }
        }
        impl LOCK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LOCK_A {
                match self.bits {
                    0 => LOCK_A::Disabled,
                    1 => LOCK_A::LockLevel1,
                    2 => LOCK_A::LockLevel2,
                    3 => LOCK_A::LockLevel3,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LOCK_A::Disabled
            }
            ///Checks if the value of the field is `LockLevel1`
            #[inline(always)]
            pub fn is_lock_level1(&self) -> bool {
                *self == LOCK_A::LockLevel1
            }
            ///Checks if the value of the field is `LockLevel2`
            #[inline(always)]
            pub fn is_lock_level2(&self) -> bool {
                *self == LOCK_A::LockLevel2
            }
            ///Checks if the value of the field is `LockLevel3`
            #[inline(always)]
            pub fn is_lock_level3(&self) -> bool {
                *self == LOCK_A::LockLevel3
            }
        }
        ///Field `LOCK` writer - Lock configuration
        pub type LOCK_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, BDTR_SPEC, u8, LOCK_A, 2, O>;
        impl<'a, const O: u8> LOCK_W<'a, O> {
            ///Lock disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LOCK_A::Disabled)
            }
            ///DTG BKE BKP AOE OISx OISxN not writable
            #[inline(always)]
            pub fn lock_level1(self) -> &'a mut W {
                self.variant(LOCK_A::LockLevel1)
            }
            ///CC polarity + OSSR OSSI + Level1
            #[inline(always)]
            pub fn lock_level2(self) -> &'a mut W {
                self.variant(LOCK_A::LockLevel2)
            }
            ///CC control + Level2
            #[inline(always)]
            pub fn lock_level3(self) -> &'a mut W {
                self.variant(LOCK_A::LockLevel3)
            }
        }
        ///Field `OSSI` reader - Off-state selection for Idle mode
        pub type OSSI_R = crate::BitReader<OSSI_A>;
        ///Off-state selection for Idle mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OSSI_A {
            ///0: No action on idle
            NoAction = 0,
            ///1: Output idle voltage level on OC/OCN when CCxE or CCxNE=1
            Output = 1,
        }
        impl From<OSSI_A> for bool {
            #[inline(always)]
            fn from(variant: OSSI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OSSI_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OSSI_A {
                match self.bits {
                    false => OSSI_A::NoAction,
                    true => OSSI_A::Output,
                }
            }
            ///Checks if the value of the field is `NoAction`
            #[inline(always)]
            pub fn is_no_action(&self) -> bool {
                *self == OSSI_A::NoAction
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == OSSI_A::Output
            }
        }
        ///Field `OSSI` writer - Off-state selection for Idle mode
        pub type OSSI_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, OSSI_A, O>;
        impl<'a, const O: u8> OSSI_W<'a, O> {
            ///No action on idle
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(OSSI_A::NoAction)
            }
            ///Output idle voltage level on OC/OCN when CCxE or CCxNE=1
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(OSSI_A::Output)
            }
        }
        ///Field `OSSR` reader - Off-state selection for Run mode
        pub type OSSR_R = crate::BitReader<OSSR_A>;
        ///Off-state selection for Run mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OSSR_A {
            ///0: No action on running
            NoAction = 0,
            ///1: Output low voltage level on OC/OCN when CCxE or CCxNE=1
            Output = 1,
        }
        impl From<OSSR_A> for bool {
            #[inline(always)]
            fn from(variant: OSSR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OSSR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OSSR_A {
                match self.bits {
                    false => OSSR_A::NoAction,
                    true => OSSR_A::Output,
                }
            }
            ///Checks if the value of the field is `NoAction`
            #[inline(always)]
            pub fn is_no_action(&self) -> bool {
                *self == OSSR_A::NoAction
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == OSSR_A::Output
            }
        }
        ///Field `OSSR` writer - Off-state selection for Run mode
        pub type OSSR_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, OSSR_A, O>;
        impl<'a, const O: u8> OSSR_W<'a, O> {
            ///No action on running
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(OSSR_A::NoAction)
            }
            ///Output low voltage level on OC/OCN when CCxE or CCxNE=1
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(OSSR_A::Output)
            }
        }
        ///Field `BKE` reader - Break enable
        pub type BKE_R = crate::BitReader<BKE_A>;
        ///Break enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BKE_A {
            ///0: Brake input disabled
            Disabled = 0,
            ///1: Brake input enabled
            Enabled = 1,
        }
        impl From<BKE_A> for bool {
            #[inline(always)]
            fn from(variant: BKE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BKE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BKE_A {
                match self.bits {
                    false => BKE_A::Disabled,
                    true => BKE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BKE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BKE_A::Enabled
            }
        }
        ///Field `BKE` writer - Break enable
        pub type BKE_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, BKE_A, O>;
        impl<'a, const O: u8> BKE_W<'a, O> {
            ///Brake input disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BKE_A::Disabled)
            }
            ///Brake input enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BKE_A::Enabled)
            }
        }
        ///Field `BKP` reader - Break polarity
        pub type BKP_R = crate::BitReader<BKP_A>;
        ///Break polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BKP_A {
            ///0: Brake input activate on low voltage
            Low = 0,
            ///1: Brake input activate on high voltage
            High = 1,
        }
        impl From<BKP_A> for bool {
            #[inline(always)]
            fn from(variant: BKP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BKP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BKP_A {
                match self.bits {
                    false => BKP_A::Low,
                    true => BKP_A::High,
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == BKP_A::Low
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == BKP_A::High
            }
        }
        ///Field `BKP` writer - Break polarity
        pub type BKP_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, BKP_A, O>;
        impl<'a, const O: u8> BKP_W<'a, O> {
            ///Brake input activate on low voltage
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(BKP_A::Low)
            }
            ///Brake input activate on high voltage
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(BKP_A::High)
            }
        }
        ///Field `AOE` reader - Automatic output enable
        pub type AOE_R = crate::BitReader<bool>;
        ///Field `AOE` writer - Automatic output enable
        pub type AOE_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, bool, O>;
        ///Field `MOE` reader - Main output enable
        pub type MOE_R = crate::BitReader<MOE_A>;
        ///Main output enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MOE_A {
            ///0: OCx and OCxN no output or force idle
            Disabled = 0,
            ///1: OCx and OCxN output enabled
            Enabled = 1,
        }
        impl From<MOE_A> for bool {
            #[inline(always)]
            fn from(variant: MOE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MOE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MOE_A {
                match self.bits {
                    false => MOE_A::Disabled,
                    true => MOE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == MOE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == MOE_A::Enabled
            }
        }
        ///Field `MOE` writer - Main output enable
        pub type MOE_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, MOE_A, O>;
        impl<'a, const O: u8> MOE_W<'a, O> {
            ///OCx and OCxN no output or force idle
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MOE_A::Disabled)
            }
            ///OCx and OCxN output enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MOE_A::Enabled)
            }
        }
        impl R {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            #[must_use]
            pub fn dtg(&mut self) -> DTG_W<0> {
                DTG_W::new(self)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            #[must_use]
            pub fn lock(&mut self) -> LOCK_W<8> {
                LOCK_W::new(self)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            #[must_use]
            pub fn ossi(&mut self) -> OSSI_W<10> {
                OSSI_W::new(self)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            #[must_use]
            pub fn ossr(&mut self) -> OSSR_W<11> {
                OSSR_W::new(self)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            #[must_use]
            pub fn bke(&mut self) -> BKE_W<12> {
                BKE_W::new(self)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            #[must_use]
            pub fn bkp(&mut self) -> BKP_W<13> {
                BKP_W::new(self)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            #[must_use]
            pub fn aoe(&mut self) -> AOE_W<14> {
                AOE_W::new(self)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            #[must_use]
            pub fn moe(&mut self) -> MOE_W<15> {
                MOE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///break and dead-time register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdtr](index.html) module
        pub struct BDTR_SPEC;
        impl crate::RegisterSpec for BDTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [bdtr::R](R) reader structure
        impl crate::Readable for BDTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdtr::W](W) writer structure
        impl crate::Writable for BDTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BDTR to value 0
        impl crate::Resettable for BDTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///General timer
pub struct TIM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM3 {}
impl TIM3 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM3 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM3").finish()
    }
}
///General timer
pub use self::tim2 as tim3;
///General timer
pub struct TIM4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM4 {}
impl TIM4 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM4 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM4").finish()
    }
}
///General timer
pub use self::tim2 as tim4;
///Inter integrated circuit
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x4000_5400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C1").finish()
    }
}
///Inter integrated circuit
pub mod i2c1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register 1
        pub ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ///0x04 - Control register 2
        pub ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        ///0x08 - Own address register 1
        pub oaddr1: OADDR1,
        _reserved3: [u8; 0x02],
        ///0x0c - Own address register 2
        pub oaddr2: OADDR2,
        _reserved4: [u8; 0x02],
        ///0x10 - Data register
        pub datar: DATAR,
        _reserved5: [u8; 0x02],
        ///0x14 - Status register 1
        pub star1: STAR1,
        _reserved6: [u8; 0x02],
        ///0x18 - Status register 2
        pub star2: STAR2,
        _reserved7: [u8; 0x02],
        ///0x1c - Clock control register
        pub ckcfgr: CKCFGR,
        _reserved8: [u8; 0x02],
        ///0x20 - RTR register
        pub rtr: RTR,
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///Control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PE` reader - Peripheral enable
        pub type PE_R = crate::BitReader<PE_A>;
        ///Peripheral enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PE_A {
            ///0: I2C disabled
            Disabled = 0,
            ///1: I2C enabled
            Enabled = 1,
        }
        impl From<PE_A> for bool {
            #[inline(always)]
            fn from(variant: PE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PE_A {
                match self.bits {
                    false => PE_A::Disabled,
                    true => PE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PE_A::Enabled
            }
        }
        ///Field `PE` writer - Peripheral enable
        pub type PE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, PE_A, O>;
        impl<'a, const O: u8> PE_W<'a, O> {
            ///I2C disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PE_A::Disabled)
            }
            ///I2C enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PE_A::Enabled)
            }
        }
        ///Field `SMBUS` reader - SMBus mode
        pub type SMBUS_R = crate::BitReader<SMBUS_A>;
        ///SMBus mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SMBUS_A {
            ///0: I2C Mode
            I2c = 0,
            ///1: SMBus
            Smbus = 1,
        }
        impl From<SMBUS_A> for bool {
            #[inline(always)]
            fn from(variant: SMBUS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SMBUS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBUS_A {
                match self.bits {
                    false => SMBUS_A::I2c,
                    true => SMBUS_A::Smbus,
                }
            }
            ///Checks if the value of the field is `I2c`
            #[inline(always)]
            pub fn is_i2c(&self) -> bool {
                *self == SMBUS_A::I2c
            }
            ///Checks if the value of the field is `Smbus`
            #[inline(always)]
            pub fn is_smbus(&self) -> bool {
                *self == SMBUS_A::Smbus
            }
        }
        ///Field `SMBUS` writer - SMBus mode
        pub type SMBUS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, SMBUS_A, O>;
        impl<'a, const O: u8> SMBUS_W<'a, O> {
            ///I2C Mode
            #[inline(always)]
            pub fn i2c(self) -> &'a mut W {
                self.variant(SMBUS_A::I2c)
            }
            ///SMBus
            #[inline(always)]
            pub fn smbus(self) -> &'a mut W {
                self.variant(SMBUS_A::Smbus)
            }
        }
        ///Field `SMBTYPE` reader - SMBus type
        pub type SMBTYPE_R = crate::BitReader<SMBTYPE_A>;
        ///SMBus type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SMBTYPE_A {
            ///0: SMBus Device
            Device = 0,
            ///1: SMBus Host
            Host = 1,
        }
        impl From<SMBTYPE_A> for bool {
            #[inline(always)]
            fn from(variant: SMBTYPE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SMBTYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBTYPE_A {
                match self.bits {
                    false => SMBTYPE_A::Device,
                    true => SMBTYPE_A::Host,
                }
            }
            ///Checks if the value of the field is `Device`
            #[inline(always)]
            pub fn is_device(&self) -> bool {
                *self == SMBTYPE_A::Device
            }
            ///Checks if the value of the field is `Host`
            #[inline(always)]
            pub fn is_host(&self) -> bool {
                *self == SMBTYPE_A::Host
            }
        }
        ///Field `SMBTYPE` writer - SMBus type
        pub type SMBTYPE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, SMBTYPE_A, O>;
        impl<'a, const O: u8> SMBTYPE_W<'a, O> {
            ///SMBus Device
            #[inline(always)]
            pub fn device(self) -> &'a mut W {
                self.variant(SMBTYPE_A::Device)
            }
            ///SMBus Host
            #[inline(always)]
            pub fn host(self) -> &'a mut W {
                self.variant(SMBTYPE_A::Host)
            }
        }
        ///Field `ENARP` reader - ARP enable
        pub type ENARP_R = crate::BitReader<ENARP_A>;
        ///ARP enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ENARP_A {
            ///0: ARP disabled
            Disabled = 0,
            ///1: ARP enabled
            Enabled = 1,
        }
        impl From<ENARP_A> for bool {
            #[inline(always)]
            fn from(variant: ENARP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ENARP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENARP_A {
                match self.bits {
                    false => ENARP_A::Disabled,
                    true => ENARP_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENARP_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENARP_A::Enabled
            }
        }
        ///Field `ENARP` writer - ARP enable
        pub type ENARP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, ENARP_A, O>;
        impl<'a, const O: u8> ENARP_W<'a, O> {
            ///ARP disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENARP_A::Disabled)
            }
            ///ARP enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENARP_A::Enabled)
            }
        }
        ///Field `ENPEC` reader - PEC enable
        pub type ENPEC_R = crate::BitReader<ENPEC_A>;
        ///PEC enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ENPEC_A {
            ///0: PEC disabled
            Disabled = 0,
            ///1: PEC enabled
            Enabled = 1,
        }
        impl From<ENPEC_A> for bool {
            #[inline(always)]
            fn from(variant: ENPEC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ENPEC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENPEC_A {
                match self.bits {
                    false => ENPEC_A::Disabled,
                    true => ENPEC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENPEC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENPEC_A::Enabled
            }
        }
        ///Field `ENPEC` writer - PEC enable
        pub type ENPEC_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, ENPEC_A, O>;
        impl<'a, const O: u8> ENPEC_W<'a, O> {
            ///PEC disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENPEC_A::Disabled)
            }
            ///PEC enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENPEC_A::Enabled)
            }
        }
        ///Field `ENGC` reader - General call enable
        pub type ENGC_R = crate::BitReader<ENGC_A>;
        ///General call enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ENGC_A {
            ///0: General call enabled
            Disabled = 0,
            ///1: General call disabled
            Enabled = 1,
        }
        impl From<ENGC_A> for bool {
            #[inline(always)]
            fn from(variant: ENGC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ENGC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENGC_A {
                match self.bits {
                    false => ENGC_A::Disabled,
                    true => ENGC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ENGC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ENGC_A::Enabled
            }
        }
        ///Field `ENGC` writer - General call enable
        pub type ENGC_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, ENGC_A, O>;
        impl<'a, const O: u8> ENGC_W<'a, O> {
            ///General call enabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENGC_A::Disabled)
            }
            ///General call disabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENGC_A::Enabled)
            }
        }
        ///Field `NOSTRETCH` reader - Clock stretching disable (Slave mode)
        pub type NOSTRETCH_R = crate::BitReader<NOSTRETCH_A>;
        ///Clock stretching disable (Slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum NOSTRETCH_A {
            ///0: Clock stretching enabled
            Enabled = 0,
            ///1: Clock stretching disabled
            Disabled = 1,
        }
        impl From<NOSTRETCH_A> for bool {
            #[inline(always)]
            fn from(variant: NOSTRETCH_A) -> Self {
                variant as u8 != 0
            }
        }
        impl NOSTRETCH_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> NOSTRETCH_A {
                match self.bits {
                    false => NOSTRETCH_A::Enabled,
                    true => NOSTRETCH_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NOSTRETCH_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NOSTRETCH_A::Disabled
            }
        }
        ///Field `NOSTRETCH` writer - Clock stretching disable (Slave mode)
        pub type NOSTRETCH_W<'a, const O: u8> =
            crate::BitWriter<'a, u16, CTLR1_SPEC, NOSTRETCH_A, O>;
        impl<'a, const O: u8> NOSTRETCH_W<'a, O> {
            ///Clock stretching enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::Enabled)
            }
            ///Clock stretching disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::Disabled)
            }
        }
        ///Field `START` reader - Start generation
        pub type START_R = crate::BitReader<START_A>;
        ///Start generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum START_A {
            ///0: No Start generation
            NoStart = 0,
            ///1: In master mode: repeated start generation, in slave mode: start generation when bus is free
            Start = 1,
        }
        impl From<START_A> for bool {
            #[inline(always)]
            fn from(variant: START_A) -> Self {
                variant as u8 != 0
            }
        }
        impl START_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> START_A {
                match self.bits {
                    false => START_A::NoStart,
                    true => START_A::Start,
                }
            }
            ///Checks if the value of the field is `NoStart`
            #[inline(always)]
            pub fn is_no_start(&self) -> bool {
                *self == START_A::NoStart
            }
            ///Checks if the value of the field is `Start`
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == START_A::Start
            }
        }
        ///Field `START` writer - Start generation
        pub type START_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, START_A, O>;
        impl<'a, const O: u8> START_W<'a, O> {
            ///No Start generation
            #[inline(always)]
            pub fn no_start(self) -> &'a mut W {
                self.variant(START_A::NoStart)
            }
            ///In master mode: repeated start generation, in slave mode: start generation when bus is free
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(START_A::Start)
            }
        }
        ///Field `STOP` reader - Stop generation
        pub type STOP_R = crate::BitReader<STOP_A>;
        ///Stop generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STOP_A {
            ///0: No Stop generation
            NoStop = 0,
            ///1: In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte
            Stop = 1,
        }
        impl From<STOP_A> for bool {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STOP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    false => STOP_A::NoStop,
                    true => STOP_A::Stop,
                }
            }
            ///Checks if the value of the field is `NoStop`
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                *self == STOP_A::NoStop
            }
            ///Checks if the value of the field is `Stop`
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == STOP_A::Stop
            }
        }
        ///Field `STOP` writer - Stop generation
        pub type STOP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, STOP_A, O>;
        impl<'a, const O: u8> STOP_W<'a, O> {
            ///No Stop generation
            #[inline(always)]
            pub fn no_stop(self) -> &'a mut W {
                self.variant(STOP_A::NoStop)
            }
            ///In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(STOP_A::Stop)
            }
        }
        ///Field `ACK` reader - Acknowledge enable
        pub type ACK_R = crate::BitReader<ACK_A>;
        ///Acknowledge enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ACK_A {
            ///0: No acknowledge returned
            Nak = 0,
            ///1: Acknowledge returned after a byte is received
            Ack = 1,
        }
        impl From<ACK_A> for bool {
            #[inline(always)]
            fn from(variant: ACK_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ACK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ACK_A {
                match self.bits {
                    false => ACK_A::Nak,
                    true => ACK_A::Ack,
                }
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == ACK_A::Nak
            }
            ///Checks if the value of the field is `Ack`
            #[inline(always)]
            pub fn is_ack(&self) -> bool {
                *self == ACK_A::Ack
            }
        }
        ///Field `ACK` writer - Acknowledge enable
        pub type ACK_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, ACK_A, O>;
        impl<'a, const O: u8> ACK_W<'a, O> {
            ///No acknowledge returned
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(ACK_A::Nak)
            }
            ///Acknowledge returned after a byte is received
            #[inline(always)]
            pub fn ack(self) -> &'a mut W {
                self.variant(ACK_A::Ack)
            }
        }
        ///Field `POS` reader - Acknowledge/PEC Position (for data reception)
        pub type POS_R = crate::BitReader<POS_A>;
        ///Acknowledge/PEC Position (for data reception)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum POS_A {
            ///0: ACK bit controls the (N)ACK of the current byte being received
            Current = 0,
            ///1: ACK bit controls the (N)ACK of the next byte to be received
            Next = 1,
        }
        impl From<POS_A> for bool {
            #[inline(always)]
            fn from(variant: POS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl POS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> POS_A {
                match self.bits {
                    false => POS_A::Current,
                    true => POS_A::Next,
                }
            }
            ///Checks if the value of the field is `Current`
            #[inline(always)]
            pub fn is_current(&self) -> bool {
                *self == POS_A::Current
            }
            ///Checks if the value of the field is `Next`
            #[inline(always)]
            pub fn is_next(&self) -> bool {
                *self == POS_A::Next
            }
        }
        ///Field `POS` writer - Acknowledge/PEC Position (for data reception)
        pub type POS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, POS_A, O>;
        impl<'a, const O: u8> POS_W<'a, O> {
            ///ACK bit controls the (N)ACK of the current byte being received
            #[inline(always)]
            pub fn current(self) -> &'a mut W {
                self.variant(POS_A::Current)
            }
            ///ACK bit controls the (N)ACK of the next byte to be received
            #[inline(always)]
            pub fn next(self) -> &'a mut W {
                self.variant(POS_A::Next)
            }
        }
        ///Field `PEC` reader - Packet error checking
        pub type PEC_R = crate::BitReader<PEC_A>;
        ///Packet error checking
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PEC_A {
            ///0: No PEC transfer
            Disabled = 0,
            ///1: PEC transfer
            Enabled = 1,
        }
        impl From<PEC_A> for bool {
            #[inline(always)]
            fn from(variant: PEC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PEC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PEC_A {
                match self.bits {
                    false => PEC_A::Disabled,
                    true => PEC_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PEC_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PEC_A::Enabled
            }
        }
        ///Field `PEC` writer - Packet error checking
        pub type PEC_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, PEC_A, O>;
        impl<'a, const O: u8> PEC_W<'a, O> {
            ///No PEC transfer
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEC_A::Disabled)
            }
            ///PEC transfer
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEC_A::Enabled)
            }
        }
        ///Field `ALERT` reader - SMBus alert
        pub type ALERT_R = crate::BitReader<ALERT_A>;
        ///SMBus alert
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ALERT_A {
            ///0: SMBA pin released high
            Release = 0,
            ///1: SMBA pin driven low
            Drive = 1,
        }
        impl From<ALERT_A> for bool {
            #[inline(always)]
            fn from(variant: ALERT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ALERT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ALERT_A {
                match self.bits {
                    false => ALERT_A::Release,
                    true => ALERT_A::Drive,
                }
            }
            ///Checks if the value of the field is `Release`
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                *self == ALERT_A::Release
            }
            ///Checks if the value of the field is `Drive`
            #[inline(always)]
            pub fn is_drive(&self) -> bool {
                *self == ALERT_A::Drive
            }
        }
        ///Field `ALERT` writer - SMBus alert
        pub type ALERT_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, ALERT_A, O>;
        impl<'a, const O: u8> ALERT_W<'a, O> {
            ///SMBA pin released high
            #[inline(always)]
            pub fn release(self) -> &'a mut W {
                self.variant(ALERT_A::Release)
            }
            ///SMBA pin driven low
            #[inline(always)]
            pub fn drive(self) -> &'a mut W {
                self.variant(ALERT_A::Drive)
            }
        }
        ///Field `SWRST` reader - Software reset
        pub type SWRST_R = crate::BitReader<SWRST_A>;
        ///Software reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SWRST_A {
            ///0: I2C peripheral not under reset
            NotReset = 0,
            ///1: I2C peripheral under reset
            Reset = 1,
        }
        impl From<SWRST_A> for bool {
            #[inline(always)]
            fn from(variant: SWRST_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SWRST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SWRST_A {
                match self.bits {
                    false => SWRST_A::NotReset,
                    true => SWRST_A::Reset,
                }
            }
            ///Checks if the value of the field is `NotReset`
            #[inline(always)]
            pub fn is_not_reset(&self) -> bool {
                *self == SWRST_A::NotReset
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == SWRST_A::Reset
            }
        }
        ///Field `SWRST` writer - Software reset
        pub type SWRST_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, SWRST_A, O>;
        impl<'a, const O: u8> SWRST_W<'a, O> {
            ///I2C peripheral not under reset
            #[inline(always)]
            pub fn not_reset(self) -> &'a mut W {
                self.variant(SWRST_A::NotReset)
            }
            ///I2C peripheral under reset
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SWRST_A::Reset)
            }
        }
        impl R {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - SMBus mode
            #[inline(always)]
            pub fn smbus(&self) -> SMBUS_R {
                SMBUS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 3 - SMBus type
            #[inline(always)]
            pub fn smbtype(&self) -> SMBTYPE_R {
                SMBTYPE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            pub fn enarp(&self) -> ENARP_R {
                ENARP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            pub fn enpec(&self) -> ENPEC_R {
                ENPEC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            pub fn engc(&self) -> ENGC_R {
                ENGC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn nostretch(&self) -> NOSTRETCH_R {
                NOSTRETCH_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            pub fn ack(&self) -> ACK_R {
                ACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn pos(&self) -> POS_R {
                POS_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - SMBus alert
            #[inline(always)]
            pub fn alert(&self) -> ALERT_R {
                ALERT_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 15 - Software reset
            #[inline(always)]
            pub fn swrst(&self) -> SWRST_R {
                SWRST_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<0> {
                PE_W::new(self)
            }
            ///Bit 1 - SMBus mode
            #[inline(always)]
            #[must_use]
            pub fn smbus(&mut self) -> SMBUS_W<1> {
                SMBUS_W::new(self)
            }
            ///Bit 3 - SMBus type
            #[inline(always)]
            #[must_use]
            pub fn smbtype(&mut self) -> SMBTYPE_W<3> {
                SMBTYPE_W::new(self)
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            #[must_use]
            pub fn enarp(&mut self) -> ENARP_W<4> {
                ENARP_W::new(self)
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            #[must_use]
            pub fn enpec(&mut self) -> ENPEC_W<5> {
                ENPEC_W::new(self)
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            #[must_use]
            pub fn engc(&mut self) -> ENGC_W<6> {
                ENGC_W::new(self)
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            #[must_use]
            pub fn nostretch(&mut self) -> NOSTRETCH_W<7> {
                NOSTRETCH_W::new(self)
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            #[must_use]
            pub fn start(&mut self) -> START_W<8> {
                START_W::new(self)
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<9> {
                STOP_W::new(self)
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            #[must_use]
            pub fn ack(&mut self) -> ACK_W<10> {
                ACK_W::new(self)
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            #[must_use]
            pub fn pos(&mut self) -> POS_W<11> {
                POS_W::new(self)
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            #[must_use]
            pub fn pec(&mut self) -> PEC_W<12> {
                PEC_W::new(self)
            }
            ///Bit 13 - SMBus alert
            #[inline(always)]
            #[must_use]
            pub fn alert(&mut self) -> ALERT_W<13> {
                ALERT_W::new(self)
            }
            ///Bit 15 - Software reset
            #[inline(always)]
            #[must_use]
            pub fn swrst(&mut self) -> SWRST_W<15> {
                SWRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///Control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FREQ` reader - Peripheral clock frequency
        pub type FREQ_R = crate::FieldReader<u8, u8>;
        ///Field `FREQ` writer - Peripheral clock frequency
        pub type FREQ_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CTLR2_SPEC, u8, u8, 6, O>;
        ///Field `ITERREN` reader - Error interrupt enable
        pub type ITERREN_R = crate::BitReader<ITERREN_A>;
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ITERREN_A {
            ///0: Error interrupt disabled
            Disabled = 0,
            ///1: Error interrupt enabled
            Enabled = 1,
        }
        impl From<ITERREN_A> for bool {
            #[inline(always)]
            fn from(variant: ITERREN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ITERREN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ITERREN_A {
                match self.bits {
                    false => ITERREN_A::Disabled,
                    true => ITERREN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ITERREN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ITERREN_A::Enabled
            }
        }
        ///Field `ITERREN` writer - Error interrupt enable
        pub type ITERREN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, ITERREN_A, O>;
        impl<'a, const O: u8> ITERREN_W<'a, O> {
            ///Error interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITERREN_A::Disabled)
            }
            ///Error interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITERREN_A::Enabled)
            }
        }
        ///Field `ITEVTEN` reader - Event interrupt enable
        pub type ITEVTEN_R = crate::BitReader<ITEVTEN_A>;
        ///Event interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ITEVTEN_A {
            ///0: Event interrupt disabled
            Disabled = 0,
            ///1: Event interrupt enabled
            Enabled = 1,
        }
        impl From<ITEVTEN_A> for bool {
            #[inline(always)]
            fn from(variant: ITEVTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ITEVTEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ITEVTEN_A {
                match self.bits {
                    false => ITEVTEN_A::Disabled,
                    true => ITEVTEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ITEVTEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ITEVTEN_A::Enabled
            }
        }
        ///Field `ITEVTEN` writer - Event interrupt enable
        pub type ITEVTEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, ITEVTEN_A, O>;
        impl<'a, const O: u8> ITEVTEN_W<'a, O> {
            ///Event interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITEVTEN_A::Disabled)
            }
            ///Event interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITEVTEN_A::Enabled)
            }
        }
        ///Field `ITBUFEN` reader - Buffer interrupt enable
        pub type ITBUFEN_R = crate::BitReader<ITBUFEN_A>;
        ///Buffer interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ITBUFEN_A {
            ///0: TxE=1 or RxNE=1 does not generate any interrupt
            Disabled = 0,
            ///1: TxE=1 or RxNE=1 generates Event interrupt
            Enabled = 1,
        }
        impl From<ITBUFEN_A> for bool {
            #[inline(always)]
            fn from(variant: ITBUFEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ITBUFEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ITBUFEN_A {
                match self.bits {
                    false => ITBUFEN_A::Disabled,
                    true => ITBUFEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ITBUFEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ITBUFEN_A::Enabled
            }
        }
        ///Field `ITBUFEN` writer - Buffer interrupt enable
        pub type ITBUFEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, ITBUFEN_A, O>;
        impl<'a, const O: u8> ITBUFEN_W<'a, O> {
            ///TxE=1 or RxNE=1 does not generate any interrupt
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITBUFEN_A::Disabled)
            }
            ///TxE=1 or RxNE=1 generates Event interrupt
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITBUFEN_A::Enabled)
            }
        }
        ///Field `DMAEN` reader - DMA requests enable
        pub type DMAEN_R = crate::BitReader<DMAEN_A>;
        ///DMA requests enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMAEN_A {
            ///0: DMA requests disabled
            Disabled = 0,
            ///1: DMA request enabled when TxE=1 or RxNE=1
            Enabled = 1,
        }
        impl From<DMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMAEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAEN_A {
                match self.bits {
                    false => DMAEN_A::Disabled,
                    true => DMAEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN_A::Enabled
            }
        }
        ///Field `DMAEN` writer - DMA requests enable
        pub type DMAEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, DMAEN_A, O>;
        impl<'a, const O: u8> DMAEN_W<'a, O> {
            ///DMA requests disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN_A::Disabled)
            }
            ///DMA request enabled when TxE=1 or RxNE=1
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN_A::Enabled)
            }
        }
        ///Field `LAST` reader - DMA last transfer
        pub type LAST_R = crate::BitReader<LAST_A>;
        ///DMA last transfer
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LAST_A {
            ///0: Next DMA EOT is not the last transfer
            NotLast = 0,
            ///1: Next DMA EOT is the last transfer
            Last = 1,
        }
        impl From<LAST_A> for bool {
            #[inline(always)]
            fn from(variant: LAST_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LAST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LAST_A {
                match self.bits {
                    false => LAST_A::NotLast,
                    true => LAST_A::Last,
                }
            }
            ///Checks if the value of the field is `NotLast`
            #[inline(always)]
            pub fn is_not_last(&self) -> bool {
                *self == LAST_A::NotLast
            }
            ///Checks if the value of the field is `Last`
            #[inline(always)]
            pub fn is_last(&self) -> bool {
                *self == LAST_A::Last
            }
        }
        ///Field `LAST` writer - DMA last transfer
        pub type LAST_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, LAST_A, O>;
        impl<'a, const O: u8> LAST_W<'a, O> {
            ///Next DMA EOT is not the last transfer
            #[inline(always)]
            pub fn not_last(self) -> &'a mut W {
                self.variant(LAST_A::NotLast)
            }
            ///Next DMA EOT is the last transfer
            #[inline(always)]
            pub fn last(self) -> &'a mut W {
                self.variant(LAST_A::Last)
            }
        }
        impl R {
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            pub fn freq(&self) -> FREQ_R {
                FREQ_R::new((self.bits & 0x3f) as u8)
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            pub fn iterren(&self) -> ITERREN_R {
                ITERREN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            pub fn itevten(&self) -> ITEVTEN_R {
                ITEVTEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            pub fn itbufen(&self) -> ITBUFEN_R {
                ITBUFEN_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            pub fn last(&self) -> LAST_R {
                LAST_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            #[must_use]
            pub fn freq(&mut self) -> FREQ_W<0> {
                FREQ_W::new(self)
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn iterren(&mut self) -> ITERREN_W<8> {
                ITERREN_W::new(self)
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itevten(&mut self) -> ITEVTEN_W<9> {
                ITEVTEN_W::new(self)
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itbufen(&mut self) -> ITBUFEN_W<10> {
                ITBUFEN_W::new(self)
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<11> {
                DMAEN_W::new(self)
            }
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            #[must_use]
            pub fn last(&mut self) -> LAST_W<12> {
                LAST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OADDR1 (rw) register accessor: an alias for `Reg<OADDR1_SPEC>`
    pub type OADDR1 = crate::Reg<oaddr1::OADDR1_SPEC>;
    ///Own address register 1
    pub mod oaddr1 {
        ///Register `OADDR1` reader
        pub struct R(crate::R<OADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OADDR1` writer
        pub struct W(crate::W<OADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADD0` reader - Interface address
        pub type ADD0_R = crate::BitReader<bool>;
        ///Field `ADD0` writer - Interface address
        pub type ADD0_W<'a, const O: u8> = crate::BitWriter<'a, u16, OADDR1_SPEC, bool, O>;
        ///Field `ADD7_1` reader - Interface address
        pub type ADD7_1_R = crate::FieldReader<u8, u8>;
        ///Field `ADD7_1` writer - Interface address
        pub type ADD7_1_W<'a, const O: u8> = crate::FieldWriter<'a, u16, OADDR1_SPEC, u8, u8, 7, O>;
        ///Field `ADD9_8` reader - Interface address
        pub type ADD9_8_R = crate::FieldReader<u8, u8>;
        ///Field `ADD9_8` writer - Interface address
        pub type ADD9_8_W<'a, const O: u8> = crate::FieldWriter<'a, u16, OADDR1_SPEC, u8, u8, 2, O>;
        ///Field `MUST1` reader - must set 1 bit
        pub type MUST1_R = crate::BitReader<bool>;
        ///Field `MUST1` writer - must set 1 bit
        pub type MUST1_W<'a, const O: u8> = crate::BitWriter<'a, u16, OADDR1_SPEC, bool, O>;
        ///Field `ADDMODE` reader - Addressing mode (slave mode)
        pub type ADDMODE_R = crate::BitReader<ADDMODE_A>;
        ///Addressing mode (slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ADDMODE_A {
            ///0: 7-bit slave address
            Add7 = 0,
            ///1: 10-bit slave address
            Add10 = 1,
        }
        impl From<ADDMODE_A> for bool {
            #[inline(always)]
            fn from(variant: ADDMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ADDMODE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADDMODE_A {
                match self.bits {
                    false => ADDMODE_A::Add7,
                    true => ADDMODE_A::Add10,
                }
            }
            ///Checks if the value of the field is `Add7`
            #[inline(always)]
            pub fn is_add7(&self) -> bool {
                *self == ADDMODE_A::Add7
            }
            ///Checks if the value of the field is `Add10`
            #[inline(always)]
            pub fn is_add10(&self) -> bool {
                *self == ADDMODE_A::Add10
            }
        }
        ///Field `ADDMODE` writer - Addressing mode (slave mode)
        pub type ADDMODE_W<'a, const O: u8> = crate::BitWriter<'a, u16, OADDR1_SPEC, ADDMODE_A, O>;
        impl<'a, const O: u8> ADDMODE_W<'a, O> {
            ///7-bit slave address
            #[inline(always)]
            pub fn add7(self) -> &'a mut W {
                self.variant(ADDMODE_A::Add7)
            }
            ///10-bit slave address
            #[inline(always)]
            pub fn add10(self) -> &'a mut W {
                self.variant(ADDMODE_A::Add10)
            }
        }
        impl R {
            ///Bit 0 - Interface address
            #[inline(always)]
            pub fn add0(&self) -> ADD0_R {
                ADD0_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add7_1(&self) -> ADD7_1_R {
                ADD7_1_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bits 8:9 - Interface address
            #[inline(always)]
            pub fn add9_8(&self) -> ADD9_8_R {
                ADD9_8_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - must set 1 bit
            #[inline(always)]
            pub fn must1(&self) -> MUST1_R {
                MUST1_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            pub fn addmode(&self) -> ADDMODE_R {
                ADDMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add0(&mut self) -> ADD0_W<0> {
                ADD0_W::new(self)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add7_1(&mut self) -> ADD7_1_W<1> {
                ADD7_1_W::new(self)
            }
            ///Bits 8:9 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add9_8(&mut self) -> ADD9_8_W<8> {
                ADD9_8_W::new(self)
            }
            ///Bit 14 - must set 1 bit
            #[inline(always)]
            #[must_use]
            pub fn must1(&mut self) -> MUST1_W<14> {
                MUST1_W::new(self)
            }
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            #[must_use]
            pub fn addmode(&mut self) -> ADDMODE_W<15> {
                ADDMODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Own address register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [oaddr1](index.html) module
        pub struct OADDR1_SPEC;
        impl crate::RegisterSpec for OADDR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [oaddr1::R](R) reader structure
        impl crate::Readable for OADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [oaddr1::W](W) writer structure
        impl crate::Writable for OADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OADDR1 to value 0
        impl crate::Resettable for OADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OADDR2 (rw) register accessor: an alias for `Reg<OADDR2_SPEC>`
    pub type OADDR2 = crate::Reg<oaddr2::OADDR2_SPEC>;
    ///Own address register 2
    pub mod oaddr2 {
        ///Register `OADDR2` reader
        pub struct R(crate::R<OADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OADDR2` writer
        pub struct W(crate::W<OADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ENDUAL` reader - Dual addressing mode enable
        pub type ENDUAL_R = crate::BitReader<ENDUAL_A>;
        ///Dual addressing mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ENDUAL_A {
            ///0: Single addressing mode
            Single = 0,
            ///1: Dual addressing mode
            Dual = 1,
        }
        impl From<ENDUAL_A> for bool {
            #[inline(always)]
            fn from(variant: ENDUAL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ENDUAL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENDUAL_A {
                match self.bits {
                    false => ENDUAL_A::Single,
                    true => ENDUAL_A::Dual,
                }
            }
            ///Checks if the value of the field is `Single`
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                *self == ENDUAL_A::Single
            }
            ///Checks if the value of the field is `Dual`
            #[inline(always)]
            pub fn is_dual(&self) -> bool {
                *self == ENDUAL_A::Dual
            }
        }
        ///Field `ENDUAL` writer - Dual addressing mode enable
        pub type ENDUAL_W<'a, const O: u8> = crate::BitWriter<'a, u16, OADDR2_SPEC, ENDUAL_A, O>;
        impl<'a, const O: u8> ENDUAL_W<'a, O> {
            ///Single addressing mode
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(ENDUAL_A::Single)
            }
            ///Dual addressing mode
            #[inline(always)]
            pub fn dual(self) -> &'a mut W {
                self.variant(ENDUAL_A::Dual)
            }
        }
        ///Field `ADD2` reader - Interface address
        pub type ADD2_R = crate::FieldReader<u8, u8>;
        ///Field `ADD2` writer - Interface address
        pub type ADD2_W<'a, const O: u8> = crate::FieldWriter<'a, u16, OADDR2_SPEC, u8, u8, 7, O>;
        impl R {
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            pub fn endual(&self) -> ENDUAL_R {
                ENDUAL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add2(&self) -> ADD2_R {
                ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            #[must_use]
            pub fn endual(&mut self) -> ENDUAL_W<0> {
                ENDUAL_W::new(self)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add2(&mut self) -> ADD2_W<1> {
                ADD2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Own address register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [oaddr2](index.html) module
        pub struct OADDR2_SPEC;
        impl crate::RegisterSpec for OADDR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [oaddr2::R](R) reader structure
        impl crate::Readable for OADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [oaddr2::W](W) writer structure
        impl crate::Writable for OADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OADDR2 to value 0
        impl crate::Resettable for OADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR (rw) register accessor: an alias for `Reg<DATAR_SPEC>`
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub struct R(crate::R<DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR` writer
        pub struct W(crate::W<DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - 8-bit data register
        pub type DR_R = crate::FieldReader<u8, u8>;
        ///Field `DR` writer - 8-bit data register
        pub type DR_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DATAR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<0> {
                DR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar](index.html) module
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar::R](R) reader structure
        impl crate::Readable for DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar::W](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STAR1 (rw) register accessor: an alias for `Reg<STAR1_SPEC>`
    pub type STAR1 = crate::Reg<star1::STAR1_SPEC>;
    ///Status register 1
    pub mod star1 {
        ///Register `STAR1` reader
        pub struct R(crate::R<STAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STAR1` writer
        pub struct W(crate::W<STAR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STAR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STAR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SB` reader - Start bit (Master mode)
        pub type SB_R = crate::BitReader<SBR_A>;
        ///Start bit (Master mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SBR_A {
            ///0: No Start condition
            NoStart = 0,
            ///1: Start condition generated
            Start = 1,
        }
        impl From<SBR_A> for bool {
            #[inline(always)]
            fn from(variant: SBR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SB_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SBR_A {
                match self.bits {
                    false => SBR_A::NoStart,
                    true => SBR_A::Start,
                }
            }
            ///Checks if the value of the field is `NoStart`
            #[inline(always)]
            pub fn is_no_start(&self) -> bool {
                *self == SBR_A::NoStart
            }
            ///Checks if the value of the field is `Start`
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == SBR_A::Start
            }
        }
        ///Field `ADDR` reader - Address sent (master mode)/matched (slave mode)
        pub type ADDR_R = crate::BitReader<ADDRR_A>;
        ///Address sent (master mode)/matched (slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ADDRR_A {
            ///0: Adress mismatched or not received
            NotMatch = 0,
            ///1: Received slave address matched with one of the enabled slave addresses
            Match = 1,
        }
        impl From<ADDRR_A> for bool {
            #[inline(always)]
            fn from(variant: ADDRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ADDR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADDRR_A {
                match self.bits {
                    false => ADDRR_A::NotMatch,
                    true => ADDRR_A::Match,
                }
            }
            ///Checks if the value of the field is `NotMatch`
            #[inline(always)]
            pub fn is_not_match(&self) -> bool {
                *self == ADDRR_A::NotMatch
            }
            ///Checks if the value of the field is `Match`
            #[inline(always)]
            pub fn is_match(&self) -> bool {
                *self == ADDRR_A::Match
            }
        }
        ///Field `BTF` reader - Byte transfer finished
        pub type BTF_R = crate::BitReader<BTFR_A>;
        ///Byte transfer finished
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BTFR_A {
            ///0: Data byte transfer not done
            NotFinished = 0,
            ///1: Data byte transfer successful
            Finished = 1,
        }
        impl From<BTFR_A> for bool {
            #[inline(always)]
            fn from(variant: BTFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BTF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BTFR_A {
                match self.bits {
                    false => BTFR_A::NotFinished,
                    true => BTFR_A::Finished,
                }
            }
            ///Checks if the value of the field is `NotFinished`
            #[inline(always)]
            pub fn is_not_finished(&self) -> bool {
                *self == BTFR_A::NotFinished
            }
            ///Checks if the value of the field is `Finished`
            #[inline(always)]
            pub fn is_finished(&self) -> bool {
                *self == BTFR_A::Finished
            }
        }
        ///Field `ADD10` reader - 10-bit header sent (Master mode)
        pub type ADD10_R = crate::BitReader<ADD10R_A>;
        ///10-bit header sent (Master mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ADD10R_A {
            ///0: First address byte not sent
            NotSent = 0,
            ///1: First address byte sent on 10-bit mode
            Sent = 1,
        }
        impl From<ADD10R_A> for bool {
            #[inline(always)]
            fn from(variant: ADD10R_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ADD10_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADD10R_A {
                match self.bits {
                    false => ADD10R_A::NotSent,
                    true => ADD10R_A::Sent,
                }
            }
            ///Checks if the value of the field is `NotSent`
            #[inline(always)]
            pub fn is_not_sent(&self) -> bool {
                *self == ADD10R_A::NotSent
            }
            ///Checks if the value of the field is `Sent`
            #[inline(always)]
            pub fn is_sent(&self) -> bool {
                *self == ADD10R_A::Sent
            }
        }
        ///Field `STOPF` reader - Stop detection (slave mode)
        pub type STOPF_R = crate::BitReader<STOPFR_A>;
        ///Stop detection (slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STOPFR_A {
            ///0: No Stop condition detected
            NoStop = 0,
            ///1: Stop condition detected
            Stop = 1,
        }
        impl From<STOPFR_A> for bool {
            #[inline(always)]
            fn from(variant: STOPFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STOPF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STOPFR_A {
                match self.bits {
                    false => STOPFR_A::NoStop,
                    true => STOPFR_A::Stop,
                }
            }
            ///Checks if the value of the field is `NoStop`
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                *self == STOPFR_A::NoStop
            }
            ///Checks if the value of the field is `Stop`
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                *self == STOPFR_A::Stop
            }
        }
        ///Field `RxNE` reader - Data register not empty (receivers)
        pub type RX_NE_R = crate::BitReader<RX_NER_A>;
        ///Data register not empty (receivers)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RX_NER_A {
            ///0: Data register empty
            Empty = 0,
            ///1: Data register not empty
            NotEmpty = 1,
        }
        impl From<RX_NER_A> for bool {
            #[inline(always)]
            fn from(variant: RX_NER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RX_NE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RX_NER_A {
                match self.bits {
                    false => RX_NER_A::Empty,
                    true => RX_NER_A::NotEmpty,
                }
            }
            ///Checks if the value of the field is `Empty`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == RX_NER_A::Empty
            }
            ///Checks if the value of the field is `NotEmpty`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == RX_NER_A::NotEmpty
            }
        }
        ///Field `TxE` reader - Data register empty (transmitters)
        pub type TX_E_R = crate::BitReader<TX_ER_A>;
        ///Data register empty (transmitters)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TX_ER_A {
            ///0: Data register not empty
            NotEmpty = 0,
            ///1: Data register empty
            Empty = 1,
        }
        impl From<TX_ER_A> for bool {
            #[inline(always)]
            fn from(variant: TX_ER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TX_E_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TX_ER_A {
                match self.bits {
                    false => TX_ER_A::NotEmpty,
                    true => TX_ER_A::Empty,
                }
            }
            ///Checks if the value of the field is `NotEmpty`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == TX_ER_A::NotEmpty
            }
            ///Checks if the value of the field is `Empty`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TX_ER_A::Empty
            }
        }
        ///Field `BERR` reader - Bus error
        pub type BERR_R = crate::BitReader<BERRR_A>;
        ///Bus error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BERRR_A {
            ///0: No misplaced Start or Stop condition
            NoError = 0,
            ///1: Misplaced Start or Stop condition
            Error = 1,
        }
        impl From<BERRR_A> for bool {
            #[inline(always)]
            fn from(variant: BERRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BERR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BERRR_A {
                match self.bits {
                    false => BERRR_A::NoError,
                    true => BERRR_A::Error,
                }
            }
            ///Checks if the value of the field is `NoError`
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == BERRR_A::NoError
            }
            ///Checks if the value of the field is `Error`
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == BERRR_A::Error
            }
        }
        ///Bus error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BERRW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<BERRW_AW> for bool {
            #[inline(always)]
            fn from(variant: BERRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BERR` writer - Bus error
        pub type BERR_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STAR1_SPEC, BERRW_AW, O>;
        impl<'a, const O: u8> BERR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(BERRW_AW::Clear)
            }
        }
        ///Field `ARLO` reader - Arbitration lost (master mode)
        pub type ARLO_R = crate::BitReader<ARLOR_A>;
        ///Arbitration lost (master mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ARLOR_A {
            ///0: No Arbitration Lost detected
            NoLost = 0,
            ///1: Arbitration Lost detected
            Lost = 1,
        }
        impl From<ARLOR_A> for bool {
            #[inline(always)]
            fn from(variant: ARLOR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ARLO_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARLOR_A {
                match self.bits {
                    false => ARLOR_A::NoLost,
                    true => ARLOR_A::Lost,
                }
            }
            ///Checks if the value of the field is `NoLost`
            #[inline(always)]
            pub fn is_no_lost(&self) -> bool {
                *self == ARLOR_A::NoLost
            }
            ///Checks if the value of the field is `Lost`
            #[inline(always)]
            pub fn is_lost(&self) -> bool {
                *self == ARLOR_A::Lost
            }
        }
        ///Arbitration lost (master mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ARLOW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<ARLOW_AW> for bool {
            #[inline(always)]
            fn from(variant: ARLOW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARLO` writer - Arbitration lost (master mode)
        pub type ARLO_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STAR1_SPEC, ARLOW_AW, O>;
        impl<'a, const O: u8> ARLO_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ARLOW_AW::Clear)
            }
        }
        ///Field `AF` reader - Acknowledge failure
        pub type AF_R = crate::BitReader<AFR_A>;
        ///Acknowledge failure
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AFR_A {
            ///0: No acknowledge failure
            NoFailure = 0,
            ///1: Acknowledge failure
            Failure = 1,
        }
        impl From<AFR_A> for bool {
            #[inline(always)]
            fn from(variant: AFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl AF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AFR_A {
                match self.bits {
                    false => AFR_A::NoFailure,
                    true => AFR_A::Failure,
                }
            }
            ///Checks if the value of the field is `NoFailure`
            #[inline(always)]
            pub fn is_no_failure(&self) -> bool {
                *self == AFR_A::NoFailure
            }
            ///Checks if the value of the field is `Failure`
            #[inline(always)]
            pub fn is_failure(&self) -> bool {
                *self == AFR_A::Failure
            }
        }
        ///Acknowledge failure
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AFW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<AFW_AW> for bool {
            #[inline(always)]
            fn from(variant: AFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AF` writer - Acknowledge failure
        pub type AF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STAR1_SPEC, AFW_AW, O>;
        impl<'a, const O: u8> AF_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(AFW_AW::Clear)
            }
        }
        ///Field `OVR` reader - Overrun/Underrun
        pub type OVR_R = crate::BitReader<OVRR_A>;
        ///Overrun/Underrun
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OVRR_A {
            ///0: No overrun/underrun occured
            NoOverrun = 0,
            ///1: Overrun/underrun occured
            Overrun = 1,
        }
        impl From<OVRR_A> for bool {
            #[inline(always)]
            fn from(variant: OVRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OVR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OVRR_A {
                match self.bits {
                    false => OVRR_A::NoOverrun,
                    true => OVRR_A::Overrun,
                }
            }
            ///Checks if the value of the field is `NoOverrun`
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVRR_A::NoOverrun
            }
            ///Checks if the value of the field is `Overrun`
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == OVRR_A::Overrun
            }
        }
        ///Overrun/Underrun
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OVRW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<OVRW_AW> for bool {
            #[inline(always)]
            fn from(variant: OVRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OVR` writer - Overrun/Underrun
        pub type OVR_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STAR1_SPEC, OVRW_AW, O>;
        impl<'a, const O: u8> OVR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVRW_AW::Clear)
            }
        }
        ///Field `PECERR` reader - PEC Error in reception
        pub type PECERR_R = crate::BitReader<PECERRR_A>;
        ///PEC Error in reception
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PECERRR_A {
            ///0: no PEC error: receiver returns ACK after PEC reception (if ACK=1)
            NoError = 0,
            ///1: PEC error: receiver returns NACK after PEC reception (whatever ACK)
            Error = 1,
        }
        impl From<PECERRR_A> for bool {
            #[inline(always)]
            fn from(variant: PECERRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PECERR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PECERRR_A {
                match self.bits {
                    false => PECERRR_A::NoError,
                    true => PECERRR_A::Error,
                }
            }
            ///Checks if the value of the field is `NoError`
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == PECERRR_A::NoError
            }
            ///Checks if the value of the field is `Error`
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == PECERRR_A::Error
            }
        }
        ///PEC Error in reception
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PECERRW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<PECERRW_AW> for bool {
            #[inline(always)]
            fn from(variant: PECERRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PECERR` writer - PEC Error in reception
        pub type PECERR_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STAR1_SPEC, PECERRW_AW, O>;
        impl<'a, const O: u8> PECERR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PECERRW_AW::Clear)
            }
        }
        ///Field `TIMEOUT` reader - Timeout or Tlow error
        pub type TIMEOUT_R = crate::BitReader<TIMEOUTR_A>;
        ///Timeout or Tlow error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIMEOUTR_A {
            ///0: No Timeout error
            NoTimeout = 0,
            ///1: SCL remained LOW for 25 ms
            Timeout = 1,
        }
        impl From<TIMEOUTR_A> for bool {
            #[inline(always)]
            fn from(variant: TIMEOUTR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TIMEOUT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIMEOUTR_A {
                match self.bits {
                    false => TIMEOUTR_A::NoTimeout,
                    true => TIMEOUTR_A::Timeout,
                }
            }
            ///Checks if the value of the field is `NoTimeout`
            #[inline(always)]
            pub fn is_no_timeout(&self) -> bool {
                *self == TIMEOUTR_A::NoTimeout
            }
            ///Checks if the value of the field is `Timeout`
            #[inline(always)]
            pub fn is_timeout(&self) -> bool {
                *self == TIMEOUTR_A::Timeout
            }
        }
        ///Timeout or Tlow error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TIMEOUTW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<TIMEOUTW_AW> for bool {
            #[inline(always)]
            fn from(variant: TIMEOUTW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIMEOUT` writer - Timeout or Tlow error
        pub type TIMEOUT_W<'a, const O: u8> =
            crate::BitWriter0C<'a, u16, STAR1_SPEC, TIMEOUTW_AW, O>;
        impl<'a, const O: u8> TIMEOUT_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIMEOUTW_AW::Clear)
            }
        }
        ///Field `SMBALERT` reader - SMBus alert
        pub type SMBALERT_R = crate::BitReader<SMBALERTR_A>;
        ///SMBus alert
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SMBALERTR_A {
            ///0: No SMBALERT occured
            NoAlert = 0,
            ///1: SMBALERT occurred
            Alert = 1,
        }
        impl From<SMBALERTR_A> for bool {
            #[inline(always)]
            fn from(variant: SMBALERTR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SMBALERT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBALERTR_A {
                match self.bits {
                    false => SMBALERTR_A::NoAlert,
                    true => SMBALERTR_A::Alert,
                }
            }
            ///Checks if the value of the field is `NoAlert`
            #[inline(always)]
            pub fn is_no_alert(&self) -> bool {
                *self == SMBALERTR_A::NoAlert
            }
            ///Checks if the value of the field is `Alert`
            #[inline(always)]
            pub fn is_alert(&self) -> bool {
                *self == SMBALERTR_A::Alert
            }
        }
        ///SMBus alert
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SMBALERTW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<SMBALERTW_AW> for bool {
            #[inline(always)]
            fn from(variant: SMBALERTW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SMBALERT` writer - SMBus alert
        pub type SMBALERT_W<'a, const O: u8> =
            crate::BitWriter0C<'a, u16, STAR1_SPEC, SMBALERTW_AW, O>;
        impl<'a, const O: u8> SMBALERT_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(SMBALERTW_AW::Clear)
            }
        }
        impl R {
            ///Bit 0 - Start bit (Master mode)
            #[inline(always)]
            pub fn sb(&self) -> SB_R {
                SB_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Address sent (master mode)/matched (slave mode)
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Byte transfer finished
            #[inline(always)]
            pub fn btf(&self) -> BTF_R {
                BTF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - 10-bit header sent (Master mode)
            #[inline(always)]
            pub fn add10(&self) -> ADD10_R {
                ADD10_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Stop detection (slave mode)
            #[inline(always)]
            pub fn stopf(&self) -> STOPF_R {
                STOPF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Data register not empty (receivers)
            #[inline(always)]
            pub fn rx_ne(&self) -> RX_NE_R {
                RX_NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Data register empty (transmitters)
            #[inline(always)]
            pub fn tx_e(&self) -> TX_E_R {
                TX_E_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Bus error
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            pub fn arlo(&self) -> ARLO_R {
                ARLO_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            pub fn af(&self) -> AF_R {
                AF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            pub fn pecerr(&self) -> PECERR_R {
                PECERR_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - Timeout or Tlow error
            #[inline(always)]
            pub fn timeout(&self) -> TIMEOUT_R {
                TIMEOUT_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - SMBus alert
            #[inline(always)]
            pub fn smbalert(&self) -> SMBALERT_R {
                SMBALERT_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - Bus error
            #[inline(always)]
            #[must_use]
            pub fn berr(&mut self) -> BERR_W<8> {
                BERR_W::new(self)
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            #[must_use]
            pub fn arlo(&mut self) -> ARLO_W<9> {
                ARLO_W::new(self)
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            #[must_use]
            pub fn af(&mut self) -> AF_W<10> {
                AF_W::new(self)
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            #[must_use]
            pub fn ovr(&mut self) -> OVR_W<11> {
                OVR_W::new(self)
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            #[must_use]
            pub fn pecerr(&mut self) -> PECERR_W<12> {
                PECERR_W::new(self)
            }
            ///Bit 14 - Timeout or Tlow error
            #[inline(always)]
            #[must_use]
            pub fn timeout(&mut self) -> TIMEOUT_W<14> {
                TIMEOUT_W::new(self)
            }
            ///Bit 15 - SMBus alert
            #[inline(always)]
            #[must_use]
            pub fn smbalert(&mut self) -> SMBALERT_W<15> {
                SMBALERT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [star1](index.html) module
        pub struct STAR1_SPEC;
        impl crate::RegisterSpec for STAR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [star1::R](R) reader structure
        impl crate::Readable for STAR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [star1::W](W) writer structure
        impl crate::Writable for STAR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0xdf00;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STAR1 to value 0
        impl crate::Resettable for STAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STAR2 (r) register accessor: an alias for `Reg<STAR2_SPEC>`
    pub type STAR2 = crate::Reg<star2::STAR2_SPEC>;
    ///Status register 2
    pub mod star2 {
        ///Register `STAR2` reader
        pub struct R(crate::R<STAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MSL` reader - Master/slave
        pub type MSL_R = crate::BitReader<MSLR_A>;
        ///Master/slave
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MSLR_A {
            ///0: I2C working at slave mode
            Slave = 0,
            ///1: I2C working at master mode
            Master = 1,
        }
        impl From<MSLR_A> for bool {
            #[inline(always)]
            fn from(variant: MSLR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MSL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MSLR_A {
                match self.bits {
                    false => MSLR_A::Slave,
                    true => MSLR_A::Master,
                }
            }
            ///Checks if the value of the field is `Slave`
            #[inline(always)]
            pub fn is_slave(&self) -> bool {
                *self == MSLR_A::Slave
            }
            ///Checks if the value of the field is `Master`
            #[inline(always)]
            pub fn is_master(&self) -> bool {
                *self == MSLR_A::Master
            }
        }
        ///Field `BUSY` reader - Bus busy
        pub type BUSY_R = crate::BitReader<BUSYR_A>;
        ///Bus busy
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BUSYR_A {
            ///0: I2C bus is idle
            Idle = 0,
            ///1: I2C bus is busy
            Busy = 1,
        }
        impl From<BUSYR_A> for bool {
            #[inline(always)]
            fn from(variant: BUSYR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BUSY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BUSYR_A {
                match self.bits {
                    false => BUSYR_A::Idle,
                    true => BUSYR_A::Busy,
                }
            }
            ///Checks if the value of the field is `Idle`
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == BUSYR_A::Idle
            }
            ///Checks if the value of the field is `Busy`
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == BUSYR_A::Busy
            }
        }
        ///Field `TRA` reader - Transmitter/receiver
        pub type TRA_R = crate::BitReader<TRAR_A>;
        ///Transmitter/receiver
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TRAR_A {
            ///0: Data received
            Received = 0,
            ///1: Data transmitted
            Transmitted = 1,
        }
        impl From<TRAR_A> for bool {
            #[inline(always)]
            fn from(variant: TRAR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TRA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TRAR_A {
                match self.bits {
                    false => TRAR_A::Received,
                    true => TRAR_A::Transmitted,
                }
            }
            ///Checks if the value of the field is `Received`
            #[inline(always)]
            pub fn is_received(&self) -> bool {
                *self == TRAR_A::Received
            }
            ///Checks if the value of the field is `Transmitted`
            #[inline(always)]
            pub fn is_transmitted(&self) -> bool {
                *self == TRAR_A::Transmitted
            }
        }
        ///Field `GENCALL` reader - General call address (Slave mode)
        pub type GENCALL_R = crate::BitReader<GENCALLR_A>;
        ///General call address (Slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GENCALLR_A {
            ///0: No general call received
            NotCalled = 0,
            ///1: General call received
            Called = 1,
        }
        impl From<GENCALLR_A> for bool {
            #[inline(always)]
            fn from(variant: GENCALLR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl GENCALL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> GENCALLR_A {
                match self.bits {
                    false => GENCALLR_A::NotCalled,
                    true => GENCALLR_A::Called,
                }
            }
            ///Checks if the value of the field is `NotCalled`
            #[inline(always)]
            pub fn is_not_called(&self) -> bool {
                *self == GENCALLR_A::NotCalled
            }
            ///Checks if the value of the field is `Called`
            #[inline(always)]
            pub fn is_called(&self) -> bool {
                *self == GENCALLR_A::Called
            }
        }
        ///Field `SMBDEFAULT` reader - SMBus device default address (Slave mode)
        pub type SMBDEFAULT_R = crate::BitReader<SMBDEFAULTR_A>;
        ///SMBus device default address (Slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SMBDEFAULTR_A {
            ///0: SMBus device default address not received
            NotReceived = 0,
            ///1: SMBus device default address received
            Received = 1,
        }
        impl From<SMBDEFAULTR_A> for bool {
            #[inline(always)]
            fn from(variant: SMBDEFAULTR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SMBDEFAULT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBDEFAULTR_A {
                match self.bits {
                    false => SMBDEFAULTR_A::NotReceived,
                    true => SMBDEFAULTR_A::Received,
                }
            }
            ///Checks if the value of the field is `NotReceived`
            #[inline(always)]
            pub fn is_not_received(&self) -> bool {
                *self == SMBDEFAULTR_A::NotReceived
            }
            ///Checks if the value of the field is `Received`
            #[inline(always)]
            pub fn is_received(&self) -> bool {
                *self == SMBDEFAULTR_A::Received
            }
        }
        ///Field `SMBHOST` reader - SMBus host header (Slave mode)
        pub type SMBHOST_R = crate::BitReader<SMBHOSTR_A>;
        ///SMBus host header (Slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SMBHOSTR_A {
            ///0: SMBus host address not received
            NotReceived = 0,
            ///1: SMBus host address received
            Received = 1,
        }
        impl From<SMBHOSTR_A> for bool {
            #[inline(always)]
            fn from(variant: SMBHOSTR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SMBHOST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBHOSTR_A {
                match self.bits {
                    false => SMBHOSTR_A::NotReceived,
                    true => SMBHOSTR_A::Received,
                }
            }
            ///Checks if the value of the field is `NotReceived`
            #[inline(always)]
            pub fn is_not_received(&self) -> bool {
                *self == SMBHOSTR_A::NotReceived
            }
            ///Checks if the value of the field is `Received`
            #[inline(always)]
            pub fn is_received(&self) -> bool {
                *self == SMBHOSTR_A::Received
            }
        }
        ///Field `DUALF` reader - Dual flag (Slave mode)
        pub type DUALF_R = crate::BitReader<DUALFR_A>;
        ///Dual flag (Slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DUALFR_A {
            ///0: Address consistent with OAR1
            Oar1 = 0,
            ///1: Address consistent with OAR2
            Oar2 = 1,
        }
        impl From<DUALFR_A> for bool {
            #[inline(always)]
            fn from(variant: DUALFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DUALF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DUALFR_A {
                match self.bits {
                    false => DUALFR_A::Oar1,
                    true => DUALFR_A::Oar2,
                }
            }
            ///Checks if the value of the field is `Oar1`
            #[inline(always)]
            pub fn is_oar1(&self) -> bool {
                *self == DUALFR_A::Oar1
            }
            ///Checks if the value of the field is `Oar2`
            #[inline(always)]
            pub fn is_oar2(&self) -> bool {
                *self == DUALFR_A::Oar2
            }
        }
        ///Field `PEC` reader - acket error checking register
        pub type PEC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bit 0 - Master/slave
            #[inline(always)]
            pub fn msl(&self) -> MSL_R {
                MSL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Bus busy
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Transmitter/receiver
            #[inline(always)]
            pub fn tra(&self) -> TRA_R {
                TRA_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - General call address (Slave mode)
            #[inline(always)]
            pub fn gencall(&self) -> GENCALL_R {
                GENCALL_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SMBus device default address (Slave mode)
            #[inline(always)]
            pub fn smbdefault(&self) -> SMBDEFAULT_R {
                SMBDEFAULT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - SMBus host header (Slave mode)
            #[inline(always)]
            pub fn smbhost(&self) -> SMBHOST_R {
                SMBHOST_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Dual flag (Slave mode)
            #[inline(always)]
            pub fn dualf(&self) -> DUALF_R {
                DUALF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - acket error checking register
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///Status register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [star2](index.html) module
        pub struct STAR2_SPEC;
        impl crate::RegisterSpec for STAR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [star2::R](R) reader structure
        impl crate::Readable for STAR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets STAR2 to value 0
        impl crate::Resettable for STAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CKCFGR (rw) register accessor: an alias for `Reg<CKCFGR_SPEC>`
    pub type CKCFGR = crate::Reg<ckcfgr::CKCFGR_SPEC>;
    ///Clock control register
    pub mod ckcfgr {
        ///Register `CKCFGR` reader
        pub struct R(crate::R<CKCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CKCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CKCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CKCFGR` writer
        pub struct W(crate::W<CKCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CKCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CKCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR` reader - Clock control register in Fast/Standard mode (Master mode)
        pub type CCR_R = crate::FieldReader<u16, u16>;
        ///Field `CCR` writer - Clock control register in Fast/Standard mode (Master mode)
        pub type CCR_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CKCFGR_SPEC, u16, u16, 12, O>;
        ///Field `DUTY` reader - Fast mode duty cycle
        pub type DUTY_R = crate::BitReader<DUTY_A>;
        ///Fast mode duty cycle
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DUTY_A {
            ///0: Duty cycle t_low/t_high = 2/1
            Duty2t1 = 0,
            ///1: Duty cycle t_low/t_high = 16/9
            Duty16t9 = 1,
        }
        impl From<DUTY_A> for bool {
            #[inline(always)]
            fn from(variant: DUTY_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DUTY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DUTY_A {
                match self.bits {
                    false => DUTY_A::Duty2t1,
                    true => DUTY_A::Duty16t9,
                }
            }
            ///Checks if the value of the field is `Duty2t1`
            #[inline(always)]
            pub fn is_duty2t1(&self) -> bool {
                *self == DUTY_A::Duty2t1
            }
            ///Checks if the value of the field is `Duty16t9`
            #[inline(always)]
            pub fn is_duty16t9(&self) -> bool {
                *self == DUTY_A::Duty16t9
            }
        }
        ///Field `DUTY` writer - Fast mode duty cycle
        pub type DUTY_W<'a, const O: u8> = crate::BitWriter<'a, u16, CKCFGR_SPEC, DUTY_A, O>;
        impl<'a, const O: u8> DUTY_W<'a, O> {
            ///Duty cycle t_low/t_high = 2/1
            #[inline(always)]
            pub fn duty2t1(self) -> &'a mut W {
                self.variant(DUTY_A::Duty2t1)
            }
            ///Duty cycle t_low/t_high = 16/9
            #[inline(always)]
            pub fn duty16t9(self) -> &'a mut W {
                self.variant(DUTY_A::Duty16t9)
            }
        }
        ///Field `F_S` reader - I2C master mode selection
        pub type F_S_R = crate::BitReader<F_S_A>;
        ///I2C master mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum F_S_A {
            ///0: Standard mode I2C
            Standard = 0,
            ///1: Fast mode I2C
            Fast = 1,
        }
        impl From<F_S_A> for bool {
            #[inline(always)]
            fn from(variant: F_S_A) -> Self {
                variant as u8 != 0
            }
        }
        impl F_S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> F_S_A {
                match self.bits {
                    false => F_S_A::Standard,
                    true => F_S_A::Fast,
                }
            }
            ///Checks if the value of the field is `Standard`
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == F_S_A::Standard
            }
            ///Checks if the value of the field is `Fast`
            #[inline(always)]
            pub fn is_fast(&self) -> bool {
                *self == F_S_A::Fast
            }
        }
        ///Field `F_S` writer - I2C master mode selection
        pub type F_S_W<'a, const O: u8> = crate::BitWriter<'a, u16, CKCFGR_SPEC, F_S_A, O>;
        impl<'a, const O: u8> F_S_W<'a, O> {
            ///Standard mode I2C
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(F_S_A::Standard)
            }
            ///Fast mode I2C
            #[inline(always)]
            pub fn fast(self) -> &'a mut W {
                self.variant(F_S_A::Fast)
            }
        }
        impl R {
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new(self.bits & 0x0fff)
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            pub fn duty(&self) -> DUTY_R {
                DUTY_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            pub fn f_s(&self) -> F_S_R {
                F_S_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn ccr(&mut self) -> CCR_W<0> {
                CCR_W::new(self)
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            #[must_use]
            pub fn duty(&mut self) -> DUTY_W<14> {
                DUTY_W::new(self)
            }
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            #[must_use]
            pub fn f_s(&mut self) -> F_S_W<15> {
                F_S_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ckcfgr](index.html) module
        pub struct CKCFGR_SPEC;
        impl crate::RegisterSpec for CKCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ckcfgr::R](R) reader structure
        impl crate::Readable for CKCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ckcfgr::W](W) writer structure
        impl crate::Writable for CKCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CKCFGR to value 0
        impl crate::Resettable for CKCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RTR (rw) register accessor: an alias for `Reg<RTR_SPEC>`
    pub type RTR = crate::Reg<rtr::RTR_SPEC>;
    ///RTR register
    pub mod rtr {
        ///Register `RTR` reader
        pub struct R(crate::R<RTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTR` writer
        pub struct W(crate::W<RTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TRISE` reader - Maximum rise time in Fast/Standard mode (Master mode)
        pub type TRISE_R = crate::FieldReader<u8, u8>;
        ///Field `TRISE` writer - Maximum rise time in Fast/Standard mode (Master mode)
        pub type TRISE_W<'a, const O: u8> = crate::FieldWriter<'a, u16, RTR_SPEC, u8, u8, 6, O>;
        impl R {
            ///Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn trise(&self) -> TRISE_R {
                TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn trise(&mut self) -> TRISE_W<0> {
                TRISE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTR register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtr](index.html) module
        pub struct RTR_SPEC;
        impl crate::RegisterSpec for RTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [rtr::R](R) reader structure
        impl crate::Readable for RTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtr::W](W) writer structure
        impl crate::Writable for RTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RTR to value 0x02
        impl crate::Resettable for RTR_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
}
///Inter integrated circuit
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x4000_5800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C2 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C2").finish()
    }
}
///Inter integrated circuit
pub use self::i2c1 as i2c2;
///Serial peripheral interface
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4001_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///Serial peripheral interface
pub mod spi1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ///0x04 - control register 2
        pub ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        ///0x08 - status register
        pub statr: STATR,
        _reserved3: [u8; 0x02],
        ///0x0c - data register
        pub datar: DATAR,
        _reserved4: [u8; 0x02],
        ///0x10 - CRCR polynomial register
        pub crcr: CRCR,
        _reserved5: [u8; 0x02],
        ///0x14 - RX CRC register
        pub rcrcr: RCRCR,
        _reserved6: [u8; 0x02],
        ///0x18 - TX CRC register
        pub tcrcr: TCRCR,
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CPHA` reader - Clock phase
        pub type CPHA_R = crate::BitReader<CPHA_A>;
        ///Clock phase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CPHA_A {
            ///0: The first clock transition is the first data capture edge
            FirstEdge = 0,
            ///1: The second clock transition is the first data capture edge
            SecondEdge = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CPHA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::FirstEdge,
                    true => CPHA_A::SecondEdge,
                }
            }
            ///Checks if the value of the field is `FirstEdge`
            #[inline(always)]
            pub fn is_first_edge(&self) -> bool {
                *self == CPHA_A::FirstEdge
            }
            ///Checks if the value of the field is `SecondEdge`
            #[inline(always)]
            pub fn is_second_edge(&self) -> bool {
                *self == CPHA_A::SecondEdge
            }
        }
        ///Field `CPHA` writer - Clock phase
        pub type CPHA_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, CPHA_A, O>;
        impl<'a, const O: u8> CPHA_W<'a, O> {
            ///The first clock transition is the first data capture edge
            #[inline(always)]
            pub fn first_edge(self) -> &'a mut W {
                self.variant(CPHA_A::FirstEdge)
            }
            ///The second clock transition is the first data capture edge
            #[inline(always)]
            pub fn second_edge(self) -> &'a mut W {
                self.variant(CPHA_A::SecondEdge)
            }
        }
        ///Field `CPOL` reader - Clock polarity
        pub type CPOL_R = crate::BitReader<CPOL_A>;
        ///Clock polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CPOL_A {
            ///0: CK to 0 when idle
            IdleLow = 0,
            ///1: CK to 1 when idle
            IdleHigh = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CPOL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::IdleLow,
                    true => CPOL_A::IdleHigh,
                }
            }
            ///Checks if the value of the field is `IdleLow`
            #[inline(always)]
            pub fn is_idle_low(&self) -> bool {
                *self == CPOL_A::IdleLow
            }
            ///Checks if the value of the field is `IdleHigh`
            #[inline(always)]
            pub fn is_idle_high(&self) -> bool {
                *self == CPOL_A::IdleHigh
            }
        }
        ///Field `CPOL` writer - Clock polarity
        pub type CPOL_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, CPOL_A, O>;
        impl<'a, const O: u8> CPOL_W<'a, O> {
            ///CK to 0 when idle
            #[inline(always)]
            pub fn idle_low(self) -> &'a mut W {
                self.variant(CPOL_A::IdleLow)
            }
            ///CK to 1 when idle
            #[inline(always)]
            pub fn idle_high(self) -> &'a mut W {
                self.variant(CPOL_A::IdleHigh)
            }
        }
        ///Field `MSTR` reader - Master selection
        pub type MSTR_R = crate::BitReader<MSTR_A>;
        ///Master selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MSTR_A {
            ///0: Slave configuration
            Slave = 0,
            ///1: Master configuration
            Master = 1,
        }
        impl From<MSTR_A> for bool {
            #[inline(always)]
            fn from(variant: MSTR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MSTR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MSTR_A {
                match self.bits {
                    false => MSTR_A::Slave,
                    true => MSTR_A::Master,
                }
            }
            ///Checks if the value of the field is `Slave`
            #[inline(always)]
            pub fn is_slave(&self) -> bool {
                *self == MSTR_A::Slave
            }
            ///Checks if the value of the field is `Master`
            #[inline(always)]
            pub fn is_master(&self) -> bool {
                *self == MSTR_A::Master
            }
        }
        ///Field `MSTR` writer - Master selection
        pub type MSTR_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, MSTR_A, O>;
        impl<'a, const O: u8> MSTR_W<'a, O> {
            ///Slave configuration
            #[inline(always)]
            pub fn slave(self) -> &'a mut W {
                self.variant(MSTR_A::Slave)
            }
            ///Master configuration
            #[inline(always)]
            pub fn master(self) -> &'a mut W {
                self.variant(MSTR_A::Master)
            }
        }
        ///Field `BR` reader - Baud rate control
        pub type BR_R = crate::FieldReader<u8, BR_A>;
        ///Baud rate control
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum BR_A {
            ///0: f_PCLK / 2
            Div2 = 0,
            ///1: f_PCLK / 4
            Div4 = 1,
            ///2: f_PCLK / 8
            Div8 = 2,
            ///3: f_PCLK / 16
            Div16 = 3,
            ///4: f_PCLK / 32
            Div32 = 4,
            ///5: f_PCLK / 64
            Div64 = 5,
            ///6: f_PCLK / 128
            Div128 = 6,
            ///7: f_PCLK / 256
            Div256 = 7,
        }
        impl From<BR_A> for u8 {
            #[inline(always)]
            fn from(variant: BR_A) -> Self {
                variant as _
            }
        }
        impl BR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BR_A {
                match self.bits {
                    0 => BR_A::Div2,
                    1 => BR_A::Div4,
                    2 => BR_A::Div8,
                    3 => BR_A::Div16,
                    4 => BR_A::Div32,
                    5 => BR_A::Div64,
                    6 => BR_A::Div128,
                    7 => BR_A::Div256,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == BR_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == BR_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == BR_A::Div8
            }
            ///Checks if the value of the field is `Div16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                *self == BR_A::Div16
            }
            ///Checks if the value of the field is `Div32`
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                *self == BR_A::Div32
            }
            ///Checks if the value of the field is `Div64`
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                *self == BR_A::Div64
            }
            ///Checks if the value of the field is `Div128`
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                *self == BR_A::Div128
            }
            ///Checks if the value of the field is `Div256`
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                *self == BR_A::Div256
            }
        }
        ///Field `BR` writer - Baud rate control
        pub type BR_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CTLR1_SPEC, u8, BR_A, 3, O>;
        impl<'a, const O: u8> BR_W<'a, O> {
            ///f_PCLK / 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(BR_A::Div2)
            }
            ///f_PCLK / 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(BR_A::Div4)
            }
            ///f_PCLK / 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(BR_A::Div8)
            }
            ///f_PCLK / 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(BR_A::Div16)
            }
            ///f_PCLK / 32
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(BR_A::Div32)
            }
            ///f_PCLK / 64
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(BR_A::Div64)
            }
            ///f_PCLK / 128
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(BR_A::Div128)
            }
            ///f_PCLK / 256
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(BR_A::Div256)
            }
        }
        ///Field `SPE` reader - SPI enable
        pub type SPE_R = crate::BitReader<SPE_A>;
        ///SPI enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SPE_A {
            ///0: Peripheral disabled
            Disabled = 0,
            ///1: Peripheral enabled
            Enabled = 1,
        }
        impl From<SPE_A> for bool {
            #[inline(always)]
            fn from(variant: SPE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SPE_A {
                match self.bits {
                    false => SPE_A::Disabled,
                    true => SPE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SPE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SPE_A::Enabled
            }
        }
        ///Field `SPE` writer - SPI enable
        pub type SPE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, SPE_A, O>;
        impl<'a, const O: u8> SPE_W<'a, O> {
            ///Peripheral disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPE_A::Disabled)
            }
            ///Peripheral enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPE_A::Enabled)
            }
        }
        ///Field `LSBFIRST` reader - Frame format
        pub type LSBFIRST_R = crate::BitReader<LSBFIRST_A>;
        ///Frame format
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LSBFIRST_A {
            ///0: Data is transmitted/received with the MSB first
            Msbfirst = 0,
            ///1: Data is transmitted/received with the LSB first
            Lsbfirst = 1,
        }
        impl From<LSBFIRST_A> for bool {
            #[inline(always)]
            fn from(variant: LSBFIRST_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LSBFIRST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSBFIRST_A {
                match self.bits {
                    false => LSBFIRST_A::Msbfirst,
                    true => LSBFIRST_A::Lsbfirst,
                }
            }
            ///Checks if the value of the field is `Msbfirst`
            #[inline(always)]
            pub fn is_msbfirst(&self) -> bool {
                *self == LSBFIRST_A::Msbfirst
            }
            ///Checks if the value of the field is `Lsbfirst`
            #[inline(always)]
            pub fn is_lsbfirst(&self) -> bool {
                *self == LSBFIRST_A::Lsbfirst
            }
        }
        ///Field `LSBFIRST` writer - Frame format
        pub type LSBFIRST_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, LSBFIRST_A, O>;
        impl<'a, const O: u8> LSBFIRST_W<'a, O> {
            ///Data is transmitted/received with the MSB first
            #[inline(always)]
            pub fn msbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::Msbfirst)
            }
            ///Data is transmitted/received with the LSB first
            #[inline(always)]
            pub fn lsbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::Lsbfirst)
            }
        }
        ///Field `SSI` reader - Internal slave select
        pub type SSI_R = crate::BitReader<SSI_A>;
        ///Internal slave select
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SSI_A {
            ///0: 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            SlaveSelected = 0,
            ///1: 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            SlaveNotSelected = 1,
        }
        impl From<SSI_A> for bool {
            #[inline(always)]
            fn from(variant: SSI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SSI_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SSI_A {
                match self.bits {
                    false => SSI_A::SlaveSelected,
                    true => SSI_A::SlaveNotSelected,
                }
            }
            ///Checks if the value of the field is `SlaveSelected`
            #[inline(always)]
            pub fn is_slave_selected(&self) -> bool {
                *self == SSI_A::SlaveSelected
            }
            ///Checks if the value of the field is `SlaveNotSelected`
            #[inline(always)]
            pub fn is_slave_not_selected(&self) -> bool {
                *self == SSI_A::SlaveNotSelected
            }
        }
        ///Field `SSI` writer - Internal slave select
        pub type SSI_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, SSI_A, O>;
        impl<'a, const O: u8> SSI_W<'a, O> {
            ///0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            #[inline(always)]
            pub fn slave_selected(self) -> &'a mut W {
                self.variant(SSI_A::SlaveSelected)
            }
            ///1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            #[inline(always)]
            pub fn slave_not_selected(self) -> &'a mut W {
                self.variant(SSI_A::SlaveNotSelected)
            }
        }
        ///Field `SSM` reader - Software slave management
        pub type SSM_R = crate::BitReader<SSM_A>;
        ///Software slave management
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SSM_A {
            ///0: Software slave management disabled
            Disabled = 0,
            ///1: Software slave management enabled
            Enabled = 1,
        }
        impl From<SSM_A> for bool {
            #[inline(always)]
            fn from(variant: SSM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SSM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SSM_A {
                match self.bits {
                    false => SSM_A::Disabled,
                    true => SSM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SSM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SSM_A::Enabled
            }
        }
        ///Field `SSM` writer - Software slave management
        pub type SSM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, SSM_A, O>;
        impl<'a, const O: u8> SSM_W<'a, O> {
            ///Software slave management disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSM_A::Disabled)
            }
            ///Software slave management enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSM_A::Enabled)
            }
        }
        ///Field `RXONLY` reader - Receive only
        pub type RXONLY_R = crate::BitReader<RXONLY_A>;
        ///Receive only
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXONLY_A {
            ///0: Full duplex (Transmit and receive)
            FullDuplex = 0,
            ///1: Output disabled (Receive-only mode)
            OutputDisabled = 1,
        }
        impl From<RXONLY_A> for bool {
            #[inline(always)]
            fn from(variant: RXONLY_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXONLY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXONLY_A {
                match self.bits {
                    false => RXONLY_A::FullDuplex,
                    true => RXONLY_A::OutputDisabled,
                }
            }
            ///Checks if the value of the field is `FullDuplex`
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                *self == RXONLY_A::FullDuplex
            }
            ///Checks if the value of the field is `OutputDisabled`
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                *self == RXONLY_A::OutputDisabled
            }
        }
        ///Field `RXONLY` writer - Receive only
        pub type RXONLY_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, RXONLY_A, O>;
        impl<'a, const O: u8> RXONLY_W<'a, O> {
            ///Full duplex (Transmit and receive)
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(RXONLY_A::FullDuplex)
            }
            ///Output disabled (Receive-only mode)
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(RXONLY_A::OutputDisabled)
            }
        }
        ///Field `DFF` reader - Data frame format
        pub type DFF_R = crate::BitReader<DFF_A>;
        ///Data frame format
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DFF_A {
            ///0: Data length 8 bits
            D8 = 0,
            ///1: Data length 16 bits
            D16 = 1,
        }
        impl From<DFF_A> for bool {
            #[inline(always)]
            fn from(variant: DFF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DFF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DFF_A {
                match self.bits {
                    false => DFF_A::D8,
                    true => DFF_A::D16,
                }
            }
            ///Checks if the value of the field is `D8`
            #[inline(always)]
            pub fn is_d8(&self) -> bool {
                *self == DFF_A::D8
            }
            ///Checks if the value of the field is `D16`
            #[inline(always)]
            pub fn is_d16(&self) -> bool {
                *self == DFF_A::D16
            }
        }
        ///Field `DFF` writer - Data frame format
        pub type DFF_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, DFF_A, O>;
        impl<'a, const O: u8> DFF_W<'a, O> {
            ///Data length 8 bits
            #[inline(always)]
            pub fn d8(self) -> &'a mut W {
                self.variant(DFF_A::D8)
            }
            ///Data length 16 bits
            #[inline(always)]
            pub fn d16(self) -> &'a mut W {
                self.variant(DFF_A::D16)
            }
        }
        ///Field `CRCNEXT` reader - CRC transfer next
        pub type CRCNEXT_R = crate::BitReader<CRCNEXT_A>;
        ///CRC transfer next
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CRCNEXT_A {
            ///0: Next transmit value is from Tx buffer
            TxBuffer = 0,
            ///1: Next transmit value is from Tx CRC register
            Crc = 1,
        }
        impl From<CRCNEXT_A> for bool {
            #[inline(always)]
            fn from(variant: CRCNEXT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CRCNEXT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CRCNEXT_A {
                match self.bits {
                    false => CRCNEXT_A::TxBuffer,
                    true => CRCNEXT_A::Crc,
                }
            }
            ///Checks if the value of the field is `TxBuffer`
            #[inline(always)]
            pub fn is_tx_buffer(&self) -> bool {
                *self == CRCNEXT_A::TxBuffer
            }
            ///Checks if the value of the field is `Crc`
            #[inline(always)]
            pub fn is_crc(&self) -> bool {
                *self == CRCNEXT_A::Crc
            }
        }
        ///Field `CRCNEXT` writer - CRC transfer next
        pub type CRCNEXT_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, CRCNEXT_A, O>;
        impl<'a, const O: u8> CRCNEXT_W<'a, O> {
            ///Next transmit value is from Tx buffer
            #[inline(always)]
            pub fn tx_buffer(self) -> &'a mut W {
                self.variant(CRCNEXT_A::TxBuffer)
            }
            ///Next transmit value is from Tx CRC register
            #[inline(always)]
            pub fn crc(self) -> &'a mut W {
                self.variant(CRCNEXT_A::Crc)
            }
        }
        ///Field `CRCEN` reader - Hardware CRC calculation enable
        pub type CRCEN_R = crate::BitReader<CRCEN_A>;
        ///Hardware CRC calculation enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CRCEN_A {
            ///0: CRC calculation disabled
            Disabled = 0,
            ///1: CRC calculation enabled
            Enabled = 1,
        }
        impl From<CRCEN_A> for bool {
            #[inline(always)]
            fn from(variant: CRCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CRCEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CRCEN_A {
                match self.bits {
                    false => CRCEN_A::Disabled,
                    true => CRCEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CRCEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CRCEN_A::Enabled
            }
        }
        ///Field `CRCEN` writer - Hardware CRC calculation enable
        pub type CRCEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, CRCEN_A, O>;
        impl<'a, const O: u8> CRCEN_W<'a, O> {
            ///CRC calculation disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRCEN_A::Disabled)
            }
            ///CRC calculation enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRCEN_A::Enabled)
            }
        }
        ///Field `BIDIOE` reader - Output enable in bidirectional mode
        pub type BIDIOE_R = crate::BitReader<BIDIOE_A>;
        ///Output enable in bidirectional mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BIDIOE_A {
            ///0: Output disabled (receive-only mode)
            OutputDisabled = 0,
            ///1: Output enabled (transmit-only mode)
            OutputEnabled = 1,
        }
        impl From<BIDIOE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIOE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BIDIOE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BIDIOE_A {
                match self.bits {
                    false => BIDIOE_A::OutputDisabled,
                    true => BIDIOE_A::OutputEnabled,
                }
            }
            ///Checks if the value of the field is `OutputDisabled`
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                *self == BIDIOE_A::OutputDisabled
            }
            ///Checks if the value of the field is `OutputEnabled`
            #[inline(always)]
            pub fn is_output_enabled(&self) -> bool {
                *self == BIDIOE_A::OutputEnabled
            }
        }
        ///Field `BIDIOE` writer - Output enable in bidirectional mode
        pub type BIDIOE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, BIDIOE_A, O>;
        impl<'a, const O: u8> BIDIOE_W<'a, O> {
            ///Output disabled (receive-only mode)
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OutputDisabled)
            }
            ///Output enabled (transmit-only mode)
            #[inline(always)]
            pub fn output_enabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OutputEnabled)
            }
        }
        ///Field `BIDIMODE` reader - Bidirectional data mode enable
        pub type BIDIMODE_R = crate::BitReader<BIDIMODE_A>;
        ///Bidirectional data mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BIDIMODE_A {
            ///0: 2-line unidirectional data mode selected
            Unidirectional = 0,
            ///1: 1-line bidirectional data mode selected
            Bidirectional = 1,
        }
        impl From<BIDIMODE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BIDIMODE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BIDIMODE_A {
                match self.bits {
                    false => BIDIMODE_A::Unidirectional,
                    true => BIDIMODE_A::Bidirectional,
                }
            }
            ///Checks if the value of the field is `Unidirectional`
            #[inline(always)]
            pub fn is_unidirectional(&self) -> bool {
                *self == BIDIMODE_A::Unidirectional
            }
            ///Checks if the value of the field is `Bidirectional`
            #[inline(always)]
            pub fn is_bidirectional(&self) -> bool {
                *self == BIDIMODE_A::Bidirectional
            }
        }
        ///Field `BIDIMODE` writer - Bidirectional data mode enable
        pub type BIDIMODE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, BIDIMODE_A, O>;
        impl<'a, const O: u8> BIDIMODE_W<'a, O> {
            ///2-line unidirectional data mode selected
            #[inline(always)]
            pub fn unidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::Unidirectional)
            }
            ///1-line bidirectional data mode selected
            #[inline(always)]
            pub fn bidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::Bidirectional)
            }
        }
        impl R {
            ///Bit 0 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            pub fn mstr(&self) -> MSTR_R {
                MSTR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            pub fn br(&self) -> BR_R {
                BR_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            pub fn spe(&self) -> SPE_R {
                SPE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            pub fn lsbfirst(&self) -> LSBFIRST_R {
                LSBFIRST_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            pub fn ssi(&self) -> SSI_R {
                SSI_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            pub fn ssm(&self) -> SSM_R {
                SSM_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            pub fn rxonly(&self) -> RXONLY_R {
                RXONLY_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            pub fn dff(&self) -> DFF_R {
                DFF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            pub fn crcnext(&self) -> CRCNEXT_R {
                CRCNEXT_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            pub fn bidioe(&self) -> BIDIOE_R {
                BIDIOE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            pub fn bidimode(&self) -> BIDIMODE_R {
                BIDIMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Clock phase
            #[inline(always)]
            #[must_use]
            pub fn cpha(&mut self) -> CPHA_W<0> {
                CPHA_W::new(self)
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            #[must_use]
            pub fn cpol(&mut self) -> CPOL_W<1> {
                CPOL_W::new(self)
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            #[must_use]
            pub fn mstr(&mut self) -> MSTR_W<2> {
                MSTR_W::new(self)
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            #[must_use]
            pub fn br(&mut self) -> BR_W<3> {
                BR_W::new(self)
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            #[must_use]
            pub fn spe(&mut self) -> SPE_W<6> {
                SPE_W::new(self)
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            #[must_use]
            pub fn lsbfirst(&mut self) -> LSBFIRST_W<7> {
                LSBFIRST_W::new(self)
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            #[must_use]
            pub fn ssi(&mut self) -> SSI_W<8> {
                SSI_W::new(self)
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            #[must_use]
            pub fn ssm(&mut self) -> SSM_W<9> {
                SSM_W::new(self)
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            #[must_use]
            pub fn rxonly(&mut self) -> RXONLY_W<10> {
                RXONLY_W::new(self)
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            #[must_use]
            pub fn dff(&mut self) -> DFF_W<11> {
                DFF_W::new(self)
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            #[must_use]
            pub fn crcnext(&mut self) -> CRCNEXT_W<12> {
                CRCNEXT_W::new(self)
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            #[must_use]
            pub fn crcen(&mut self) -> CRCEN_W<13> {
                CRCEN_W::new(self)
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            #[must_use]
            pub fn bidioe(&mut self) -> BIDIOE_W<14> {
                BIDIOE_W::new(self)
            }
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            #[must_use]
            pub fn bidimode(&mut self) -> BIDIMODE_W<15> {
                BIDIMODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RXDMAEN` reader - Rx buffer DMA enable
        pub type RXDMAEN_R = crate::BitReader<RXDMAEN_A>;
        ///Rx buffer DMA enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXDMAEN_A {
            ///0: Rx buffer DMA disabled
            Disabled = 0,
            ///1: Rx buffer DMA enabled
            Enabled = 1,
        }
        impl From<RXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: RXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXDMAEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXDMAEN_A {
                match self.bits {
                    false => RXDMAEN_A::Disabled,
                    true => RXDMAEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RXDMAEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RXDMAEN_A::Enabled
            }
        }
        ///Field `RXDMAEN` writer - Rx buffer DMA enable
        pub type RXDMAEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, RXDMAEN_A, O>;
        impl<'a, const O: u8> RXDMAEN_W<'a, O> {
            ///Rx buffer DMA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::Disabled)
            }
            ///Rx buffer DMA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::Enabled)
            }
        }
        ///Field `TXDMAEN` reader - Tx buffer DMA enable
        pub type TXDMAEN_R = crate::BitReader<TXDMAEN_A>;
        ///Tx buffer DMA enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TXDMAEN_A {
            ///0: Tx buffer DMA disabled
            Disabled = 0,
            ///1: Tx buffer DMA enabled
            Enabled = 1,
        }
        impl From<TXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: TXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TXDMAEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXDMAEN_A {
                match self.bits {
                    false => TXDMAEN_A::Disabled,
                    true => TXDMAEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TXDMAEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TXDMAEN_A::Enabled
            }
        }
        ///Field `TXDMAEN` writer - Tx buffer DMA enable
        pub type TXDMAEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, TXDMAEN_A, O>;
        impl<'a, const O: u8> TXDMAEN_W<'a, O> {
            ///Tx buffer DMA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::Disabled)
            }
            ///Tx buffer DMA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::Enabled)
            }
        }
        ///Field `SSOE` reader - SS output enable
        pub type SSOE_R = crate::BitReader<SSOE_A>;
        ///SS output enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SSOE_A {
            ///0: SS output is disabled in master mode
            Disabled = 0,
            ///1: SS output is enabled in master mode
            Enabled = 1,
        }
        impl From<SSOE_A> for bool {
            #[inline(always)]
            fn from(variant: SSOE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SSOE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SSOE_A {
                match self.bits {
                    false => SSOE_A::Disabled,
                    true => SSOE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SSOE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SSOE_A::Enabled
            }
        }
        ///Field `SSOE` writer - SS output enable
        pub type SSOE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, SSOE_A, O>;
        impl<'a, const O: u8> SSOE_W<'a, O> {
            ///SS output is disabled in master mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSOE_A::Disabled)
            }
            ///SS output is enabled in master mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSOE_A::Enabled)
            }
        }
        ///Field `ERRIE` reader - Error interrupt enable
        pub type ERRIE_R = crate::BitReader<ERRIE_A>;
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERRIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERRIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::Disabled,
                    true => ERRIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ERRIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ERRIE_A::Enabled
            }
        }
        ///Field `ERRIE` writer - Error interrupt enable
        pub type ERRIE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, ERRIE_A, O>;
        impl<'a, const O: u8> ERRIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ERRIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ERRIE_A::Enabled)
            }
        }
        ///Field `RXNEIE` reader - RX buffer not empty interrupt enable
        pub use ERRIE_R as RXNEIE_R;
        ///Field `TXEIE` reader - Tx buffer empty interrupt enable
        pub use ERRIE_R as TXEIE_R;
        ///Field `RXNEIE` writer - RX buffer not empty interrupt enable
        pub use ERRIE_W as RXNEIE_W;
        ///Field `TXEIE` writer - Tx buffer empty interrupt enable
        pub use ERRIE_W as TXEIE_W;
        impl R {
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            pub fn rxdmaen(&self) -> RXDMAEN_R {
                RXDMAEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            pub fn txdmaen(&self) -> TXDMAEN_R {
                TXDMAEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            pub fn ssoe(&self) -> SSOE_R {
                SSOE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rxdmaen(&mut self) -> RXDMAEN_W<0> {
                RXDMAEN_W::new(self)
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            #[must_use]
            pub fn txdmaen(&mut self) -> TXDMAEN_W<1> {
                TXDMAEN_W::new(self)
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            #[must_use]
            pub fn ssoe(&mut self) -> SSOE_W<2> {
                SSOE_W::new(self)
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn errie(&mut self) -> ERRIE_W<5> {
                ERRIE_W::new(self)
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rxneie(&mut self) -> RXNEIE_W<6> {
                RXNEIE_W::new(self)
            }
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn txeie(&mut self) -> TXEIE_W<7> {
                TXEIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RXNE` reader - Receive buffer not empty
        pub type RXNE_R = crate::BitReader<RXNER_A>;
        ///Receive buffer not empty
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXNER_A {
            ///0: Rx buffer empty
            Empty = 0,
            ///1: Rx buffer not empty
            NotEmpty = 1,
        }
        impl From<RXNER_A> for bool {
            #[inline(always)]
            fn from(variant: RXNER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXNE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXNER_A {
                match self.bits {
                    false => RXNER_A::Empty,
                    true => RXNER_A::NotEmpty,
                }
            }
            ///Checks if the value of the field is `Empty`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == RXNER_A::Empty
            }
            ///Checks if the value of the field is `NotEmpty`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == RXNER_A::NotEmpty
            }
        }
        ///Field `TXE` reader - Transmit buffer empty
        pub type TXE_R = crate::BitReader<TXE_A>;
        ///Transmit buffer empty
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TXE_A {
            ///0: Tx buffer not empty
            NotEmpty = 0,
            ///1: Tx buffer empty
            Empty = 1,
        }
        impl From<TXE_A> for bool {
            #[inline(always)]
            fn from(variant: TXE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TXE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXE_A {
                match self.bits {
                    false => TXE_A::NotEmpty,
                    true => TXE_A::Empty,
                }
            }
            ///Checks if the value of the field is `NotEmpty`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                *self == TXE_A::NotEmpty
            }
            ///Checks if the value of the field is `Empty`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TXE_A::Empty
            }
        }
        ///Field `CRCERR` reader - CRC error flag
        pub type CRCERR_R = crate::BitReader<CRCERRR_A>;
        ///CRC error flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CRCERRR_A {
            ///0: CRC value received matches the SPIx_RXCRCR value
            Match = 0,
            ///1: CRC value received does not match the SPIx_RXCRCR value
            NoMatch = 1,
        }
        impl From<CRCERRR_A> for bool {
            #[inline(always)]
            fn from(variant: CRCERRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CRCERR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CRCERRR_A {
                match self.bits {
                    false => CRCERRR_A::Match,
                    true => CRCERRR_A::NoMatch,
                }
            }
            ///Checks if the value of the field is `Match`
            #[inline(always)]
            pub fn is_match(&self) -> bool {
                *self == CRCERRR_A::Match
            }
            ///Checks if the value of the field is `NoMatch`
            #[inline(always)]
            pub fn is_no_match(&self) -> bool {
                *self == CRCERRR_A::NoMatch
            }
        }
        ///CRC error flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CRCERRW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<CRCERRW_AW> for bool {
            #[inline(always)]
            fn from(variant: CRCERRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CRCERR` writer - CRC error flag
        pub type CRCERR_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STATR_SPEC, CRCERRW_AW, O>;
        impl<'a, const O: u8> CRCERR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CRCERRW_AW::Clear)
            }
        }
        ///Field `MODF` reader - Mode fault
        pub type MODF_R = crate::BitReader<MODFR_A>;
        ///Mode fault
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODFR_A {
            ///0: No mode fault occurred
            NoFault = 0,
            ///1: Mode fault occurred
            Fault = 1,
        }
        impl From<MODFR_A> for bool {
            #[inline(always)]
            fn from(variant: MODFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MODF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MODFR_A {
                match self.bits {
                    false => MODFR_A::NoFault,
                    true => MODFR_A::Fault,
                }
            }
            ///Checks if the value of the field is `NoFault`
            #[inline(always)]
            pub fn is_no_fault(&self) -> bool {
                *self == MODFR_A::NoFault
            }
            ///Checks if the value of the field is `Fault`
            #[inline(always)]
            pub fn is_fault(&self) -> bool {
                *self == MODFR_A::Fault
            }
        }
        ///Mode fault
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MODFW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<MODFW_AW> for bool {
            #[inline(always)]
            fn from(variant: MODFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MODF` writer - Mode fault
        pub type MODF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STATR_SPEC, MODFW_AW, O>;
        impl<'a, const O: u8> MODF_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(MODFW_AW::Clear)
            }
        }
        ///Field `OVR` reader - Overrun flag
        pub type OVR_R = crate::BitReader<OVRR_A>;
        ///Overrun flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OVRR_A {
            ///0: No overrun occurred
            NoOverrun = 0,
            ///1: Overrun occurred
            Overrun = 1,
        }
        impl From<OVRR_A> for bool {
            #[inline(always)]
            fn from(variant: OVRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OVR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OVRR_A {
                match self.bits {
                    false => OVRR_A::NoOverrun,
                    true => OVRR_A::Overrun,
                }
            }
            ///Checks if the value of the field is `NoOverrun`
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVRR_A::NoOverrun
            }
            ///Checks if the value of the field is `Overrun`
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == OVRR_A::Overrun
            }
        }
        ///Overrun flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OVRW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<OVRW_AW> for bool {
            #[inline(always)]
            fn from(variant: OVRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OVR` writer - Overrun flag
        pub type OVR_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, STATR_SPEC, OVRW_AW, O>;
        impl<'a, const O: u8> OVR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVRW_AW::Clear)
            }
        }
        ///Field `BSY` reader - Busy flag
        pub type BSY_R = crate::BitReader<BSYR_A>;
        ///Busy flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BSYR_A {
            ///0: SPI not busy
            NotBusy = 0,
            ///1: SPI busy
            Busy = 1,
        }
        impl From<BSYR_A> for bool {
            #[inline(always)]
            fn from(variant: BSYR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BSY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BSYR_A {
                match self.bits {
                    false => BSYR_A::NotBusy,
                    true => BSYR_A::Busy,
                }
            }
            ///Checks if the value of the field is `NotBusy`
            #[inline(always)]
            pub fn is_not_busy(&self) -> bool {
                *self == BSYR_A::NotBusy
            }
            ///Checks if the value of the field is `Busy`
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == BSYR_A::Busy
            }
        }
        impl R {
            ///Bit 0 - Receive buffer not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transmit buffer empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 4 - CRC error flag
            #[inline(always)]
            pub fn crcerr(&self) -> CRCERR_R {
                CRCERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Mode fault
            #[inline(always)]
            pub fn modf(&self) -> MODF_R {
                MODF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Overrun flag
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Busy flag
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - CRC error flag
            #[inline(always)]
            #[must_use]
            pub fn crcerr(&mut self) -> CRCERR_W<4> {
                CRCERR_W::new(self)
            }
            ///Bit 5 - Mode fault
            #[inline(always)]
            #[must_use]
            pub fn modf(&mut self) -> MODF_W<5> {
                MODF_W::new(self)
            }
            ///Bit 6 - Overrun flag
            #[inline(always)]
            #[must_use]
            pub fn ovr(&mut self) -> OVR_W<6> {
                OVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x70;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0x02
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///DATAR (rw) register accessor: an alias for `Reg<DATAR_SPEC>`
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///data register
    pub mod datar {
        ///Register `DATAR` reader
        pub struct R(crate::R<DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR` writer
        pub struct W(crate::W<DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DATAR` reader - Data register
        pub type DATAR_R = crate::FieldReader<u16, u16>;
        ///Field `DATAR` writer - Data register
        pub type DATAR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, DATAR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Data register
            #[inline(always)]
            pub fn datar(&self) -> DATAR_R {
                DATAR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Data register
            #[inline(always)]
            #[must_use]
            pub fn datar(&mut self) -> DATAR_W<0> {
                DATAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar](index.html) module
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [datar::R](R) reader structure
        impl crate::Readable for DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar::W](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CRCR (rw) register accessor: an alias for `Reg<CRCR_SPEC>`
    pub type CRCR = crate::Reg<crcr::CRCR_SPEC>;
    ///CRCR polynomial register
    pub mod crcr {
        ///Register `CRCR` reader
        pub struct R(crate::R<CRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CRCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CRCR` writer
        pub struct W(crate::W<CRCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CRCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CRCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CRCPOLY` reader - CRC polynomial register
        pub type CRCPOLY_R = crate::FieldReader<u16, u16>;
        ///Field `CRCPOLY` writer - CRC polynomial register
        pub type CRCPOLY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CRCR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            pub fn crcpoly(&self) -> CRCPOLY_R {
                CRCPOLY_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            #[must_use]
            pub fn crcpoly(&mut self) -> CRCPOLY_W<0> {
                CRCPOLY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///CRCR polynomial register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [crcr](index.html) module
        pub struct CRCR_SPEC;
        impl crate::RegisterSpec for CRCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [crcr::R](R) reader structure
        impl crate::Readable for CRCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [crcr::W](W) writer structure
        impl crate::Writable for CRCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CRCR to value 0x07
        impl crate::Resettable for CRCR_SPEC {
            const RESET_VALUE: Self::Ux = 0x07;
        }
    }
    ///RCRCR (r) register accessor: an alias for `Reg<RCRCR_SPEC>`
    pub type RCRCR = crate::Reg<rcrcr::RCRCR_SPEC>;
    ///RX CRC register
    pub mod rcrcr {
        ///Register `RCRCR` reader
        pub struct R(crate::R<RCRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RCRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RCRCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RCRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RxCRC` reader - Rx CRC register
        pub type RX_CRC_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Rx CRC register
            #[inline(always)]
            pub fn rx_crc(&self) -> RX_CRC_R {
                RX_CRC_R::new(self.bits)
            }
        }
        ///RX CRC register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rcrcr](index.html) module
        pub struct RCRCR_SPEC;
        impl crate::RegisterSpec for RCRCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [rcrcr::R](R) reader structure
        impl crate::Readable for RCRCR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RCRCR to value 0
        impl crate::Resettable for RCRCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TCRCR (r) register accessor: an alias for `Reg<TCRCR_SPEC>`
    pub type TCRCR = crate::Reg<tcrcr::TCRCR_SPEC>;
    ///TX CRC register
    pub mod tcrcr {
        ///Register `TCRCR` reader
        pub struct R(crate::R<TCRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TCRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TCRCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TCRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TxCRC` reader - Tx CRC register
        pub type TX_CRC_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Tx CRC register
            #[inline(always)]
            pub fn tx_crc(&self) -> TX_CRC_R {
                TX_CRC_R::new(self.bits)
            }
        }
        ///TX CRC register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tcrcr](index.html) module
        pub struct TCRCR_SPEC;
        impl crate::RegisterSpec for TCRCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [tcrcr::R](R) reader structure
        impl crate::Readable for TCRCR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TCRCR to value 0
        impl crate::Resettable for TCRCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Serial peripheral interface
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI2").finish()
    }
}
///Serial peripheral interface
pub use self::spi1 as spi2;
///Universal synchronous asynchronous receiver transmitter
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART1 {}
impl USART1 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4001_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USART1 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART1").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub mod usart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Status register
        pub statr: STATR,
        ///0x04 - Data register
        pub datar: DATAR,
        ///0x08 - Baud rate register
        pub brr: BRR,
        ///0x0c - Control register 1
        pub ctlr1: CTLR1,
        ///0x10 - Control register 2
        pub ctlr2: CTLR2,
        ///0x14 - Control register 3
        pub ctlr3: CTLR3,
        ///0x18 - Guard time and prescaler register
        pub gpr: GPR,
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PE` reader - Parity error
        pub type PE_R = crate::BitReader<PER_A>;
        ///Parity error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PER_A {
            ///0: No error occurred
            NoError = 0,
            ///1: Error occurred
            HasError = 1,
        }
        impl From<PER_A> for bool {
            #[inline(always)]
            fn from(variant: PER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PER_A {
                match self.bits {
                    false => PER_A::NoError,
                    true => PER_A::HasError,
                }
            }
            ///Checks if the value of the field is `NoError`
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == PER_A::NoError
            }
            ///Checks if the value of the field is `HasError`
            #[inline(always)]
            pub fn is_has_error(&self) -> bool {
                *self == PER_A::HasError
            }
        }
        ///Field `FE` reader - Framing error
        pub use PE_R as FE_R;
        ///Field `NE` reader - Noise error flag
        pub use PE_R as NE_R;
        ///Field `ORE` reader - Overrun error
        pub use PE_R as ORE_R;
        ///Field `IDLE` reader - IDLE line detected
        pub type IDLE_R = crate::BitReader<IDLER_A>;
        ///IDLE line detected
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IDLER_A {
            ///0: Line busy
            Busy = 0,
            ///1: Line idle
            Idle = 1,
        }
        impl From<IDLER_A> for bool {
            #[inline(always)]
            fn from(variant: IDLER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IDLE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IDLER_A {
                match self.bits {
                    false => IDLER_A::Busy,
                    true => IDLER_A::Idle,
                }
            }
            ///Checks if the value of the field is `Busy`
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == IDLER_A::Busy
            }
            ///Checks if the value of the field is `Idle`
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == IDLER_A::Idle
            }
        }
        ///Field `RXNE` reader - Read data register not empty
        pub type RXNE_R = crate::BitReader<RXNER_A>;
        ///Read data register not empty
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXNER_A {
            ///0: Waiting for data
            Waiting = 0,
            ///1: Data received, register readable
            Readable = 1,
        }
        impl From<RXNER_A> for bool {
            #[inline(always)]
            fn from(variant: RXNER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXNE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXNER_A {
                match self.bits {
                    false => RXNER_A::Waiting,
                    true => RXNER_A::Readable,
                }
            }
            ///Checks if the value of the field is `Waiting`
            #[inline(always)]
            pub fn is_waiting(&self) -> bool {
                *self == RXNER_A::Waiting
            }
            ///Checks if the value of the field is `Readable`
            #[inline(always)]
            pub fn is_readable(&self) -> bool {
                *self == RXNER_A::Readable
            }
        }
        ///Read data register not empty
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXNEW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<RXNEW_AW> for bool {
            #[inline(always)]
            fn from(variant: RXNEW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RXNE` writer - Read data register not empty
        pub type RXNE_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, STATR_SPEC, RXNEW_AW, O>;
        impl<'a, const O: u8> RXNE_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RXNEW_AW::Clear)
            }
        }
        ///Field `TC` reader - Transmission complete
        pub type TC_R = crate::BitReader<TCR_A>;
        ///Transmission complete
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCR_A {
            ///0: Transmission in progress
            InProgress = 0,
            ///1: Transmission completed
            Completed = 1,
        }
        impl From<TCR_A> for bool {
            #[inline(always)]
            fn from(variant: TCR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCR_A {
                match self.bits {
                    false => TCR_A::InProgress,
                    true => TCR_A::Completed,
                }
            }
            ///Checks if the value of the field is `InProgress`
            #[inline(always)]
            pub fn is_in_progress(&self) -> bool {
                *self == TCR_A::InProgress
            }
            ///Checks if the value of the field is `Completed`
            #[inline(always)]
            pub fn is_completed(&self) -> bool {
                *self == TCR_A::Completed
            }
        }
        ///Transmission complete
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TCW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<TCW_AW> for bool {
            #[inline(always)]
            fn from(variant: TCW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TC` writer - Transmission complete
        pub type TC_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, STATR_SPEC, TCW_AW, O>;
        impl<'a, const O: u8> TC_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TCW_AW::Clear)
            }
        }
        ///Field `TXE` reader - Transmit data register empty
        pub type TXE_R = crate::BitReader<TXER_A>;
        ///Transmit data register empty
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TXER_A {
            ///0: Data transfer in progress
            InProgress = 0,
            ///1: Data transfer completed
            Transferred = 1,
        }
        impl From<TXER_A> for bool {
            #[inline(always)]
            fn from(variant: TXER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TXE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXER_A {
                match self.bits {
                    false => TXER_A::InProgress,
                    true => TXER_A::Transferred,
                }
            }
            ///Checks if the value of the field is `InProgress`
            #[inline(always)]
            pub fn is_in_progress(&self) -> bool {
                *self == TXER_A::InProgress
            }
            ///Checks if the value of the field is `Transferred`
            #[inline(always)]
            pub fn is_transferred(&self) -> bool {
                *self == TXER_A::Transferred
            }
        }
        ///Field `LBD` reader - LIN break detection flag
        pub type LBD_R = crate::BitReader<LBDR_A>;
        ///LIN break detection flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LBDR_A {
            ///0: LIN disconnection not detected
            Connected = 0,
            ///1: LIN disconnection detected
            Disconnected = 1,
        }
        impl From<LBDR_A> for bool {
            #[inline(always)]
            fn from(variant: LBDR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LBD_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LBDR_A {
                match self.bits {
                    false => LBDR_A::Connected,
                    true => LBDR_A::Disconnected,
                }
            }
            ///Checks if the value of the field is `Connected`
            #[inline(always)]
            pub fn is_connected(&self) -> bool {
                *self == LBDR_A::Connected
            }
            ///Checks if the value of the field is `Disconnected`
            #[inline(always)]
            pub fn is_disconnected(&self) -> bool {
                *self == LBDR_A::Disconnected
            }
        }
        ///LIN break detection flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LBDW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<LBDW_AW> for bool {
            #[inline(always)]
            fn from(variant: LBDW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LBD` writer - LIN break detection flag
        pub type LBD_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, STATR_SPEC, LBDW_AW, O>;
        impl<'a, const O: u8> LBD_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LBDW_AW::Clear)
            }
        }
        ///Field `CTS` reader - CTS flag
        pub type CTS_R = crate::BitReader<CTSR_A>;
        ///CTS flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTSR_A {
            ///0: No change detected on nCTS
            NoChange = 0,
            ///1: Change detected on nCTS
            Changed = 1,
        }
        impl From<CTSR_A> for bool {
            #[inline(always)]
            fn from(variant: CTSR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CTSR_A {
                match self.bits {
                    false => CTSR_A::NoChange,
                    true => CTSR_A::Changed,
                }
            }
            ///Checks if the value of the field is `NoChange`
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == CTSR_A::NoChange
            }
            ///Checks if the value of the field is `Changed`
            #[inline(always)]
            pub fn is_changed(&self) -> bool {
                *self == CTSR_A::Changed
            }
        }
        ///CTS flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTSW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<CTSW_AW> for bool {
            #[inline(always)]
            fn from(variant: CTSW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTS` writer - CTS flag
        pub type CTS_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, STATR_SPEC, CTSW_AW, O>;
        impl<'a, const O: u8> CTS_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTSW_AW::Clear)
            }
        }
        impl R {
            ///Bit 0 - Parity error
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Framing error
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Noise error flag
            #[inline(always)]
            pub fn ne(&self) -> NE_R {
                NE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Overrun error
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IDLE line detected
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Transmit data register empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            pub fn lbd(&self) -> LBD_R {
                LBD_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - CTS flag
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            #[must_use]
            pub fn rxne(&mut self) -> RXNE_W<5> {
                RXNE_W::new(self)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            #[must_use]
            pub fn tc(&mut self) -> TC_W<6> {
                TC_W::new(self)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            #[must_use]
            pub fn lbd(&mut self) -> LBD_W<8> {
                LBD_W::new(self)
            }
            ///Bit 9 - CTS flag
            #[inline(always)]
            #[must_use]
            pub fn cts(&mut self) -> CTS_W<9> {
                CTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0360;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0xc0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0xc0;
        }
    }
    ///DATAR (rw) register accessor: an alias for `Reg<DATAR_SPEC>`
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub struct R(crate::R<DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR` writer
        pub struct W(crate::W<DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - Data value
        pub type DR_R = crate::FieldReader<u16, u16>;
        ///Field `DR` writer - Data value
        pub type DR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DATAR_SPEC, u16, u16, 9, O>;
        impl R {
            ///Bits 0:8 - Data value
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            ///Bits 0:8 - Data value
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<0> {
                DR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar](index.html) module
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [datar::R](R) reader structure
        impl crate::Readable for DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar::W](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BRR (rw) register accessor: an alias for `Reg<BRR_SPEC>`
    pub type BRR = crate::Reg<brr::BRR_SPEC>;
    ///Baud rate register
    pub mod brr {
        ///Register `BRR` reader
        pub struct R(crate::R<BRR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BRR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BRR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BRR` writer
        pub struct W(crate::W<BRR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BRR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BRR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DIV_Fraction` reader - fraction of USARTDIV
        pub type DIV_FRACTION_R = crate::FieldReader<u8, u8>;
        ///Field `DIV_Fraction` writer - fraction of USARTDIV
        pub type DIV_FRACTION_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BRR_SPEC, u8, u8, 4, O>;
        ///Field `DIV_Mantissa` reader - mantissa of USARTDIV
        pub type DIV_MANTISSA_R = crate::FieldReader<u16, u16>;
        ///Field `DIV_Mantissa` writer - mantissa of USARTDIV
        pub type DIV_MANTISSA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BRR_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            pub fn div_fraction(&self) -> DIV_FRACTION_R {
                DIV_FRACTION_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            pub fn div_mantissa(&self) -> DIV_MANTISSA_R {
                DIV_MANTISSA_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            #[must_use]
            pub fn div_fraction(&mut self) -> DIV_FRACTION_W<0> {
                DIV_FRACTION_W::new(self)
            }
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            #[must_use]
            pub fn div_mantissa(&mut self) -> DIV_MANTISSA_W<4> {
                DIV_MANTISSA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Baud rate register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [brr](index.html) module
        pub struct BRR_SPEC;
        impl crate::RegisterSpec for BRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [brr::R](R) reader structure
        impl crate::Readable for BRR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [brr::W](W) writer structure
        impl crate::Writable for BRR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BRR to value 0
        impl crate::Resettable for BRR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///Control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SBK` reader - Send break
        pub type SBK_R = crate::BitReader<SBK_A>;
        ///Send break
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SBK_A {
            ///0: No break character is transmitted
            NoBreak = 0,
            ///1: Break character transmitted
            Break = 1,
        }
        impl From<SBK_A> for bool {
            #[inline(always)]
            fn from(variant: SBK_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SBK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SBK_A {
                match self.bits {
                    false => SBK_A::NoBreak,
                    true => SBK_A::Break,
                }
            }
            ///Checks if the value of the field is `NoBreak`
            #[inline(always)]
            pub fn is_no_break(&self) -> bool {
                *self == SBK_A::NoBreak
            }
            ///Checks if the value of the field is `Break`
            #[inline(always)]
            pub fn is_break(&self) -> bool {
                *self == SBK_A::Break
            }
        }
        ///Field `SBK` writer - Send break
        pub type SBK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, SBK_A, O>;
        impl<'a, const O: u8> SBK_W<'a, O> {
            ///No break character is transmitted
            #[inline(always)]
            pub fn no_break(self) -> &'a mut W {
                self.variant(SBK_A::NoBreak)
            }
            ///Break character transmitted
            #[inline(always)]
            pub fn break_(self) -> &'a mut W {
                self.variant(SBK_A::Break)
            }
        }
        ///Field `RWU` reader - Receiver wakeup
        pub type RWU_R = crate::BitReader<RWU_A>;
        ///Receiver wakeup
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RWU_A {
            ///0: Receiver in active mode
            Active = 0,
            ///1: Receiver in mute mode
            Muted = 1,
        }
        impl From<RWU_A> for bool {
            #[inline(always)]
            fn from(variant: RWU_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RWU_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RWU_A {
                match self.bits {
                    false => RWU_A::Active,
                    true => RWU_A::Muted,
                }
            }
            ///Checks if the value of the field is `Active`
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                *self == RWU_A::Active
            }
            ///Checks if the value of the field is `Muted`
            #[inline(always)]
            pub fn is_muted(&self) -> bool {
                *self == RWU_A::Muted
            }
        }
        ///Field `RWU` writer - Receiver wakeup
        pub type RWU_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, RWU_A, O>;
        impl<'a, const O: u8> RWU_W<'a, O> {
            ///Receiver in active mode
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(RWU_A::Active)
            }
            ///Receiver in mute mode
            #[inline(always)]
            pub fn muted(self) -> &'a mut W {
                self.variant(RWU_A::Muted)
            }
        }
        ///Field `RE` reader - Receiver enable
        pub type RE_R = crate::BitReader<RE_A>;
        ///Receiver enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RE_A {
            ///0: Module disabled
            Disabled = 0,
            ///1: Module enabled
            Enabled = 1,
        }
        impl From<RE_A> for bool {
            #[inline(always)]
            fn from(variant: RE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RE_A {
                match self.bits {
                    false => RE_A::Disabled,
                    true => RE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RE_A::Enabled
            }
        }
        ///Field `RE` writer - Receiver enable
        pub type RE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, RE_A, O>;
        impl<'a, const O: u8> RE_W<'a, O> {
            ///Module disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RE_A::Disabled)
            }
            ///Module enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RE_A::Enabled)
            }
        }
        ///Field `TE` reader - Transmitter enable
        pub use RE_R as TE_R;
        ///Field `TE` writer - Transmitter enable
        pub use RE_W as TE_W;
        ///Field `IDLEIE` reader - IDLE interrupt enable
        pub type IDLEIE_R = crate::BitReader<IDLEIE_A>;
        ///IDLE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IDLEIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<IDLEIE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IDLEIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IDLEIE_A {
                match self.bits {
                    false => IDLEIE_A::Disabled,
                    true => IDLEIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IDLEIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IDLEIE_A::Enabled
            }
        }
        ///Field `IDLEIE` writer - IDLE interrupt enable
        pub type IDLEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, IDLEIE_A, O>;
        impl<'a, const O: u8> IDLEIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::Enabled)
            }
        }
        ///Field `RXNEIE` reader - RXNE interrupt enable
        pub use IDLEIE_R as RXNEIE_R;
        ///Field `TCIE` reader - Transmission complete interrupt enable
        pub use IDLEIE_R as TCIE_R;
        ///Field `TXEIE` reader - TXE interrupt enable
        pub use IDLEIE_R as TXEIE_R;
        ///Field `PEIE` reader - PE interrupt enable
        pub use IDLEIE_R as PEIE_R;
        ///Field `RXNEIE` writer - RXNE interrupt enable
        pub use IDLEIE_W as RXNEIE_W;
        ///Field `TCIE` writer - Transmission complete interrupt enable
        pub use IDLEIE_W as TCIE_W;
        ///Field `TXEIE` writer - TXE interrupt enable
        pub use IDLEIE_W as TXEIE_W;
        ///Field `PEIE` writer - PE interrupt enable
        pub use IDLEIE_W as PEIE_W;
        ///Field `PS` reader - Parity selection
        pub type PS_R = crate::BitReader<PS_A>;
        ///Parity selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PS_A {
            ///0: Even parity check
            Even = 0,
            ///1: Odd parity check
            Odd = 1,
        }
        impl From<PS_A> for bool {
            #[inline(always)]
            fn from(variant: PS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PS_A {
                match self.bits {
                    false => PS_A::Even,
                    true => PS_A::Odd,
                }
            }
            ///Checks if the value of the field is `Even`
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == PS_A::Even
            }
            ///Checks if the value of the field is `Odd`
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == PS_A::Odd
            }
        }
        ///Field `PS` writer - Parity selection
        pub type PS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, PS_A, O>;
        impl<'a, const O: u8> PS_W<'a, O> {
            ///Even parity check
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(PS_A::Even)
            }
            ///Odd parity check
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(PS_A::Odd)
            }
        }
        ///Field `PCE` reader - Parity control enable
        pub type PCE_R = crate::BitReader<bool>;
        ///Field `PCE` writer - Parity control enable
        pub type PCE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `WAKE` reader - Wakeup method
        pub type WAKE_R = crate::BitReader<WAKE_A>;
        ///Wakeup method
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WAKE_A {
            ///0: USART wake up on idle line
            IdleLine = 0,
            ///1: USART wake up on address mark
            AddressMark = 1,
        }
        impl From<WAKE_A> for bool {
            #[inline(always)]
            fn from(variant: WAKE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WAKE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAKE_A {
                match self.bits {
                    false => WAKE_A::IdleLine,
                    true => WAKE_A::AddressMark,
                }
            }
            ///Checks if the value of the field is `IdleLine`
            #[inline(always)]
            pub fn is_idle_line(&self) -> bool {
                *self == WAKE_A::IdleLine
            }
            ///Checks if the value of the field is `AddressMark`
            #[inline(always)]
            pub fn is_address_mark(&self) -> bool {
                *self == WAKE_A::AddressMark
            }
        }
        ///Field `WAKE` writer - Wakeup method
        pub type WAKE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, WAKE_A, O>;
        impl<'a, const O: u8> WAKE_W<'a, O> {
            ///USART wake up on idle line
            #[inline(always)]
            pub fn idle_line(self) -> &'a mut W {
                self.variant(WAKE_A::IdleLine)
            }
            ///USART wake up on address mark
            #[inline(always)]
            pub fn address_mark(self) -> &'a mut W {
                self.variant(WAKE_A::AddressMark)
            }
        }
        ///Field `M` reader - Word length
        pub type M_R = crate::BitReader<M_A>;
        ///Word length
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum M_A {
            ///0: Word length 8 data bits
            L8 = 0,
            ///1: Word length 9 data bits
            L9 = 1,
        }
        impl From<M_A> for bool {
            #[inline(always)]
            fn from(variant: M_A) -> Self {
                variant as u8 != 0
            }
        }
        impl M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> M_A {
                match self.bits {
                    false => M_A::L8,
                    true => M_A::L9,
                }
            }
            ///Checks if the value of the field is `L8`
            #[inline(always)]
            pub fn is_l8(&self) -> bool {
                *self == M_A::L8
            }
            ///Checks if the value of the field is `L9`
            #[inline(always)]
            pub fn is_l9(&self) -> bool {
                *self == M_A::L9
            }
        }
        ///Field `M` writer - Word length
        pub type M_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, M_A, O>;
        impl<'a, const O: u8> M_W<'a, O> {
            ///Word length 8 data bits
            #[inline(always)]
            pub fn l8(self) -> &'a mut W {
                self.variant(M_A::L8)
            }
            ///Word length 9 data bits
            #[inline(always)]
            pub fn l9(self) -> &'a mut W {
                self.variant(M_A::L9)
            }
        }
        ///Field `UE` reader - USART enable
        pub type UE_R = crate::BitReader<UE_A>;
        ///USART enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UE_A {
            ///0: USART enabled
            Enabled = 0,
            ///1: USART disabled
            Disabled = 1,
        }
        impl From<UE_A> for bool {
            #[inline(always)]
            fn from(variant: UE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UE_A {
                match self.bits {
                    false => UE_A::Enabled,
                    true => UE_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UE_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UE_A::Disabled
            }
        }
        ///Field `UE` writer - USART enable
        pub type UE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, UE_A, O>;
        impl<'a, const O: u8> UE_W<'a, O> {
            ///USART enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UE_A::Enabled)
            }
            ///USART disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UE_A::Disabled)
            }
        }
        impl R {
            ///Bit 0 - Send break
            #[inline(always)]
            pub fn sbk(&self) -> SBK_R {
                SBK_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            pub fn m(&self) -> M_R {
                M_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Send break
            #[inline(always)]
            #[must_use]
            pub fn sbk(&mut self) -> SBK_W<0> {
                SBK_W::new(self)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            #[must_use]
            pub fn rwu(&mut self) -> RWU_W<1> {
                RWU_W::new(self)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            #[must_use]
            pub fn re(&mut self) -> RE_W<2> {
                RE_W::new(self)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            #[must_use]
            pub fn te(&mut self) -> TE_W<3> {
                TE_W::new(self)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn idleie(&mut self) -> IDLEIE_W<4> {
                IDLEIE_W::new(self)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rxneie(&mut self) -> RXNEIE_W<5> {
                RXNEIE_W::new(self)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<6> {
                TCIE_W::new(self)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn txeie(&mut self) -> TXEIE_W<7> {
                TXEIE_W::new(self)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn peie(&mut self) -> PEIE_W<8> {
                PEIE_W::new(self)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            #[must_use]
            pub fn ps(&mut self) -> PS_W<9> {
                PS_W::new(self)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            #[must_use]
            pub fn pce(&mut self) -> PCE_W<10> {
                PCE_W::new(self)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            #[must_use]
            pub fn wake(&mut self) -> WAKE_W<11> {
                WAKE_W::new(self)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            #[must_use]
            pub fn m(&mut self) -> M_W<12> {
                M_W::new(self)
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            #[must_use]
            pub fn ue(&mut self) -> UE_W<13> {
                UE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///Control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADD` reader - Address of the USART node
        pub type ADD_R = crate::FieldReader<u8, u8>;
        ///Field `ADD` writer - Address of the USART node
        pub type ADD_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 4, O>;
        ///Field `LBDL` reader - lin break detection length
        pub type LBDL_R = crate::BitReader<LBDL_A>;
        ///lin break detection length
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LBDL_A {
            ///0: 10-bit break detection
            Lbdl10 = 0,
            ///1: 11-bit break detection
            Lbdl11 = 1,
        }
        impl From<LBDL_A> for bool {
            #[inline(always)]
            fn from(variant: LBDL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LBDL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LBDL_A {
                match self.bits {
                    false => LBDL_A::Lbdl10,
                    true => LBDL_A::Lbdl11,
                }
            }
            ///Checks if the value of the field is `Lbdl10`
            #[inline(always)]
            pub fn is_lbdl10(&self) -> bool {
                *self == LBDL_A::Lbdl10
            }
            ///Checks if the value of the field is `Lbdl11`
            #[inline(always)]
            pub fn is_lbdl11(&self) -> bool {
                *self == LBDL_A::Lbdl11
            }
        }
        ///Field `LBDL` writer - lin break detection length
        pub type LBDL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, LBDL_A, O>;
        impl<'a, const O: u8> LBDL_W<'a, O> {
            ///10-bit break detection
            #[inline(always)]
            pub fn lbdl10(self) -> &'a mut W {
                self.variant(LBDL_A::Lbdl10)
            }
            ///11-bit break detection
            #[inline(always)]
            pub fn lbdl11(self) -> &'a mut W {
                self.variant(LBDL_A::Lbdl11)
            }
        }
        ///Field `LBDIE` reader - LIN break detection interrupt enable
        pub type LBDIE_R = crate::BitReader<LBDIE_A>;
        ///LIN break detection interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LBDIE_A {
            ///0: LIN break detection disabled
            Disabled = 0,
            ///1: LIN break detection enabled
            Enabled = 1,
        }
        impl From<LBDIE_A> for bool {
            #[inline(always)]
            fn from(variant: LBDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LBDIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LBDIE_A {
                match self.bits {
                    false => LBDIE_A::Disabled,
                    true => LBDIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LBDIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LBDIE_A::Enabled
            }
        }
        ///Field `LBDIE` writer - LIN break detection interrupt enable
        pub type LBDIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, LBDIE_A, O>;
        impl<'a, const O: u8> LBDIE_W<'a, O> {
            ///LIN break detection disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LBDIE_A::Disabled)
            }
            ///LIN break detection enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LBDIE_A::Enabled)
            }
        }
        ///Field `LBCL` reader - Last bit clock pulse
        pub type LBCL_R = crate::BitReader<bool>;
        ///Field `LBCL` writer - Last bit clock pulse
        pub type LBCL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CPHA` reader - Clock phase
        pub type CPHA_R = crate::BitReader<CPHA_A>;
        ///Clock phase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CPHA_A {
            ///0: The first clock transition is the first data capture edge
            First = 0,
            ///1: The second clock transition is the first data capture edge
            Second = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CPHA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::First,
                    true => CPHA_A::Second,
                }
            }
            ///Checks if the value of the field is `First`
            #[inline(always)]
            pub fn is_first(&self) -> bool {
                *self == CPHA_A::First
            }
            ///Checks if the value of the field is `Second`
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                *self == CPHA_A::Second
            }
        }
        ///Field `CPHA` writer - Clock phase
        pub type CPHA_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, CPHA_A, O>;
        impl<'a, const O: u8> CPHA_W<'a, O> {
            ///The first clock transition is the first data capture edge
            #[inline(always)]
            pub fn first(self) -> &'a mut W {
                self.variant(CPHA_A::First)
            }
            ///The second clock transition is the first data capture edge
            #[inline(always)]
            pub fn second(self) -> &'a mut W {
                self.variant(CPHA_A::Second)
            }
        }
        ///Field `CPOL` reader - Clock polarity
        pub type CPOL_R = crate::BitReader<CPOL_A>;
        ///Clock polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CPOL_A {
            ///0: Steady low value on CK pin outside transmission window
            Low = 0,
            ///1: Steady high value on CK pin outside transmission window
            High = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CPOL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::Low,
                    true => CPOL_A::High,
                }
            }
            ///Checks if the value of the field is `Low`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == CPOL_A::Low
            }
            ///Checks if the value of the field is `High`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == CPOL_A::High
            }
        }
        ///Field `CPOL` writer - Clock polarity
        pub type CPOL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, CPOL_A, O>;
        impl<'a, const O: u8> CPOL_W<'a, O> {
            ///Steady low value on CK pin outside transmission window
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(CPOL_A::Low)
            }
            ///Steady high value on CK pin outside transmission window
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(CPOL_A::High)
            }
        }
        ///Field `CLKEN` reader - Clock enable
        pub type CLKEN_R = crate::BitReader<CLKEN_A>;
        ///Clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CLKEN_A {
            ///0: CK pin disabled
            Disabled = 0,
            ///1: CK pin enabled
            Enabled = 1,
        }
        impl From<CLKEN_A> for bool {
            #[inline(always)]
            fn from(variant: CLKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CLKEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CLKEN_A {
                match self.bits {
                    false => CLKEN_A::Disabled,
                    true => CLKEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CLKEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CLKEN_A::Enabled
            }
        }
        ///Field `CLKEN` writer - Clock enable
        pub type CLKEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, CLKEN_A, O>;
        impl<'a, const O: u8> CLKEN_W<'a, O> {
            ///CK pin disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CLKEN_A::Disabled)
            }
            ///CK pin enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CLKEN_A::Enabled)
            }
        }
        ///Field `STOP` reader - STOP bits
        pub type STOP_R = crate::FieldReader<u8, STOP_A>;
        ///STOP bits
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STOP_A {
            ///0: 1 stop bit
            Stop1 = 0,
            ///1: 0.5 stop bits
            Stop0p5 = 1,
            ///2: 2 stop bits
            Stop2 = 2,
            ///3: 1.5 stop bits
            Stop1p5 = 3,
        }
        impl From<STOP_A> for u8 {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as _
            }
        }
        impl STOP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    0 => STOP_A::Stop1,
                    1 => STOP_A::Stop0p5,
                    2 => STOP_A::Stop2,
                    3 => STOP_A::Stop1p5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Stop1`
            #[inline(always)]
            pub fn is_stop1(&self) -> bool {
                *self == STOP_A::Stop1
            }
            ///Checks if the value of the field is `Stop0p5`
            #[inline(always)]
            pub fn is_stop0p5(&self) -> bool {
                *self == STOP_A::Stop0p5
            }
            ///Checks if the value of the field is `Stop2`
            #[inline(always)]
            pub fn is_stop2(&self) -> bool {
                *self == STOP_A::Stop2
            }
            ///Checks if the value of the field is `Stop1p5`
            #[inline(always)]
            pub fn is_stop1p5(&self) -> bool {
                *self == STOP_A::Stop1p5
            }
        }
        ///Field `STOP` writer - STOP bits
        pub type STOP_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CTLR2_SPEC, u8, STOP_A, 2, O>;
        impl<'a, const O: u8> STOP_W<'a, O> {
            ///1 stop bit
            #[inline(always)]
            pub fn stop1(self) -> &'a mut W {
                self.variant(STOP_A::Stop1)
            }
            ///0.5 stop bits
            #[inline(always)]
            pub fn stop0p5(self) -> &'a mut W {
                self.variant(STOP_A::Stop0p5)
            }
            ///2 stop bits
            #[inline(always)]
            pub fn stop2(self) -> &'a mut W {
                self.variant(STOP_A::Stop2)
            }
            ///1.5 stop bits
            #[inline(always)]
            pub fn stop1p5(self) -> &'a mut W {
                self.variant(STOP_A::Stop1p5)
            }
        }
        ///Field `LINEN` reader - LIN mode enable
        pub type LINEN_R = crate::BitReader<LINEN_A>;
        ///LIN mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LINEN_A {
            ///0: LIN mode disabled
            Disabled = 0,
            ///1: LIN mode enabled
            Enabled = 1,
        }
        impl From<LINEN_A> for bool {
            #[inline(always)]
            fn from(variant: LINEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LINEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LINEN_A {
                match self.bits {
                    false => LINEN_A::Disabled,
                    true => LINEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LINEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LINEN_A::Enabled
            }
        }
        ///Field `LINEN` writer - LIN mode enable
        pub type LINEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, LINEN_A, O>;
        impl<'a, const O: u8> LINEN_W<'a, O> {
            ///LIN mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LINEN_A::Disabled)
            }
            ///LIN mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LINEN_A::Enabled)
            }
        }
        impl R {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            pub fn lbcl(&self) -> LBCL_R {
                LBCL_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            #[must_use]
            pub fn add(&mut self) -> ADD_W<0> {
                ADD_W::new(self)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            #[must_use]
            pub fn lbdl(&mut self) -> LBDL_W<5> {
                LBDL_W::new(self)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn lbdie(&mut self) -> LBDIE_W<6> {
                LBDIE_W::new(self)
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            #[must_use]
            pub fn lbcl(&mut self) -> LBCL_W<8> {
                LBCL_W::new(self)
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            #[must_use]
            pub fn cpha(&mut self) -> CPHA_W<9> {
                CPHA_W::new(self)
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            #[must_use]
            pub fn cpol(&mut self) -> CPOL_W<10> {
                CPOL_W::new(self)
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            #[must_use]
            pub fn clken(&mut self) -> CLKEN_W<11> {
                CLKEN_W::new(self)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<12> {
                STOP_W::new(self)
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            #[must_use]
            pub fn linen(&mut self) -> LINEN_W<14> {
                LINEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR3 (rw) register accessor: an alias for `Reg<CTLR3_SPEC>`
    pub type CTLR3 = crate::Reg<ctlr3::CTLR3_SPEC>;
    ///Control register 3
    pub mod ctlr3 {
        ///Register `CTLR3` reader
        pub struct R(crate::R<CTLR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR3` writer
        pub struct W(crate::W<CTLR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EIE` reader - Error interrupt enable
        pub type EIE_R = crate::BitReader<EIE_A>;
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EIE_A {
            ///0: Error interrupt disabled
            Disabled = 0,
            ///1: Error interrupt enabled
            Enabled = 1,
        }
        impl From<EIE_A> for bool {
            #[inline(always)]
            fn from(variant: EIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EIE_A {
                match self.bits {
                    false => EIE_A::Disabled,
                    true => EIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EIE_A::Enabled
            }
        }
        ///Field `EIE` writer - Error interrupt enable
        pub type EIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, EIE_A, O>;
        impl<'a, const O: u8> EIE_W<'a, O> {
            ///Error interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EIE_A::Disabled)
            }
            ///Error interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EIE_A::Enabled)
            }
        }
        ///Field `IREN` reader - IrDA mode enable
        pub type IREN_R = crate::BitReader<IREN_A>;
        ///IrDA mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IREN_A {
            ///0: IrDA disabled
            Disabled = 0,
            ///1: IrDA enabled
            Enabled = 1,
        }
        impl From<IREN_A> for bool {
            #[inline(always)]
            fn from(variant: IREN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IREN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IREN_A {
                match self.bits {
                    false => IREN_A::Disabled,
                    true => IREN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IREN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IREN_A::Enabled
            }
        }
        ///Field `IREN` writer - IrDA mode enable
        pub type IREN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, IREN_A, O>;
        impl<'a, const O: u8> IREN_W<'a, O> {
            ///IrDA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IREN_A::Disabled)
            }
            ///IrDA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IREN_A::Enabled)
            }
        }
        ///Field `IRLP` reader - IrDA low-power
        pub type IRLP_R = crate::BitReader<IRLP_A>;
        ///IrDA low-power
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IRLP_A {
            ///0: Normal mode
            Normal = 0,
            ///1: Low-power mode
            LowPower = 1,
        }
        impl From<IRLP_A> for bool {
            #[inline(always)]
            fn from(variant: IRLP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IRLP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IRLP_A {
                match self.bits {
                    false => IRLP_A::Normal,
                    true => IRLP_A::LowPower,
                }
            }
            ///Checks if the value of the field is `Normal`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == IRLP_A::Normal
            }
            ///Checks if the value of the field is `LowPower`
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                *self == IRLP_A::LowPower
            }
        }
        ///Field `IRLP` writer - IrDA low-power
        pub type IRLP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, IRLP_A, O>;
        impl<'a, const O: u8> IRLP_W<'a, O> {
            ///Normal mode
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(IRLP_A::Normal)
            }
            ///Low-power mode
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(IRLP_A::LowPower)
            }
        }
        ///Field `HDSEL` reader - Half-duplex selection
        pub type HDSEL_R = crate::BitReader<HDSEL_A>;
        ///Half-duplex selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HDSEL_A {
            ///0: Half duplex mode is not selected
            FullDuplex = 0,
            ///1: Half duplex mode is selected
            HalfDuplex = 1,
        }
        impl From<HDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: HDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HDSEL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HDSEL_A {
                match self.bits {
                    false => HDSEL_A::FullDuplex,
                    true => HDSEL_A::HalfDuplex,
                }
            }
            ///Checks if the value of the field is `FullDuplex`
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                *self == HDSEL_A::FullDuplex
            }
            ///Checks if the value of the field is `HalfDuplex`
            #[inline(always)]
            pub fn is_half_duplex(&self) -> bool {
                *self == HDSEL_A::HalfDuplex
            }
        }
        ///Field `HDSEL` writer - Half-duplex selection
        pub type HDSEL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, HDSEL_A, O>;
        impl<'a, const O: u8> HDSEL_W<'a, O> {
            ///Half duplex mode is not selected
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::FullDuplex)
            }
            ///Half duplex mode is selected
            #[inline(always)]
            pub fn half_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::HalfDuplex)
            }
        }
        ///Field `NACK` reader - Smartcard NACK enable
        pub type NACK_R = crate::BitReader<NACK_A>;
        ///Smartcard NACK enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum NACK_A {
            ///0: NACK transmission in case of parity error is disabled
            Disabled = 0,
            ///1: NACK transmission during parity error is enabled
            Enabled = 1,
        }
        impl From<NACK_A> for bool {
            #[inline(always)]
            fn from(variant: NACK_A) -> Self {
                variant as u8 != 0
            }
        }
        impl NACK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> NACK_A {
                match self.bits {
                    false => NACK_A::Disabled,
                    true => NACK_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NACK_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NACK_A::Enabled
            }
        }
        ///Field `NACK` writer - Smartcard NACK enable
        pub type NACK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, NACK_A, O>;
        impl<'a, const O: u8> NACK_W<'a, O> {
            ///NACK transmission in case of parity error is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NACK_A::Disabled)
            }
            ///NACK transmission during parity error is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NACK_A::Enabled)
            }
        }
        ///Field `SCEN` reader - Smartcard mode enable
        pub type SCEN_R = crate::BitReader<SCEN_A>;
        ///Smartcard mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SCEN_A {
            ///0: Smartcard mode disabled
            Disabled = 0,
            ///1: Smartcard mode enabled
            Enabled = 1,
        }
        impl From<SCEN_A> for bool {
            #[inline(always)]
            fn from(variant: SCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SCEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SCEN_A {
                match self.bits {
                    false => SCEN_A::Disabled,
                    true => SCEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SCEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SCEN_A::Enabled
            }
        }
        ///Field `SCEN` writer - Smartcard mode enable
        pub type SCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, SCEN_A, O>;
        impl<'a, const O: u8> SCEN_W<'a, O> {
            ///Smartcard mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCEN_A::Disabled)
            }
            ///Smartcard mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCEN_A::Enabled)
            }
        }
        ///Field `DMAR` reader - DMA enable receiver
        pub type DMAR_R = crate::BitReader<DMAR_A>;
        ///DMA enable receiver
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMAR_A {
            ///0: DMA mode is disabled for reception
            Disabled = 0,
            ///1: DMA mode is enabled for reception
            Enabled = 1,
        }
        impl From<DMAR_A> for bool {
            #[inline(always)]
            fn from(variant: DMAR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMAR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAR_A {
                match self.bits {
                    false => DMAR_A::Disabled,
                    true => DMAR_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAR_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAR_A::Enabled
            }
        }
        ///Field `DMAR` writer - DMA enable receiver
        pub type DMAR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, DMAR_A, O>;
        impl<'a, const O: u8> DMAR_W<'a, O> {
            ///DMA mode is disabled for reception
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAR_A::Disabled)
            }
            ///DMA mode is enabled for reception
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAR_A::Enabled)
            }
        }
        ///Field `DMAT` reader - DMA enable transmitter
        pub type DMAT_R = crate::BitReader<DMAT_A>;
        ///DMA enable transmitter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMAT_A {
            ///0: DMA mode is disabled for transmission
            Disabled = 0,
            ///1: DMA mode is enabled for transmission
            Enabled = 1,
        }
        impl From<DMAT_A> for bool {
            #[inline(always)]
            fn from(variant: DMAT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMAT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAT_A {
                match self.bits {
                    false => DMAT_A::Disabled,
                    true => DMAT_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAT_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAT_A::Enabled
            }
        }
        ///Field `DMAT` writer - DMA enable transmitter
        pub type DMAT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, DMAT_A, O>;
        impl<'a, const O: u8> DMAT_W<'a, O> {
            ///DMA mode is disabled for transmission
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAT_A::Disabled)
            }
            ///DMA mode is enabled for transmission
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAT_A::Enabled)
            }
        }
        ///Field `RTSE` reader - RTS enable
        pub type RTSE_R = crate::BitReader<RTSE_A>;
        ///RTS enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RTSE_A {
            ///0: RTS hardware flow control disabled
            Disabled = 0,
            ///1: RTS hardware flow control enabled
            Enabled = 1,
        }
        impl From<RTSE_A> for bool {
            #[inline(always)]
            fn from(variant: RTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RTSE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RTSE_A {
                match self.bits {
                    false => RTSE_A::Disabled,
                    true => RTSE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RTSE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RTSE_A::Enabled
            }
        }
        ///Field `RTSE` writer - RTS enable
        pub type RTSE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, RTSE_A, O>;
        impl<'a, const O: u8> RTSE_W<'a, O> {
            ///RTS hardware flow control disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTSE_A::Disabled)
            }
            ///RTS hardware flow control enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTSE_A::Enabled)
            }
        }
        ///Field `CTSE` reader - CTS enable
        pub type CTSE_R = crate::BitReader<CTSE_A>;
        ///CTS enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTSE_A {
            ///0: CTS hardware flow control disabled
            Disabled = 0,
            ///1: CTS hardware flow control enabled
            Enabled = 1,
        }
        impl From<CTSE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTSE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CTSE_A {
                match self.bits {
                    false => CTSE_A::Disabled,
                    true => CTSE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSE_A::Enabled
            }
        }
        ///Field `CTSE` writer - CTS enable
        pub type CTSE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, CTSE_A, O>;
        impl<'a, const O: u8> CTSE_W<'a, O> {
            ///CTS hardware flow control disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSE_A::Disabled)
            }
            ///CTS hardware flow control enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSE_A::Enabled)
            }
        }
        ///Field `CTSIE` reader - CTS interrupt enable
        pub type CTSIE_R = crate::BitReader<CTSIE_A>;
        ///CTS interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTSIE_A {
            ///0: CTS interrupt disabled
            Disabled = 0,
            ///1: CTS interrupt enabled
            Enabled = 1,
        }
        impl From<CTSIE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTSIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CTSIE_A {
                match self.bits {
                    false => CTSIE_A::Disabled,
                    true => CTSIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTSIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTSIE_A::Enabled
            }
        }
        ///Field `CTSIE` writer - CTS interrupt enable
        pub type CTSIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, CTSIE_A, O>;
        impl<'a, const O: u8> CTSIE_W<'a, O> {
            ///CTS interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSIE_A::Disabled)
            }
            ///CTS interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSIE_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            pub fn scen(&self) -> SCEN_R {
                SCEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            pub fn rtse(&self) -> RTSE_R {
                RTSE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            pub fn ctse(&self) -> CTSE_R {
                CTSE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            pub fn ctsie(&self) -> CTSIE_R {
                CTSIE_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn eie(&mut self) -> EIE_W<0> {
                EIE_W::new(self)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            #[must_use]
            pub fn iren(&mut self) -> IREN_W<1> {
                IREN_W::new(self)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            #[must_use]
            pub fn irlp(&mut self) -> IRLP_W<2> {
                IRLP_W::new(self)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            #[must_use]
            pub fn hdsel(&mut self) -> HDSEL_W<3> {
                HDSEL_W::new(self)
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            #[must_use]
            pub fn nack(&mut self) -> NACK_W<4> {
                NACK_W::new(self)
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            #[must_use]
            pub fn scen(&mut self) -> SCEN_W<5> {
                SCEN_W::new(self)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            #[must_use]
            pub fn dmar(&mut self) -> DMAR_W<6> {
                DMAR_W::new(self)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            #[must_use]
            pub fn dmat(&mut self) -> DMAT_W<7> {
                DMAT_W::new(self)
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            #[must_use]
            pub fn rtse(&mut self) -> RTSE_W<8> {
                RTSE_W::new(self)
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            #[must_use]
            pub fn ctse(&mut self) -> CTSE_W<9> {
                CTSE_W::new(self)
            }
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ctsie(&mut self) -> CTSIE_W<10> {
                CTSIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr3](index.html) module
        pub struct CTLR3_SPEC;
        impl crate::RegisterSpec for CTLR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr3::R](R) reader structure
        impl crate::Readable for CTLR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr3::W](W) writer structure
        impl crate::Writable for CTLR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR3 to value 0
        impl crate::Resettable for CTLR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///GPR (rw) register accessor: an alias for `Reg<GPR_SPEC>`
    pub type GPR = crate::Reg<gpr::GPR_SPEC>;
    ///Guard time and prescaler register
    pub mod gpr {
        ///Register `GPR` reader
        pub struct R(crate::R<GPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GPR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `GPR` writer
        pub struct W(crate::W<GPR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<GPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<GPR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<GPR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u8, u8>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, const O: u8> = crate::FieldWriter<'a, u32, GPR_SPEC, u8, u8, 8, O>;
        ///Field `GT` reader - Guard time value
        pub type GT_R = crate::FieldReader<u8, u8>;
        ///Field `GT` writer - Guard time value
        pub type GT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, GPR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            pub fn gt(&self) -> GT_R {
                GT_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<0> {
                PSC_W::new(self)
            }
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            #[must_use]
            pub fn gt(&mut self) -> GT_W<8> {
                GT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Guard time and prescaler register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [gpr](index.html) module
        pub struct GPR_SPEC;
        impl crate::RegisterSpec for GPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [gpr::R](R) reader structure
        impl crate::Readable for GPR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [gpr::W](W) writer structure
        impl crate::Writable for GPR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets GPR to value 0
        impl crate::Resettable for GPR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Universal synchronous asynchronous receiver transmitter
pub struct USART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART2 {}
impl USART2 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4000_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USART2 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART2").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub use self::usart1 as usart2;
///Universal synchronous asynchronous receiver transmitter
pub struct USART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART3 {}
impl USART3 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4000_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USART3 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART3").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub use self::usart1 as usart3;
///Analog to digital converter
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    ///Pointer to the register block
    pub const PTR: *const adc::RegisterBlock = 0x4001_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC").finish()
    }
}
///Analog to digital converter
pub mod adc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - status register
        pub statr: STATR,
        ///0x04 - control register 1
        pub ctlr1: CTLR1,
        ///0x08 - control register 2
        pub ctlr2: CTLR2,
        ///0x0c - sample time register 1
        pub samptr1: SAMPTR1,
        ///0x10 - sample time register 2
        pub samptr2: SAMPTR2,
        ///0x14 - injected channel data offset register x
        pub iofr1: IOFR1,
        ///0x18 - injected channel data offset register x
        pub iofr2: IOFR2,
        ///0x1c - injected channel data offset register x
        pub iofr3: IOFR3,
        ///0x20 - injected channel data offset register x
        pub iofr4: IOFR4,
        ///0x24 - watchdog higher threshold register
        pub wdhtr: WDHTR,
        ///0x28 - watchdog lower threshold register
        pub wdltr: WDLTR,
        ///0x2c - regular sequence register 1
        pub rsqr1: RSQR1,
        ///0x30 - regular sequence register 2
        pub rsqr2: RSQR2,
        ///0x34 - regular sequence register 3
        pub rsqr3: RSQR3,
        ///0x38 - injected sequence register
        pub isqr: ISQR,
        ///0x3c - injected data register x
        pub idatar1: IDATAR1,
        ///0x40 - injected data register x
        pub idatar2: IDATAR2,
        ///0x44 - injected data register x
        pub idatar3: IDATAR3,
        ///0x48 - injected data register x
        pub idatar4: IDATAR4,
        ///0x4c - regular data register
        pub rdatar: RDATAR,
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AWD` reader - Analog watchdog flag
        pub type AWD_R = crate::BitReader<AWDR_A>;
        ///Analog watchdog flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AWDR_A {
            ///0: No analog watch dog event occurred
            NoEvent = 0,
            ///1: Analog watch dog event occurred
            HasEvent = 1,
        }
        impl From<AWDR_A> for bool {
            #[inline(always)]
            fn from(variant: AWDR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl AWD_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AWDR_A {
                match self.bits {
                    false => AWDR_A::NoEvent,
                    true => AWDR_A::HasEvent,
                }
            }
            ///Checks if the value of the field is `NoEvent`
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                *self == AWDR_A::NoEvent
            }
            ///Checks if the value of the field is `HasEvent`
            #[inline(always)]
            pub fn is_has_event(&self) -> bool {
                *self == AWDR_A::HasEvent
            }
        }
        ///Analog watchdog flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AWDW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<AWDW_AW> for bool {
            #[inline(always)]
            fn from(variant: AWDW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AWD` writer - Analog watchdog flag
        pub type AWD_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, STATR_SPEC, AWDW_AW, O>;
        impl<'a, const O: u8> AWD_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(AWDW_AW::Clear)
            }
        }
        ///Field `EOC` reader - Regular channel end of conversion
        pub type EOC_R = crate::BitReader<EOCR_A>;
        ///Regular channel end of conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EOCR_A {
            ///0: Conversion in progress
            InProgress = 0,
            ///1: Conversion completed
            Completed = 1,
        }
        impl From<EOCR_A> for bool {
            #[inline(always)]
            fn from(variant: EOCR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EOC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EOCR_A {
                match self.bits {
                    false => EOCR_A::InProgress,
                    true => EOCR_A::Completed,
                }
            }
            ///Checks if the value of the field is `InProgress`
            #[inline(always)]
            pub fn is_in_progress(&self) -> bool {
                *self == EOCR_A::InProgress
            }
            ///Checks if the value of the field is `Completed`
            #[inline(always)]
            pub fn is_completed(&self) -> bool {
                *self == EOCR_A::Completed
            }
        }
        ///Regular channel end of conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EOCW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<EOCW_AW> for bool {
            #[inline(always)]
            fn from(variant: EOCW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EOC` writer - Regular channel end of conversion
        pub type EOC_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, STATR_SPEC, EOCW_AW, O>;
        impl<'a, const O: u8> EOC_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOCW_AW::Clear)
            }
        }
        ///Field `IEOC` reader - Injected channel end of conversion
        pub use EOC_R as IEOC_R;
        ///Field `IEOC` writer - Injected channel end of conversion
        pub use EOC_W as IEOC_W;
        ///Field `ISTRT` reader - Injected channel start flag
        pub type ISTRT_R = crate::BitReader<ISTRTR_A>;
        ///Injected channel start flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ISTRTR_A {
            ///0: Conversion not started
            Idle = 0,
            ///1: Conversion started
            Started = 1,
        }
        impl From<ISTRTR_A> for bool {
            #[inline(always)]
            fn from(variant: ISTRTR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ISTRT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ISTRTR_A {
                match self.bits {
                    false => ISTRTR_A::Idle,
                    true => ISTRTR_A::Started,
                }
            }
            ///Checks if the value of the field is `Idle`
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == ISTRTR_A::Idle
            }
            ///Checks if the value of the field is `Started`
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                *self == ISTRTR_A::Started
            }
        }
        ///Injected channel start flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ISTRTW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<ISTRTW_AW> for bool {
            #[inline(always)]
            fn from(variant: ISTRTW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ISTRT` writer - Injected channel start flag
        pub type ISTRT_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, STATR_SPEC, ISTRTW_AW, O>;
        impl<'a, const O: u8> ISTRT_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ISTRTW_AW::Clear)
            }
        }
        ///Field `RSTRT` reader - Regular channel start flag
        pub use ISTRT_R as RSTRT_R;
        ///Field `RSTRT` writer - Regular channel start flag
        pub use ISTRT_W as RSTRT_W;
        impl R {
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            pub fn awd(&self) -> AWD_R {
                AWD_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            pub fn ieoc(&self) -> IEOC_R {
                IEOC_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            pub fn istrt(&self) -> ISTRT_R {
                ISTRT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            pub fn rstrt(&self) -> RSTRT_R {
                RSTRT_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            #[must_use]
            pub fn awd(&mut self) -> AWD_W<0> {
                AWD_W::new(self)
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            #[must_use]
            pub fn eoc(&mut self) -> EOC_W<1> {
                EOC_W::new(self)
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            #[must_use]
            pub fn ieoc(&mut self) -> IEOC_W<2> {
                IEOC_W::new(self)
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            #[must_use]
            pub fn istrt(&mut self) -> ISTRT_W<3> {
                ISTRT_W::new(self)
            }
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            #[must_use]
            pub fn rstrt(&mut self) -> RSTRT_W<4> {
                RSTRT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x1f;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AWDCH` reader - Analog watchdog channel select bits
        pub type AWDCH_R = crate::FieldReader<u8, u8>;
        ///Field `AWDCH` writer - Analog watchdog channel select bits
        pub type AWDCH_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 5, O>;
        ///Field `EOCIE` reader - Interrupt enable for EOC
        pub type EOCIE_R = crate::BitReader<EOCIE_A>;
        ///Interrupt enable for EOC
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EOCIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<EOCIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EOCIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EOCIE_A {
                match self.bits {
                    false => EOCIE_A::Disabled,
                    true => EOCIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EOCIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EOCIE_A::Enabled
            }
        }
        ///Field `EOCIE` writer - Interrupt enable for EOC
        pub type EOCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, EOCIE_A, O>;
        impl<'a, const O: u8> EOCIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOCIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOCIE_A::Enabled)
            }
        }
        ///Field `AWDIE` reader - Analog watchdog interrupt enable
        pub use EOCIE_R as AWDIE_R;
        ///Field `IEOCIE` reader - Interrupt enable for injected channels
        pub use EOCIE_R as IEOCIE_R;
        ///Field `AWDIE` writer - Analog watchdog interrupt enable
        pub use EOCIE_W as AWDIE_W;
        ///Field `IEOCIE` writer - Interrupt enable for injected channels
        pub use EOCIE_W as IEOCIE_W;
        ///Field `SCAN` reader - Scan mode
        pub type SCAN_R = crate::BitReader<SCAN_A>;
        ///Scan mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SCAN_A {
            ///0: Scan mode disabled
            Disabled = 0,
            ///1: Scan mode enabled
            Enabled = 1,
        }
        impl From<SCAN_A> for bool {
            #[inline(always)]
            fn from(variant: SCAN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SCAN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SCAN_A {
                match self.bits {
                    false => SCAN_A::Disabled,
                    true => SCAN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SCAN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SCAN_A::Enabled
            }
        }
        ///Field `SCAN` writer - Scan mode
        pub type SCAN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, SCAN_A, O>;
        impl<'a, const O: u8> SCAN_W<'a, O> {
            ///Scan mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCAN_A::Disabled)
            }
            ///Scan mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCAN_A::Enabled)
            }
        }
        ///Field `AWDSGL` reader - Enable the watchdog on a single channel in scan mode
        pub type AWDSGL_R = crate::BitReader<AWDSGL_A>;
        ///Enable the watchdog on a single channel in scan mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum AWDSGL_A {
            ///0: AWDG enabled on all channel in scan mode
            All = 0,
            ///1: AWDG enabled on specific channel in scan mode
            Specific = 1,
        }
        impl From<AWDSGL_A> for bool {
            #[inline(always)]
            fn from(variant: AWDSGL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl AWDSGL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AWDSGL_A {
                match self.bits {
                    false => AWDSGL_A::All,
                    true => AWDSGL_A::Specific,
                }
            }
            ///Checks if the value of the field is `All`
            #[inline(always)]
            pub fn is_all(&self) -> bool {
                *self == AWDSGL_A::All
            }
            ///Checks if the value of the field is `Specific`
            #[inline(always)]
            pub fn is_specific(&self) -> bool {
                *self == AWDSGL_A::Specific
            }
        }
        ///Field `AWDSGL` writer - Enable the watchdog on a single channel in scan mode
        pub type AWDSGL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, AWDSGL_A, O>;
        impl<'a, const O: u8> AWDSGL_W<'a, O> {
            ///AWDG enabled on all channel in scan mode
            #[inline(always)]
            pub fn all(self) -> &'a mut W {
                self.variant(AWDSGL_A::All)
            }
            ///AWDG enabled on specific channel in scan mode
            #[inline(always)]
            pub fn specific(self) -> &'a mut W {
                self.variant(AWDSGL_A::Specific)
            }
        }
        ///Field `IAUTO` reader - Automatic injected group conversion
        pub type IAUTO_R = crate::BitReader<IAUTO_A>;
        ///Automatic injected group conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IAUTO_A {
            ///0: Auto injection disabled
            Disabled = 0,
            ///1: Auto injection enabled
            Enabled = 1,
        }
        impl From<IAUTO_A> for bool {
            #[inline(always)]
            fn from(variant: IAUTO_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IAUTO_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IAUTO_A {
                match self.bits {
                    false => IAUTO_A::Disabled,
                    true => IAUTO_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IAUTO_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IAUTO_A::Enabled
            }
        }
        ///Field `IAUTO` writer - Automatic injected group conversion
        pub type IAUTO_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, IAUTO_A, O>;
        impl<'a, const O: u8> IAUTO_W<'a, O> {
            ///Auto injection disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IAUTO_A::Disabled)
            }
            ///Auto injection enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IAUTO_A::Enabled)
            }
        }
        ///Field `DISCEN` reader - Discontinuous mode on regular channels
        pub type DISCEN_R = crate::BitReader<bool>;
        ///Field `DISCEN` writer - Discontinuous mode on regular channels
        pub type DISCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `IDISCEN` reader - Discontinuous mode on injected channels
        pub type IDISCEN_R = crate::BitReader<IDISCEN_A>;
        ///Discontinuous mode on injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IDISCEN_A {
            ///0: Discontinuous mode disabled
            Disabled = 0,
            ///1: Discontinuous mode enabled
            Enabled = 1,
        }
        impl From<IDISCEN_A> for bool {
            #[inline(always)]
            fn from(variant: IDISCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IDISCEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IDISCEN_A {
                match self.bits {
                    false => IDISCEN_A::Disabled,
                    true => IDISCEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IDISCEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IDISCEN_A::Enabled
            }
        }
        ///Field `IDISCEN` writer - Discontinuous mode on injected channels
        pub type IDISCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, IDISCEN_A, O>;
        impl<'a, const O: u8> IDISCEN_W<'a, O> {
            ///Discontinuous mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDISCEN_A::Disabled)
            }
            ///Discontinuous mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDISCEN_A::Enabled)
            }
        }
        ///Field `DISCNUM` reader - Discontinuous mode channel count
        pub type DISCNUM_R = crate::FieldReader<u8, u8>;
        ///Field `DISCNUM` writer - Discontinuous mode channel count
        pub type DISCNUM_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 3, O>;
        ///Field `IAWDEN` reader - Analog watchdog enable on injected channels
        pub type IAWDEN_R = crate::BitReader<IAWDEN_A>;
        ///Analog watchdog enable on injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IAWDEN_A {
            ///0: Analog watch dog disabled
            Disabled = 0,
            ///1: Analog watch dog enabled
            Enabled = 1,
        }
        impl From<IAWDEN_A> for bool {
            #[inline(always)]
            fn from(variant: IAWDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IAWDEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IAWDEN_A {
                match self.bits {
                    false => IAWDEN_A::Disabled,
                    true => IAWDEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IAWDEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IAWDEN_A::Enabled
            }
        }
        ///Field `IAWDEN` writer - Analog watchdog enable on injected channels
        pub type IAWDEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, IAWDEN_A, O>;
        impl<'a, const O: u8> IAWDEN_W<'a, O> {
            ///Analog watch dog disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IAWDEN_A::Disabled)
            }
            ///Analog watch dog enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IAWDEN_A::Enabled)
            }
        }
        ///Field `AWDEN` reader - Analog watchdog enable on regular channels
        pub type AWDEN_R = crate::BitReader<bool>;
        ///Field `AWDEN` writer - Analog watchdog enable on regular channels
        pub type AWDEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `TKENABLE` reader - Touch key enable, including TKEY_F and TKEY_V
        pub type TKENABLE_R = crate::BitReader<TKENABLE_A>;
        ///Touch key enable, including TKEY_F and TKEY_V
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TKENABLE_A {
            ///0: TKEY module disabled
            Disabled = 0,
            ///1: TKEY module enabled
            Enabled = 1,
        }
        impl From<TKENABLE_A> for bool {
            #[inline(always)]
            fn from(variant: TKENABLE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TKENABLE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKENABLE_A {
                match self.bits {
                    false => TKENABLE_A::Disabled,
                    true => TKENABLE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TKENABLE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TKENABLE_A::Enabled
            }
        }
        ///Field `TKENABLE` writer - Touch key enable, including TKEY_F and TKEY_V
        pub type TKENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, TKENABLE_A, O>;
        impl<'a, const O: u8> TKENABLE_W<'a, O> {
            ///TKEY module disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TKENABLE_A::Disabled)
            }
            ///TKEY module enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TKENABLE_A::Enabled)
            }
        }
        impl R {
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            pub fn awdch(&self) -> AWDCH_R {
                AWDCH_R::new((self.bits & 0x1f) as u8)
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            pub fn eocie(&self) -> EOCIE_R {
                EOCIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            pub fn awdie(&self) -> AWDIE_R {
                AWDIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            pub fn ieocie(&self) -> IEOCIE_R {
                IEOCIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Scan mode
            #[inline(always)]
            pub fn scan(&self) -> SCAN_R {
                SCAN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            pub fn awdsgl(&self) -> AWDSGL_R {
                AWDSGL_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            pub fn iauto(&self) -> IAUTO_R {
                IAUTO_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            pub fn discen(&self) -> DISCEN_R {
                DISCEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            pub fn idiscen(&self) -> IDISCEN_R {
                IDISCEN_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            pub fn discnum(&self) -> DISCNUM_R {
                DISCNUM_R::new(((self.bits >> 13) & 7) as u8)
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            pub fn iawden(&self) -> IAWDEN_R {
                IAWDEN_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            pub fn awden(&self) -> AWDEN_R {
                AWDEN_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Touch key enable, including TKEY_F and TKEY_V
            #[inline(always)]
            pub fn tkenable(&self) -> TKENABLE_R {
                TKENABLE_R::new(((self.bits >> 24) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            #[must_use]
            pub fn awdch(&mut self) -> AWDCH_W<0> {
                AWDCH_W::new(self)
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            #[must_use]
            pub fn eocie(&mut self) -> EOCIE_W<5> {
                EOCIE_W::new(self)
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn awdie(&mut self) -> AWDIE_W<6> {
                AWDIE_W::new(self)
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            #[must_use]
            pub fn ieocie(&mut self) -> IEOCIE_W<7> {
                IEOCIE_W::new(self)
            }
            ///Bit 8 - Scan mode
            #[inline(always)]
            #[must_use]
            pub fn scan(&mut self) -> SCAN_W<8> {
                SCAN_W::new(self)
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            #[must_use]
            pub fn awdsgl(&mut self) -> AWDSGL_W<9> {
                AWDSGL_W::new(self)
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            #[must_use]
            pub fn iauto(&mut self) -> IAUTO_W<10> {
                IAUTO_W::new(self)
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            #[must_use]
            pub fn discen(&mut self) -> DISCEN_W<11> {
                DISCEN_W::new(self)
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            #[must_use]
            pub fn idiscen(&mut self) -> IDISCEN_W<12> {
                IDISCEN_W::new(self)
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            #[must_use]
            pub fn discnum(&mut self) -> DISCNUM_W<13> {
                DISCNUM_W::new(self)
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            #[must_use]
            pub fn iawden(&mut self) -> IAWDEN_W<22> {
                IAWDEN_W::new(self)
            }
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            #[must_use]
            pub fn awden(&mut self) -> AWDEN_W<23> {
                AWDEN_W::new(self)
            }
            ///Bit 24 - Touch key enable, including TKEY_F and TKEY_V
            #[inline(always)]
            #[must_use]
            pub fn tkenable(&mut self) -> TKENABLE_W<24> {
                TKENABLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADON` reader - A/D converter ON / OFF
        pub type ADON_R = crate::BitReader<ADON_A>;
        ///A/D converter ON / OFF
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ADON_A {
            ///0: ADC disabled
            Disabled = 0,
            ///1: ADC enabled and proceed conversion
            Enabled = 1,
        }
        impl From<ADON_A> for bool {
            #[inline(always)]
            fn from(variant: ADON_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ADON_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADON_A {
                match self.bits {
                    false => ADON_A::Disabled,
                    true => ADON_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ADON_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ADON_A::Enabled
            }
        }
        ///Field `ADON` writer - A/D converter ON / OFF
        pub type ADON_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, ADON_A, O>;
        impl<'a, const O: u8> ADON_W<'a, O> {
            ///ADC disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADON_A::Disabled)
            }
            ///ADC enabled and proceed conversion
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADON_A::Enabled)
            }
        }
        ///Field `CONT` reader - Continuous conversion
        pub type CONT_R = crate::BitReader<CONT_A>;
        ///Continuous conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CONT_A {
            ///0: Continuous conversion disabled
            Disabled = 0,
            ///1: Continuous conversion enabled
            Enabled = 1,
        }
        impl From<CONT_A> for bool {
            #[inline(always)]
            fn from(variant: CONT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CONT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CONT_A {
                match self.bits {
                    false => CONT_A::Disabled,
                    true => CONT_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CONT_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CONT_A::Enabled
            }
        }
        ///Field `CONT` writer - Continuous conversion
        pub type CONT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, CONT_A, O>;
        impl<'a, const O: u8> CONT_W<'a, O> {
            ///Continuous conversion disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CONT_A::Disabled)
            }
            ///Continuous conversion enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CONT_A::Enabled)
            }
        }
        ///Field `CAL` reader - A/D calibration
        pub type CAL_R = crate::BitReader<CALR_A>;
        ///A/D calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CALR_A {
            ///0: Calibration done
            Done = 0,
            ///1: Calibration in progress
            Calibrating = 1,
        }
        impl From<CALR_A> for bool {
            #[inline(always)]
            fn from(variant: CALR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CAL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CALR_A {
                match self.bits {
                    false => CALR_A::Done,
                    true => CALR_A::Calibrating,
                }
            }
            ///Checks if the value of the field is `Done`
            #[inline(always)]
            pub fn is_done(&self) -> bool {
                *self == CALR_A::Done
            }
            ///Checks if the value of the field is `Calibrating`
            #[inline(always)]
            pub fn is_calibrating(&self) -> bool {
                *self == CALR_A::Calibrating
            }
        }
        ///A/D calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CALW_AW {
            ///1: Start calibration
            Calibrate = 1,
        }
        impl From<CALW_AW> for bool {
            #[inline(always)]
            fn from(variant: CALW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CAL` writer - A/D calibration
        pub type CAL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, CALW_AW, O>;
        impl<'a, const O: u8> CAL_W<'a, O> {
            ///Start calibration
            #[inline(always)]
            pub fn calibrate(self) -> &'a mut W {
                self.variant(CALW_AW::Calibrate)
            }
        }
        ///Field `RSTCAL` reader - Reset calibration
        pub type RSTCAL_R = crate::BitReader<RSTCALR_A>;
        ///Reset calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RSTCALR_A {
            ///0: Reset done
            Done = 0,
            ///1: Reset in progress
            Resetting = 1,
        }
        impl From<RSTCALR_A> for bool {
            #[inline(always)]
            fn from(variant: RSTCALR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RSTCAL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RSTCALR_A {
                match self.bits {
                    false => RSTCALR_A::Done,
                    true => RSTCALR_A::Resetting,
                }
            }
            ///Checks if the value of the field is `Done`
            #[inline(always)]
            pub fn is_done(&self) -> bool {
                *self == RSTCALR_A::Done
            }
            ///Checks if the value of the field is `Resetting`
            #[inline(always)]
            pub fn is_resetting(&self) -> bool {
                *self == RSTCALR_A::Resetting
            }
        }
        ///Reset calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RSTCALW_AW {
            ///1: Reset calibration
            Reset = 1,
        }
        impl From<RSTCALW_AW> for bool {
            #[inline(always)]
            fn from(variant: RSTCALW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RSTCAL` writer - Reset calibration
        pub type RSTCAL_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, CTLR2_SPEC, RSTCALW_AW, O>;
        impl<'a, const O: u8> RSTCAL_W<'a, O> {
            ///Reset calibration
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RSTCALW_AW::Reset)
            }
        }
        ///Field `DMA` reader - Direct memory access mode
        pub type DMA_R = crate::BitReader<DMA_A>;
        ///Direct memory access mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMA_A {
            ///0: DMA mode disabled
            Disabled = 0,
            ///1: DMA mode enabled
            Enabled = 1,
        }
        impl From<DMA_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMA_A {
                match self.bits {
                    false => DMA_A::Disabled,
                    true => DMA_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMA_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMA_A::Enabled
            }
        }
        ///Field `DMA` writer - Direct memory access mode
        pub type DMA_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, DMA_A, O>;
        impl<'a, const O: u8> DMA_W<'a, O> {
            ///DMA mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA_A::Disabled)
            }
            ///DMA mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA_A::Enabled)
            }
        }
        ///Field `ALIGN` reader - Data alignment
        pub type ALIGN_R = crate::BitReader<ALIGN_A>;
        ///Data alignment
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ALIGN_A {
            ///0: Right alignment
            Right = 0,
            ///1: Left alignment
            Left = 1,
        }
        impl From<ALIGN_A> for bool {
            #[inline(always)]
            fn from(variant: ALIGN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ALIGN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ALIGN_A {
                match self.bits {
                    false => ALIGN_A::Right,
                    true => ALIGN_A::Left,
                }
            }
            ///Checks if the value of the field is `Right`
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                *self == ALIGN_A::Right
            }
            ///Checks if the value of the field is `Left`
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                *self == ALIGN_A::Left
            }
        }
        ///Field `ALIGN` writer - Data alignment
        pub type ALIGN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, ALIGN_A, O>;
        impl<'a, const O: u8> ALIGN_W<'a, O> {
            ///Right alignment
            #[inline(always)]
            pub fn right(self) -> &'a mut W {
                self.variant(ALIGN_A::Right)
            }
            ///Left alignment
            #[inline(always)]
            pub fn left(self) -> &'a mut W {
                self.variant(ALIGN_A::Left)
            }
        }
        ///Field `IEXTSEL` reader - External event select for injected group
        pub type IEXTSEL_R = crate::FieldReader<u8, IEXTSEL_A>;
        ///External event select for injected group
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IEXTSEL_A {
            ///0: TIM1 TRG0 event
            Tim1trg0 = 0,
            ///1: TIM1 CC4 event
            Tim1cc4 = 1,
            ///2: TIM2 TRG0 event
            Tim2trg0 = 2,
            ///3: TIM2 CC1 event
            Tim2cc1 = 3,
            ///4: TIM3 CC4 event
            Tim3cc4 = 4,
            ///5: TIM4 TRG0 event
            Tim4trg0 = 5,
            ///6: EXTI line 15
            Exti15 = 6,
            ///7: Software trigger
            Iswstart = 7,
        }
        impl From<IEXTSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: IEXTSEL_A) -> Self {
                variant as _
            }
        }
        impl IEXTSEL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IEXTSEL_A {
                match self.bits {
                    0 => IEXTSEL_A::Tim1trg0,
                    1 => IEXTSEL_A::Tim1cc4,
                    2 => IEXTSEL_A::Tim2trg0,
                    3 => IEXTSEL_A::Tim2cc1,
                    4 => IEXTSEL_A::Tim3cc4,
                    5 => IEXTSEL_A::Tim4trg0,
                    6 => IEXTSEL_A::Exti15,
                    7 => IEXTSEL_A::Iswstart,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Tim1trg0`
            #[inline(always)]
            pub fn is_tim1trg0(&self) -> bool {
                *self == IEXTSEL_A::Tim1trg0
            }
            ///Checks if the value of the field is `Tim1cc4`
            #[inline(always)]
            pub fn is_tim1cc4(&self) -> bool {
                *self == IEXTSEL_A::Tim1cc4
            }
            ///Checks if the value of the field is `Tim2trg0`
            #[inline(always)]
            pub fn is_tim2trg0(&self) -> bool {
                *self == IEXTSEL_A::Tim2trg0
            }
            ///Checks if the value of the field is `Tim2cc1`
            #[inline(always)]
            pub fn is_tim2cc1(&self) -> bool {
                *self == IEXTSEL_A::Tim2cc1
            }
            ///Checks if the value of the field is `Tim3cc4`
            #[inline(always)]
            pub fn is_tim3cc4(&self) -> bool {
                *self == IEXTSEL_A::Tim3cc4
            }
            ///Checks if the value of the field is `Tim4trg0`
            #[inline(always)]
            pub fn is_tim4trg0(&self) -> bool {
                *self == IEXTSEL_A::Tim4trg0
            }
            ///Checks if the value of the field is `Exti15`
            #[inline(always)]
            pub fn is_exti15(&self) -> bool {
                *self == IEXTSEL_A::Exti15
            }
            ///Checks if the value of the field is `Iswstart`
            #[inline(always)]
            pub fn is_iswstart(&self) -> bool {
                *self == IEXTSEL_A::Iswstart
            }
        }
        ///Field `IEXTSEL` writer - External event select for injected group
        pub type IEXTSEL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CTLR2_SPEC, u8, IEXTSEL_A, 3, O>;
        impl<'a, const O: u8> IEXTSEL_W<'a, O> {
            ///TIM1 TRG0 event
            #[inline(always)]
            pub fn tim1trg0(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Tim1trg0)
            }
            ///TIM1 CC4 event
            #[inline(always)]
            pub fn tim1cc4(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Tim1cc4)
            }
            ///TIM2 TRG0 event
            #[inline(always)]
            pub fn tim2trg0(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Tim2trg0)
            }
            ///TIM2 CC1 event
            #[inline(always)]
            pub fn tim2cc1(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Tim2cc1)
            }
            ///TIM3 CC4 event
            #[inline(always)]
            pub fn tim3cc4(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Tim3cc4)
            }
            ///TIM4 TRG0 event
            #[inline(always)]
            pub fn tim4trg0(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Tim4trg0)
            }
            ///EXTI line 15
            #[inline(always)]
            pub fn exti15(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Exti15)
            }
            ///Software trigger
            #[inline(always)]
            pub fn iswstart(self) -> &'a mut W {
                self.variant(IEXTSEL_A::Iswstart)
            }
        }
        ///Field `IEXTTRIG` reader - External trigger conversion mode for injected channels
        pub type IEXTTRIG_R = crate::BitReader<IEXTTRIG_A>;
        ///External trigger conversion mode for injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum IEXTTRIG_A {
            ///0: External event trigger disabled
            Disabled = 0,
            ///1: External event trigger enabled
            Enabled = 1,
        }
        impl From<IEXTTRIG_A> for bool {
            #[inline(always)]
            fn from(variant: IEXTTRIG_A) -> Self {
                variant as u8 != 0
            }
        }
        impl IEXTTRIG_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IEXTTRIG_A {
                match self.bits {
                    false => IEXTTRIG_A::Disabled,
                    true => IEXTTRIG_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == IEXTTRIG_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == IEXTTRIG_A::Enabled
            }
        }
        ///Field `IEXTTRIG` writer - External trigger conversion mode for injected channels
        pub type IEXTTRIG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, IEXTTRIG_A, O>;
        impl<'a, const O: u8> IEXTTRIG_W<'a, O> {
            ///External event trigger disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IEXTTRIG_A::Disabled)
            }
            ///External event trigger enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IEXTTRIG_A::Enabled)
            }
        }
        ///Field `REXTSEL` reader - External event select for regular group
        pub type REXTSEL_R = crate::FieldReader<u8, REXTSEL_A>;
        ///External event select for regular group
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum REXTSEL_A {
            ///0: TIM1 CC1 event
            Tim1cc1 = 0,
            ///1: TIM1 CC2 event
            Tim1cc2 = 1,
            ///2: TIM1 CC4 event
            Tim1cc3 = 2,
            ///3: TIM2 CC2 event
            Tim2cc2 = 3,
            ///4: TIM3 TRG0 event
            Tim3trg0 = 4,
            ///5: TIM4 CC4 event
            Tim4cc4 = 5,
            ///6: EXTI line 11
            Exti11 = 6,
            ///7: Software trigger
            Rswstart = 7,
        }
        impl From<REXTSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: REXTSEL_A) -> Self {
                variant as _
            }
        }
        impl REXTSEL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> REXTSEL_A {
                match self.bits {
                    0 => REXTSEL_A::Tim1cc1,
                    1 => REXTSEL_A::Tim1cc2,
                    2 => REXTSEL_A::Tim1cc3,
                    3 => REXTSEL_A::Tim2cc2,
                    4 => REXTSEL_A::Tim3trg0,
                    5 => REXTSEL_A::Tim4cc4,
                    6 => REXTSEL_A::Exti11,
                    7 => REXTSEL_A::Rswstart,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Tim1cc1`
            #[inline(always)]
            pub fn is_tim1cc1(&self) -> bool {
                *self == REXTSEL_A::Tim1cc1
            }
            ///Checks if the value of the field is `Tim1cc2`
            #[inline(always)]
            pub fn is_tim1cc2(&self) -> bool {
                *self == REXTSEL_A::Tim1cc2
            }
            ///Checks if the value of the field is `Tim1cc3`
            #[inline(always)]
            pub fn is_tim1cc3(&self) -> bool {
                *self == REXTSEL_A::Tim1cc3
            }
            ///Checks if the value of the field is `Tim2cc2`
            #[inline(always)]
            pub fn is_tim2cc2(&self) -> bool {
                *self == REXTSEL_A::Tim2cc2
            }
            ///Checks if the value of the field is `Tim3trg0`
            #[inline(always)]
            pub fn is_tim3trg0(&self) -> bool {
                *self == REXTSEL_A::Tim3trg0
            }
            ///Checks if the value of the field is `Tim4cc4`
            #[inline(always)]
            pub fn is_tim4cc4(&self) -> bool {
                *self == REXTSEL_A::Tim4cc4
            }
            ///Checks if the value of the field is `Exti11`
            #[inline(always)]
            pub fn is_exti11(&self) -> bool {
                *self == REXTSEL_A::Exti11
            }
            ///Checks if the value of the field is `Rswstart`
            #[inline(always)]
            pub fn is_rswstart(&self) -> bool {
                *self == REXTSEL_A::Rswstart
            }
        }
        ///Field `REXTSEL` writer - External event select for regular group
        pub type REXTSEL_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, CTLR2_SPEC, u8, REXTSEL_A, 3, O>;
        impl<'a, const O: u8> REXTSEL_W<'a, O> {
            ///TIM1 CC1 event
            #[inline(always)]
            pub fn tim1cc1(self) -> &'a mut W {
                self.variant(REXTSEL_A::Tim1cc1)
            }
            ///TIM1 CC2 event
            #[inline(always)]
            pub fn tim1cc2(self) -> &'a mut W {
                self.variant(REXTSEL_A::Tim1cc2)
            }
            ///TIM1 CC4 event
            #[inline(always)]
            pub fn tim1cc3(self) -> &'a mut W {
                self.variant(REXTSEL_A::Tim1cc3)
            }
            ///TIM2 CC2 event
            #[inline(always)]
            pub fn tim2cc2(self) -> &'a mut W {
                self.variant(REXTSEL_A::Tim2cc2)
            }
            ///TIM3 TRG0 event
            #[inline(always)]
            pub fn tim3trg0(self) -> &'a mut W {
                self.variant(REXTSEL_A::Tim3trg0)
            }
            ///TIM4 CC4 event
            #[inline(always)]
            pub fn tim4cc4(self) -> &'a mut W {
                self.variant(REXTSEL_A::Tim4cc4)
            }
            ///EXTI line 11
            #[inline(always)]
            pub fn exti11(self) -> &'a mut W {
                self.variant(REXTSEL_A::Exti11)
            }
            ///Software trigger
            #[inline(always)]
            pub fn rswstart(self) -> &'a mut W {
                self.variant(REXTSEL_A::Rswstart)
            }
        }
        ///Field `REXTTRIG` reader - External trigger conversion mode for regular channels
        pub type REXTTRIG_R = crate::BitReader<REXTTRIG_A>;
        ///External trigger conversion mode for regular channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum REXTTRIG_A {
            ///0: External event trigger disabled
            Disabled = 0,
            ///1: External event trigger enabled
            Enabled = 1,
        }
        impl From<REXTTRIG_A> for bool {
            #[inline(always)]
            fn from(variant: REXTTRIG_A) -> Self {
                variant as u8 != 0
            }
        }
        impl REXTTRIG_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> REXTTRIG_A {
                match self.bits {
                    false => REXTTRIG_A::Disabled,
                    true => REXTTRIG_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == REXTTRIG_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == REXTTRIG_A::Enabled
            }
        }
        ///Field `REXTTRIG` writer - External trigger conversion mode for regular channels
        pub type REXTTRIG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, REXTTRIG_A, O>;
        impl<'a, const O: u8> REXTTRIG_W<'a, O> {
            ///External event trigger disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(REXTTRIG_A::Disabled)
            }
            ///External event trigger enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(REXTTRIG_A::Enabled)
            }
        }
        ///Field `ISWSTART` reader - Start conversion of injected channels
        pub type ISWSTART_R = crate::BitReader<ISWSTART_A>;
        ///Start conversion of injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ISWSTART_A {
            ///0: Reset state
            Reset = 0,
            ///1: Start conversion
            Start = 1,
        }
        impl From<ISWSTART_A> for bool {
            #[inline(always)]
            fn from(variant: ISWSTART_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ISWSTART_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ISWSTART_A {
                match self.bits {
                    false => ISWSTART_A::Reset,
                    true => ISWSTART_A::Start,
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == ISWSTART_A::Reset
            }
            ///Checks if the value of the field is `Start`
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == ISWSTART_A::Start
            }
        }
        ///Field `ISWSTART` writer - Start conversion of injected channels
        pub type ISWSTART_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, ISWSTART_A, O>;
        impl<'a, const O: u8> ISWSTART_W<'a, O> {
            ///Reset state
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(ISWSTART_A::Reset)
            }
            ///Start conversion
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(ISWSTART_A::Start)
            }
        }
        ///Field `RSWSTART` reader - Start conversion of regular channels
        pub use ISWSTART_R as RSWSTART_R;
        ///Field `RSWSTART` writer - Start conversion of regular channels
        pub use ISWSTART_W as RSWSTART_W;
        ///Field `TSVREFE` reader - Temperature sensor and VREFINT enable
        pub type TSVREFE_R = crate::BitReader<TSVREFE_A>;
        ///Temperature sensor and VREFINT enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TSVREFE_A {
            ///0: Temperature and internal voltage channel disabled
            Disabled = 0,
            ///1: Temperature and internal voltage channel enabled
            Enabled = 1,
        }
        impl From<TSVREFE_A> for bool {
            #[inline(always)]
            fn from(variant: TSVREFE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TSVREFE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TSVREFE_A {
                match self.bits {
                    false => TSVREFE_A::Disabled,
                    true => TSVREFE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TSVREFE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TSVREFE_A::Enabled
            }
        }
        ///Field `TSVREFE` writer - Temperature sensor and VREFINT enable
        pub type TSVREFE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, TSVREFE_A, O>;
        impl<'a, const O: u8> TSVREFE_W<'a, O> {
            ///Temperature and internal voltage channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TSVREFE_A::Disabled)
            }
            ///Temperature and internal voltage channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TSVREFE_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            pub fn adon(&self) -> ADON_R {
                ADON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            pub fn cont(&self) -> CONT_R {
                CONT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            pub fn rstcal(&self) -> RSTCAL_R {
                RSTCAL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            pub fn dma(&self) -> DMA_R {
                DMA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            pub fn align(&self) -> ALIGN_R {
                ALIGN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            pub fn iextsel(&self) -> IEXTSEL_R {
                IEXTSEL_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            pub fn iexttrig(&self) -> IEXTTRIG_R {
                IEXTTRIG_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            pub fn rextsel(&self) -> REXTSEL_R {
                REXTSEL_R::new(((self.bits >> 17) & 7) as u8)
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            pub fn rexttrig(&self) -> REXTTRIG_R {
                REXTTRIG_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            pub fn iswstart(&self) -> ISWSTART_R {
                ISWSTART_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            pub fn rswstart(&self) -> RSWSTART_R {
                RSWSTART_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Temperature sensor and VREFINT enable
            #[inline(always)]
            pub fn tsvrefe(&self) -> TSVREFE_R {
                TSVREFE_R::new(((self.bits >> 23) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            #[must_use]
            pub fn adon(&mut self) -> ADON_W<0> {
                ADON_W::new(self)
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            #[must_use]
            pub fn cont(&mut self) -> CONT_W<1> {
                CONT_W::new(self)
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            #[must_use]
            pub fn cal(&mut self) -> CAL_W<2> {
                CAL_W::new(self)
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            #[must_use]
            pub fn rstcal(&mut self) -> RSTCAL_W<3> {
                RSTCAL_W::new(self)
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            #[must_use]
            pub fn dma(&mut self) -> DMA_W<8> {
                DMA_W::new(self)
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            #[must_use]
            pub fn align(&mut self) -> ALIGN_W<11> {
                ALIGN_W::new(self)
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            #[must_use]
            pub fn iextsel(&mut self) -> IEXTSEL_W<12> {
                IEXTSEL_W::new(self)
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            #[must_use]
            pub fn iexttrig(&mut self) -> IEXTTRIG_W<15> {
                IEXTTRIG_W::new(self)
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            #[must_use]
            pub fn rextsel(&mut self) -> REXTSEL_W<17> {
                REXTSEL_W::new(self)
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            #[must_use]
            pub fn rexttrig(&mut self) -> REXTTRIG_W<20> {
                REXTTRIG_W::new(self)
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            #[must_use]
            pub fn iswstart(&mut self) -> ISWSTART_W<21> {
                ISWSTART_W::new(self)
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            #[must_use]
            pub fn rswstart(&mut self) -> RSWSTART_W<22> {
                RSWSTART_W::new(self)
            }
            ///Bit 23 - Temperature sensor and VREFINT enable
            #[inline(always)]
            #[must_use]
            pub fn tsvrefe(&mut self) -> TSVREFE_W<23> {
                TSVREFE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x08;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SAMPTR1 (rw) register accessor: an alias for `Reg<SAMPTR1_SPEC>`
    pub type SAMPTR1 = crate::Reg<samptr1::SAMPTR1_SPEC>;
    ///sample time register 1
    pub mod samptr1 {
        ///Register `SAMPTR1` reader
        pub struct R(crate::R<SAMPTR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAMPTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAMPTR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAMPTR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SAMPTR1` writer
        pub struct W(crate::W<SAMPTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SAMPTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SAMPTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SAMPTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMP10` reader - Channel 10 sample time selection
        pub type SMP10_R = crate::FieldReader<u8, SMP10_A>;
        ///Channel 10 sample time selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SMP10_A {
            ///0: 1.5T sampling rate
            T1p5 = 0,
            ///1: 7.5T sampling rate
            T7p5 = 1,
            ///2: 13.5T sampling rate
            T13p5 = 2,
            ///3: 28.5T sampling rate
            T28p5 = 3,
            ///4: 41.5T sampling rate
            T41p5 = 4,
            ///5: 55.5T sampling rate
            T55p5 = 5,
            ///6: 71.5T sampling rate
            T71p5 = 6,
            ///7: 239.5T sampling rate
            T239p5 = 7,
        }
        impl From<SMP10_A> for u8 {
            #[inline(always)]
            fn from(variant: SMP10_A) -> Self {
                variant as _
            }
        }
        impl SMP10_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMP10_A {
                match self.bits {
                    0 => SMP10_A::T1p5,
                    1 => SMP10_A::T7p5,
                    2 => SMP10_A::T13p5,
                    3 => SMP10_A::T28p5,
                    4 => SMP10_A::T41p5,
                    5 => SMP10_A::T55p5,
                    6 => SMP10_A::T71p5,
                    7 => SMP10_A::T239p5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `T1p5`
            #[inline(always)]
            pub fn is_t1p5(&self) -> bool {
                *self == SMP10_A::T1p5
            }
            ///Checks if the value of the field is `T7p5`
            #[inline(always)]
            pub fn is_t7p5(&self) -> bool {
                *self == SMP10_A::T7p5
            }
            ///Checks if the value of the field is `T13p5`
            #[inline(always)]
            pub fn is_t13p5(&self) -> bool {
                *self == SMP10_A::T13p5
            }
            ///Checks if the value of the field is `T28p5`
            #[inline(always)]
            pub fn is_t28p5(&self) -> bool {
                *self == SMP10_A::T28p5
            }
            ///Checks if the value of the field is `T41p5`
            #[inline(always)]
            pub fn is_t41p5(&self) -> bool {
                *self == SMP10_A::T41p5
            }
            ///Checks if the value of the field is `T55p5`
            #[inline(always)]
            pub fn is_t55p5(&self) -> bool {
                *self == SMP10_A::T55p5
            }
            ///Checks if the value of the field is `T71p5`
            #[inline(always)]
            pub fn is_t71p5(&self) -> bool {
                *self == SMP10_A::T71p5
            }
            ///Checks if the value of the field is `T239p5`
            #[inline(always)]
            pub fn is_t239p5(&self) -> bool {
                *self == SMP10_A::T239p5
            }
        }
        ///Field `SMP10` writer - Channel 10 sample time selection
        pub type SMP10_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, SAMPTR1_SPEC, u8, SMP10_A, 3, O>;
        impl<'a, const O: u8> SMP10_W<'a, O> {
            ///1.5T sampling rate
            #[inline(always)]
            pub fn t1p5(self) -> &'a mut W {
                self.variant(SMP10_A::T1p5)
            }
            ///7.5T sampling rate
            #[inline(always)]
            pub fn t7p5(self) -> &'a mut W {
                self.variant(SMP10_A::T7p5)
            }
            ///13.5T sampling rate
            #[inline(always)]
            pub fn t13p5(self) -> &'a mut W {
                self.variant(SMP10_A::T13p5)
            }
            ///28.5T sampling rate
            #[inline(always)]
            pub fn t28p5(self) -> &'a mut W {
                self.variant(SMP10_A::T28p5)
            }
            ///41.5T sampling rate
            #[inline(always)]
            pub fn t41p5(self) -> &'a mut W {
                self.variant(SMP10_A::T41p5)
            }
            ///55.5T sampling rate
            #[inline(always)]
            pub fn t55p5(self) -> &'a mut W {
                self.variant(SMP10_A::T55p5)
            }
            ///71.5T sampling rate
            #[inline(always)]
            pub fn t71p5(self) -> &'a mut W {
                self.variant(SMP10_A::T71p5)
            }
            ///239.5T sampling rate
            #[inline(always)]
            pub fn t239p5(self) -> &'a mut W {
                self.variant(SMP10_A::T239p5)
            }
        }
        ///Field `SMP11` reader - Channel 11 sample time selection
        pub use SMP10_R as SMP11_R;
        ///Field `SMP12` reader - Channel 12 sample time selection
        pub use SMP10_R as SMP12_R;
        ///Field `SMP13` reader - Channel 13 sample time selection
        pub use SMP10_R as SMP13_R;
        ///Field `SMP14` reader - Channel 14 sample time selection
        pub use SMP10_R as SMP14_R;
        ///Field `SMP15` reader - Channel 15 sample time selection
        pub use SMP10_R as SMP15_R;
        ///Field `SMP16` reader - Channel 16 sample time selection
        pub use SMP10_R as SMP16_R;
        ///Field `SMP17` reader - Channel 17 sample time selection
        pub use SMP10_R as SMP17_R;
        ///Field `SMP11` writer - Channel 11 sample time selection
        pub use SMP10_W as SMP11_W;
        ///Field `SMP12` writer - Channel 12 sample time selection
        pub use SMP10_W as SMP12_W;
        ///Field `SMP13` writer - Channel 13 sample time selection
        pub use SMP10_W as SMP13_W;
        ///Field `SMP14` writer - Channel 14 sample time selection
        pub use SMP10_W as SMP14_W;
        ///Field `SMP15` writer - Channel 15 sample time selection
        pub use SMP10_W as SMP15_W;
        ///Field `SMP16` writer - Channel 16 sample time selection
        pub use SMP10_W as SMP16_W;
        ///Field `SMP17` writer - Channel 17 sample time selection
        pub use SMP10_W as SMP17_W;
        impl R {
            ///Bits 0:2 - Channel 10 sample time selection
            #[inline(always)]
            pub fn smp10(&self) -> SMP10_R {
                SMP10_R::new((self.bits & 7) as u8)
            }
            ///Bits 3:5 - Channel 11 sample time selection
            #[inline(always)]
            pub fn smp11(&self) -> SMP11_R {
                SMP11_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:8 - Channel 12 sample time selection
            #[inline(always)]
            pub fn smp12(&self) -> SMP12_R {
                SMP12_R::new(((self.bits >> 6) & 7) as u8)
            }
            ///Bits 9:11 - Channel 13 sample time selection
            #[inline(always)]
            pub fn smp13(&self) -> SMP13_R {
                SMP13_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bits 12:14 - Channel 14 sample time selection
            #[inline(always)]
            pub fn smp14(&self) -> SMP14_R {
                SMP14_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bits 15:17 - Channel 15 sample time selection
            #[inline(always)]
            pub fn smp15(&self) -> SMP15_R {
                SMP15_R::new(((self.bits >> 15) & 7) as u8)
            }
            ///Bits 18:20 - Channel 16 sample time selection
            #[inline(always)]
            pub fn smp16(&self) -> SMP16_R {
                SMP16_R::new(((self.bits >> 18) & 7) as u8)
            }
            ///Bits 21:23 - Channel 17 sample time selection
            #[inline(always)]
            pub fn smp17(&self) -> SMP17_R {
                SMP17_R::new(((self.bits >> 21) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Channel 10 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp10(&mut self) -> SMP10_W<0> {
                SMP10_W::new(self)
            }
            ///Bits 3:5 - Channel 11 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp11(&mut self) -> SMP11_W<3> {
                SMP11_W::new(self)
            }
            ///Bits 6:8 - Channel 12 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp12(&mut self) -> SMP12_W<6> {
                SMP12_W::new(self)
            }
            ///Bits 9:11 - Channel 13 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp13(&mut self) -> SMP13_W<9> {
                SMP13_W::new(self)
            }
            ///Bits 12:14 - Channel 14 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp14(&mut self) -> SMP14_W<12> {
                SMP14_W::new(self)
            }
            ///Bits 15:17 - Channel 15 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp15(&mut self) -> SMP15_W<15> {
                SMP15_W::new(self)
            }
            ///Bits 18:20 - Channel 16 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp16(&mut self) -> SMP16_W<18> {
                SMP16_W::new(self)
            }
            ///Bits 21:23 - Channel 17 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp17(&mut self) -> SMP17_W<21> {
                SMP17_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///sample time register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [samptr1](index.html) module
        pub struct SAMPTR1_SPEC;
        impl crate::RegisterSpec for SAMPTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [samptr1::R](R) reader structure
        impl crate::Readable for SAMPTR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [samptr1::W](W) writer structure
        impl crate::Writable for SAMPTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SAMPTR1 to value 0
        impl crate::Resettable for SAMPTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SAMPTR2 (rw) register accessor: an alias for `Reg<SAMPTR2_SPEC>`
    pub type SAMPTR2 = crate::Reg<samptr2::SAMPTR2_SPEC>;
    ///sample time register 2
    pub mod samptr2 {
        ///Register `SAMPTR2` reader
        pub struct R(crate::R<SAMPTR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAMPTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAMPTR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAMPTR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SAMPTR2` writer
        pub struct W(crate::W<SAMPTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SAMPTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SAMPTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SAMPTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMP0` reader - Channel 0 sample time selection
        pub type SMP0_R = crate::FieldReader<u8, SMP0_A>;
        ///Channel 0 sample time selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SMP0_A {
            ///0: 1.5T sampling rate
            T1p5 = 0,
            ///1: 7.5T sampling rate
            T7p5 = 1,
            ///2: 13.5T sampling rate
            T13p5 = 2,
            ///3: 28.5T sampling rate
            T28p5 = 3,
            ///4: 41.5T sampling rate
            T41p5 = 4,
            ///5: 55.5T sampling rate
            T55p5 = 5,
            ///6: 71.5T sampling rate
            T71p5 = 6,
            ///7: 239.5T sampling rate
            T239p5 = 7,
        }
        impl From<SMP0_A> for u8 {
            #[inline(always)]
            fn from(variant: SMP0_A) -> Self {
                variant as _
            }
        }
        impl SMP0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMP0_A {
                match self.bits {
                    0 => SMP0_A::T1p5,
                    1 => SMP0_A::T7p5,
                    2 => SMP0_A::T13p5,
                    3 => SMP0_A::T28p5,
                    4 => SMP0_A::T41p5,
                    5 => SMP0_A::T55p5,
                    6 => SMP0_A::T71p5,
                    7 => SMP0_A::T239p5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `T1p5`
            #[inline(always)]
            pub fn is_t1p5(&self) -> bool {
                *self == SMP0_A::T1p5
            }
            ///Checks if the value of the field is `T7p5`
            #[inline(always)]
            pub fn is_t7p5(&self) -> bool {
                *self == SMP0_A::T7p5
            }
            ///Checks if the value of the field is `T13p5`
            #[inline(always)]
            pub fn is_t13p5(&self) -> bool {
                *self == SMP0_A::T13p5
            }
            ///Checks if the value of the field is `T28p5`
            #[inline(always)]
            pub fn is_t28p5(&self) -> bool {
                *self == SMP0_A::T28p5
            }
            ///Checks if the value of the field is `T41p5`
            #[inline(always)]
            pub fn is_t41p5(&self) -> bool {
                *self == SMP0_A::T41p5
            }
            ///Checks if the value of the field is `T55p5`
            #[inline(always)]
            pub fn is_t55p5(&self) -> bool {
                *self == SMP0_A::T55p5
            }
            ///Checks if the value of the field is `T71p5`
            #[inline(always)]
            pub fn is_t71p5(&self) -> bool {
                *self == SMP0_A::T71p5
            }
            ///Checks if the value of the field is `T239p5`
            #[inline(always)]
            pub fn is_t239p5(&self) -> bool {
                *self == SMP0_A::T239p5
            }
        }
        ///Field `SMP0` writer - Channel 0 sample time selection
        pub type SMP0_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, SAMPTR2_SPEC, u8, SMP0_A, 3, O>;
        impl<'a, const O: u8> SMP0_W<'a, O> {
            ///1.5T sampling rate
            #[inline(always)]
            pub fn t1p5(self) -> &'a mut W {
                self.variant(SMP0_A::T1p5)
            }
            ///7.5T sampling rate
            #[inline(always)]
            pub fn t7p5(self) -> &'a mut W {
                self.variant(SMP0_A::T7p5)
            }
            ///13.5T sampling rate
            #[inline(always)]
            pub fn t13p5(self) -> &'a mut W {
                self.variant(SMP0_A::T13p5)
            }
            ///28.5T sampling rate
            #[inline(always)]
            pub fn t28p5(self) -> &'a mut W {
                self.variant(SMP0_A::T28p5)
            }
            ///41.5T sampling rate
            #[inline(always)]
            pub fn t41p5(self) -> &'a mut W {
                self.variant(SMP0_A::T41p5)
            }
            ///55.5T sampling rate
            #[inline(always)]
            pub fn t55p5(self) -> &'a mut W {
                self.variant(SMP0_A::T55p5)
            }
            ///71.5T sampling rate
            #[inline(always)]
            pub fn t71p5(self) -> &'a mut W {
                self.variant(SMP0_A::T71p5)
            }
            ///239.5T sampling rate
            #[inline(always)]
            pub fn t239p5(self) -> &'a mut W {
                self.variant(SMP0_A::T239p5)
            }
        }
        ///Field `SMP1` reader - Channel 1 sample time selection
        pub use SMP0_R as SMP1_R;
        ///Field `SMP2` reader - Channel 2 sample time selection
        pub use SMP0_R as SMP2_R;
        ///Field `SMP3` reader - Channel 3 sample time selection
        pub use SMP0_R as SMP3_R;
        ///Field `SMP4` reader - Channel 4 sample time selection
        pub use SMP0_R as SMP4_R;
        ///Field `SMP5` reader - Channel 5 sample time selection
        pub use SMP0_R as SMP5_R;
        ///Field `SMP6` reader - Channel 6 sample time selection
        pub use SMP0_R as SMP6_R;
        ///Field `SMP7` reader - Channel 7 sample time selection
        pub use SMP0_R as SMP7_R;
        ///Field `SMP8` reader - Channel 8 sample time selection
        pub use SMP0_R as SMP8_R;
        ///Field `SMP9` reader - Channel 9 sample time selection
        pub use SMP0_R as SMP9_R;
        ///Field `SMP1` writer - Channel 1 sample time selection
        pub use SMP0_W as SMP1_W;
        ///Field `SMP2` writer - Channel 2 sample time selection
        pub use SMP0_W as SMP2_W;
        ///Field `SMP3` writer - Channel 3 sample time selection
        pub use SMP0_W as SMP3_W;
        ///Field `SMP4` writer - Channel 4 sample time selection
        pub use SMP0_W as SMP4_W;
        ///Field `SMP5` writer - Channel 5 sample time selection
        pub use SMP0_W as SMP5_W;
        ///Field `SMP6` writer - Channel 6 sample time selection
        pub use SMP0_W as SMP6_W;
        ///Field `SMP7` writer - Channel 7 sample time selection
        pub use SMP0_W as SMP7_W;
        ///Field `SMP8` writer - Channel 8 sample time selection
        pub use SMP0_W as SMP8_W;
        ///Field `SMP9` writer - Channel 9 sample time selection
        pub use SMP0_W as SMP9_W;
        impl R {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            pub fn smp0(&self) -> SMP0_R {
                SMP0_R::new((self.bits & 7) as u8)
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            pub fn smp1(&self) -> SMP1_R {
                SMP1_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            pub fn smp2(&self) -> SMP2_R {
                SMP2_R::new(((self.bits >> 6) & 7) as u8)
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            pub fn smp3(&self) -> SMP3_R {
                SMP3_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            pub fn smp4(&self) -> SMP4_R {
                SMP4_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            pub fn smp5(&self) -> SMP5_R {
                SMP5_R::new(((self.bits >> 15) & 7) as u8)
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            pub fn smp6(&self) -> SMP6_R {
                SMP6_R::new(((self.bits >> 18) & 7) as u8)
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            pub fn smp7(&self) -> SMP7_R {
                SMP7_R::new(((self.bits >> 21) & 7) as u8)
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            pub fn smp8(&self) -> SMP8_R {
                SMP8_R::new(((self.bits >> 24) & 7) as u8)
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            pub fn smp9(&self) -> SMP9_R {
                SMP9_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp0(&mut self) -> SMP0_W<0> {
                SMP0_W::new(self)
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp1(&mut self) -> SMP1_W<3> {
                SMP1_W::new(self)
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp2(&mut self) -> SMP2_W<6> {
                SMP2_W::new(self)
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp3(&mut self) -> SMP3_W<9> {
                SMP3_W::new(self)
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp4(&mut self) -> SMP4_W<12> {
                SMP4_W::new(self)
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp5(&mut self) -> SMP5_W<15> {
                SMP5_W::new(self)
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp6(&mut self) -> SMP6_W<18> {
                SMP6_W::new(self)
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp7(&mut self) -> SMP7_W<21> {
                SMP7_W::new(self)
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp8(&mut self) -> SMP8_W<24> {
                SMP8_W::new(self)
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp9(&mut self) -> SMP9_W<27> {
                SMP9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///sample time register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [samptr2](index.html) module
        pub struct SAMPTR2_SPEC;
        impl crate::RegisterSpec for SAMPTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [samptr2::R](R) reader structure
        impl crate::Readable for SAMPTR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [samptr2::W](W) writer structure
        impl crate::Writable for SAMPTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SAMPTR2 to value 0
        impl crate::Resettable for SAMPTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR1 (rw) register accessor: an alias for `Reg<IOFR1_SPEC>`
    pub type IOFR1 = crate::Reg<iofr1::IOFR1_SPEC>;
    ///injected channel data offset register x
    pub mod iofr1 {
        ///Register `IOFR1` reader
        pub struct R(crate::R<IOFR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR1` writer
        pub struct W(crate::W<IOFR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IOFFSET` reader - Data offset for injected channel x
        pub type IOFFSET_R = crate::FieldReader<u16, u16>;
        ///Field `IOFFSET` writer - Data offset for injected channel x
        pub type IOFFSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR1_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn ioffset(&self) -> IOFFSET_R {
                IOFFSET_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn ioffset(&mut self) -> IOFFSET_W<0> {
                IOFFSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr1](index.html) module
        pub struct IOFR1_SPEC;
        impl crate::RegisterSpec for IOFR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr1::R](R) reader structure
        impl crate::Readable for IOFR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr1::W](W) writer structure
        impl crate::Writable for IOFR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR1 to value 0
        impl crate::Resettable for IOFR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR2 (rw) register accessor: an alias for `Reg<IOFR2_SPEC>`
    pub type IOFR2 = crate::Reg<iofr2::IOFR2_SPEC>;
    ///injected channel data offset register x
    pub mod iofr2 {
        ///Register `IOFR2` reader
        pub struct R(crate::R<IOFR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR2` writer
        pub struct W(crate::W<IOFR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IOFFSET` reader - Data offset for injected channel x
        pub type IOFFSET_R = crate::FieldReader<u16, u16>;
        ///Field `IOFFSET` writer - Data offset for injected channel x
        pub type IOFFSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR2_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn ioffset(&self) -> IOFFSET_R {
                IOFFSET_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn ioffset(&mut self) -> IOFFSET_W<0> {
                IOFFSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr2](index.html) module
        pub struct IOFR2_SPEC;
        impl crate::RegisterSpec for IOFR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr2::R](R) reader structure
        impl crate::Readable for IOFR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr2::W](W) writer structure
        impl crate::Writable for IOFR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR2 to value 0
        impl crate::Resettable for IOFR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR3 (rw) register accessor: an alias for `Reg<IOFR3_SPEC>`
    pub type IOFR3 = crate::Reg<iofr3::IOFR3_SPEC>;
    ///injected channel data offset register x
    pub mod iofr3 {
        ///Register `IOFR3` reader
        pub struct R(crate::R<IOFR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR3` writer
        pub struct W(crate::W<IOFR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IOFFSET` reader - Data offset for injected channel x
        pub type IOFFSET_R = crate::FieldReader<u16, u16>;
        ///Field `IOFFSET` writer - Data offset for injected channel x
        pub type IOFFSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR3_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn ioffset(&self) -> IOFFSET_R {
                IOFFSET_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn ioffset(&mut self) -> IOFFSET_W<0> {
                IOFFSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr3](index.html) module
        pub struct IOFR3_SPEC;
        impl crate::RegisterSpec for IOFR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr3::R](R) reader structure
        impl crate::Readable for IOFR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr3::W](W) writer structure
        impl crate::Writable for IOFR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR3 to value 0
        impl crate::Resettable for IOFR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR4 (rw) register accessor: an alias for `Reg<IOFR4_SPEC>`
    pub type IOFR4 = crate::Reg<iofr4::IOFR4_SPEC>;
    ///injected channel data offset register x
    pub mod iofr4 {
        ///Register `IOFR4` reader
        pub struct R(crate::R<IOFR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR4` writer
        pub struct W(crate::W<IOFR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IOFFSET` reader - Data offset for injected channel x
        pub type IOFFSET_R = crate::FieldReader<u16, u16>;
        ///Field `IOFFSET` writer - Data offset for injected channel x
        pub type IOFFSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR4_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            pub fn ioffset(&self) -> IOFFSET_R {
                IOFFSET_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn ioffset(&mut self) -> IOFFSET_W<0> {
                IOFFSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr4](index.html) module
        pub struct IOFR4_SPEC;
        impl crate::RegisterSpec for IOFR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr4::R](R) reader structure
        impl crate::Readable for IOFR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr4::W](W) writer structure
        impl crate::Writable for IOFR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR4 to value 0
        impl crate::Resettable for IOFR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///WDHTR (rw) register accessor: an alias for `Reg<WDHTR_SPEC>`
    pub type WDHTR = crate::Reg<wdhtr::WDHTR_SPEC>;
    ///watchdog higher threshold register
    pub mod wdhtr {
        ///Register `WDHTR` reader
        pub struct R(crate::R<WDHTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WDHTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WDHTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WDHTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `WDHTR` writer
        pub struct W(crate::W<WDHTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<WDHTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<WDHTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<WDHTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HT` reader - Analog watchdog higher threshold
        pub type HT_R = crate::FieldReader<u16, u16>;
        ///Field `HT` writer - Analog watchdog higher threshold
        pub type HT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, WDHTR_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Analog watchdog higher threshold
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Analog watchdog higher threshold
            #[inline(always)]
            #[must_use]
            pub fn ht(&mut self) -> HT_W<0> {
                HT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///watchdog higher threshold register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wdhtr](index.html) module
        pub struct WDHTR_SPEC;
        impl crate::RegisterSpec for WDHTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [wdhtr::R](R) reader structure
        impl crate::Readable for WDHTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [wdhtr::W](W) writer structure
        impl crate::Writable for WDHTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets WDHTR to value 0
        impl crate::Resettable for WDHTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///WDLTR (rw) register accessor: an alias for `Reg<WDLTR_SPEC>`
    pub type WDLTR = crate::Reg<wdltr::WDLTR_SPEC>;
    ///watchdog lower threshold register
    pub mod wdltr {
        ///Register `WDLTR` reader
        pub struct R(crate::R<WDLTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WDLTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WDLTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WDLTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `WDLTR` writer
        pub struct W(crate::W<WDLTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<WDLTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<WDLTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<WDLTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LT` reader - Analog watchdog lower threshold
        pub type LT_R = crate::FieldReader<u16, u16>;
        ///Field `LT` writer - Analog watchdog lower threshold
        pub type LT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, WDLTR_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Analog watchdog lower threshold
            #[inline(always)]
            pub fn lt(&self) -> LT_R {
                LT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Analog watchdog lower threshold
            #[inline(always)]
            #[must_use]
            pub fn lt(&mut self) -> LT_W<0> {
                LT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///watchdog lower threshold register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wdltr](index.html) module
        pub struct WDLTR_SPEC;
        impl crate::RegisterSpec for WDLTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [wdltr::R](R) reader structure
        impl crate::Readable for WDLTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [wdltr::W](W) writer structure
        impl crate::Writable for WDLTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets WDLTR to value 0
        impl crate::Resettable for WDLTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSQR1 (rw) register accessor: an alias for `Reg<RSQR1_SPEC>`
    pub type RSQR1 = crate::Reg<rsqr1::RSQR1_SPEC>;
    ///regular sequence register 1
    pub mod rsqr1 {
        ///Register `RSQR1` reader
        pub struct R(crate::R<RSQR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSQR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSQR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSQR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSQR1` writer
        pub struct W(crate::W<RSQR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSQR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSQR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSQR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ13` reader - 13th conversion in regular sequence
        pub type SQ13_R = crate::FieldReader<u8, u8>;
        ///Field `SQ13` writer - 13th conversion in regular sequence
        pub type SQ13_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `SQ14` reader - 14th conversion in regular sequence
        pub type SQ14_R = crate::FieldReader<u8, u8>;
        ///Field `SQ14` writer - 14th conversion in regular sequence
        pub type SQ14_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `SQ15` reader - 15th conversion in regular sequence
        pub type SQ15_R = crate::FieldReader<u8, u8>;
        ///Field `SQ15` writer - 15th conversion in regular sequence
        pub type SQ15_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `SQ16` reader - 16th conversion in regular sequence
        pub type SQ16_R = crate::FieldReader<u8, u8>;
        ///Field `SQ16` writer - 16th conversion in regular sequence
        pub type SQ16_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `L` reader - Regular channel sequence length
        pub type L_R = crate::FieldReader<u8, u8>;
        ///Field `L` writer - Regular channel sequence length
        pub type L_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            pub fn sq13(&self) -> SQ13_R {
                SQ13_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            pub fn sq14(&self) -> SQ14_R {
                SQ14_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            pub fn sq15(&self) -> SQ15_R {
                SQ15_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            pub fn sq16(&self) -> SQ16_R {
                SQ16_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            pub fn l(&self) -> L_R {
                L_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq13(&mut self) -> SQ13_W<0> {
                SQ13_W::new(self)
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq14(&mut self) -> SQ14_W<5> {
                SQ14_W::new(self)
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq15(&mut self) -> SQ15_W<10> {
                SQ15_W::new(self)
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq16(&mut self) -> SQ16_W<15> {
                SQ16_W::new(self)
            }
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            #[must_use]
            pub fn l(&mut self) -> L_W<20> {
                L_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rsqr1](index.html) module
        pub struct RSQR1_SPEC;
        impl crate::RegisterSpec for RSQR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rsqr1::R](R) reader structure
        impl crate::Readable for RSQR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rsqr1::W](W) writer structure
        impl crate::Writable for RSQR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RSQR1 to value 0
        impl crate::Resettable for RSQR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSQR2 (rw) register accessor: an alias for `Reg<RSQR2_SPEC>`
    pub type RSQR2 = crate::Reg<rsqr2::RSQR2_SPEC>;
    ///regular sequence register 2
    pub mod rsqr2 {
        ///Register `RSQR2` reader
        pub struct R(crate::R<RSQR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSQR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSQR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSQR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSQR2` writer
        pub struct W(crate::W<RSQR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSQR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSQR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSQR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ7` reader - 7th conversion in regular sequence
        pub type SQ7_R = crate::FieldReader<u8, u8>;
        ///Field `SQ7` writer - 7th conversion in regular sequence
        pub type SQ7_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ8` reader - 8th conversion in regular sequence
        pub type SQ8_R = crate::FieldReader<u8, u8>;
        ///Field `SQ8` writer - 8th conversion in regular sequence
        pub type SQ8_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ9` reader - 9th conversion in regular sequence
        pub type SQ9_R = crate::FieldReader<u8, u8>;
        ///Field `SQ9` writer - 9th conversion in regular sequence
        pub type SQ9_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ10` reader - 10th conversion in regular sequence
        pub type SQ10_R = crate::FieldReader<u8, u8>;
        ///Field `SQ10` writer - 10th conversion in regular sequence
        pub type SQ10_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ11` reader - 11th conversion in regular sequence
        pub type SQ11_R = crate::FieldReader<u8, u8>;
        ///Field `SQ11` writer - 11th conversion in regular sequence
        pub type SQ11_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ12` reader - 12th conversion in regular sequence
        pub type SQ12_R = crate::FieldReader<u8, u8>;
        ///Field `SQ12` writer - 12th conversion in regular sequence
        pub type SQ12_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            pub fn sq7(&self) -> SQ7_R {
                SQ7_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            pub fn sq8(&self) -> SQ8_R {
                SQ8_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            pub fn sq9(&self) -> SQ9_R {
                SQ9_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            pub fn sq10(&self) -> SQ10_R {
                SQ10_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            pub fn sq11(&self) -> SQ11_R {
                SQ11_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            pub fn sq12(&self) -> SQ12_R {
                SQ12_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq7(&mut self) -> SQ7_W<0> {
                SQ7_W::new(self)
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq8(&mut self) -> SQ8_W<5> {
                SQ8_W::new(self)
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq9(&mut self) -> SQ9_W<10> {
                SQ9_W::new(self)
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq10(&mut self) -> SQ10_W<15> {
                SQ10_W::new(self)
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq11(&mut self) -> SQ11_W<20> {
                SQ11_W::new(self)
            }
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq12(&mut self) -> SQ12_W<25> {
                SQ12_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rsqr2](index.html) module
        pub struct RSQR2_SPEC;
        impl crate::RegisterSpec for RSQR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rsqr2::R](R) reader structure
        impl crate::Readable for RSQR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rsqr2::W](W) writer structure
        impl crate::Writable for RSQR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RSQR2 to value 0
        impl crate::Resettable for RSQR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSQR3 (rw) register accessor: an alias for `Reg<RSQR3_SPEC>`
    pub type RSQR3 = crate::Reg<rsqr3::RSQR3_SPEC>;
    ///regular sequence register 3
    pub mod rsqr3 {
        ///Register `RSQR3` reader
        pub struct R(crate::R<RSQR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSQR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSQR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSQR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSQR3` writer
        pub struct W(crate::W<RSQR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSQR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSQR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSQR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ1` reader - 1st conversion in regular sequence
        pub type SQ1_R = crate::FieldReader<u8, u8>;
        ///Field `SQ1` writer - 1st conversion in regular sequence
        pub type SQ1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ2` reader - 2nd conversion in regular sequence
        pub type SQ2_R = crate::FieldReader<u8, u8>;
        ///Field `SQ2` writer - 2nd conversion in regular sequence
        pub type SQ2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ3` reader - 3rd conversion in regular sequence
        pub type SQ3_R = crate::FieldReader<u8, u8>;
        ///Field `SQ3` writer - 3rd conversion in regular sequence
        pub type SQ3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ4` reader - 4th conversion in regular sequence
        pub type SQ4_R = crate::FieldReader<u8, u8>;
        ///Field `SQ4` writer - 4th conversion in regular sequence
        pub type SQ4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ5` reader - 5th conversion in regular sequence
        pub type SQ5_R = crate::FieldReader<u8, u8>;
        ///Field `SQ5` writer - 5th conversion in regular sequence
        pub type SQ5_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ6` reader - 6th conversion in regular sequence
        pub type SQ6_R = crate::FieldReader<u8, u8>;
        ///Field `SQ6` writer - 6th conversion in regular sequence
        pub type SQ6_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            pub fn sq1(&self) -> SQ1_R {
                SQ1_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            pub fn sq2(&self) -> SQ2_R {
                SQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            pub fn sq3(&self) -> SQ3_R {
                SQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            pub fn sq4(&self) -> SQ4_R {
                SQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            pub fn sq5(&self) -> SQ5_R {
                SQ5_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            pub fn sq6(&self) -> SQ6_R {
                SQ6_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq1(&mut self) -> SQ1_W<0> {
                SQ1_W::new(self)
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq2(&mut self) -> SQ2_W<5> {
                SQ2_W::new(self)
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq3(&mut self) -> SQ3_W<10> {
                SQ3_W::new(self)
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq4(&mut self) -> SQ4_W<15> {
                SQ4_W::new(self)
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq5(&mut self) -> SQ5_W<20> {
                SQ5_W::new(self)
            }
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq6(&mut self) -> SQ6_W<25> {
                SQ6_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rsqr3](index.html) module
        pub struct RSQR3_SPEC;
        impl crate::RegisterSpec for RSQR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rsqr3::R](R) reader structure
        impl crate::Readable for RSQR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rsqr3::W](W) writer structure
        impl crate::Writable for RSQR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RSQR3 to value 0
        impl crate::Resettable for RSQR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ISQR (rw) register accessor: an alias for `Reg<ISQR_SPEC>`
    pub type ISQR = crate::Reg<isqr::ISQR_SPEC>;
    ///injected sequence register
    pub mod isqr {
        ///Register `ISQR` reader
        pub struct R(crate::R<ISQR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISQR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISQR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISQR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ISQR` writer
        pub struct W(crate::W<ISQR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ISQR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ISQR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ISQR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ISQ1` reader - 1st conversion in injected sequence
        pub type ISQ1_R = crate::FieldReader<u8, u8>;
        ///Field `ISQ1` writer - 1st conversion in injected sequence
        pub type ISQ1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `ISQ2` reader - 2nd conversion in injected sequence
        pub type ISQ2_R = crate::FieldReader<u8, u8>;
        ///Field `ISQ2` writer - 2nd conversion in injected sequence
        pub type ISQ2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `ISQ3` reader - 3rd conversion in injected sequence
        pub type ISQ3_R = crate::FieldReader<u8, u8>;
        ///Field `ISQ3` writer - 3rd conversion in injected sequence
        pub type ISQ3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `ISQ4` reader - 4th conversion in injected sequence
        pub type ISQ4_R = crate::FieldReader<u8, u8>;
        ///Field `ISQ4` writer - 4th conversion in injected sequence
        pub type ISQ4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `ILEN` reader - Injected sequence length
        pub type ILEN_R = crate::FieldReader<u8, u8>;
        ///Field `ILEN` writer - Injected sequence length
        pub type ILEN_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            pub fn isq1(&self) -> ISQ1_R {
                ISQ1_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            pub fn isq2(&self) -> ISQ2_R {
                ISQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            pub fn isq3(&self) -> ISQ3_R {
                ISQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            pub fn isq4(&self) -> ISQ4_R {
                ISQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            pub fn ilen(&self) -> ILEN_R {
                ILEN_R::new(((self.bits >> 20) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn isq1(&mut self) -> ISQ1_W<0> {
                ISQ1_W::new(self)
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn isq2(&mut self) -> ISQ2_W<5> {
                ISQ2_W::new(self)
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn isq3(&mut self) -> ISQ3_W<10> {
                ISQ3_W::new(self)
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn isq4(&mut self) -> ISQ4_W<15> {
                ISQ4_W::new(self)
            }
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            #[must_use]
            pub fn ilen(&mut self) -> ILEN_W<20> {
                ILEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected sequence register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isqr](index.html) module
        pub struct ISQR_SPEC;
        impl crate::RegisterSpec for ISQR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isqr::R](R) reader structure
        impl crate::Readable for ISQR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [isqr::W](W) writer structure
        impl crate::Writable for ISQR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ISQR to value 0
        impl crate::Resettable for ISQR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR1 (r) register accessor: an alias for `Reg<IDATAR1_SPEC>`
    pub type IDATAR1 = crate::Reg<idatar1::IDATAR1_SPEC>;
    ///injected data register x
    pub mod idatar1 {
        ///Register `IDATAR1` reader
        pub struct R(crate::R<IDATAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar1](index.html) module
        pub struct IDATAR1_SPEC;
        impl crate::RegisterSpec for IDATAR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar1::R](R) reader structure
        impl crate::Readable for IDATAR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR1 to value 0
        impl crate::Resettable for IDATAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR2 (r) register accessor: an alias for `Reg<IDATAR2_SPEC>`
    pub type IDATAR2 = crate::Reg<idatar2::IDATAR2_SPEC>;
    ///injected data register x
    pub mod idatar2 {
        ///Register `IDATAR2` reader
        pub struct R(crate::R<IDATAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar2](index.html) module
        pub struct IDATAR2_SPEC;
        impl crate::RegisterSpec for IDATAR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar2::R](R) reader structure
        impl crate::Readable for IDATAR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR2 to value 0
        impl crate::Resettable for IDATAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR3 (r) register accessor: an alias for `Reg<IDATAR3_SPEC>`
    pub type IDATAR3 = crate::Reg<idatar3::IDATAR3_SPEC>;
    ///injected data register x
    pub mod idatar3 {
        ///Register `IDATAR3` reader
        pub struct R(crate::R<IDATAR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar3](index.html) module
        pub struct IDATAR3_SPEC;
        impl crate::RegisterSpec for IDATAR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar3::R](R) reader structure
        impl crate::Readable for IDATAR3_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR3 to value 0
        impl crate::Resettable for IDATAR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR4 (r) register accessor: an alias for `Reg<IDATAR4_SPEC>`
    pub type IDATAR4 = crate::Reg<idatar4::IDATAR4_SPEC>;
    ///injected data register x
    pub mod idatar4 {
        ///Register `IDATAR4` reader
        pub struct R(crate::R<IDATAR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar4](index.html) module
        pub struct IDATAR4_SPEC;
        impl crate::RegisterSpec for IDATAR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar4::R](R) reader structure
        impl crate::Readable for IDATAR4_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR4 to value 0
        impl crate::Resettable for IDATAR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RDATAR (r) register accessor: an alias for `Reg<RDATAR_SPEC>`
    pub type RDATAR = crate::Reg<rdatar::RDATAR_SPEC>;
    ///regular data register
    pub mod rdatar {
        ///Register `RDATAR` reader
        pub struct R(crate::R<RDATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RDATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RDATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RDATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DATA` reader - Regular data
        pub type DATA_R = crate::FieldReader<u16, u16>;
        ///Field `ADC2DATA` reader - ADC2 data
        pub type ADC2DATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Regular data
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xffff) as u16)
            }
            ///Bits 16:31 - ADC2 data
            #[inline(always)]
            pub fn adc2data(&self) -> ADC2DATA_R {
                ADC2DATA_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        ///regular data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rdatar](index.html) module
        pub struct RDATAR_SPEC;
        impl crate::RegisterSpec for RDATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rdatar::R](R) reader structure
        impl crate::Readable for RDATAR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RDATAR to value 0
        impl crate::Resettable for RDATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Digital to analog converter
pub struct DAC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DAC1 {}
impl DAC1 {
    ///Pointer to the register block
    pub const PTR: *const dac1::RegisterBlock = 0x4000_7400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dac1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DAC1 {
    type Target = dac1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DAC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DAC1").finish()
    }
}
///Digital to analog converter
pub mod dac1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register (DAC_CTLR)
        pub ctlr: CTLR,
        ///0x04 - DAC software trigger register (DAC_SWTR)
        pub swtr: SWTR,
        ///0x08 - DAC channel1 12-bit right-aligned data holding register(DAC_R12BDHR1)
        pub r12bdhr1: R12BDHR1,
        ///0x0c - DAC channel1 12-bit left aligned data holding register (DAC_L12BDHR1)
        pub l12bdhr1: L12BDHR1,
        _reserved4: [u8; 0x04],
        ///0x14 - DAC channel2 12-bit right aligned data holding register (DAC_R12BDHR2)
        pub r12bdhr2: R12BDHR2,
        ///0x18 - DAC channel2 12-bit left aligned data holding register (DAC_L12BDHR2)
        pub l12bdhr2: L12BDHR2,
        _reserved6: [u8; 0x10],
        ///0x2c - DAC channel1 data output register (DAC_DOR1)
        pub dor1: DOR1,
        ///0x30 - DAC channel2 data output register (DAC_DOR2)
        pub dor2: DOR2,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register (DAC_CTLR)
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN1` reader - DAC channel1 enable
        pub type EN1_R = crate::BitReader<EN1_A>;
        ///DAC channel1 enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EN1_A {
            ///0: DAC channel disabled
            Disabled = 0,
            ///1: DAC channel enabled
            Enabled = 1,
        }
        impl From<EN1_A> for bool {
            #[inline(always)]
            fn from(variant: EN1_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EN1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN1_A {
                match self.bits {
                    false => EN1_A::Disabled,
                    true => EN1_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EN1_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EN1_A::Enabled
            }
        }
        ///Field `EN1` writer - DAC channel1 enable
        pub type EN1_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, EN1_A, O>;
        impl<'a, const O: u8> EN1_W<'a, O> {
            ///DAC channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN1_A::Disabled)
            }
            ///DAC channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN1_A::Enabled)
            }
        }
        ///Field `BOFF1` reader - DAC channel1 output buffer disable
        pub type BOFF1_R = crate::BitReader<BOFF1_A>;
        ///DAC channel1 output buffer disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BOFF1_A {
            ///0: DAC channel output buffer enabled
            Enabled = 0,
            ///1: DAC channel output buffer disabled
            Disabled = 1,
        }
        impl From<BOFF1_A> for bool {
            #[inline(always)]
            fn from(variant: BOFF1_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BOFF1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BOFF1_A {
                match self.bits {
                    false => BOFF1_A::Enabled,
                    true => BOFF1_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BOFF1_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BOFF1_A::Disabled
            }
        }
        ///Field `BOFF1` writer - DAC channel1 output buffer disable
        pub type BOFF1_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, BOFF1_A, O>;
        impl<'a, const O: u8> BOFF1_W<'a, O> {
            ///DAC channel output buffer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BOFF1_A::Enabled)
            }
            ///DAC channel output buffer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BOFF1_A::Disabled)
            }
        }
        ///Field `TEN1` reader - DAC channel1 trigger enable
        pub type TEN1_R = crate::BitReader<TEN1_A>;
        ///DAC channel1 trigger enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TEN1_A {
            ///0: DAC channel trigger disabled
            Disabled = 0,
            ///1: DAC channel trigger enabled
            Enabled = 1,
        }
        impl From<TEN1_A> for bool {
            #[inline(always)]
            fn from(variant: TEN1_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TEN1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TEN1_A {
                match self.bits {
                    false => TEN1_A::Disabled,
                    true => TEN1_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TEN1_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TEN1_A::Enabled
            }
        }
        ///Field `TEN1` writer - DAC channel1 trigger enable
        pub type TEN1_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, TEN1_A, O>;
        impl<'a, const O: u8> TEN1_W<'a, O> {
            ///DAC channel trigger disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEN1_A::Disabled)
            }
            ///DAC channel trigger enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEN1_A::Enabled)
            }
        }
        ///Field `TSEL1` reader - DAC channel1 trigger selection
        pub type TSEL1_R = crate::FieldReader<u8, TSEL1_A>;
        ///DAC channel1 trigger selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TSEL1_A {
            ///1: TIM3 TRG0
            Tim3 = 1,
            ///4: TIM2 TRG0
            Tim2 = 4,
            ///5: TIM4 TRG0
            Tim4 = 5,
            ///6: EXTI 9
            Exti9 = 6,
            ///7: Software trigger
            Software = 7,
        }
        impl From<TSEL1_A> for u8 {
            #[inline(always)]
            fn from(variant: TSEL1_A) -> Self {
                variant as _
            }
        }
        impl TSEL1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<TSEL1_A> {
                match self.bits {
                    1 => Some(TSEL1_A::Tim3),
                    4 => Some(TSEL1_A::Tim2),
                    5 => Some(TSEL1_A::Tim4),
                    6 => Some(TSEL1_A::Exti9),
                    7 => Some(TSEL1_A::Software),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Tim3`
            #[inline(always)]
            pub fn is_tim3(&self) -> bool {
                *self == TSEL1_A::Tim3
            }
            ///Checks if the value of the field is `Tim2`
            #[inline(always)]
            pub fn is_tim2(&self) -> bool {
                *self == TSEL1_A::Tim2
            }
            ///Checks if the value of the field is `Tim4`
            #[inline(always)]
            pub fn is_tim4(&self) -> bool {
                *self == TSEL1_A::Tim4
            }
            ///Checks if the value of the field is `Exti9`
            #[inline(always)]
            pub fn is_exti9(&self) -> bool {
                *self == TSEL1_A::Exti9
            }
            ///Checks if the value of the field is `Software`
            #[inline(always)]
            pub fn is_software(&self) -> bool {
                *self == TSEL1_A::Software
            }
        }
        ///Field `TSEL1` writer - DAC channel1 trigger selection
        pub type TSEL1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CTLR_SPEC, u8, TSEL1_A, 3, O>;
        impl<'a, const O: u8> TSEL1_W<'a, O> {
            ///TIM3 TRG0
            #[inline(always)]
            pub fn tim3(self) -> &'a mut W {
                self.variant(TSEL1_A::Tim3)
            }
            ///TIM2 TRG0
            #[inline(always)]
            pub fn tim2(self) -> &'a mut W {
                self.variant(TSEL1_A::Tim2)
            }
            ///TIM4 TRG0
            #[inline(always)]
            pub fn tim4(self) -> &'a mut W {
                self.variant(TSEL1_A::Tim4)
            }
            ///EXTI 9
            #[inline(always)]
            pub fn exti9(self) -> &'a mut W {
                self.variant(TSEL1_A::Exti9)
            }
            ///Software trigger
            #[inline(always)]
            pub fn software(self) -> &'a mut W {
                self.variant(TSEL1_A::Software)
            }
        }
        ///Field `WAVE1` reader - DAC channel1 noise/triangle wave generation enable
        pub type WAVE1_R = crate::FieldReader<u8, WAVE1_A>;
        ///DAC channel1 noise/triangle wave generation enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum WAVE1_A {
            ///0: Wave generator disabled
            Disabled = 0,
            ///1: Noise generator enabled
            Noise = 1,
            ///2: Triangular wave enabled
            Triangular = 2,
        }
        impl From<WAVE1_A> for u8 {
            #[inline(always)]
            fn from(variant: WAVE1_A) -> Self {
                variant as _
            }
        }
        impl WAVE1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<WAVE1_A> {
                match self.bits {
                    0 => Some(WAVE1_A::Disabled),
                    1 => Some(WAVE1_A::Noise),
                    2 => Some(WAVE1_A::Triangular),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WAVE1_A::Disabled
            }
            ///Checks if the value of the field is `Noise`
            #[inline(always)]
            pub fn is_noise(&self) -> bool {
                *self == WAVE1_A::Noise
            }
            ///Checks if the value of the field is `Triangular`
            #[inline(always)]
            pub fn is_triangular(&self) -> bool {
                *self == WAVE1_A::Triangular
            }
        }
        ///Field `WAVE1` writer - DAC channel1 noise/triangle wave generation enable
        pub type WAVE1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CTLR_SPEC, u8, WAVE1_A, 2, O>;
        impl<'a, const O: u8> WAVE1_W<'a, O> {
            ///Wave generator disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAVE1_A::Disabled)
            }
            ///Noise generator enabled
            #[inline(always)]
            pub fn noise(self) -> &'a mut W {
                self.variant(WAVE1_A::Noise)
            }
            ///Triangular wave enabled
            #[inline(always)]
            pub fn triangular(self) -> &'a mut W {
                self.variant(WAVE1_A::Triangular)
            }
        }
        ///Field `MAMP1` reader - DAC channel1 mask/amplitude selector
        pub type MAMP1_R = crate::FieldReader<u8, MAMP1_A>;
        ///DAC channel1 mask/amplitude selector
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MAMP1_A {
            ///0: No shutting on LSFR bit 0/Triangular wave amplitude 1
            NoShutting0amp1 = 0,
            ///1: No shutting on LSFR bits \[1:0\]/Triangular wave amplitude 3
            NoShutting10amp3 = 1,
            ///2: No shutting on LSFR bits \[2:0\]/Triangular wave amplitude 7
            NoShutting20amp7 = 2,
            ///3: No shutting on LSFR bits \[3:0\]/Triangular wave amplitude 15
            NoShutting30amp15 = 3,
            ///4: No shutting on LSFR bits \[4:0\]/Triangular wave amplitude 31
            NoShutting40amp31 = 4,
            ///5: No shutting on LSFR bits \[5:0\]/Triangular wave amplitude 63
            NoShutting50amp63 = 5,
            ///6: No shutting on LSFR bits \[6:0\]/Triangular wave amplitude 127
            NoShutting60amp127 = 6,
            ///7: No shutting on LSFR bits \[7:0\]/Triangular wave amplitude 255
            NoShutting70amp255 = 7,
            ///8: No shutting on LSFR bits \[8:0\]/Triangular wave amplitude 511
            NoShutting80amp511 = 8,
            ///9: No shutting on LSFR bits \[9:0\]/Triangular wave amplitude 1023
            NoShutting90amp1023 = 9,
            ///10: No shutting on LSFR bits \[10:0\]/Triangular wave amplitude 2047
            NoShutting100amp2047 = 10,
            ///11: No shutting on LSFR bits \[11:0\]/Triangular wave amplitude 4095
            NoShutting110amp4095 = 11,
        }
        impl From<MAMP1_A> for u8 {
            #[inline(always)]
            fn from(variant: MAMP1_A) -> Self {
                variant as _
            }
        }
        impl MAMP1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MAMP1_A> {
                match self.bits {
                    0 => Some(MAMP1_A::NoShutting0amp1),
                    1 => Some(MAMP1_A::NoShutting10amp3),
                    2 => Some(MAMP1_A::NoShutting20amp7),
                    3 => Some(MAMP1_A::NoShutting30amp15),
                    4 => Some(MAMP1_A::NoShutting40amp31),
                    5 => Some(MAMP1_A::NoShutting50amp63),
                    6 => Some(MAMP1_A::NoShutting60amp127),
                    7 => Some(MAMP1_A::NoShutting70amp255),
                    8 => Some(MAMP1_A::NoShutting80amp511),
                    9 => Some(MAMP1_A::NoShutting90amp1023),
                    10 => Some(MAMP1_A::NoShutting100amp2047),
                    11 => Some(MAMP1_A::NoShutting110amp4095),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NoShutting0amp1`
            #[inline(always)]
            pub fn is_no_shutting0amp1(&self) -> bool {
                *self == MAMP1_A::NoShutting0amp1
            }
            ///Checks if the value of the field is `NoShutting10amp3`
            #[inline(always)]
            pub fn is_no_shutting10amp3(&self) -> bool {
                *self == MAMP1_A::NoShutting10amp3
            }
            ///Checks if the value of the field is `NoShutting20amp7`
            #[inline(always)]
            pub fn is_no_shutting20amp7(&self) -> bool {
                *self == MAMP1_A::NoShutting20amp7
            }
            ///Checks if the value of the field is `NoShutting30amp15`
            #[inline(always)]
            pub fn is_no_shutting30amp15(&self) -> bool {
                *self == MAMP1_A::NoShutting30amp15
            }
            ///Checks if the value of the field is `NoShutting40amp31`
            #[inline(always)]
            pub fn is_no_shutting40amp31(&self) -> bool {
                *self == MAMP1_A::NoShutting40amp31
            }
            ///Checks if the value of the field is `NoShutting50amp63`
            #[inline(always)]
            pub fn is_no_shutting50amp63(&self) -> bool {
                *self == MAMP1_A::NoShutting50amp63
            }
            ///Checks if the value of the field is `NoShutting60amp127`
            #[inline(always)]
            pub fn is_no_shutting60amp127(&self) -> bool {
                *self == MAMP1_A::NoShutting60amp127
            }
            ///Checks if the value of the field is `NoShutting70amp255`
            #[inline(always)]
            pub fn is_no_shutting70amp255(&self) -> bool {
                *self == MAMP1_A::NoShutting70amp255
            }
            ///Checks if the value of the field is `NoShutting80amp511`
            #[inline(always)]
            pub fn is_no_shutting80amp511(&self) -> bool {
                *self == MAMP1_A::NoShutting80amp511
            }
            ///Checks if the value of the field is `NoShutting90amp1023`
            #[inline(always)]
            pub fn is_no_shutting90amp1023(&self) -> bool {
                *self == MAMP1_A::NoShutting90amp1023
            }
            ///Checks if the value of the field is `NoShutting100amp2047`
            #[inline(always)]
            pub fn is_no_shutting100amp2047(&self) -> bool {
                *self == MAMP1_A::NoShutting100amp2047
            }
            ///Checks if the value of the field is `NoShutting110amp4095`
            #[inline(always)]
            pub fn is_no_shutting110amp4095(&self) -> bool {
                *self == MAMP1_A::NoShutting110amp4095
            }
        }
        ///Field `MAMP1` writer - DAC channel1 mask/amplitude selector
        pub type MAMP1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CTLR_SPEC, u8, MAMP1_A, 4, O>;
        impl<'a, const O: u8> MAMP1_W<'a, O> {
            ///No shutting on LSFR bit 0/Triangular wave amplitude 1
            #[inline(always)]
            pub fn no_shutting0amp1(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting0amp1)
            }
            ///No shutting on LSFR bits \[1:0\]/Triangular wave amplitude 3
            #[inline(always)]
            pub fn no_shutting10amp3(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting10amp3)
            }
            ///No shutting on LSFR bits \[2:0\]/Triangular wave amplitude 7
            #[inline(always)]
            pub fn no_shutting20amp7(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting20amp7)
            }
            ///No shutting on LSFR bits \[3:0\]/Triangular wave amplitude 15
            #[inline(always)]
            pub fn no_shutting30amp15(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting30amp15)
            }
            ///No shutting on LSFR bits \[4:0\]/Triangular wave amplitude 31
            #[inline(always)]
            pub fn no_shutting40amp31(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting40amp31)
            }
            ///No shutting on LSFR bits \[5:0\]/Triangular wave amplitude 63
            #[inline(always)]
            pub fn no_shutting50amp63(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting50amp63)
            }
            ///No shutting on LSFR bits \[6:0\]/Triangular wave amplitude 127
            #[inline(always)]
            pub fn no_shutting60amp127(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting60amp127)
            }
            ///No shutting on LSFR bits \[7:0\]/Triangular wave amplitude 255
            #[inline(always)]
            pub fn no_shutting70amp255(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting70amp255)
            }
            ///No shutting on LSFR bits \[8:0\]/Triangular wave amplitude 511
            #[inline(always)]
            pub fn no_shutting80amp511(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting80amp511)
            }
            ///No shutting on LSFR bits \[9:0\]/Triangular wave amplitude 1023
            #[inline(always)]
            pub fn no_shutting90amp1023(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting90amp1023)
            }
            ///No shutting on LSFR bits \[10:0\]/Triangular wave amplitude 2047
            #[inline(always)]
            pub fn no_shutting100amp2047(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting100amp2047)
            }
            ///No shutting on LSFR bits \[11:0\]/Triangular wave amplitude 4095
            #[inline(always)]
            pub fn no_shutting110amp4095(self) -> &'a mut W {
                self.variant(MAMP1_A::NoShutting110amp4095)
            }
        }
        ///Field `DMAEN1` reader - DAC channel1 DMA enable
        pub type DMAEN1_R = crate::BitReader<DMAEN1_A>;
        ///DAC channel1 DMA enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMAEN1_A {
            ///0: DAC channel DMA disabled
            Disabled = 0,
            ///1: DAC channel DMA enabled
            Enabled = 1,
        }
        impl From<DMAEN1_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN1_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DMAEN1_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAEN1_A {
                match self.bits {
                    false => DMAEN1_A::Disabled,
                    true => DMAEN1_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == DMAEN1_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN1_A::Enabled
            }
        }
        ///Field `DMAEN1` writer - DAC channel1 DMA enable
        pub type DMAEN1_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, DMAEN1_A, O>;
        impl<'a, const O: u8> DMAEN1_W<'a, O> {
            ///DAC channel DMA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::Disabled)
            }
            ///DAC channel DMA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::Enabled)
            }
        }
        ///Field `BOFF2` reader - DAC channel2 output buffer disable
        pub use BOFF1_R as BOFF2_R;
        ///Field `BOFF2` writer - DAC channel2 output buffer disable
        pub use BOFF1_W as BOFF2_W;
        ///Field `DMAEN2` reader - DAC channel2 DMA enable
        pub use DMAEN1_R as DMAEN2_R;
        ///Field `DMAEN2` writer - DAC channel2 DMA enable
        pub use DMAEN1_W as DMAEN2_W;
        ///Field `EN2` reader - DAC channel2 enable
        pub use EN1_R as EN2_R;
        ///Field `EN2` writer - DAC channel2 enable
        pub use EN1_W as EN2_W;
        ///Field `MAMP2` reader - DAC channel2 mask/amplitude selector
        pub use MAMP1_R as MAMP2_R;
        ///Field `MAMP2` writer - DAC channel2 mask/amplitude selector
        pub use MAMP1_W as MAMP2_W;
        ///Field `TEN2` reader - DAC channel2 trigger enable
        pub use TEN1_R as TEN2_R;
        ///Field `TEN2` writer - DAC channel2 trigger enable
        pub use TEN1_W as TEN2_W;
        ///Field `TSEL2` reader - DAC channel2 trigger selection
        pub use TSEL1_R as TSEL2_R;
        ///Field `TSEL2` writer - DAC channel2 trigger selection
        pub use TSEL1_W as TSEL2_W;
        ///Field `WAVE2` reader - DAC channel2 noise/triangle wave generation enable
        pub use WAVE1_R as WAVE2_R;
        ///Field `WAVE2` writer - DAC channel2 noise/triangle wave generation enable
        pub use WAVE1_W as WAVE2_W;
        impl R {
            ///Bit 0 - DAC channel1 enable
            #[inline(always)]
            pub fn en1(&self) -> EN1_R {
                EN1_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DAC channel1 output buffer disable
            #[inline(always)]
            pub fn boff1(&self) -> BOFF1_R {
                BOFF1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DAC channel1 trigger enable
            #[inline(always)]
            pub fn ten1(&self) -> TEN1_R {
                TEN1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:5 - DAC channel1 trigger selection
            #[inline(always)]
            pub fn tsel1(&self) -> TSEL1_R {
                TSEL1_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:7 - DAC channel1 noise/triangle wave generation enable
            #[inline(always)]
            pub fn wave1(&self) -> WAVE1_R {
                WAVE1_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:11 - DAC channel1 mask/amplitude selector
            #[inline(always)]
            pub fn mamp1(&self) -> MAMP1_R {
                MAMP1_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bit 12 - DAC channel1 DMA enable
            #[inline(always)]
            pub fn dmaen1(&self) -> DMAEN1_R {
                DMAEN1_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 16 - DAC channel2 enable
            #[inline(always)]
            pub fn en2(&self) -> EN2_R {
                EN2_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - DAC channel2 output buffer disable
            #[inline(always)]
            pub fn boff2(&self) -> BOFF2_R {
                BOFF2_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - DAC channel2 trigger enable
            #[inline(always)]
            pub fn ten2(&self) -> TEN2_R {
                TEN2_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bits 19:21 - DAC channel2 trigger selection
            #[inline(always)]
            pub fn tsel2(&self) -> TSEL2_R {
                TSEL2_R::new(((self.bits >> 19) & 7) as u8)
            }
            ///Bits 22:23 - DAC channel2 noise/triangle wave generation enable
            #[inline(always)]
            pub fn wave2(&self) -> WAVE2_R {
                WAVE2_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:27 - DAC channel2 mask/amplitude selector
            #[inline(always)]
            pub fn mamp2(&self) -> MAMP2_R {
                MAMP2_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            ///Bit 28 - DAC channel2 DMA enable
            #[inline(always)]
            pub fn dmaen2(&self) -> DMAEN2_R {
                DMAEN2_R::new(((self.bits >> 28) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DAC channel1 enable
            #[inline(always)]
            #[must_use]
            pub fn en1(&mut self) -> EN1_W<0> {
                EN1_W::new(self)
            }
            ///Bit 1 - DAC channel1 output buffer disable
            #[inline(always)]
            #[must_use]
            pub fn boff1(&mut self) -> BOFF1_W<1> {
                BOFF1_W::new(self)
            }
            ///Bit 2 - DAC channel1 trigger enable
            #[inline(always)]
            #[must_use]
            pub fn ten1(&mut self) -> TEN1_W<2> {
                TEN1_W::new(self)
            }
            ///Bits 3:5 - DAC channel1 trigger selection
            #[inline(always)]
            #[must_use]
            pub fn tsel1(&mut self) -> TSEL1_W<3> {
                TSEL1_W::new(self)
            }
            ///Bits 6:7 - DAC channel1 noise/triangle wave generation enable
            #[inline(always)]
            #[must_use]
            pub fn wave1(&mut self) -> WAVE1_W<6> {
                WAVE1_W::new(self)
            }
            ///Bits 8:11 - DAC channel1 mask/amplitude selector
            #[inline(always)]
            #[must_use]
            pub fn mamp1(&mut self) -> MAMP1_W<8> {
                MAMP1_W::new(self)
            }
            ///Bit 12 - DAC channel1 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn dmaen1(&mut self) -> DMAEN1_W<12> {
                DMAEN1_W::new(self)
            }
            ///Bit 16 - DAC channel2 enable
            #[inline(always)]
            #[must_use]
            pub fn en2(&mut self) -> EN2_W<16> {
                EN2_W::new(self)
            }
            ///Bit 17 - DAC channel2 output buffer disable
            #[inline(always)]
            #[must_use]
            pub fn boff2(&mut self) -> BOFF2_W<17> {
                BOFF2_W::new(self)
            }
            ///Bit 18 - DAC channel2 trigger enable
            #[inline(always)]
            #[must_use]
            pub fn ten2(&mut self) -> TEN2_W<18> {
                TEN2_W::new(self)
            }
            ///Bits 19:21 - DAC channel2 trigger selection
            #[inline(always)]
            #[must_use]
            pub fn tsel2(&mut self) -> TSEL2_W<19> {
                TSEL2_W::new(self)
            }
            ///Bits 22:23 - DAC channel2 noise/triangle wave generation enable
            #[inline(always)]
            #[must_use]
            pub fn wave2(&mut self) -> WAVE2_W<22> {
                WAVE2_W::new(self)
            }
            ///Bits 24:27 - DAC channel2 mask/amplitude selector
            #[inline(always)]
            #[must_use]
            pub fn mamp2(&mut self) -> MAMP2_W<24> {
                MAMP2_W::new(self)
            }
            ///Bit 28 - DAC channel2 DMA enable
            #[inline(always)]
            #[must_use]
            pub fn dmaen2(&mut self) -> DMAEN2_W<28> {
                DMAEN2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register (DAC_CTLR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SWTR (w) register accessor: an alias for `Reg<SWTR_SPEC>`
    pub type SWTR = crate::Reg<swtr::SWTR_SPEC>;
    ///DAC software trigger register (DAC_SWTR)
    pub mod swtr {
        ///Register `SWTR` writer
        pub struct W(crate::W<SWTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SWTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SWTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SWTRIG1` writer - DAC channel1 software trigger
        pub type SWTRIG1_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWTR_SPEC, bool, O>;
        ///Field `SWTRIG2` writer - DAC channel2 software trigger
        pub type SWTRIG2_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWTR_SPEC, bool, O>;
        impl W {
            ///Bit 0 - DAC channel1 software trigger
            #[inline(always)]
            #[must_use]
            pub fn swtrig1(&mut self) -> SWTRIG1_W<0> {
                SWTRIG1_W::new(self)
            }
            ///Bit 1 - DAC channel2 software trigger
            #[inline(always)]
            #[must_use]
            pub fn swtrig2(&mut self) -> SWTRIG2_W<1> {
                SWTRIG2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC software trigger register (DAC_SWTR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swtr](index.html) module
        pub struct SWTR_SPEC;
        impl crate::RegisterSpec for SWTR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [swtr::W](W) writer structure
        impl crate::Writable for SWTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SWTR to value 0
        impl crate::Resettable for SWTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R12BDHR1 (rw) register accessor: an alias for `Reg<R12BDHR1_SPEC>`
    pub type R12BDHR1 = crate::Reg<r12bdhr1::R12BDHR1_SPEC>;
    ///DAC channel1 12-bit right-aligned data holding register(DAC_R12BDHR1)
    pub mod r12bdhr1 {
        ///Register `R12BDHR1` reader
        pub struct R(crate::R<R12BDHR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R12BDHR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R12BDHR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R12BDHR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R12BDHR1` writer
        pub struct W(crate::W<R12BDHR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R12BDHR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R12BDHR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R12BDHR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 12-bit right-aligned data
        pub type DACC1DHR_R = crate::FieldReader<u16, u16>;
        ///Field `DACC1DHR` writer - DAC channel1 12-bit right-aligned data
        pub type DACC1DHR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R12BDHR1_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - DAC channel1 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - DAC channel1 12-bit right-aligned data
            #[inline(always)]
            #[must_use]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W<0> {
                DACC1DHR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel1 12-bit right-aligned data holding register(DAC_R12BDHR1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r12bdhr1](index.html) module
        pub struct R12BDHR1_SPEC;
        impl crate::RegisterSpec for R12BDHR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r12bdhr1::R](R) reader structure
        impl crate::Readable for R12BDHR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r12bdhr1::W](W) writer structure
        impl crate::Writable for R12BDHR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R12BDHR1 to value 0
        impl crate::Resettable for R12BDHR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///L12BDHR1 (rw) register accessor: an alias for `Reg<L12BDHR1_SPEC>`
    pub type L12BDHR1 = crate::Reg<l12bdhr1::L12BDHR1_SPEC>;
    ///DAC channel1 12-bit left aligned data holding register (DAC_L12BDHR1)
    pub mod l12bdhr1 {
        ///Register `L12BDHR1` reader
        pub struct R(crate::R<L12BDHR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<L12BDHR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<L12BDHR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<L12BDHR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `L12BDHR1` writer
        pub struct W(crate::W<L12BDHR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<L12BDHR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<L12BDHR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<L12BDHR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 12-bit left-aligned data
        pub type DACC1DHR_R = crate::FieldReader<u16, u16>;
        ///Field `DACC1DHR` writer - DAC channel1 12-bit left-aligned data
        pub type DACC1DHR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, L12BDHR1_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 4:15 - DAC channel1 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 4:15 - DAC channel1 12-bit left-aligned data
            #[inline(always)]
            #[must_use]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W<4> {
                DACC1DHR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel1 12-bit left aligned data holding register (DAC_L12BDHR1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [l12bdhr1](index.html) module
        pub struct L12BDHR1_SPEC;
        impl crate::RegisterSpec for L12BDHR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [l12bdhr1::R](R) reader structure
        impl crate::Readable for L12BDHR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [l12bdhr1::W](W) writer structure
        impl crate::Writable for L12BDHR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets L12BDHR1 to value 0
        impl crate::Resettable for L12BDHR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///R12BDHR2 (rw) register accessor: an alias for `Reg<R12BDHR2_SPEC>`
    pub type R12BDHR2 = crate::Reg<r12bdhr2::R12BDHR2_SPEC>;
    ///DAC channel2 12-bit right aligned data holding register (DAC_R12BDHR2)
    pub mod r12bdhr2 {
        ///Register `R12BDHR2` reader
        pub struct R(crate::R<R12BDHR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<R12BDHR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<R12BDHR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<R12BDHR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `R12BDHR2` writer
        pub struct W(crate::W<R12BDHR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<R12BDHR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<R12BDHR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<R12BDHR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 12-bit right-aligned data
        pub type DACC2DHR_R = crate::FieldReader<u16, u16>;
        ///Field `DACC2DHR` writer - DAC channel2 12-bit right-aligned data
        pub type DACC2DHR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, R12BDHR2_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            #[must_use]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W<0> {
                DACC2DHR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel2 12-bit right aligned data holding register (DAC_R12BDHR2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [r12bdhr2](index.html) module
        pub struct R12BDHR2_SPEC;
        impl crate::RegisterSpec for R12BDHR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [r12bdhr2::R](R) reader structure
        impl crate::Readable for R12BDHR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [r12bdhr2::W](W) writer structure
        impl crate::Writable for R12BDHR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets R12BDHR2 to value 0
        impl crate::Resettable for R12BDHR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///L12BDHR2 (rw) register accessor: an alias for `Reg<L12BDHR2_SPEC>`
    pub type L12BDHR2 = crate::Reg<l12bdhr2::L12BDHR2_SPEC>;
    ///DAC channel2 12-bit left aligned data holding register (DAC_L12BDHR2)
    pub mod l12bdhr2 {
        ///Register `L12BDHR2` reader
        pub struct R(crate::R<L12BDHR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<L12BDHR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<L12BDHR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<L12BDHR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `L12BDHR2` writer
        pub struct W(crate::W<L12BDHR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<L12BDHR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<L12BDHR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<L12BDHR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 12-bit left-aligned data
        pub type DACC2DHR_R = crate::FieldReader<u16, u16>;
        ///Field `DACC2DHR` writer - DAC channel2 12-bit left-aligned data
        pub type DACC2DHR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, L12BDHR2_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 4:15 - DAC channel2 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 4:15 - DAC channel2 12-bit left-aligned data
            #[inline(always)]
            #[must_use]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W<4> {
                DACC2DHR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel2 12-bit left aligned data holding register (DAC_L12BDHR2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [l12bdhr2](index.html) module
        pub struct L12BDHR2_SPEC;
        impl crate::RegisterSpec for L12BDHR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [l12bdhr2::R](R) reader structure
        impl crate::Readable for L12BDHR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [l12bdhr2::W](W) writer structure
        impl crate::Writable for L12BDHR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets L12BDHR2 to value 0
        impl crate::Resettable for L12BDHR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DOR1 (r) register accessor: an alias for `Reg<DOR1_SPEC>`
    pub type DOR1 = crate::Reg<dor1::DOR1_SPEC>;
    ///DAC channel1 data output register (DAC_DOR1)
    pub mod dor1 {
        ///Register `DOR1` reader
        pub struct R(crate::R<DOR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DOR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DOR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DACC1DOR` reader - DAC channel1 data output
        pub type DACC1DOR_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:11 - DAC channel1 data output
            #[inline(always)]
            pub fn dacc1dor(&self) -> DACC1DOR_R {
                DACC1DOR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        ///DAC channel1 data output register (DAC_DOR1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dor1](index.html) module
        pub struct DOR1_SPEC;
        impl crate::RegisterSpec for DOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dor1::R](R) reader structure
        impl crate::Readable for DOR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DOR1 to value 0
        impl crate::Resettable for DOR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DOR2 (r) register accessor: an alias for `Reg<DOR2_SPEC>`
    pub type DOR2 = crate::Reg<dor2::DOR2_SPEC>;
    ///DAC channel2 data output register (DAC_DOR2)
    pub mod dor2 {
        ///Register `DOR2` reader
        pub struct R(crate::R<DOR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DOR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DOR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DACC2DOR` reader - DAC channel2 data output
        pub type DACC2DOR_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:11 - DAC channel2 data output
            #[inline(always)]
            pub fn dacc2dor(&self) -> DACC2DOR_R {
                DACC2DOR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        ///DAC channel2 data output register (DAC_DOR2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dor2](index.html) module
        pub struct DOR2_SPEC;
        impl crate::RegisterSpec for DOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dor2::R](R) reader structure
        impl crate::Readable for DOR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DOR2 to value 0
        impl crate::Resettable for DOR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Debug support
pub struct DBG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DBG {}
impl DBG {
    ///Pointer to the register block
    pub const PTR: *const dbg::RegisterBlock = 0xe004_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dbg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DBG {
    type Target = dbg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DBG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DBG").finish()
    }
}
///Debug support
pub mod dbg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - DBGMCU_IDCODE
        pub idcode: IDCODE,
        ///0x04 - DBGMCU_CFGR
        pub cfgr: CFGR,
    }
    ///IDCODE (r) register accessor: an alias for `Reg<IDCODE_SPEC>`
    pub type IDCODE = crate::Reg<idcode::IDCODE_SPEC>;
    ///DBGMCU_IDCODE
    pub mod idcode {
        ///Register `IDCODE` reader
        pub struct R(crate::R<IDCODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDCODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDCODE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDCODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DEV_ID` reader - DEV_ID
        pub type DEV_ID_R = crate::FieldReader<u16, u16>;
        ///Field `REV_ID` reader - REV_ID
        pub type REV_ID_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:11 - DEV_ID
            #[inline(always)]
            pub fn dev_id(&self) -> DEV_ID_R {
                DEV_ID_R::new((self.bits & 0x0fff) as u16)
            }
            ///Bits 16:31 - REV_ID
            #[inline(always)]
            pub fn rev_id(&self) -> REV_ID_R {
                REV_ID_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        ///DBGMCU_IDCODE
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idcode](index.html) module
        pub struct IDCODE_SPEC;
        impl crate::RegisterSpec for IDCODE_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idcode::R](R) reader structure
        impl crate::Readable for IDCODE_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDCODE to value 0
        impl crate::Resettable for IDCODE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR (rw) register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///DBGMCU_CFGR
    pub mod cfgr {
        ///Register `CFGR` reader
        pub struct R(crate::R<CFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBG_SLEEP` reader - DBG_SLEEP
        pub type DBG_SLEEP_R = crate::BitReader<bool>;
        ///Field `DBG_SLEEP` writer - DBG_SLEEP
        pub type DBG_SLEEP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_STOP` reader - DBG_STOP
        pub type DBG_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_STOP` writer - DBG_STOP
        pub type DBG_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_STANDBY` reader - DBG_STANDBY
        pub type DBG_STANDBY_R = crate::BitReader<bool>;
        ///Field `DBG_STANDBY` writer - DBG_STANDBY
        pub type DBG_STANDBY_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `TRACE_IOEN` reader - TRACE_IOEN
        pub type TRACE_IOEN_R = crate::BitReader<bool>;
        ///Field `TRACE_IOEN` writer - TRACE_IOEN
        pub type TRACE_IOEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `TRACE_MODE` reader - TRACE_MODE
        pub type TRACE_MODE_R = crate::FieldReader<u8, u8>;
        ///Field `TRACE_MODE` writer - TRACE_MODE
        pub type TRACE_MODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR_SPEC, u8, u8, 2, O>;
        ///Field `DBG_IWDG_STOP` reader - DBG_IWDG_STOP
        pub type DBG_IWDG_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_IWDG_STOP` writer - DBG_IWDG_STOP
        pub type DBG_IWDG_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_WWDG_STOP` reader - DBG_WWDG_STOP
        pub type DBG_WWDG_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_WWDG_STOP` writer - DBG_WWDG_STOP
        pub type DBG_WWDG_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM1_STOP` reader - DBG_TIM1_STOP
        pub type DBG_TIM1_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM1_STOP` writer - DBG_TIM1_STOP
        pub type DBG_TIM1_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM2_STOP` reader - DBG_TIM2_STOP
        pub type DBG_TIM2_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM2_STOP` writer - DBG_TIM2_STOP
        pub type DBG_TIM2_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM3_STOP` reader - DBG_TIM3_STOP
        pub type DBG_TIM3_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM3_STOP` writer - DBG_TIM3_STOP
        pub type DBG_TIM3_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM4_STOP` reader - DBG_TIM4_STOP
        pub type DBG_TIM4_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM4_STOP` writer - DBG_TIM4_STOP
        pub type DBG_TIM4_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_CAN1_STOP` reader - DBG_CAN1_STOP
        pub type DBG_CAN1_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_CAN1_STOP` writer - DBG_CAN1_STOP
        pub type DBG_CAN1_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_I2C1_SMBUS_TIMEOUT` reader - DBG_I2C1_SMBUS_TIMEOUT
        pub type DBG_I2C1_SMBUS_TIMEOUT_R = crate::BitReader<bool>;
        ///Field `DBG_I2C1_SMBUS_TIMEOUT` writer - DBG_I2C1_SMBUS_TIMEOUT
        pub type DBG_I2C1_SMBUS_TIMEOUT_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_I2C2_SMBUS_TIMEOUT` reader - DBG_I2C2_SMBUS_TIMEOUT
        pub type DBG_I2C2_SMBUS_TIMEOUT_R = crate::BitReader<bool>;
        ///Field `DBG_I2C2_SMBUS_TIMEOUT` writer - DBG_I2C2_SMBUS_TIMEOUT
        pub type DBG_I2C2_SMBUS_TIMEOUT_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM8_STOP` reader - DBG_TIM8_STOP
        pub type DBG_TIM8_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM8_STOP` writer - DBG_TIM8_STOP
        pub type DBG_TIM8_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM5_STOP` reader - DBG_TIM5_STOP
        pub type DBG_TIM5_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM5_STOP` writer - DBG_TIM5_STOP
        pub type DBG_TIM5_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM6_STOP` reader - DBG_TIM6_STOP
        pub type DBG_TIM6_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM6_STOP` writer - DBG_TIM6_STOP
        pub type DBG_TIM6_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_TIM7_STOP` reader - DBG_TIM7_STOP
        pub type DBG_TIM7_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_TIM7_STOP` writer - DBG_TIM7_STOP
        pub type DBG_TIM7_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `DBG_CAN2_STOP` reader - DBG_CAN2_STOP
        pub type DBG_CAN2_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_CAN2_STOP` writer - DBG_CAN2_STOP
        pub type DBG_CAN2_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DBG_SLEEP
            #[inline(always)]
            pub fn dbg_sleep(&self) -> DBG_SLEEP_R {
                DBG_SLEEP_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DBG_STOP
            #[inline(always)]
            pub fn dbg_stop(&self) -> DBG_STOP_R {
                DBG_STOP_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DBG_STANDBY
            #[inline(always)]
            pub fn dbg_standby(&self) -> DBG_STANDBY_R {
                DBG_STANDBY_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 5 - TRACE_IOEN
            #[inline(always)]
            pub fn trace_ioen(&self) -> TRACE_IOEN_R {
                TRACE_IOEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bits 6:7 - TRACE_MODE
            #[inline(always)]
            pub fn trace_mode(&self) -> TRACE_MODE_R {
                TRACE_MODE_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bit 8 - DBG_IWDG_STOP
            #[inline(always)]
            pub fn dbg_iwdg_stop(&self) -> DBG_IWDG_STOP_R {
                DBG_IWDG_STOP_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - DBG_WWDG_STOP
            #[inline(always)]
            pub fn dbg_wwdg_stop(&self) -> DBG_WWDG_STOP_R {
                DBG_WWDG_STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - DBG_TIM1_STOP
            #[inline(always)]
            pub fn dbg_tim1_stop(&self) -> DBG_TIM1_STOP_R {
                DBG_TIM1_STOP_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - DBG_TIM2_STOP
            #[inline(always)]
            pub fn dbg_tim2_stop(&self) -> DBG_TIM2_STOP_R {
                DBG_TIM2_STOP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - DBG_TIM3_STOP
            #[inline(always)]
            pub fn dbg_tim3_stop(&self) -> DBG_TIM3_STOP_R {
                DBG_TIM3_STOP_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - DBG_TIM4_STOP
            #[inline(always)]
            pub fn dbg_tim4_stop(&self) -> DBG_TIM4_STOP_R {
                DBG_TIM4_STOP_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - DBG_CAN1_STOP
            #[inline(always)]
            pub fn dbg_can1_stop(&self) -> DBG_CAN1_STOP_R {
                DBG_CAN1_STOP_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - DBG_I2C1_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn dbg_i2c1_smbus_timeout(&self) -> DBG_I2C1_SMBUS_TIMEOUT_R {
                DBG_I2C1_SMBUS_TIMEOUT_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - DBG_I2C2_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn dbg_i2c2_smbus_timeout(&self) -> DBG_I2C2_SMBUS_TIMEOUT_R {
                DBG_I2C2_SMBUS_TIMEOUT_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - DBG_TIM8_STOP
            #[inline(always)]
            pub fn dbg_tim8_stop(&self) -> DBG_TIM8_STOP_R {
                DBG_TIM8_STOP_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - DBG_TIM5_STOP
            #[inline(always)]
            pub fn dbg_tim5_stop(&self) -> DBG_TIM5_STOP_R {
                DBG_TIM5_STOP_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - DBG_TIM6_STOP
            #[inline(always)]
            pub fn dbg_tim6_stop(&self) -> DBG_TIM6_STOP_R {
                DBG_TIM6_STOP_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - DBG_TIM7_STOP
            #[inline(always)]
            pub fn dbg_tim7_stop(&self) -> DBG_TIM7_STOP_R {
                DBG_TIM7_STOP_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - DBG_CAN2_STOP
            #[inline(always)]
            pub fn dbg_can2_stop(&self) -> DBG_CAN2_STOP_R {
                DBG_CAN2_STOP_R::new(((self.bits >> 21) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DBG_SLEEP
            #[inline(always)]
            #[must_use]
            pub fn dbg_sleep(&mut self) -> DBG_SLEEP_W<0> {
                DBG_SLEEP_W::new(self)
            }
            ///Bit 1 - DBG_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_stop(&mut self) -> DBG_STOP_W<1> {
                DBG_STOP_W::new(self)
            }
            ///Bit 2 - DBG_STANDBY
            #[inline(always)]
            #[must_use]
            pub fn dbg_standby(&mut self) -> DBG_STANDBY_W<2> {
                DBG_STANDBY_W::new(self)
            }
            ///Bit 5 - TRACE_IOEN
            #[inline(always)]
            #[must_use]
            pub fn trace_ioen(&mut self) -> TRACE_IOEN_W<5> {
                TRACE_IOEN_W::new(self)
            }
            ///Bits 6:7 - TRACE_MODE
            #[inline(always)]
            #[must_use]
            pub fn trace_mode(&mut self) -> TRACE_MODE_W<6> {
                TRACE_MODE_W::new(self)
            }
            ///Bit 8 - DBG_IWDG_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_iwdg_stop(&mut self) -> DBG_IWDG_STOP_W<8> {
                DBG_IWDG_STOP_W::new(self)
            }
            ///Bit 9 - DBG_WWDG_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_wwdg_stop(&mut self) -> DBG_WWDG_STOP_W<9> {
                DBG_WWDG_STOP_W::new(self)
            }
            ///Bit 10 - DBG_TIM1_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim1_stop(&mut self) -> DBG_TIM1_STOP_W<10> {
                DBG_TIM1_STOP_W::new(self)
            }
            ///Bit 11 - DBG_TIM2_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim2_stop(&mut self) -> DBG_TIM2_STOP_W<11> {
                DBG_TIM2_STOP_W::new(self)
            }
            ///Bit 12 - DBG_TIM3_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim3_stop(&mut self) -> DBG_TIM3_STOP_W<12> {
                DBG_TIM3_STOP_W::new(self)
            }
            ///Bit 13 - DBG_TIM4_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim4_stop(&mut self) -> DBG_TIM4_STOP_W<13> {
                DBG_TIM4_STOP_W::new(self)
            }
            ///Bit 14 - DBG_CAN1_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_can1_stop(&mut self) -> DBG_CAN1_STOP_W<14> {
                DBG_CAN1_STOP_W::new(self)
            }
            ///Bit 15 - DBG_I2C1_SMBUS_TIMEOUT
            #[inline(always)]
            #[must_use]
            pub fn dbg_i2c1_smbus_timeout(&mut self) -> DBG_I2C1_SMBUS_TIMEOUT_W<15> {
                DBG_I2C1_SMBUS_TIMEOUT_W::new(self)
            }
            ///Bit 16 - DBG_I2C2_SMBUS_TIMEOUT
            #[inline(always)]
            #[must_use]
            pub fn dbg_i2c2_smbus_timeout(&mut self) -> DBG_I2C2_SMBUS_TIMEOUT_W<16> {
                DBG_I2C2_SMBUS_TIMEOUT_W::new(self)
            }
            ///Bit 17 - DBG_TIM8_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim8_stop(&mut self) -> DBG_TIM8_STOP_W<17> {
                DBG_TIM8_STOP_W::new(self)
            }
            ///Bit 18 - DBG_TIM5_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim5_stop(&mut self) -> DBG_TIM5_STOP_W<18> {
                DBG_TIM5_STOP_W::new(self)
            }
            ///Bit 19 - DBG_TIM6_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim6_stop(&mut self) -> DBG_TIM6_STOP_W<19> {
                DBG_TIM6_STOP_W::new(self)
            }
            ///Bit 20 - DBG_TIM7_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_tim7_stop(&mut self) -> DBG_TIM7_STOP_W<20> {
                DBG_TIM7_STOP_W::new(self)
            }
            ///Bit 21 - DBG_CAN2_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_can2_stop(&mut self) -> DBG_CAN2_STOP_W<21> {
                DBG_CAN2_STOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DBGMCU_CFGR
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr::R](R) reader structure
        impl crate::Readable for CFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///USB register
pub struct USBHD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USBHD {}
impl USBHD {
    ///Pointer to the register block
    pub const PTR: *const usbhd::RegisterBlock = 0x4002_3400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usbhd::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USBHD {
    type Target = usbhd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USBHD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBHD").finish()
    }
}
///USB register
pub mod usbhd {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - USB base control
        pub usb_ctrl: USB_CTRL,
        ///0x01 - USB device physical prot control
        pub udev_ctrl__r8_uhost_ctrl: UDEV_CTRL__R8_UHOST_CTRL,
        ///0x02 - USB interrupt enable
        pub usb_int_en: USB_INT_EN,
        ///0x03 - USB device address
        pub usb_dev_ad: USB_DEV_AD,
        _reserved4: [u8; 0x01],
        ///0x05 - USB miscellaneous status
        pub usb_mis_st: USB_MIS_ST,
        ///0x06 - USB interrupt flag
        pub usb_int_fg: USB_INT_FG,
        ///0x07 - USB interrupt status
        pub usb_int_st: USB_INT_ST,
        ///0x08 - USB receiving length
        pub usb_rx_len: USB_RX_LEN,
        _reserved8: [u8; 0x03],
        ///0x0c - endpoint 4/1 mode
        pub uep4_1_mod: UEP4_1_MOD,
        ///0x0d - endpoint 2/3 mode;host endpoint mode
        pub uep2_3_mod__r8_uh_ep_mod: UEP2_3_MOD__R8_UH_EP_MOD,
        _reserved10: [u8; 0x02],
        ///0x10 - endpoint 0 DMA buffer address
        pub uep0_dma: UEP0_DMA,
        _reserved11: [u8; 0x02],
        ///0x14 - endpoint 1 DMA buffer address
        pub uep1_dma: UEP1_DMA,
        _reserved12: [u8; 0x02],
        ///0x18 - endpoint 2 DMA buffer address;host rx endpoint buffer high address
        pub uep2_dma__r16_uh_rx_dma: UEP2_DMA__R16_UH_RX_DMA,
        _reserved13: [u8; 0x02],
        ///0x1c - endpoint 3 DMA buffer address;host tx endpoint buffer high address
        pub uep3_dma__r16_uh_tx_dma: UEP3_DMA__R16_UH_TX_DMA,
        _reserved14: [u8; 0x02],
        ///0x20 - endpoint 0 transmittal length
        pub uep0_t_len: UEP0_T_LEN,
        _reserved15: [u8; 0x01],
        ///0x22 - endpoint 0 control
        pub uep0_ctrl: UEP0_CTRL,
        _reserved16: [u8; 0x01],
        ///0x24 - endpoint 1 transmittal length
        pub uep1_t_len: UEP1_T_LEN,
        _reserved17: [u8; 0x01],
        ///0x26 - endpoint 1 control;host aux setup
        pub uep1_ctrl__r8_uh_setup: UEP1_CTRL__R8_UH_SETUP,
        _reserved18: [u8; 0x01],
        ///0x28 - endpoint 2 transmittal length;host endpoint and PID
        pub uep2_t_len__r8_uh_ep_pid: UEP2_T_LEN__R8_UH_EP_PID,
        _reserved19: [u8; 0x01],
        ///0x2a - endpoint 2 control;host receiver endpoint control
        pub uep2_ctrl__r8_uh_rx_ctrl: UEP2_CTRL__R8_UH_RX_CTRL,
        _reserved20: [u8; 0x01],
        ///0x2c - endpoint 3 transmittal length;host transmittal endpoint transmittal length
        pub uep3_t_len__r8_uh_tx_len: UEP3_T_LEN__R8_UH_TX_LEN,
        _reserved21: [u8; 0x01],
        ///0x2e - endpoint 3 control;host transmittal endpoint control
        pub uep3_ctrl__r8_uh_tx_ctrl: UEP3_CTRL__R8_UH_TX_CTRL,
        _reserved22: [u8; 0x01],
        ///0x30 - endpoint 4 transmittal length
        pub uep4_t_len: UEP4_T_LEN,
        _reserved23: [u8; 0x01],
        ///0x32 - endpoint 4 control
        pub uep4_ctrl: UEP4_CTRL,
        _reserved24: [u8; 0x05],
        ///0x38 - USB type-C control
        pub usb_type_c_ctrl: USB_TYPE_C_CTRL,
    }
    ///USB_CTRL (rw) register accessor: an alias for `Reg<USB_CTRL_SPEC>`
    pub type USB_CTRL = crate::Reg<usb_ctrl::USB_CTRL_SPEC>;
    ///USB base control
    pub mod usb_ctrl {
        ///Register `USB_CTRL` reader
        pub struct R(crate::R<USB_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_CTRL` writer
        pub struct W(crate::W<USB_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_R = crate::BitReader<bool>;
        ///Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB
        pub type UC_DMA_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_CLR_ALL` reader - force clear FIFO and count of USB
        pub type UC_CLR_ALL_R = crate::BitReader<bool>;
        ///Field `UC_CLR_ALL` writer - force clear FIFO and count of USB
        pub type UC_CLR_ALL_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_R = crate::BitReader<bool>;
        ///Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear
        pub type UC_RESET_SIE_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_R = crate::BitReader<bool>;
        ///Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
        pub type UC_INT_BUSY_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `MASK_UC_SYS_CTRL` reader - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UC_SYS_CTRL` writer - bit mask of USB system control
        pub type MASK_UC_SYS_CTRL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps
        pub type UC_LOW_SPEED_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        ///Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_R = crate::BitReader<bool>;
        ///Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode
        pub type UC_HOST_MODE_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_CTRL_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UC_DMA_EN_R {
                UC_DMA_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UC_CLR_ALL_R {
                UC_CLR_ALL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UC_RESET_SIE_R {
                UC_RESET_SIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UC_INT_BUSY_R {
                UC_INT_BUSY_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            pub fn mask_uc_sys_ctrl(&self) -> MASK_UC_SYS_CTRL_R {
                MASK_UC_SYS_CTRL_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UC_LOW_SPEED_R {
                UC_LOW_SPEED_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UC_HOST_MODE_R {
                UC_HOST_MODE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA enable and DMA interrupt enable for USB
            #[inline(always)]
            #[must_use]
            pub fn uc_dma_en(&mut self) -> UC_DMA_EN_W<0> {
                UC_DMA_EN_W::new(self)
            }
            ///Bit 1 - force clear FIFO and count of USB
            #[inline(always)]
            #[must_use]
            pub fn uc_clr_all(&mut self) -> UC_CLR_ALL_W<1> {
                UC_CLR_ALL_W::new(self)
            }
            ///Bit 2 - force reset USB SIE, need software clear
            #[inline(always)]
            #[must_use]
            pub fn uc_reset_sie(&mut self) -> UC_RESET_SIE_W<2> {
                UC_RESET_SIE_W::new(self)
            }
            ///Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid
            #[inline(always)]
            #[must_use]
            pub fn uc_int_busy(&mut self) -> UC_INT_BUSY_W<3> {
                UC_INT_BUSY_W::new(self)
            }
            ///Bits 4:5 - bit mask of USB system control
            #[inline(always)]
            #[must_use]
            pub fn mask_uc_sys_ctrl(&mut self) -> MASK_UC_SYS_CTRL_W<4> {
                MASK_UC_SYS_CTRL_W::new(self)
            }
            ///Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps
            #[inline(always)]
            #[must_use]
            pub fn uc_low_speed(&mut self) -> UC_LOW_SPEED_W<6> {
                UC_LOW_SPEED_W::new(self)
            }
            ///Bit 7 - enable USB host mode: 0=device mode, 1=host mode
            #[inline(always)]
            #[must_use]
            pub fn uc_host_mode(&mut self) -> UC_HOST_MODE_W<7> {
                UC_HOST_MODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB base control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_ctrl](index.html) module
        pub struct USB_CTRL_SPEC;
        impl crate::RegisterSpec for USB_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_ctrl::R](R) reader structure
        impl crate::Readable for USB_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_ctrl::W](W) writer structure
        impl crate::Writable for USB_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_CTRL to value 0
        impl crate::Resettable for USB_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UDEV_CTRL__R8_UHOST_CTRL (rw) register accessor: an alias for `Reg<UDEV_CTRL__R8_UHOST_CTRL_SPEC>`
    pub type UDEV_CTRL__R8_UHOST_CTRL =
        crate::Reg<udev_ctrl__r8_uhost_ctrl::UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
    ///USB device physical prot control
    pub mod udev_ctrl__r8_uhost_ctrl {
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` reader
        pub struct R(crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UDEV_CTRL__R8_UHOST_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UDEV_CTRL__R8_UHOST_CTRL` writer
        pub struct W(crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UDEV_CTRL__R8_UHOST_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` reader - enable USB physical port I/O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_R = crate::BitReader<bool>;
        ///Field `UD_PORT_EN__RB_UH_PORT_EN` writer - enable USB physical port I/O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
        pub type UD_PORT_EN__RB_UH_PORT_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` reader - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `UD_GP_BIT__RB_UH_BUS_RESET` writer - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
        pub type UD_GP_BIT__RB_UH_BUS_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_R = crate::BitReader<bool>;
        ///Field `UD_LOW_SPEED__RB_UH_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
        pub type UD_LOW_SPEED__RB_UH_LOW_SPEED_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UDEV_CTRL__R8_UHOST_CTRL_SPEC, bool, O>;
        ///Field `UD_DM_PIN__RB_UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level
        pub type UD_DM_PIN__RB_UH_DM_PIN_R = crate::BitReader<bool>;
        ///Field `UD_DP_PIN__RB_UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level
        pub type UD_DP_PIN__RB_UH_DP_PIN_R = crate::BitReader<bool>;
        ///Field `UD_PD_DIS__RB_UH_PD_DIS` reader - disable USB UDP/UDM pulldown resistance: 0=enable pulldown, 1=disable
        pub type UD_PD_DIS__RB_UH_PD_DIS_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - enable USB physical port I/O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            pub fn ud_port_en__rb_uh_port_en(&self) -> UD_PORT_EN__RB_UH_PORT_EN_R {
                UD_PORT_EN__RB_UH_PORT_EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            pub fn ud_gp_bit__rb_uh_bus_reset(&self) -> UD_GP_BIT__RB_UH_BUS_RESET_R {
                UD_GP_BIT__RB_UH_BUS_RESET_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            pub fn ud_low_speed__rb_uh_low_speed(&self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_R {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - ReadOnly: indicate current UDM pin level
            #[inline(always)]
            pub fn ud_dm_pin__rb_uh_dm_pin(&self) -> UD_DM_PIN__RB_UH_DM_PIN_R {
                UD_DM_PIN__RB_UH_DM_PIN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - ReadOnly: indicate current UDP pin level
            #[inline(always)]
            pub fn ud_dp_pin__rb_uh_dp_pin(&self) -> UD_DP_PIN__RB_UH_DP_PIN_R {
                UD_DP_PIN__RB_UH_DP_PIN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 7 - disable USB UDP/UDM pulldown resistance: 0=enable pulldown, 1=disable
            #[inline(always)]
            pub fn ud_pd_dis__rb_uh_pd_dis(&self) -> UD_PD_DIS__RB_UH_PD_DIS_R {
                UD_PD_DIS__RB_UH_PD_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable USB physical port I/O: 0=disable, 1=enable;enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached
            #[inline(always)]
            #[must_use]
            pub fn ud_port_en__rb_uh_port_en(&mut self) -> UD_PORT_EN__RB_UH_PORT_EN_W<0> {
                UD_PORT_EN__RB_UH_PORT_EN_W::new(self)
            }
            ///Bit 1 - general purpose bit;control USB bus reset: 0=normal, 1=force bus reset
            #[inline(always)]
            #[must_use]
            pub fn ud_gp_bit__rb_uh_bus_reset(&mut self) -> UD_GP_BIT__RB_UH_BUS_RESET_W<1> {
                UD_GP_BIT__RB_UH_BUS_RESET_W::new(self)
            }
            ///Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed;enable USB port low speed: 0=full speed, 1=low speed
            #[inline(always)]
            #[must_use]
            pub fn ud_low_speed__rb_uh_low_speed(&mut self) -> UD_LOW_SPEED__RB_UH_LOW_SPEED_W<2> {
                UD_LOW_SPEED__RB_UH_LOW_SPEED_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device physical prot control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [udev_ctrl__r8_uhost_ctrl](index.html) module
        pub struct UDEV_CTRL__R8_UHOST_CTRL_SPEC;
        impl crate::RegisterSpec for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [udev_ctrl__r8_uhost_ctrl::R](R) reader structure
        impl crate::Readable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [udev_ctrl__r8_uhost_ctrl::W](W) writer structure
        impl crate::Writable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UDEV_CTRL__R8_UHOST_CTRL to value 0
        impl crate::Resettable for UDEV_CTRL__R8_UHOST_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_INT_EN (rw) register accessor: an alias for `Reg<USB_INT_EN_SPEC>`
    pub type USB_INT_EN = crate::Reg<usb_int_en::USB_INT_EN_SPEC>;
    ///USB interrupt enable
    pub mod usb_int_en {
        ///Register `USB_INT_EN` reader
        pub struct R(crate::R<USB_INT_EN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_EN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_EN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_INT_EN` writer
        pub struct W(crate::W<USB_INT_EN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_INT_EN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_INT_EN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_INT_EN_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` reader - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_R = crate::BitReader<bool>;
        ///Field `UIE_BUS_RST__RB_UIE_DETECT` writer - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
        pub type UIE_BUS_RST__RB_UIE_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_R = crate::BitReader<bool>;
        ///Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion
        pub type UIE_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event
        pub type UIE_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_R = crate::BitReader<bool>;
        ///Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode
        pub type UIE_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow
        pub type UIE_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_R = crate::BitReader<bool>;
        ///Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode
        pub type UIE_DEV_NAK_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        ///Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_R = crate::BitReader<bool>;
        ///Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode
        pub type UIE_DEV_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_EN_SPEC, bool, O>;
        impl R {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            pub fn uie_bus_rst__rb_uie_detect(&self) -> UIE_BUS_RST__RB_UIE_DETECT_R {
                UIE_BUS_RST__RB_UIE_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            pub fn uie_transfer(&self) -> UIE_TRANSFER_R {
                UIE_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            pub fn uie_suspend(&self) -> UIE_SUSPEND_R {
                UIE_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UIE_HST_SOF_R {
                UIE_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UIE_FIFO_OV_R {
                UIE_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UIE_DEV_NAK_R {
                UIE_DEV_NAK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UIE_DEV_SOF_R {
                UIE_DEV_SOF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - enable interrupt for USB bus reset event for USB device mode;enable interrupt for USB device detected event for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_bus_rst__rb_uie_detect(&mut self) -> UIE_BUS_RST__RB_UIE_DETECT_W<0> {
                UIE_BUS_RST__RB_UIE_DETECT_W::new(self)
            }
            ///Bit 1 - enable interrupt for USB transfer completion
            #[inline(always)]
            #[must_use]
            pub fn uie_transfer(&mut self) -> UIE_TRANSFER_W<1> {
                UIE_TRANSFER_W::new(self)
            }
            ///Bit 2 - enable interrupt for USB suspend or resume event
            #[inline(always)]
            #[must_use]
            pub fn uie_suspend(&mut self) -> UIE_SUSPEND_W<2> {
                UIE_SUSPEND_W::new(self)
            }
            ///Bit 3 - enable interrupt for host SOF timer action for USB host mode
            #[inline(always)]
            #[must_use]
            pub fn uie_hst_sof(&mut self) -> UIE_HST_SOF_W<3> {
                UIE_HST_SOF_W::new(self)
            }
            ///Bit 4 - enable interrupt for FIFO overflow
            #[inline(always)]
            #[must_use]
            pub fn uie_fifo_ov(&mut self) -> UIE_FIFO_OV_W<4> {
                UIE_FIFO_OV_W::new(self)
            }
            ///Bit 6 - enable interrupt for NAK responded for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_nak(&mut self) -> UIE_DEV_NAK_W<6> {
                UIE_DEV_NAK_W::new(self)
            }
            ///Bit 7 - enable interrupt for SOF received for USB device mode
            #[inline(always)]
            #[must_use]
            pub fn uie_dev_sof(&mut self) -> UIE_DEV_SOF_W<7> {
                UIE_DEV_SOF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt enable
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_en](index.html) module
        pub struct USB_INT_EN_SPEC;
        impl crate::RegisterSpec for USB_INT_EN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_en::R](R) reader structure
        impl crate::Readable for USB_INT_EN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_int_en::W](W) writer structure
        impl crate::Writable for USB_INT_EN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_INT_EN to value 0
        impl crate::Resettable for USB_INT_EN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_DEV_AD (rw) register accessor: an alias for `Reg<USB_DEV_AD_SPEC>`
    pub type USB_DEV_AD = crate::Reg<usb_dev_ad::USB_DEV_AD_SPEC>;
    ///USB device address
    pub mod usb_dev_ad {
        ///Register `USB_DEV_AD` reader
        pub struct R(crate::R<USB_DEV_AD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_DEV_AD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_DEV_AD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_DEV_AD` writer
        pub struct W(crate::W<USB_DEV_AD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_DEV_AD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_DEV_AD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_DEV_AD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_USB_ADDR` reader - bit mask for USB device address
        pub type MASK_USB_ADDR_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_USB_ADDR` writer - bit mask for USB device address
        pub type MASK_USB_ADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB_DEV_AD_SPEC, u8, u8, 7, O>;
        ///Field `UDA_GP_BIT` reader - general purpose bit
        pub type UDA_GP_BIT_R = crate::BitReader<bool>;
        ///Field `UDA_GP_BIT` writer - general purpose bit
        pub type UDA_GP_BIT_W<'a, const O: u8> = crate::BitWriter<'a, u8, USB_DEV_AD_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            pub fn mask_usb_addr(&self) -> MASK_USB_ADDR_R {
                MASK_USB_ADDR_R::new(self.bits & 0x7f)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UDA_GP_BIT_R {
                UDA_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - bit mask for USB device address
            #[inline(always)]
            #[must_use]
            pub fn mask_usb_addr(&mut self) -> MASK_USB_ADDR_W<0> {
                MASK_USB_ADDR_W::new(self)
            }
            ///Bit 7 - general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn uda_gp_bit(&mut self) -> UDA_GP_BIT_W<7> {
                UDA_GP_BIT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB device address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_dev_ad](index.html) module
        pub struct USB_DEV_AD_SPEC;
        impl crate::RegisterSpec for USB_DEV_AD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_dev_ad::R](R) reader structure
        impl crate::Readable for USB_DEV_AD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_dev_ad::W](W) writer structure
        impl crate::Writable for USB_DEV_AD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_DEV_AD to value 0
        impl crate::Resettable for USB_DEV_AD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_MIS_ST (r) register accessor: an alias for `Reg<USB_MIS_ST_SPEC>`
    pub type USB_MIS_ST = crate::Reg<usb_mis_st::USB_MIS_ST_SPEC>;
    ///USB miscellaneous status
    pub mod usb_mis_st {
        ///Register `USB_MIS_ST` reader
        pub struct R(crate::R<USB_MIS_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_MIS_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_MIS_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_MIS_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host
        pub type UMS_DEV_ATTACH_R = crate::BitReader<bool>;
        ///Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host
        pub type UMS_DM_LEVEL_R = crate::BitReader<bool>;
        ///Field `UMS_SUSPEND` reader - RO, indicate USB suspend status
        pub type UMS_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status
        pub type UMS_BUS_RESET_R = crate::BitReader<bool>;
        ///Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)
        pub type UMS_R_FIFO_RDY_R = crate::BitReader<bool>;
        ///Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type UMS_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host
        pub type UMS_SOF_ACT_R = crate::BitReader<bool>;
        ///Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status
        pub type UMS_SOF_PRES_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - RO, indicate device attached status on USB host
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UMS_DEV_ATTACH_R {
                UMS_DEV_ATTACH_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - RO, indicate UDM level saved at device attached to USB host
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UMS_DM_LEVEL_R {
                UMS_DM_LEVEL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - RO, indicate USB suspend status
            #[inline(always)]
            pub fn ums_suspend(&self) -> UMS_SUSPEND_R {
                UMS_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - RO, indicate USB bus reset status
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UMS_BUS_RESET_R {
                UMS_BUS_RESET_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UMS_R_FIFO_RDY_R {
                UMS_R_FIFO_RDY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UMS_SIE_FREE_R {
                UMS_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate host SOF timer action status for USB host
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UMS_SOF_ACT_R {
                UMS_SOF_ACT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate host SOF timer presage status
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UMS_SOF_PRES_R {
                UMS_SOF_PRES_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB miscellaneous status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_mis_st](index.html) module
        pub struct USB_MIS_ST_SPEC;
        impl crate::RegisterSpec for USB_MIS_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_mis_st::R](R) reader structure
        impl crate::Readable for USB_MIS_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_MIS_ST to value 0
        impl crate::Resettable for USB_MIS_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_INT_FG (rw) register accessor: an alias for `Reg<USB_INT_FG_SPEC>`
    pub type USB_INT_FG = crate::Reg<usb_int_fg::USB_INT_FG_SPEC>;
    ///USB interrupt flag
    pub mod usb_int_fg {
        ///Register `USB_INT_FG` reader
        pub struct R(crate::R<USB_INT_FG_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_FG_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_FG_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_INT_FG` writer
        pub struct W(crate::W<USB_INT_FG_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_INT_FG_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_INT_FG_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_INT_FG_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` reader - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_R = crate::BitReader<bool>;
        ///Field `UIF_BUS_RST__RB_UIF_DETECT` writer - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
        pub type UIF_BUS_RST__RB_UIF_DETECT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_TRANSFER` reader - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_R = crate::BitReader<bool>;
        ///Field `UIF_TRANSFER` writer - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_TRANSFER_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_SUSPEND` reader - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_R = crate::BitReader<bool>;
        ///Field `UIF_SUSPEND` writer - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
        pub type UIF_SUSPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_HST_SOF` reader - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_R = crate::BitReader<bool>;
        ///Field `UIF_HST_SOF` writer - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
        pub type UIF_HST_SOF_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `UIF_FIFO_OV` reader - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_R = crate::BitReader<bool>;
        ///Field `UIF_FIFO_OV` writer - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
        pub type UIF_FIFO_OV_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_INT_FG_SPEC, bool, O>;
        ///Field `U_SIE_FREE` reader - RO, indicate USB SIE free status
        pub type U_SIE_FREE_R = crate::BitReader<bool>;
        ///Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type U_TOG_OK_R = crate::BitReader<bool>;
        ///Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received
        pub type U_IS_NAK_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_bus_rst__rb_uif_detect(&self) -> UIF_BUS_RST__RB_UIF_DETECT_R {
                UIF_BUS_RST__RB_UIF_DETECT_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_transfer(&self) -> UIF_TRANSFER_R {
                UIF_TRANSFER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_suspend(&self) -> UIF_SUSPEND_R {
                UIF_SUSPEND_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UIF_HST_SOF_R {
                UIF_HST_SOF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UIF_FIFO_OV_R {
                UIF_FIFO_OV_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RO, indicate USB SIE free status
            #[inline(always)]
            pub fn u_sie_free(&self) -> U_SIE_FREE_R {
                U_SIE_FREE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn u_tog_ok(&self) -> U_TOG_OK_R {
                U_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received
            #[inline(always)]
            pub fn u_is_nak(&self) -> U_IS_NAK_R {
                U_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear;device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_bus_rst__rb_uif_detect(&mut self) -> UIF_BUS_RST__RB_UIF_DETECT_W<0> {
                UIF_BUS_RST__RB_UIF_DETECT_W::new(self)
            }
            ///Bit 1 - USB transfer completion interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_transfer(&mut self) -> UIF_TRANSFER_W<1> {
                UIF_TRANSFER_W::new(self)
            }
            ///Bit 2 - USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_suspend(&mut self) -> UIF_SUSPEND_W<2> {
                UIF_SUSPEND_W::new(self)
            }
            ///Bit 3 - host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_hst_sof(&mut self) -> UIF_HST_SOF_W<3> {
                UIF_HST_SOF_W::new(self)
            }
            ///Bit 4 - FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear
            #[inline(always)]
            #[must_use]
            pub fn uif_fifo_ov(&mut self) -> UIF_FIFO_OV_W<4> {
                UIF_FIFO_OV_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB interrupt flag
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_fg](index.html) module
        pub struct USB_INT_FG_SPEC;
        impl crate::RegisterSpec for USB_INT_FG_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_fg::R](R) reader structure
        impl crate::Readable for USB_INT_FG_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_int_fg::W](W) writer structure
        impl crate::Writable for USB_INT_FG_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_INT_FG to value 0
        impl crate::Resettable for USB_INT_FG_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_INT_ST (r) register accessor: an alias for `Reg<USB_INT_ST_SPEC>`
    pub type USB_INT_ST = crate::Reg<usb_int_st::USB_INT_ST_SPEC>;
    ///USB interrupt status
    pub mod usb_int_st {
        ///Register `USB_INT_ST` reader
        pub struct R(crate::R<USB_INT_ST_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_INT_ST_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_INT_ST_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_INT_ST_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MASK_UIS_H_RES__MASK_UIS_ENDP` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
        pub type MASK_UIS_H_RES__MASK_UIS_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode
        pub type MASK_UIS_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK
        pub type UIS_TOG_OK_R = crate::BitReader<bool>;
        ///Field `UIS_IS_NAK` reader - RO, indicate current USB transfer is NAK received for USB device mode
        pub type UIS_IS_NAK_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received;RO, bit mask of current transfer endpoint number for USB device mode
            #[inline(always)]
            pub fn mask_uis_h_res__mask_uis_endp(&self) -> MASK_UIS_H_RES__MASK_UIS_ENDP_R {
                MASK_UIS_H_RES__MASK_UIS_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:5 - RO, bit mask of current token PID code received for USB device mode
            #[inline(always)]
            pub fn mask_uis_token(&self) -> MASK_UIS_TOKEN_R {
                MASK_UIS_TOKEN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - RO, indicate current USB transfer toggle is OK
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UIS_TOG_OK_R {
                UIS_TOG_OK_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode
            #[inline(always)]
            pub fn uis_is_nak(&self) -> UIS_IS_NAK_R {
                UIS_IS_NAK_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///USB interrupt status
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_int_st](index.html) module
        pub struct USB_INT_ST_SPEC;
        impl crate::RegisterSpec for USB_INT_ST_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_int_st::R](R) reader structure
        impl crate::Readable for USB_INT_ST_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_INT_ST to value 0
        impl crate::Resettable for USB_INT_ST_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_RX_LEN (r) register accessor: an alias for `Reg<USB_RX_LEN_SPEC>`
    pub type USB_RX_LEN = crate::Reg<usb_rx_len::USB_RX_LEN_SPEC>;
    ///USB receiving length
    pub mod usb_rx_len {
        ///Register `USB_RX_LEN` reader
        pub struct R(crate::R<USB_RX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_RX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_RX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_RX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///USB receiving length
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_rx_len](index.html) module
        pub struct USB_RX_LEN_SPEC;
        impl crate::RegisterSpec for USB_RX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_rx_len::R](R) reader structure
        impl crate::Readable for USB_RX_LEN_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets USB_RX_LEN to value 0
        impl crate::Resettable for USB_RX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_1_MOD (rw) register accessor: an alias for `Reg<UEP4_1_MOD_SPEC>`
    pub type UEP4_1_MOD = crate::Reg<uep4_1_mod::UEP4_1_MOD_SPEC>;
    ///endpoint 4/1 mode
    pub mod uep4_1_mod {
        ///Register `UEP4_1_MOD` reader
        pub struct R(crate::R<UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_1_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_1_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_1_MOD` writer
        pub struct W(crate::W<UEP4_1_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_1_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_1_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_1_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)
        pub type UEP4_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)
        pub type UEP4_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1
        pub type UEP1_BUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)
        pub type UEP1_TX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        ///Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)
        pub type UEP1_RX_EN_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_1_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> UEP4_TX_EN_R {
                UEP4_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> UEP4_RX_EN_R {
                UEP4_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> UEP1_BUF_MOD_R {
                UEP1_BUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> UEP1_TX_EN_R {
                UEP1_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> UEP1_RX_EN_R {
                UEP1_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - enable USB endpoint 4 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep4_tx_en(&mut self) -> UEP4_TX_EN_W<2> {
                UEP4_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 4 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep4_rx_en(&mut self) -> UEP4_RX_EN_W<3> {
                UEP4_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 1
            #[inline(always)]
            #[must_use]
            pub fn uep1_buf_mod(&mut self) -> UEP1_BUF_MOD_W<4> {
                UEP1_BUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 1 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep1_tx_en(&mut self) -> UEP1_TX_EN_W<6> {
                UEP1_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 1 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep1_rx_en(&mut self) -> UEP1_RX_EN_W<7> {
                UEP1_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4/1 mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_1_mod](index.html) module
        pub struct UEP4_1_MOD_SPEC;
        impl crate::RegisterSpec for UEP4_1_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_1_mod::R](R) reader structure
        impl crate::Readable for UEP4_1_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_1_mod::W](W) writer structure
        impl crate::Writable for UEP4_1_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_1_MOD to value 0
        impl crate::Resettable for UEP4_1_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_3_MOD__R8_UH_EP_MOD (rw) register accessor: an alias for `Reg<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>`
    pub type UEP2_3_MOD__R8_UH_EP_MOD =
        crate::Reg<uep2_3_mod__r8_uh_ep_mod::UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
    ///endpoint 2/3 mode;host endpoint mode
    pub mod uep2_3_mod__r8_uh_ep_mod {
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` reader
        pub struct R(crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_3_MOD__R8_UH_EP_MOD` writer
        pub struct W(crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_3_MOD__R8_UH_EP_MOD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` reader - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD` writer - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
        pub type UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)
        pub type UEP2_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` reader - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP2_RX_EN__RB_UH_EP_RX_EN` writer - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
        pub type UEP2_RX_EN__RB_UH_EP_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` reader - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R = crate::BitReader<bool>;
        ///Field `UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD` writer - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
        pub type UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` reader - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_R = crate::BitReader<bool>;
        ///Field `UEP3_TX_EN__RB_UH_EP_TX_EN` writer - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
        pub type UEP3_TX_EN__RB_UH_EP_TX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        ///Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_R = crate::BitReader<bool>;
        ///Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)
        pub type UEP3_RX_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_3_MOD__R8_UH_EP_MOD_SPEC, bool, O>;
        impl R {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(&self) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> UEP2_TX_EN_R {
                UEP2_TX_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_R {
                UEP2_RX_EN__RB_UH_EP_RX_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(&self) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_R {
                UEP3_TX_EN__RB_UH_EP_TX_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> UEP3_RX_EN_R {
                UEP3_RX_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - buffer mode of USB endpoint 2;buffer mode of USB host IN endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep2_buf_mod__rb_uh_ep_rbuf_mod(
                &mut self,
            ) -> UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W<0> {
                UEP2_BUF_MOD__RB_UH_EP_RBUF_MOD_W::new(self)
            }
            ///Bit 2 - enable USB endpoint 2 transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn uep2_tx_en(&mut self) -> UEP2_TX_EN_W<2> {
                UEP2_TX_EN_W::new(self)
            }
            ///Bit 3 - enable USB endpoint 2 receiving (OUT);enable USB host IN endpoint receiving
            #[inline(always)]
            #[must_use]
            pub fn uep2_rx_en__rb_uh_ep_rx_en(&mut self) -> UEP2_RX_EN__RB_UH_EP_RX_EN_W<3> {
                UEP2_RX_EN__RB_UH_EP_RX_EN_W::new(self)
            }
            ///Bit 4 - buffer mode of USB endpoint 3;buffer mode of USB host OUT endpoint
            #[inline(always)]
            #[must_use]
            pub fn uep3_buf_mod__rb_uh_ep_tbuf_mod(
                &mut self,
            ) -> UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W<4> {
                UEP3_BUF_MOD__RB_UH_EP_TBUF_MOD_W::new(self)
            }
            ///Bit 6 - enable USB endpoint 3 transmittal (IN);enable USB host OUT endpoint transmittal
            #[inline(always)]
            #[must_use]
            pub fn uep3_tx_en__rb_uh_ep_tx_en(&mut self) -> UEP3_TX_EN__RB_UH_EP_TX_EN_W<6> {
                UEP3_TX_EN__RB_UH_EP_TX_EN_W::new(self)
            }
            ///Bit 7 - enable USB endpoint 3 receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn uep3_rx_en(&mut self) -> UEP3_RX_EN_W<7> {
                UEP3_RX_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2/3 mode;host endpoint mode
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_3_mod__r8_uh_ep_mod](index.html) module
        pub struct UEP2_3_MOD__R8_UH_EP_MOD_SPEC;
        impl crate::RegisterSpec for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_3_mod__r8_uh_ep_mod::R](R) reader structure
        impl crate::Readable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_3_mod__r8_uh_ep_mod::W](W) writer structure
        impl crate::Writable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_3_MOD__R8_UH_EP_MOD to value 0
        impl crate::Resettable for UEP2_3_MOD__R8_UH_EP_MOD_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_DMA (rw) register accessor: an alias for `Reg<UEP0_DMA_SPEC>`
    pub type UEP0_DMA = crate::Reg<uep0_dma::UEP0_DMA_SPEC>;
    ///endpoint 0 DMA buffer address
    pub mod uep0_dma {
        ///Register `UEP0_DMA` reader
        pub struct R(crate::R<UEP0_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_DMA` writer
        pub struct W(crate::W<UEP0_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_dma](index.html) module
        pub struct UEP0_DMA_SPEC;
        impl crate::RegisterSpec for UEP0_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep0_dma::R](R) reader structure
        impl crate::Readable for UEP0_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_dma::W](W) writer structure
        impl crate::Writable for UEP0_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_DMA to value 0
        impl crate::Resettable for UEP0_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_DMA (rw) register accessor: an alias for `Reg<UEP1_DMA_SPEC>`
    pub type UEP1_DMA = crate::Reg<uep1_dma::UEP1_DMA_SPEC>;
    ///endpoint 1 DMA buffer address
    pub mod uep1_dma {
        ///Register `UEP1_DMA` reader
        pub struct R(crate::R<UEP1_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_DMA` writer
        pub struct W(crate::W<UEP1_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 DMA buffer address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_dma](index.html) module
        pub struct UEP1_DMA_SPEC;
        impl crate::RegisterSpec for UEP1_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep1_dma::R](R) reader structure
        impl crate::Readable for UEP1_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_dma::W](W) writer structure
        impl crate::Writable for UEP1_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_DMA to value 0
        impl crate::Resettable for UEP1_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_DMA__R16_UH_RX_DMA (rw) register accessor: an alias for `Reg<UEP2_DMA__R16_UH_RX_DMA_SPEC>`
    pub type UEP2_DMA__R16_UH_RX_DMA =
        crate::Reg<uep2_dma__r16_uh_rx_dma::UEP2_DMA__R16_UH_RX_DMA_SPEC>;
    ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
    pub mod uep2_dma__r16_uh_rx_dma {
        ///Register `UEP2_DMA__R16_UH_RX_DMA` reader
        pub struct R(crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_DMA__R16_UH_RX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_DMA__R16_UH_RX_DMA` writer
        pub struct W(crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_DMA__R16_UH_RX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 DMA buffer address;host rx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_dma__r16_uh_rx_dma](index.html) module
        pub struct UEP2_DMA__R16_UH_RX_DMA_SPEC;
        impl crate::RegisterSpec for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep2_dma__r16_uh_rx_dma::R](R) reader structure
        impl crate::Readable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_dma__r16_uh_rx_dma::W](W) writer structure
        impl crate::Writable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_DMA__R16_UH_RX_DMA to value 0
        impl crate::Resettable for UEP2_DMA__R16_UH_RX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_DMA__R16_UH_TX_DMA (rw) register accessor: an alias for `Reg<UEP3_DMA__R16_UH_TX_DMA_SPEC>`
    pub type UEP3_DMA__R16_UH_TX_DMA =
        crate::Reg<uep3_dma__r16_uh_tx_dma::UEP3_DMA__R16_UH_TX_DMA_SPEC>;
    ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
    pub mod uep3_dma__r16_uh_tx_dma {
        ///Register `UEP3_DMA__R16_UH_TX_DMA` reader
        pub struct R(crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_DMA__R16_UH_TX_DMA_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_DMA__R16_UH_TX_DMA` writer
        pub struct W(crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_DMA__R16_UH_TX_DMA_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 DMA buffer address;host tx endpoint buffer high address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_dma__r16_uh_tx_dma](index.html) module
        pub struct UEP3_DMA__R16_UH_TX_DMA_SPEC;
        impl crate::RegisterSpec for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [uep3_dma__r16_uh_tx_dma::R](R) reader structure
        impl crate::Readable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_dma__r16_uh_tx_dma::W](W) writer structure
        impl crate::Writable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_DMA__R16_UH_TX_DMA to value 0
        impl crate::Resettable for UEP3_DMA__R16_UH_TX_DMA_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_T_LEN (rw) register accessor: an alias for `Reg<UEP0_T_LEN_SPEC>`
    pub type UEP0_T_LEN = crate::Reg<uep0_t_len::UEP0_T_LEN_SPEC>;
    ///endpoint 0 transmittal length
    pub mod uep0_t_len {
        ///Register `UEP0_T_LEN` reader
        pub struct R(crate::R<UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_T_LEN` writer
        pub struct W(crate::W<UEP0_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_t_len](index.html) module
        pub struct UEP0_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP0_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep0_t_len::R](R) reader structure
        impl crate::Readable for UEP0_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_t_len::W](W) writer structure
        impl crate::Writable for UEP0_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_T_LEN to value 0
        impl crate::Resettable for UEP0_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP0_CTRL (rw) register accessor: an alias for `Reg<UEP0_CTRL_SPEC>`
    pub type UEP0_CTRL = crate::Reg<uep0_ctrl::UEP0_CTRL_SPEC>;
    ///endpoint 0 control
    pub mod uep0_ctrl {
        ///Register `UEP0_CTRL` reader
        pub struct R(crate::R<UEP0_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP0_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP0_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP0_CTRL` writer
        pub struct W(crate::W<UEP0_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP0_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP0_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP0_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP0_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP0_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP0_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP0_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep0_ctrl](index.html) module
        pub struct UEP0_CTRL_SPEC;
        impl crate::RegisterSpec for UEP0_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep0_ctrl::R](R) reader structure
        impl crate::Readable for UEP0_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep0_ctrl::W](W) writer structure
        impl crate::Writable for UEP0_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP0_CTRL to value 0
        impl crate::Resettable for UEP0_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_T_LEN (rw) register accessor: an alias for `Reg<UEP1_T_LEN_SPEC>`
    pub type UEP1_T_LEN = crate::Reg<uep1_t_len::UEP1_T_LEN_SPEC>;
    ///endpoint 1 transmittal length
    pub mod uep1_t_len {
        ///Register `UEP1_T_LEN` reader
        pub struct R(crate::R<UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_T_LEN` writer
        pub struct W(crate::W<UEP1_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_t_len](index.html) module
        pub struct UEP1_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP1_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep1_t_len::R](R) reader structure
        impl crate::Readable for UEP1_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_t_len::W](W) writer structure
        impl crate::Writable for UEP1_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_T_LEN to value 0
        impl crate::Resettable for UEP1_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP1_CTRL__R8_UH_SETUP (rw) register accessor: an alias for `Reg<UEP1_CTRL__R8_UH_SETUP_SPEC>`
    pub type UEP1_CTRL__R8_UH_SETUP =
        crate::Reg<uep1_ctrl__r8_uh_setup::UEP1_CTRL__R8_UH_SETUP_SPEC>;
    ///endpoint 1 control;host aux setup
    pub mod uep1_ctrl__r8_uh_setup {
        ///Register `UEP1_CTRL__R8_UH_SETUP` reader
        pub struct R(crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP1_CTRL__R8_UH_SETUP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP1_CTRL__R8_UH_SETUP` writer
        pub struct W(crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP1_CTRL__R8_UH_SETUP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG__RB_UH_SOF_EN` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
        pub type UEP_T_TOG__RB_UH_SOF_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG__RB_UH_PRE_PID_EN` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
        pub type UEP_R_TOG__RB_UH_PRE_PID_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP1_CTRL__R8_UH_SETUP_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            pub fn uep_t_tog__rb_uh_sof_en(&self) -> UEP_T_TOG__RB_UH_SOF_EN_R {
                UEP_T_TOG__RB_UH_SOF_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_R {
                UEP_R_TOG__RB_UH_PRE_PID_EN_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1;USB host automatic SOF enable
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog__rb_uh_sof_en(&mut self) -> UEP_T_TOG__RB_UH_SOF_EN_W<6> {
                UEP_T_TOG__RB_UH_SOF_EN_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;RB_UH_PRE_PID_EN;USB host PRE PID enable for low speed device via hub
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_pre_pid_en(&mut self) -> UEP_R_TOG__RB_UH_PRE_PID_EN_W<7> {
                UEP_R_TOG__RB_UH_PRE_PID_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 control;host aux setup
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep1_ctrl__r8_uh_setup](index.html) module
        pub struct UEP1_CTRL__R8_UH_SETUP_SPEC;
        impl crate::RegisterSpec for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep1_ctrl__r8_uh_setup::R](R) reader structure
        impl crate::Readable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep1_ctrl__r8_uh_setup::W](W) writer structure
        impl crate::Writable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP1_CTRL__R8_UH_SETUP to value 0
        impl crate::Resettable for UEP1_CTRL__R8_UH_SETUP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_T_LEN__R8_UH_EP_PID (rw) register accessor: an alias for `Reg<UEP2_T_LEN__R8_UH_EP_PID_SPEC>`
    pub type UEP2_T_LEN__R8_UH_EP_PID =
        crate::Reg<uep2_t_len__r8_uh_ep_pid::UEP2_T_LEN__R8_UH_EP_PID_SPEC>;
    ///endpoint 2 transmittal length;host endpoint and PID
    pub mod uep2_t_len__r8_uh_ep_pid {
        ///Register `UEP2_T_LEN__R8_UH_EP_PID` reader
        pub struct R(crate::R<UEP2_T_LEN__R8_UH_EP_PID_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_T_LEN__R8_UH_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_T_LEN__R8_UH_EP_PID_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_T_LEN__R8_UH_EP_PID_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_T_LEN__R8_UH_EP_PID` writer
        pub struct W(crate::W<UEP2_T_LEN__R8_UH_EP_PID_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_T_LEN__R8_UH_EP_PID_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_T_LEN__R8_UH_EP_PID_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_T_LEN__R8_UH_EP_PID_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UH_ENDP` reader - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_ENDP` writer - bit mask of endpoint number for USB host transfer
        pub type MASK_UH_ENDP_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_T_LEN__R8_UH_EP_PID_SPEC, u8, u8, 4, O>;
        ///Field `MASK_UH_TOKEN` reader - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UH_TOKEN` writer - bit mask of token PID for USB host transfer
        pub type MASK_UH_TOKEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_T_LEN__R8_UH_EP_PID_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            pub fn mask_uh_endp(&self) -> MASK_UH_ENDP_R {
                MASK_UH_ENDP_R::new(self.bits & 0x0f)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            pub fn mask_uh_token(&self) -> MASK_UH_TOKEN_R {
                MASK_UH_TOKEN_R::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            ///Bits 0:3 - bit mask of endpoint number for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_endp(&mut self) -> MASK_UH_ENDP_W<0> {
                MASK_UH_ENDP_W::new(self)
            }
            ///Bits 4:7 - bit mask of token PID for USB host transfer
            #[inline(always)]
            #[must_use]
            pub fn mask_uh_token(&mut self) -> MASK_UH_TOKEN_W<4> {
                MASK_UH_TOKEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 transmittal length;host endpoint and PID
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_t_len__r8_uh_ep_pid](index.html) module
        pub struct UEP2_T_LEN__R8_UH_EP_PID_SPEC;
        impl crate::RegisterSpec for UEP2_T_LEN__R8_UH_EP_PID_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_t_len__r8_uh_ep_pid::R](R) reader structure
        impl crate::Readable for UEP2_T_LEN__R8_UH_EP_PID_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_t_len__r8_uh_ep_pid::W](W) writer structure
        impl crate::Writable for UEP2_T_LEN__R8_UH_EP_PID_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_T_LEN__R8_UH_EP_PID to value 0
        impl crate::Resettable for UEP2_T_LEN__R8_UH_EP_PID_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP2_CTRL__R8_UH_RX_CTRL (rw) register accessor: an alias for `Reg<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>`
    pub type UEP2_CTRL__R8_UH_RX_CTRL =
        crate::Reg<uep2_ctrl__r8_uh_rx_ctrl::UEP2_CTRL__R8_UH_RX_CTRL_SPEC>;
    ///endpoint 2 control;host receiver endpoint control
    pub mod uep2_ctrl__r8_uh_rx_ctrl {
        ///Register `UEP2_CTRL__R8_UH_RX_CTRL` reader
        pub struct R(crate::R<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP2_CTRL__R8_UH_RX_CTRL` writer
        pub struct W(crate::W<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP2_CTRL__R8_UH_RX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_CTRL__R8_UH_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP2_CTRL__R8_UH_RX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG__RB_UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_CTRL__R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_CTRL__R8_UH_RX_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG__RB_UH_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG__RB_UH_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP2_CTRL__R8_UH_RX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(&self) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog__rb_uh_r_tog(&self) -> UEP_R_TOG__RB_UH_R_TOG_R {
                UEP_R_TOG__RB_UH_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle;enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog__rb_uh_r_auto_tog(
                &mut self,
            ) -> UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W<4> {
                UEP_AUTO_TOG__RB_UH_R_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1;expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog__rb_uh_r_tog(&mut self) -> UEP_R_TOG__RB_UH_R_TOG_W<7> {
                UEP_R_TOG__RB_UH_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 control;host receiver endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep2_ctrl__r8_uh_rx_ctrl](index.html) module
        pub struct UEP2_CTRL__R8_UH_RX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP2_CTRL__R8_UH_RX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep2_ctrl__r8_uh_rx_ctrl::R](R) reader structure
        impl crate::Readable for UEP2_CTRL__R8_UH_RX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep2_ctrl__r8_uh_rx_ctrl::W](W) writer structure
        impl crate::Writable for UEP2_CTRL__R8_UH_RX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP2_CTRL__R8_UH_RX_CTRL to value 0
        impl crate::Resettable for UEP2_CTRL__R8_UH_RX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_T_LEN__R8_UH_TX_LEN (rw) register accessor: an alias for `Reg<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>`
    pub type UEP3_T_LEN__R8_UH_TX_LEN =
        crate::Reg<uep3_t_len__r8_uh_tx_len::UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
    ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
    pub mod uep3_t_len__r8_uh_tx_len {
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` reader
        pub struct R(crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_T_LEN__R8_UH_TX_LEN` writer
        pub struct W(crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_T_LEN__R8_UH_TX_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 transmittal length;host transmittal endpoint transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_t_len__r8_uh_tx_len](index.html) module
        pub struct UEP3_T_LEN__R8_UH_TX_LEN_SPEC;
        impl crate::RegisterSpec for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep3_t_len__r8_uh_tx_len::R](R) reader structure
        impl crate::Readable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_t_len__r8_uh_tx_len::W](W) writer structure
        impl crate::Writable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_T_LEN__R8_UH_TX_LEN to value 0
        impl crate::Resettable for UEP3_T_LEN__R8_UH_TX_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP3_CTRL__R8_UH_TX_CTRL (rw) register accessor: an alias for `Reg<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>`
    pub type UEP3_CTRL__R8_UH_TX_CTRL =
        crate::Reg<uep3_ctrl__r8_uh_tx_ctrl::UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
    ///endpoint 3 control;host transmittal endpoint control
    pub mod uep3_ctrl__r8_uh_tx_ctrl {
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` reader
        pub struct R(crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP3_CTRL__R8_UH_TX_CTRL` writer
        pub struct W(crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP3_CTRL__R8_UH_TX_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP3_CTRL__R8_UH_TX_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 control;host transmittal endpoint control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep3_ctrl__r8_uh_tx_ctrl](index.html) module
        pub struct UEP3_CTRL__R8_UH_TX_CTRL_SPEC;
        impl crate::RegisterSpec for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep3_ctrl__r8_uh_tx_ctrl::R](R) reader structure
        impl crate::Readable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep3_ctrl__r8_uh_tx_ctrl::W](W) writer structure
        impl crate::Writable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP3_CTRL__R8_UH_TX_CTRL to value 0
        impl crate::Resettable for UEP3_CTRL__R8_UH_TX_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_T_LEN (rw) register accessor: an alias for `Reg<UEP4_T_LEN_SPEC>`
    pub type UEP4_T_LEN = crate::Reg<uep4_t_len::UEP4_T_LEN_SPEC>;
    ///endpoint 4 transmittal length
    pub mod uep4_t_len {
        ///Register `UEP4_T_LEN` reader
        pub struct R(crate::R<UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_T_LEN_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_T_LEN_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_T_LEN` writer
        pub struct W(crate::W<UEP4_T_LEN_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_T_LEN_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_T_LEN_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_T_LEN_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 transmittal length
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_t_len](index.html) module
        pub struct UEP4_T_LEN_SPEC;
        impl crate::RegisterSpec for UEP4_T_LEN_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_t_len::R](R) reader structure
        impl crate::Readable for UEP4_T_LEN_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_t_len::W](W) writer structure
        impl crate::Writable for UEP4_T_LEN_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_T_LEN to value 0
        impl crate::Resettable for UEP4_T_LEN_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UEP4_CTRL (rw) register accessor: an alias for `Reg<UEP4_CTRL_SPEC>`
    pub type UEP4_CTRL = crate::Reg<uep4_ctrl::UEP4_CTRL_SPEC>;
    ///endpoint 4 control
    pub mod uep4_ctrl {
        ///Register `UEP4_CTRL` reader
        pub struct R(crate::R<UEP4_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UEP4_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UEP4_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `UEP4_CTRL` writer
        pub struct W(crate::W<UEP4_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<UEP4_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<UEP4_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<UEP4_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MASK_UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)
        pub type MASK_UEP_T_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `MASK_UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_R = crate::FieldReader<u8, u8>;
        ///Field `MASK_UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)
        pub type MASK_UEP_R_RES_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, UEP4_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
        pub type UEP_AUTO_TOG_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, UEP4_CTRL_SPEC, bool, O>;
        ///Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
        pub type UEP_T_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_CTRL_SPEC, bool, O>;
        ///Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_R = crate::BitReader<bool>;
        ///Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
        pub type UEP_R_TOG_W<'a, const O: u8> = crate::BitWriter<'a, u8, UEP4_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            pub fn mask_uep_t_res(&self) -> MASK_UEP_T_RES_R {
                MASK_UEP_T_RES_R::new(self.bits & 3)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            pub fn mask_uep_r_res(&self) -> MASK_UEP_R_RES_R {
                MASK_UEP_R_RES_R::new((self.bits >> 2) & 3)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UEP_AUTO_TOG_R {
                UEP_AUTO_TOG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UEP_T_TOG_R {
                UEP_T_TOG_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UEP_R_TOG_R {
                UEP_R_TOG_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_t_res(&mut self) -> MASK_UEP_T_RES_W<0> {
                MASK_UEP_T_RES_W::new(self)
            }
            ///Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)
            #[inline(always)]
            #[must_use]
            pub fn mask_uep_r_res(&mut self) -> MASK_UEP_R_RES_W<2> {
                MASK_UEP_R_RES_W::new(self)
            }
            ///Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1/2/3: 0=manual toggle, 1=automatic toggle
            #[inline(always)]
            #[must_use]
            pub fn uep_auto_tog(&mut self) -> UEP_AUTO_TOG_W<4> {
                UEP_AUTO_TOG_W::new(self)
            }
            ///Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_t_tog(&mut self) -> UEP_T_TOG_W<6> {
                UEP_T_TOG_W::new(self)
            }
            ///Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1
            #[inline(always)]
            #[must_use]
            pub fn uep_r_tog(&mut self) -> UEP_R_TOG_W<7> {
                UEP_R_TOG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uep4_ctrl](index.html) module
        pub struct UEP4_CTRL_SPEC;
        impl crate::RegisterSpec for UEP4_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [uep4_ctrl::R](R) reader structure
        impl crate::Readable for UEP4_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [uep4_ctrl::W](W) writer structure
        impl crate::Writable for UEP4_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets UEP4_CTRL to value 0
        impl crate::Resettable for UEP4_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///USB_TYPE_C_CTRL (rw) register accessor: an alias for `Reg<USB_TYPE_C_CTRL_SPEC>`
    pub type USB_TYPE_C_CTRL = crate::Reg<usb_type_c_ctrl::USB_TYPE_C_CTRL_SPEC>;
    ///USB type-C control
    pub mod usb_type_c_ctrl {
        ///Register `USB_TYPE_C_CTRL` reader
        pub struct R(crate::R<USB_TYPE_C_CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<USB_TYPE_C_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<USB_TYPE_C_CTRL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<USB_TYPE_C_CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `USB_TYPE_C_CTRL` writer
        pub struct W(crate::W<USB_TYPE_C_CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<USB_TYPE_C_CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<USB_TYPE_C_CTRL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<USB_TYPE_C_CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UCC1_PU_EN` reader - USB CC1 pullup resistance control
        pub type UCC1_PU_EN_R = crate::FieldReader<u8, u8>;
        ///Field `UCC1_PU_EN` writer - USB CC1 pullup resistance control
        pub type UCC1_PU_EN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB_TYPE_C_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UCC1_PD_EN` reader - USB CC1 5.1K pulldown resistance: 0=disable, 1=enable pulldown
        pub type UCC1_PD_EN_R = crate::BitReader<bool>;
        ///Field `UCC1_PD_EN` writer - USB CC1 5.1K pulldown resistance: 0=disable, 1=enable pulldown
        pub type UCC1_PD_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_TYPE_C_CTRL_SPEC, bool, O>;
        ///Field `VBUS_PD_EN` reader - USB VBUS 10K pulldown resistance: 0=disable, 1=enable pullup
        pub type VBUS_PD_EN_R = crate::BitReader<bool>;
        ///Field `VBUS_PD_EN` writer - USB VBUS 10K pulldown resistance: 0=disable, 1=enable pullup
        pub type VBUS_PD_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_TYPE_C_CTRL_SPEC, bool, O>;
        ///Field `UCC2_PU_EN` reader - USB CC2 pullup resistance control
        pub type UCC2_PU_EN_R = crate::FieldReader<u8, u8>;
        ///Field `UCC2_PU_EN` writer - USB CC2 pullup resistance control
        pub type UCC2_PU_EN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u8, USB_TYPE_C_CTRL_SPEC, u8, u8, 2, O>;
        ///Field `UCC2_PD_EN` reader - USB CC2 5.1K pulldown resistance: 0=disable, 1=enable pulldown
        pub type UCC2_PD_EN_R = crate::BitReader<bool>;
        ///Field `UCC2_PD_EN` writer - USB CC2 5.1K pulldown resistance: 0=disable, 1=enable pulldown
        pub type UCC2_PD_EN_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_TYPE_C_CTRL_SPEC, bool, O>;
        ///Field `UTCC_GP_BIT` reader - USB general purpose bit
        pub type UTCC_GP_BIT_R = crate::BitReader<bool>;
        ///Field `UTCC_GP_BIT` writer - USB general purpose bit
        pub type UTCC_GP_BIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u8, USB_TYPE_C_CTRL_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - USB CC1 pullup resistance control
            #[inline(always)]
            pub fn ucc1_pu_en(&self) -> UCC1_PU_EN_R {
                UCC1_PU_EN_R::new(self.bits & 3)
            }
            ///Bit 2 - USB CC1 5.1K pulldown resistance: 0=disable, 1=enable pulldown
            #[inline(always)]
            pub fn ucc1_pd_en(&self) -> UCC1_PD_EN_R {
                UCC1_PD_EN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - USB VBUS 10K pulldown resistance: 0=disable, 1=enable pullup
            #[inline(always)]
            pub fn vbus_pd_en(&self) -> VBUS_PD_EN_R {
                VBUS_PD_EN_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:5 - USB CC2 pullup resistance control
            #[inline(always)]
            pub fn ucc2_pu_en(&self) -> UCC2_PU_EN_R {
                UCC2_PU_EN_R::new((self.bits >> 4) & 3)
            }
            ///Bit 6 - USB CC2 5.1K pulldown resistance: 0=disable, 1=enable pulldown
            #[inline(always)]
            pub fn ucc2_pd_en(&self) -> UCC2_PD_EN_R {
                UCC2_PD_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - USB general purpose bit
            #[inline(always)]
            pub fn utcc_gp_bit(&self) -> UTCC_GP_BIT_R {
                UTCC_GP_BIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - USB CC1 pullup resistance control
            #[inline(always)]
            #[must_use]
            pub fn ucc1_pu_en(&mut self) -> UCC1_PU_EN_W<0> {
                UCC1_PU_EN_W::new(self)
            }
            ///Bit 2 - USB CC1 5.1K pulldown resistance: 0=disable, 1=enable pulldown
            #[inline(always)]
            #[must_use]
            pub fn ucc1_pd_en(&mut self) -> UCC1_PD_EN_W<2> {
                UCC1_PD_EN_W::new(self)
            }
            ///Bit 3 - USB VBUS 10K pulldown resistance: 0=disable, 1=enable pullup
            #[inline(always)]
            #[must_use]
            pub fn vbus_pd_en(&mut self) -> VBUS_PD_EN_W<3> {
                VBUS_PD_EN_W::new(self)
            }
            ///Bits 4:5 - USB CC2 pullup resistance control
            #[inline(always)]
            #[must_use]
            pub fn ucc2_pu_en(&mut self) -> UCC2_PU_EN_W<4> {
                UCC2_PU_EN_W::new(self)
            }
            ///Bit 6 - USB CC2 5.1K pulldown resistance: 0=disable, 1=enable pulldown
            #[inline(always)]
            #[must_use]
            pub fn ucc2_pd_en(&mut self) -> UCC2_PD_EN_W<6> {
                UCC2_PD_EN_W::new(self)
            }
            ///Bit 7 - USB general purpose bit
            #[inline(always)]
            #[must_use]
            pub fn utcc_gp_bit(&mut self) -> UTCC_GP_BIT_W<7> {
                UTCC_GP_BIT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///USB type-C control
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [usb_type_c_ctrl](index.html) module
        pub struct USB_TYPE_C_CTRL_SPEC;
        impl crate::RegisterSpec for USB_TYPE_C_CTRL_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [usb_type_c_ctrl::R](R) reader structure
        impl crate::Readable for USB_TYPE_C_CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [usb_type_c_ctrl::W](W) writer structure
        impl crate::Writable for USB_TYPE_C_CTRL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets USB_TYPE_C_CTRL to value 0
        impl crate::Resettable for USB_TYPE_C_CTRL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///CRC calculation unit
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    ///Pointer to the register block
    pub const PTR: *const crc::RegisterBlock = 0x4002_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRC").finish()
    }
}
///CRC calculation unit
pub mod crc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Data register
        pub datar: DATAR,
        ///0x04 - Independent Data register
        pub idatar: IDATAR,
        _reserved2: [u8; 0x03],
        ///0x08 - Control register
        pub ctlr: CTLR,
    }
    ///DATAR (rw) register accessor: an alias for `Reg<DATAR_SPEC>`
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub struct R(crate::R<DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR` writer
        pub struct W(crate::W<DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DATA` reader - Data Register
        pub type DATA_R = crate::FieldReader<u32, u32>;
        ///Field `DATA` writer - Data Register
        pub type DATA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DATAR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Data Register
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Data Register
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<0> {
                DATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar](index.html) module
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [datar::R](R) reader structure
        impl crate::Readable for DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar::W](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR to value 0xffff_ffff
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0xffff_ffff;
        }
    }
    ///IDATAR (rw) register accessor: an alias for `Reg<IDATAR_SPEC>`
    pub type IDATAR = crate::Reg<idatar::IDATAR_SPEC>;
    ///Independent Data register
    pub mod idatar {
        ///Register `IDATAR` reader
        pub struct R(crate::R<IDATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IDATAR` writer
        pub struct W(crate::W<IDATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IDATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IDATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IDATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IDATA` reader - Independent Data register
        pub type IDATA_R = crate::FieldReader<u8, u8>;
        ///Field `IDATA` writer - Independent Data register
        pub type IDATA_W<'a, const O: u8> = crate::FieldWriter<'a, u8, IDATAR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - Independent Data register
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:7 - Independent Data register
            #[inline(always)]
            #[must_use]
            pub fn idata(&mut self) -> IDATA_W<0> {
                IDATA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Independent Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar](index.html) module
        pub struct IDATAR_SPEC;
        impl crate::RegisterSpec for IDATAR_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [idatar::R](R) reader structure
        impl crate::Readable for IDATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [idatar::W](W) writer structure
        impl crate::Writable for IDATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IDATAR to value 0
        impl crate::Resettable for IDATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR (w) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register
    pub mod ctlr {
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Reset bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RSTW_AW {
            ///1: Reset CRC
            Reset = 1,
        }
        impl From<RSTW_AW> for bool {
            #[inline(always)]
            fn from(variant: RSTW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RST` writer - Reset bit
        pub type RST_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, RSTW_AW, O>;
        impl<'a, const O: u8> RST_W<'a, O> {
            ///Reset CRC
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RSTW_AW::Reset)
            }
        }
        impl W {
            ///Bit 0 - Reset bit
            #[inline(always)]
            #[must_use]
            pub fn rst(&mut self) -> RST_W<0> {
                RST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///FLASH
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    ///Pointer to the register block
    pub const PTR: *const flash::RegisterBlock = 0x4002_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH").finish()
    }
}
///FLASH
pub mod flash {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Flash access control register
        pub actlr: ACTLR,
        ///0x04 - Flash key register
        pub keyr: KEYR,
        ///0x08 - Flash option key register
        pub obkeyr: OBKEYR,
        ///0x0c - Status register
        pub statr: STATR,
        ///0x10 - Control register
        pub ctlr: CTLR,
        ///0x14 - Flash address register
        pub addr: ADDR,
        _reserved6: [u8; 0x04],
        ///0x1c - Option byte register
        pub obr: OBR,
        ///0x20 - Write protection register
        pub wpr: WPR,
        ///0x24 - Extension key register
        pub modekeyr: MODEKEYR,
    }
    ///ACTLR (rw) register accessor: an alias for `Reg<ACTLR_SPEC>`
    pub type ACTLR = crate::Reg<actlr::ACTLR_SPEC>;
    ///Flash access control register
    pub mod actlr {
        ///Register `ACTLR` reader
        pub struct R(crate::R<ACTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ACTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ACTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ACTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ACTLR` writer
        pub struct W(crate::W<ACTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ACTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ACTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ACTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LATENCY` reader - Latency
        pub type LATENCY_R = crate::FieldReader<u8, LATENCY_A>;
        ///Latency
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum LATENCY_A {
            ///0: No latency, 0 < SYSCLK <= 24MHz recommended
            Zero = 0,
            ///1: 24MHz < SYSCLK <= 48MHz recommended
            One = 1,
            ///2: 48MHz < SYSCLK <= 72MHz recommended
            Two = 2,
        }
        impl From<LATENCY_A> for u8 {
            #[inline(always)]
            fn from(variant: LATENCY_A) -> Self {
                variant as _
            }
        }
        impl LATENCY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<LATENCY_A> {
                match self.bits {
                    0 => Some(LATENCY_A::Zero),
                    1 => Some(LATENCY_A::One),
                    2 => Some(LATENCY_A::Two),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Zero`
            #[inline(always)]
            pub fn is_zero(&self) -> bool {
                *self == LATENCY_A::Zero
            }
            ///Checks if the value of the field is `One`
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == LATENCY_A::One
            }
            ///Checks if the value of the field is `Two`
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == LATENCY_A::Two
            }
        }
        ///Field `LATENCY` writer - Latency
        pub type LATENCY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, ACTLR_SPEC, u8, LATENCY_A, 3, O>;
        impl<'a, const O: u8> LATENCY_W<'a, O> {
            ///No latency, 0 < SYSCLK <= 24MHz recommended
            #[inline(always)]
            pub fn zero(self) -> &'a mut W {
                self.variant(LATENCY_A::Zero)
            }
            ///24MHz < SYSCLK <= 48MHz recommended
            #[inline(always)]
            pub fn one(self) -> &'a mut W {
                self.variant(LATENCY_A::One)
            }
            ///48MHz < SYSCLK <= 72MHz recommended
            #[inline(always)]
            pub fn two(self) -> &'a mut W {
                self.variant(LATENCY_A::Two)
            }
        }
        ///Field `PRFTBE` reader - Prefetch buffer enable
        pub type PRFTBE_R = crate::BitReader<PRFTBE_A>;
        ///Prefetch buffer enable
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PRFTBE_A {
            ///0: Prefetch buffer disabled
            Disabled = 0,
            ///1: Prefetch buffer enabled
            Enabled = 1,
        }
        impl From<PRFTBE_A> for bool {
            #[inline(always)]
            fn from(variant: PRFTBE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PRFTBE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PRFTBE_A {
                match self.bits {
                    false => PRFTBE_A::Disabled,
                    true => PRFTBE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PRFTBE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PRFTBE_A::Enabled
            }
        }
        ///Field `PRFTBE` writer - Prefetch buffer enable
        pub type PRFTBE_W<'a, const O: u8> = crate::BitWriter<'a, u32, ACTLR_SPEC, PRFTBE_A, O>;
        impl<'a, const O: u8> PRFTBE_W<'a, O> {
            ///Prefetch buffer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PRFTBE_A::Disabled)
            }
            ///Prefetch buffer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PRFTBE_A::Enabled)
            }
        }
        ///Field `PRFTBS` reader - Prefetch buffer status
        pub type PRFTBS_R = crate::BitReader<PRFTBSR_A>;
        ///Prefetch buffer status
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PRFTBSR_A {
            ///0: Prefetch buffer disabled
            Disabled = 0,
            ///1: Prefetch buffer enabled
            Enabled = 1,
        }
        impl From<PRFTBSR_A> for bool {
            #[inline(always)]
            fn from(variant: PRFTBSR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PRFTBS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PRFTBSR_A {
                match self.bits {
                    false => PRFTBSR_A::Disabled,
                    true => PRFTBSR_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PRFTBSR_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PRFTBSR_A::Enabled
            }
        }
        impl R {
            ///Bits 0:2 - Latency
            #[inline(always)]
            pub fn latency(&self) -> LATENCY_R {
                LATENCY_R::new((self.bits & 7) as u8)
            }
            ///Bit 4 - Prefetch buffer enable
            #[inline(always)]
            pub fn prftbe(&self) -> PRFTBE_R {
                PRFTBE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Prefetch buffer status
            #[inline(always)]
            pub fn prftbs(&self) -> PRFTBS_R {
                PRFTBS_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Latency
            #[inline(always)]
            #[must_use]
            pub fn latency(&mut self) -> LATENCY_W<0> {
                LATENCY_W::new(self)
            }
            ///Bit 4 - Prefetch buffer enable
            #[inline(always)]
            #[must_use]
            pub fn prftbe(&mut self) -> PRFTBE_W<4> {
                PRFTBE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash access control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [actlr](index.html) module
        pub struct ACTLR_SPEC;
        impl crate::RegisterSpec for ACTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [actlr::R](R) reader structure
        impl crate::Readable for ACTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [actlr::W](W) writer structure
        impl crate::Writable for ACTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ACTLR to value 0x30
        impl crate::Resettable for ACTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x30;
        }
    }
    ///KEYR (w) register accessor: an alias for `Reg<KEYR_SPEC>`
    pub type KEYR = crate::Reg<keyr::KEYR_SPEC>;
    ///Flash key register
    pub mod keyr {
        ///Register `KEYR` writer
        pub struct W(crate::W<KEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<KEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<KEYR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<KEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///FPEC key
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u32)]
        pub enum KEYRW_AW {
            ///165: RDPRT
            Rdprt = 165,
            ///1164378403: Key1
            Key1 = 1164378403,
            ///3455027627: Key2
            Key2 = 3455027627,
        }
        impl From<KEYRW_AW> for u32 {
            #[inline(always)]
            fn from(variant: KEYRW_AW) -> Self {
                variant as _
            }
        }
        ///Field `KEYR` writer - FPEC key
        pub type KEYR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, KEYR_SPEC, u32, KEYRW_AW, 32, O>;
        impl<'a, const O: u8> KEYR_W<'a, O> {
            ///RDPRT
            #[inline(always)]
            pub fn rdprt(self) -> &'a mut W {
                self.variant(KEYRW_AW::Rdprt)
            }
            ///Key1
            #[inline(always)]
            pub fn key1(self) -> &'a mut W {
                self.variant(KEYRW_AW::Key1)
            }
            ///Key2
            #[inline(always)]
            pub fn key2(self) -> &'a mut W {
                self.variant(KEYRW_AW::Key2)
            }
        }
        impl W {
            ///Bits 0:31 - FPEC key
            #[inline(always)]
            #[must_use]
            pub fn keyr(&mut self) -> KEYR_W<0> {
                KEYR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [keyr](index.html) module
        pub struct KEYR_SPEC;
        impl crate::RegisterSpec for KEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [keyr::W](W) writer structure
        impl crate::Writable for KEYR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets KEYR to value 0
        impl crate::Resettable for KEYR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OBKEYR (w) register accessor: an alias for `Reg<OBKEYR_SPEC>`
    pub type OBKEYR = crate::Reg<obkeyr::OBKEYR_SPEC>;
    ///Flash option key register
    pub mod obkeyr {
        ///Register `OBKEYR` writer
        pub struct W(crate::W<OBKEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OBKEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OBKEYR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OBKEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OBKEYR` writer - Option byte key
        pub type OBKEYR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, OBKEYR_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - Option byte key
            #[inline(always)]
            #[must_use]
            pub fn obkeyr(&mut self) -> OBKEYR_W<0> {
                OBKEYR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash option key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [obkeyr](index.html) module
        pub struct OBKEYR_SPEC;
        impl crate::RegisterSpec for OBKEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [obkeyr::W](W) writer structure
        impl crate::Writable for OBKEYR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OBKEYR to value 0
        impl crate::Resettable for OBKEYR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BSY` reader - Busy
        pub type BSY_R = crate::BitReader<BSYR_A>;
        ///Busy
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BSYR_A {
            ///0: Operation accomplished or error
            Idle = 0,
            ///1: FLASH in operation
            Busy = 1,
        }
        impl From<BSYR_A> for bool {
            #[inline(always)]
            fn from(variant: BSYR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BSY_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BSYR_A {
                match self.bits {
                    false => BSYR_A::Idle,
                    true => BSYR_A::Busy,
                }
            }
            ///Checks if the value of the field is `Idle`
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == BSYR_A::Idle
            }
            ///Checks if the value of the field is `Busy`
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == BSYR_A::Busy
            }
        }
        ///Field `PGERR` reader - Programming error
        pub type PGERR_R = crate::BitReader<bool>;
        ///Field `PGERR` writer - Programming error
        pub type PGERR_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `WRPRTERR` reader - Write protection error
        pub type WRPRTERR_R = crate::BitReader<WRPRTERRR_A>;
        ///Write protection error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WRPRTERRR_A {
            ///0: No error
            NoError = 0,
            ///1: Error
            Error = 1,
        }
        impl From<WRPRTERRR_A> for bool {
            #[inline(always)]
            fn from(variant: WRPRTERRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WRPRTERR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WRPRTERRR_A {
                match self.bits {
                    false => WRPRTERRR_A::NoError,
                    true => WRPRTERRR_A::Error,
                }
            }
            ///Checks if the value of the field is `NoError`
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                *self == WRPRTERRR_A::NoError
            }
            ///Checks if the value of the field is `Error`
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == WRPRTERRR_A::Error
            }
        }
        ///Write protection error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WRPRTERRW_AW {
            ///1: Clear this flag
            Clear = 1,
        }
        impl From<WRPRTERRW_AW> for bool {
            #[inline(always)]
            fn from(variant: WRPRTERRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WRPRTERR` writer - Write protection error
        pub type WRPRTERR_W<'a, const O: u8> =
            crate::BitWriter1C<'a, u32, STATR_SPEC, WRPRTERRW_AW, O>;
        impl<'a, const O: u8> WRPRTERR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(WRPRTERRW_AW::Clear)
            }
        }
        ///Field `EOP` reader - End of operation
        pub type EOP_R = crate::BitReader<EOPR_A>;
        ///End of operation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EOPR_A {
            ///0: Operating
            Operating = 0,
            ///1: End of operation
            Done = 1,
        }
        impl From<EOPR_A> for bool {
            #[inline(always)]
            fn from(variant: EOPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EOP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EOPR_A {
                match self.bits {
                    false => EOPR_A::Operating,
                    true => EOPR_A::Done,
                }
            }
            ///Checks if the value of the field is `Operating`
            #[inline(always)]
            pub fn is_operating(&self) -> bool {
                *self == EOPR_A::Operating
            }
            ///Checks if the value of the field is `Done`
            #[inline(always)]
            pub fn is_done(&self) -> bool {
                *self == EOPR_A::Done
            }
        }
        ///End of operation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EOPW_AW {
            ///1: Clear this flag
            Clear = 1,
        }
        impl From<EOPW_AW> for bool {
            #[inline(always)]
            fn from(variant: EOPW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EOP` writer - End of operation
        pub type EOP_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, STATR_SPEC, EOPW_AW, O>;
        impl<'a, const O: u8> EOP_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOPW_AW::Clear)
            }
        }
        impl R {
            ///Bit 0 - Busy
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - Programming error
            #[inline(always)]
            pub fn pgerr(&self) -> PGERR_R {
                PGERR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - Write protection error
            #[inline(always)]
            pub fn wrprterr(&self) -> WRPRTERR_R {
                WRPRTERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - End of operation
            #[inline(always)]
            pub fn eop(&self) -> EOP_R {
                EOP_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 2 - Programming error
            #[inline(always)]
            #[must_use]
            pub fn pgerr(&mut self) -> PGERR_W<2> {
                PGERR_W::new(self)
            }
            ///Bit 4 - Write protection error
            #[inline(always)]
            #[must_use]
            pub fn wrprterr(&mut self) -> WRPRTERR_W<4> {
                WRPRTERR_W::new(self)
            }
            ///Bit 5 - End of operation
            #[inline(always)]
            #[must_use]
            pub fn eop(&mut self) -> EOP_W<5> {
                EOP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x30;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PG` reader - Programming
        pub type PG_R = crate::BitReader<PG_A>;
        ///Programming
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PG_A {
            ///1: Conduct programming
            Program = 1,
        }
        impl From<PG_A> for bool {
            #[inline(always)]
            fn from(variant: PG_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PG_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PG_A> {
                match self.bits {
                    true => Some(PG_A::Program),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Program`
            #[inline(always)]
            pub fn is_program(&self) -> bool {
                *self == PG_A::Program
            }
        }
        ///Field `PG` writer - Programming
        pub type PG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, PG_A, O>;
        impl<'a, const O: u8> PG_W<'a, O> {
            ///Conduct programming
            #[inline(always)]
            pub fn program(self) -> &'a mut W {
                self.variant(PG_A::Program)
            }
        }
        ///Field `PER` reader - Page Erase
        pub type PER_R = crate::BitReader<PER_A>;
        ///Page Erase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PER_A {
            ///1: Erase 1KB
            Erase = 1,
        }
        impl From<PER_A> for bool {
            #[inline(always)]
            fn from(variant: PER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PER_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PER_A> {
                match self.bits {
                    true => Some(PER_A::Erase),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Erase`
            #[inline(always)]
            pub fn is_erase(&self) -> bool {
                *self == PER_A::Erase
            }
        }
        ///Field `PER` writer - Page Erase
        pub type PER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, PER_A, O>;
        impl<'a, const O: u8> PER_W<'a, O> {
            ///Erase 1KB
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(PER_A::Erase)
            }
        }
        ///Field `MER` reader - Mass Erase
        pub type MER_R = crate::BitReader<MER_A>;
        ///Mass Erase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MER_A {
            ///1: Erase USER
            Erase = 1,
        }
        impl From<MER_A> for bool {
            #[inline(always)]
            fn from(variant: MER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MER_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MER_A> {
                match self.bits {
                    true => Some(MER_A::Erase),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Erase`
            #[inline(always)]
            pub fn is_erase(&self) -> bool {
                *self == MER_A::Erase
            }
        }
        ///Field `MER` writer - Mass Erase
        pub type MER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, MER_A, O>;
        impl<'a, const O: u8> MER_W<'a, O> {
            ///Erase USER
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(MER_A::Erase)
            }
        }
        ///Field `OBPG` reader - Option byte programming
        pub type OBPG_R = crate::BitReader<OBPG_A>;
        ///Option byte programming
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OBPG_A {
            ///1: Conduct programming
            Program = 1,
        }
        impl From<OBPG_A> for bool {
            #[inline(always)]
            fn from(variant: OBPG_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OBPG_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<OBPG_A> {
                match self.bits {
                    true => Some(OBPG_A::Program),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Program`
            #[inline(always)]
            pub fn is_program(&self) -> bool {
                *self == OBPG_A::Program
            }
        }
        ///Field `OBPG` writer - Option byte programming
        pub type OBPG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, OBPG_A, O>;
        impl<'a, const O: u8> OBPG_W<'a, O> {
            ///Conduct programming
            #[inline(always)]
            pub fn program(self) -> &'a mut W {
                self.variant(OBPG_A::Program)
            }
        }
        ///Field `OBER` reader - Option byte erase
        pub type OBER_R = crate::BitReader<OBER_A>;
        ///Option byte erase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OBER_A {
            ///1: Conduct erase
            Erase = 1,
        }
        impl From<OBER_A> for bool {
            #[inline(always)]
            fn from(variant: OBER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OBER_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<OBER_A> {
                match self.bits {
                    true => Some(OBER_A::Erase),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Erase`
            #[inline(always)]
            pub fn is_erase(&self) -> bool {
                *self == OBER_A::Erase
            }
        }
        ///Field `OBER` writer - Option byte erase
        pub type OBER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, OBER_A, O>;
        impl<'a, const O: u8> OBER_W<'a, O> {
            ///Conduct erase
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(OBER_A::Erase)
            }
        }
        ///Field `STRT` reader - Start
        pub type STRT_R = crate::BitReader<STRTW_A>;
        ///Start
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STRTW_A {
            ///1: Conduct erase or programming
            Start = 1,
        }
        impl From<STRTW_A> for bool {
            #[inline(always)]
            fn from(variant: STRTW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STRT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<STRTW_A> {
                match self.bits {
                    true => Some(STRTW_A::Start),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Start`
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                *self == STRTW_A::Start
            }
        }
        ///Field `STRT` writer - Start
        pub type STRT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, STRTW_A, O>;
        impl<'a, const O: u8> STRT_W<'a, O> {
            ///Conduct erase or programming
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(STRTW_A::Start)
            }
        }
        ///Field `LOCK` reader - Lock
        pub type LOCK_R = crate::BitReader<LOCKW_A>;
        ///Lock
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LOCKW_A {
            ///1: Lock
            Lock = 1,
        }
        impl From<LOCKW_A> for bool {
            #[inline(always)]
            fn from(variant: LOCKW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LOCK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<LOCKW_A> {
                match self.bits {
                    true => Some(LOCKW_A::Lock),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Lock`
            #[inline(always)]
            pub fn is_lock(&self) -> bool {
                *self == LOCKW_A::Lock
            }
        }
        ///Field `LOCK` writer - Lock
        pub type LOCK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, LOCKW_A, O>;
        impl<'a, const O: u8> LOCK_W<'a, O> {
            ///Lock
            #[inline(always)]
            pub fn lock(self) -> &'a mut W {
                self.variant(LOCKW_A::Lock)
            }
        }
        ///Field `OBWRE` reader - Option bytes write enable
        pub type OBWRE_R = crate::BitReader<bool>;
        ///Field `OBWRE` writer - Option bytes write enable
        pub type OBWRE_W<'a, const O: u8> = crate::BitWriter0C<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `ERRIE` reader - Error interrupt enable
        pub type ERRIE_R = crate::BitReader<ERRIE_A>;
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERRIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERRIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::Disabled,
                    true => ERRIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ERRIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ERRIE_A::Enabled
            }
        }
        ///Field `ERRIE` writer - Error interrupt enable
        pub type ERRIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, ERRIE_A, O>;
        impl<'a, const O: u8> ERRIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ERRIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ERRIE_A::Enabled)
            }
        }
        ///Field `EOPIE` reader - End of operation interrupt enable
        pub use ERRIE_R as EOPIE_R;
        ///Field `EOPIE` writer - End of operation interrupt enable
        pub use ERRIE_W as EOPIE_W;
        ///Field `FLOCK` reader - FAST programming lock
        pub type FLOCK_R = crate::BitReader<FLOCKR_A>;
        ///FAST programming lock
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FLOCKR_A {
            ///0: Unlocked
            Unlocked = 0,
            ///1: Locked
            Locked = 1,
        }
        impl From<FLOCKR_A> for bool {
            #[inline(always)]
            fn from(variant: FLOCKR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FLOCK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> FLOCKR_A {
                match self.bits {
                    false => FLOCKR_A::Unlocked,
                    true => FLOCKR_A::Locked,
                }
            }
            ///Checks if the value of the field is `Unlocked`
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                *self == FLOCKR_A::Unlocked
            }
            ///Checks if the value of the field is `Locked`
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == FLOCKR_A::Locked
            }
        }
        ///FAST programming lock
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FLOCKW_AW {
            ///1: Lock
            Lock = 1,
        }
        impl From<FLOCKW_AW> for bool {
            #[inline(always)]
            fn from(variant: FLOCKW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `FLOCK` writer - FAST programming lock
        pub type FLOCK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, FLOCKW_AW, O>;
        impl<'a, const O: u8> FLOCK_W<'a, O> {
            ///Lock
            #[inline(always)]
            pub fn lock(self) -> &'a mut W {
                self.variant(FLOCKW_AW::Lock)
            }
        }
        ///Field `FTPG` reader - execute fast programming
        pub type FTPG_R = crate::BitReader<FTPG_A>;
        ///execute fast programming
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FTPG_A {
            ///1: Conduct fast programming
            Program = 1,
        }
        impl From<FTPG_A> for bool {
            #[inline(always)]
            fn from(variant: FTPG_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FTPG_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<FTPG_A> {
                match self.bits {
                    true => Some(FTPG_A::Program),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Program`
            #[inline(always)]
            pub fn is_program(&self) -> bool {
                *self == FTPG_A::Program
            }
        }
        ///Field `FTPG` writer - execute fast programming
        pub type FTPG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, FTPG_A, O>;
        impl<'a, const O: u8> FTPG_W<'a, O> {
            ///Conduct fast programming
            #[inline(always)]
            pub fn program(self) -> &'a mut W {
                self.variant(FTPG_A::Program)
            }
        }
        ///Field `FTER` reader - execute fast 128byte erase
        pub type FTER_R = crate::BitReader<FTER_A>;
        ///execute fast 128byte erase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FTER_A {
            ///1: Conduct fast erase
            Erase = 1,
        }
        impl From<FTER_A> for bool {
            #[inline(always)]
            fn from(variant: FTER_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FTER_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<FTER_A> {
                match self.bits {
                    true => Some(FTER_A::Erase),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Erase`
            #[inline(always)]
            pub fn is_erase(&self) -> bool {
                *self == FTER_A::Erase
            }
        }
        ///Field `FTER` writer - execute fast 128byte erase
        pub type FTER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, FTER_A, O>;
        impl<'a, const O: u8> FTER_W<'a, O> {
            ///Conduct fast erase
            #[inline(always)]
            pub fn erase(self) -> &'a mut W {
                self.variant(FTER_A::Erase)
            }
        }
        ///Field `BUFLOAD` reader - execute data load inner buffer
        pub type BUFLOAD_R = crate::BitReader<BUFLOAD_A>;
        ///execute data load inner buffer
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BUFLOAD_A {
            ///1: Conduct buffer data load
            Load = 1,
        }
        impl From<BUFLOAD_A> for bool {
            #[inline(always)]
            fn from(variant: BUFLOAD_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BUFLOAD_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<BUFLOAD_A> {
                match self.bits {
                    true => Some(BUFLOAD_A::Load),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Load`
            #[inline(always)]
            pub fn is_load(&self) -> bool {
                *self == BUFLOAD_A::Load
            }
        }
        ///Field `BUFLOAD` writer - execute data load inner buffer
        pub type BUFLOAD_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, BUFLOAD_A, O>;
        impl<'a, const O: u8> BUFLOAD_W<'a, O> {
            ///Conduct buffer data load
            #[inline(always)]
            pub fn load(self) -> &'a mut W {
                self.variant(BUFLOAD_A::Load)
            }
        }
        ///Field `BUFRST` reader - execute inner buffer reset
        pub type BUFRST_R = crate::BitReader<BUFRST_A>;
        ///execute inner buffer reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum BUFRST_A {
            ///1: Conduct buffer data clear
            Reset = 1,
        }
        impl From<BUFRST_A> for bool {
            #[inline(always)]
            fn from(variant: BUFRST_A) -> Self {
                variant as u8 != 0
            }
        }
        impl BUFRST_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<BUFRST_A> {
                match self.bits {
                    true => Some(BUFRST_A::Reset),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == BUFRST_A::Reset
            }
        }
        ///Field `BUFRST` writer - execute inner buffer reset
        pub type BUFRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, BUFRST_A, O>;
        impl<'a, const O: u8> BUFRST_W<'a, O> {
            ///Conduct buffer data clear
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BUFRST_A::Reset)
            }
        }
        impl R {
            ///Bit 0 - Programming
            #[inline(always)]
            pub fn pg(&self) -> PG_R {
                PG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Page Erase
            #[inline(always)]
            pub fn per(&self) -> PER_R {
                PER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            pub fn mer(&self) -> MER_R {
                MER_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            pub fn obpg(&self) -> OBPG_R {
                OBPG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            pub fn ober(&self) -> OBER_R {
                OBER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Start
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Lock
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            pub fn obwre(&self) -> OBWRE_R {
                OBWRE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            pub fn eopie(&self) -> EOPIE_R {
                EOPIE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 15 - FAST programming lock
            #[inline(always)]
            pub fn flock(&self) -> FLOCK_R {
                FLOCK_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - execute fast programming
            #[inline(always)]
            pub fn ftpg(&self) -> FTPG_R {
                FTPG_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - execute fast 128byte erase
            #[inline(always)]
            pub fn fter(&self) -> FTER_R {
                FTER_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - execute data load inner buffer
            #[inline(always)]
            pub fn bufload(&self) -> BUFLOAD_R {
                BUFLOAD_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - execute inner buffer reset
            #[inline(always)]
            pub fn bufrst(&self) -> BUFRST_R {
                BUFRST_R::new(((self.bits >> 19) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Programming
            #[inline(always)]
            #[must_use]
            pub fn pg(&mut self) -> PG_W<0> {
                PG_W::new(self)
            }
            ///Bit 1 - Page Erase
            #[inline(always)]
            #[must_use]
            pub fn per(&mut self) -> PER_W<1> {
                PER_W::new(self)
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            #[must_use]
            pub fn mer(&mut self) -> MER_W<2> {
                MER_W::new(self)
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            #[must_use]
            pub fn obpg(&mut self) -> OBPG_W<4> {
                OBPG_W::new(self)
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            #[must_use]
            pub fn ober(&mut self) -> OBER_W<5> {
                OBER_W::new(self)
            }
            ///Bit 6 - Start
            #[inline(always)]
            #[must_use]
            pub fn strt(&mut self) -> STRT_W<6> {
                STRT_W::new(self)
            }
            ///Bit 7 - Lock
            #[inline(always)]
            #[must_use]
            pub fn lock(&mut self) -> LOCK_W<7> {
                LOCK_W::new(self)
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            #[must_use]
            pub fn obwre(&mut self) -> OBWRE_W<9> {
                OBWRE_W::new(self)
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn errie(&mut self) -> ERRIE_W<10> {
                ERRIE_W::new(self)
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn eopie(&mut self) -> EOPIE_W<12> {
                EOPIE_W::new(self)
            }
            ///Bit 15 - FAST programming lock
            #[inline(always)]
            #[must_use]
            pub fn flock(&mut self) -> FLOCK_W<15> {
                FLOCK_W::new(self)
            }
            ///Bit 16 - execute fast programming
            #[inline(always)]
            #[must_use]
            pub fn ftpg(&mut self) -> FTPG_W<16> {
                FTPG_W::new(self)
            }
            ///Bit 17 - execute fast 128byte erase
            #[inline(always)]
            #[must_use]
            pub fn fter(&mut self) -> FTER_W<17> {
                FTER_W::new(self)
            }
            ///Bit 18 - execute data load inner buffer
            #[inline(always)]
            #[must_use]
            pub fn bufload(&mut self) -> BUFLOAD_W<18> {
                BUFLOAD_W::new(self)
            }
            ///Bit 19 - execute inner buffer reset
            #[inline(always)]
            #[must_use]
            pub fn bufrst(&mut self) -> BUFRST_W<19> {
                BUFRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0200;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0x80
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x80;
        }
    }
    ///ADDR (w) register accessor: an alias for `Reg<ADDR_SPEC>`
    pub type ADDR = crate::Reg<addr::ADDR_SPEC>;
    ///Flash address register
    pub mod addr {
        ///Register `ADDR` writer
        pub struct W(crate::W<ADDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FAR` writer - Flash Address
        pub type FAR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ADDR_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - Flash Address
            #[inline(always)]
            #[must_use]
            pub fn far(&mut self) -> FAR_W<0> {
                FAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash address register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [addr](index.html) module
        pub struct ADDR_SPEC;
        impl crate::RegisterSpec for ADDR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [addr::W](W) writer structure
        impl crate::Writable for ADDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADDR to value 0
        impl crate::Resettable for ADDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OBR (r) register accessor: an alias for `Reg<OBR_SPEC>`
    pub type OBR = crate::Reg<obr::OBR_SPEC>;
    ///Option byte register
    pub mod obr {
        ///Register `OBR` reader
        pub struct R(crate::R<OBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `OPTERR` reader - Option byte error
        pub type OPTERR_R = crate::BitReader<bool>;
        ///Field `RDPRT` reader - Read protection
        pub type RDPRT_R = crate::BitReader<bool>;
        ///Field `IWDG_SW` reader - IWDG_SW
        pub type IWDG_SW_R = crate::BitReader<bool>;
        ///Field `nRST_STOP` reader - nRST_STOP
        pub type N_RST_STOP_R = crate::BitReader<bool>;
        ///Field `nRST_STDBY` reader - nRST_STDBY
        pub type N_RST_STDBY_R = crate::BitReader<bool>;
        ///Field `USBD_MODE` reader - USBD compatible speed mode configure
        pub type USBD_MODE_R = crate::BitReader<bool>;
        ///Field `USBD_PU` reader - USBD compatible inner pull up resistance configure
        pub type USBD_PU_R = crate::BitReader<bool>;
        ///Field `POR_CTR` reader - Power on reset time
        pub type POR_CTR_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Option byte error
            #[inline(always)]
            pub fn opterr(&self) -> OPTERR_R {
                OPTERR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Read protection
            #[inline(always)]
            pub fn rdprt(&self) -> RDPRT_R {
                RDPRT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - IWDG_SW
            #[inline(always)]
            pub fn iwdg_sw(&self) -> IWDG_SW_R {
                IWDG_SW_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - nRST_STOP
            #[inline(always)]
            pub fn n_rst_stop(&self) -> N_RST_STOP_R {
                N_RST_STOP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - nRST_STDBY
            #[inline(always)]
            pub fn n_rst_stdby(&self) -> N_RST_STDBY_R {
                N_RST_STDBY_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - USBD compatible speed mode configure
            #[inline(always)]
            pub fn usbd_mode(&self) -> USBD_MODE_R {
                USBD_MODE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - USBD compatible inner pull up resistance configure
            #[inline(always)]
            pub fn usbd_pu(&self) -> USBD_PU_R {
                USBD_PU_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Power on reset time
            #[inline(always)]
            pub fn por_ctr(&self) -> POR_CTR_R {
                POR_CTR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///Option byte register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [obr](index.html) module
        pub struct OBR_SPEC;
        impl crate::RegisterSpec for OBR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [obr::R](R) reader structure
        impl crate::Readable for OBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets OBR to value 0x03ff_fffc
        impl crate::Resettable for OBR_SPEC {
            const RESET_VALUE: Self::Ux = 0x03ff_fffc;
        }
    }
    ///WPR (r) register accessor: an alias for `Reg<WPR_SPEC>`
    pub type WPR = crate::Reg<wpr::WPR_SPEC>;
    ///Write protection register
    pub mod wpr {
        ///Register `WPR` reader
        pub struct R(crate::R<WPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WPR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `WRP0` reader - Write protect
        pub type WRP0_R = crate::BitReader<WRP0R_A>;
        ///Write protect
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WRP0R_A {
            ///0: Write protection activated
            Activated = 0,
            ///1: Write protection deactivated
            Deactivated = 1,
        }
        impl From<WRP0R_A> for bool {
            #[inline(always)]
            fn from(variant: WRP0R_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WRP0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WRP0R_A {
                match self.bits {
                    false => WRP0R_A::Activated,
                    true => WRP0R_A::Deactivated,
                }
            }
            ///Checks if the value of the field is `Activated`
            #[inline(always)]
            pub fn is_activated(&self) -> bool {
                *self == WRP0R_A::Activated
            }
            ///Checks if the value of the field is `Deactivated`
            #[inline(always)]
            pub fn is_deactivated(&self) -> bool {
                *self == WRP0R_A::Deactivated
            }
        }
        ///Field `WRP1` reader - Write protect
        pub use WRP0_R as WRP1_R;
        ///Field `WRP2` reader - Write protect
        pub use WRP0_R as WRP2_R;
        ///Field `WRP3` reader - Write protect
        pub use WRP0_R as WRP3_R;
        ///Field `WRP4` reader - Write protect
        pub use WRP0_R as WRP4_R;
        ///Field `WRP5` reader - Write protect
        pub use WRP0_R as WRP5_R;
        ///Field `WRP6` reader - Write protect
        pub use WRP0_R as WRP6_R;
        ///Field `WRP7` reader - Write protect
        pub use WRP0_R as WRP7_R;
        ///Field `WRP8` reader - Write protect
        pub use WRP0_R as WRP8_R;
        ///Field `WRP9` reader - Write protect
        pub use WRP0_R as WRP9_R;
        ///Field `WRP10` reader - Write protect
        pub use WRP0_R as WRP10_R;
        ///Field `WRP11` reader - Write protect
        pub use WRP0_R as WRP11_R;
        ///Field `WRP12` reader - Write protect
        pub use WRP0_R as WRP12_R;
        ///Field `WRP13` reader - Write protect
        pub use WRP0_R as WRP13_R;
        ///Field `WRP14` reader - Write protect
        pub use WRP0_R as WRP14_R;
        ///Field `WRP15` reader - Write protect
        pub use WRP0_R as WRP15_R;
        ///Field `WRP16` reader - Write protect
        pub use WRP0_R as WRP16_R;
        ///Field `WRP17` reader - Write protect
        pub use WRP0_R as WRP17_R;
        ///Field `WRP18` reader - Write protect
        pub use WRP0_R as WRP18_R;
        ///Field `WRP19` reader - Write protect
        pub use WRP0_R as WRP19_R;
        ///Field `WRP20` reader - Write protect
        pub use WRP0_R as WRP20_R;
        ///Field `WRP21` reader - Write protect
        pub use WRP0_R as WRP21_R;
        ///Field `WRP22` reader - Write protect
        pub use WRP0_R as WRP22_R;
        ///Field `WRP23` reader - Write protect
        pub use WRP0_R as WRP23_R;
        ///Field `WRP24` reader - Write protect
        pub use WRP0_R as WRP24_R;
        ///Field `WRP25` reader - Write protect
        pub use WRP0_R as WRP25_R;
        ///Field `WRP26` reader - Write protect
        pub use WRP0_R as WRP26_R;
        ///Field `WRP27` reader - Write protect
        pub use WRP0_R as WRP27_R;
        ///Field `WRP28` reader - Write protect
        pub use WRP0_R as WRP28_R;
        ///Field `WRP29` reader - Write protect
        pub use WRP0_R as WRP29_R;
        ///Field `WRP30` reader - Write protect
        pub use WRP0_R as WRP30_R;
        ///Field `WRP31` reader - Write protect
        pub use WRP0_R as WRP31_R;
        impl R {
            ///Bit 0 - Write protect
            #[inline(always)]
            pub fn wrp0(&self) -> WRP0_R {
                WRP0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Write protect
            #[inline(always)]
            pub fn wrp1(&self) -> WRP1_R {
                WRP1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Write protect
            #[inline(always)]
            pub fn wrp2(&self) -> WRP2_R {
                WRP2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Write protect
            #[inline(always)]
            pub fn wrp3(&self) -> WRP3_R {
                WRP3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Write protect
            #[inline(always)]
            pub fn wrp4(&self) -> WRP4_R {
                WRP4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Write protect
            #[inline(always)]
            pub fn wrp5(&self) -> WRP5_R {
                WRP5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Write protect
            #[inline(always)]
            pub fn wrp6(&self) -> WRP6_R {
                WRP6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Write protect
            #[inline(always)]
            pub fn wrp7(&self) -> WRP7_R {
                WRP7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Write protect
            #[inline(always)]
            pub fn wrp8(&self) -> WRP8_R {
                WRP8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Write protect
            #[inline(always)]
            pub fn wrp9(&self) -> WRP9_R {
                WRP9_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Write protect
            #[inline(always)]
            pub fn wrp10(&self) -> WRP10_R {
                WRP10_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Write protect
            #[inline(always)]
            pub fn wrp11(&self) -> WRP11_R {
                WRP11_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Write protect
            #[inline(always)]
            pub fn wrp12(&self) -> WRP12_R {
                WRP12_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Write protect
            #[inline(always)]
            pub fn wrp13(&self) -> WRP13_R {
                WRP13_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Write protect
            #[inline(always)]
            pub fn wrp14(&self) -> WRP14_R {
                WRP14_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Write protect
            #[inline(always)]
            pub fn wrp15(&self) -> WRP15_R {
                WRP15_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Write protect
            #[inline(always)]
            pub fn wrp16(&self) -> WRP16_R {
                WRP16_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Write protect
            #[inline(always)]
            pub fn wrp17(&self) -> WRP17_R {
                WRP17_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Write protect
            #[inline(always)]
            pub fn wrp18(&self) -> WRP18_R {
                WRP18_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Write protect
            #[inline(always)]
            pub fn wrp19(&self) -> WRP19_R {
                WRP19_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Write protect
            #[inline(always)]
            pub fn wrp20(&self) -> WRP20_R {
                WRP20_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Write protect
            #[inline(always)]
            pub fn wrp21(&self) -> WRP21_R {
                WRP21_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Write protect
            #[inline(always)]
            pub fn wrp22(&self) -> WRP22_R {
                WRP22_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Write protect
            #[inline(always)]
            pub fn wrp23(&self) -> WRP23_R {
                WRP23_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Write protect
            #[inline(always)]
            pub fn wrp24(&self) -> WRP24_R {
                WRP24_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Write protect
            #[inline(always)]
            pub fn wrp25(&self) -> WRP25_R {
                WRP25_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Write protect
            #[inline(always)]
            pub fn wrp26(&self) -> WRP26_R {
                WRP26_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Write protect
            #[inline(always)]
            pub fn wrp27(&self) -> WRP27_R {
                WRP27_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Write protect
            #[inline(always)]
            pub fn wrp28(&self) -> WRP28_R {
                WRP28_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Write protect
            #[inline(always)]
            pub fn wrp29(&self) -> WRP29_R {
                WRP29_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Write protect
            #[inline(always)]
            pub fn wrp30(&self) -> WRP30_R {
                WRP30_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Write protect
            #[inline(always)]
            pub fn wrp31(&self) -> WRP31_R {
                WRP31_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        ///Write protection register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wpr](index.html) module
        pub struct WPR_SPEC;
        impl crate::RegisterSpec for WPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [wpr::R](R) reader structure
        impl crate::Readable for WPR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets WPR to value 0xffff_ffff
        impl crate::Resettable for WPR_SPEC {
            const RESET_VALUE: Self::Ux = 0xffff_ffff;
        }
    }
    ///MODEKEYR (w) register accessor: an alias for `Reg<MODEKEYR_SPEC>`
    pub type MODEKEYR = crate::Reg<modekeyr::MODEKEYR_SPEC>;
    ///Extension key register
    pub mod modekeyr {
        ///Register `MODEKEYR` writer
        pub struct W(crate::W<MODEKEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MODEKEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MODEKEYR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MODEKEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///high speed write /erase mode ENABLE
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u32)]
        pub enum MODEKEYRW_AW {
            ///1164378403: Key1
            Key1 = 1164378403,
            ///3455027627: Key2
            Key2 = 3455027627,
        }
        impl From<MODEKEYRW_AW> for u32 {
            #[inline(always)]
            fn from(variant: MODEKEYRW_AW) -> Self {
                variant as _
            }
        }
        ///Field `MODEKEYR` writer - high speed write /erase mode ENABLE
        pub type MODEKEYR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MODEKEYR_SPEC, u32, MODEKEYRW_AW, 32, O>;
        impl<'a, const O: u8> MODEKEYR_W<'a, O> {
            ///Key1
            #[inline(always)]
            pub fn key1(self) -> &'a mut W {
                self.variant(MODEKEYRW_AW::Key1)
            }
            ///Key2
            #[inline(always)]
            pub fn key2(self) -> &'a mut W {
                self.variant(MODEKEYRW_AW::Key2)
            }
        }
        impl W {
            ///Bits 0:31 - high speed write /erase mode ENABLE
            #[inline(always)]
            #[must_use]
            pub fn modekeyr(&mut self) -> MODEKEYR_W<0> {
                MODEKEYR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Extension key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [modekeyr](index.html) module
        pub struct MODEKEYR_SPEC;
        impl crate::RegisterSpec for MODEKEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [modekeyr::W](W) writer structure
        impl crate::Writable for MODEKEYR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MODEKEYR to value 0
        impl crate::Resettable for MODEKEYR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Programmable Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Programmable Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Interrupt Status Register
        pub isr1: ISR1,
        ///0x04 - Interrupt Status Register
        pub isr2: ISR2,
        _reserved2: [u8; 0x18],
        ///0x20 - Interrupt Pending Register
        pub ipr1: IPR1,
        ///0x24 - Interrupt Pending Register
        pub ipr2: IPR2,
        _reserved4: [u8; 0x18],
        ///0x40 - Interrupt Priority Register
        pub ithresdr: ITHRESDR,
        ///0x44 - Interrupt Fast Address Register
        pub fibaddrr: FIBADDRR,
        ///0x48 - Interrupt Config Register
        pub cfgr: CFGR,
        ///0x4c - Interrupt Global Register
        pub gisr: GISR,
        _reserved8: [u8; 0x10],
        ///0x60 - Interrupt 0 address Register
        pub fifoaddrr0: FIFOADDRR0,
        ///0x64 - Interrupt 1 address Register
        pub fifoaddrr1: FIFOADDRR1,
        ///0x68 - Interrupt 2 address Register
        pub fifoaddrr2: FIFOADDRR2,
        ///0x6c - Interrupt 3 address Register
        pub fifoaddrr3: FIFOADDRR3,
        _reserved12: [u8; 0x90],
        ///0x100 - Interrupt Setting Register
        pub ienr1: IENR1,
        ///0x104 - Interrupt Setting Register
        pub ienr2: IENR2,
        _reserved14: [u8; 0x78],
        ///0x180 - Interrupt Clear Register
        pub irer1: IRER1,
        ///0x184 - Interrupt Clear Register
        pub irer2: IRER2,
        _reserved16: [u8; 0x78],
        ///0x200 - Interrupt Pending Register
        pub ipsr1: IPSR1,
        ///0x204 - Interrupt Pending Register
        pub ipsr2: IPSR2,
        _reserved18: [u8; 0x78],
        ///0x280 - Interrupt Pending Clear Register
        pub iprr1: IPRR1,
        ///0x284 - Interrupt Pending Clear Register
        pub iprr2: IPRR2,
        _reserved20: [u8; 0x78],
        ///0x300 - Interrupt ACTIVE Register
        pub iactr1: IACTR1,
        ///0x304 - Interrupt ACTIVE Register
        pub iactr2: IACTR2,
        _reserved22: [u8; 0x0a08],
        ///0xd10 - System Control Register
        pub sctlr: SCTLR,
    }
    ///ISR1 (r) register accessor: an alias for `Reg<ISR1_SPEC>`
    pub type ISR1 = crate::Reg<isr1::ISR1_SPEC>;
    ///Interrupt Status Register
    pub mod isr1 {
        ///Register `ISR1` reader
        pub struct R(crate::R<ISR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA2_3` reader - Interrupt ID Status
        pub type INTENSTA2_3_R = crate::FieldReader<u8, u8>;
        ///Field `INTENSTA12_31` reader - Interrupt ID Status
        pub type INTENSTA12_31_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 2:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta2_3(&self) -> INTENSTA2_3_R {
                INTENSTA2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta12_31(&self) -> INTENSTA12_31_R {
                INTENSTA12_31_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///Interrupt Status Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr1](index.html) module
        pub struct ISR1_SPEC;
        impl crate::RegisterSpec for ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr1::R](R) reader structure
        impl crate::Readable for ISR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR1 to value 0
        impl crate::Resettable for ISR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ISR2 (r) register accessor: an alias for `Reg<ISR2_SPEC>`
    pub type ISR2 = crate::Reg<isr2::ISR2_SPEC>;
    ///Interrupt Status Register
    pub mod isr2 {
        ///Register `ISR2` reader
        pub struct R(crate::R<ISR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:27 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new(self.bits & 0x0fff_ffff)
            }
        }
        ///Interrupt Status Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr2](index.html) module
        pub struct ISR2_SPEC;
        impl crate::RegisterSpec for ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr2::R](R) reader structure
        impl crate::Readable for ISR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR2 to value 0
        impl crate::Resettable for ISR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR1 (r) register accessor: an alias for `Reg<IPR1_SPEC>`
    pub type IPR1 = crate::Reg<ipr1::IPR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr1 {
        ///Register `IPR1` reader
        pub struct R(crate::R<IPR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA2_3` reader - PENDSTA
        pub type PENDSTA2_3_R = crate::FieldReader<u8, u8>;
        ///Field `PENDSTA12_31` reader - PENDSTA
        pub type PENDSTA12_31_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 2:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta2_3(&self) -> PENDSTA2_3_R {
                PENDSTA2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta12_31(&self) -> PENDSTA12_31_R {
                PENDSTA12_31_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr1](index.html) module
        pub struct IPR1_SPEC;
        impl crate::RegisterSpec for IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr1::R](R) reader structure
        impl crate::Readable for IPR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR1 to value 0
        impl crate::Resettable for IPR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR2 (r) register accessor: an alias for `Reg<IPR2_SPEC>`
    pub type IPR2 = crate::Reg<ipr2::IPR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr2 {
        ///Register `IPR2` reader
        pub struct R(crate::R<IPR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:27 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new(self.bits & 0x0fff_ffff)
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr2](index.html) module
        pub struct IPR2_SPEC;
        impl crate::RegisterSpec for IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr2::R](R) reader structure
        impl crate::Readable for IPR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR2 to value 0
        impl crate::Resettable for IPR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ITHRESDR (rw) register accessor: an alias for `Reg<ITHRESDR_SPEC>`
    pub type ITHRESDR = crate::Reg<ithresdr::ITHRESDR_SPEC>;
    ///Interrupt Priority Register
    pub mod ithresdr {
        ///Register `ITHRESDR` reader
        pub struct R(crate::R<ITHRESDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ITHRESDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ITHRESDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ITHRESDR` writer
        pub struct W(crate::W<ITHRESDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ITHRESDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ITHRESDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `THRESHOLD` reader - THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader<u8, u8>;
        ///Field `THRESHOLD` writer - THRESHOLD
        pub type THRESHOLD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, ITHRESDR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<0> {
                THRESHOLD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ithresdr](index.html) module
        pub struct ITHRESDR_SPEC;
        impl crate::RegisterSpec for ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ithresdr::R](R) reader structure
        impl crate::Readable for ITHRESDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ithresdr::W](W) writer structure
        impl crate::Writable for ITHRESDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ITHRESDR to value 0
        impl crate::Resettable for ITHRESDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIBADDRR (rw) register accessor: an alias for `Reg<FIBADDRR_SPEC>`
    pub type FIBADDRR = crate::Reg<fibaddrr::FIBADDRR_SPEC>;
    ///Interrupt Fast Address Register
    pub mod fibaddrr {
        ///Register `FIBADDRR` reader
        pub struct R(crate::R<FIBADDRR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIBADDRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIBADDRR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIBADDRR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIBADDRR` writer
        pub struct W(crate::W<FIBADDRR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIBADDRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIBADDRR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIBADDRR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BASEADDR` reader - BASEADDR
        pub type BASEADDR_R = crate::FieldReader<u8, u8>;
        ///Field `BASEADDR` writer - BASEADDR
        pub type BASEADDR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIBADDRR_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 28:31 - BASEADDR
            #[inline(always)]
            pub fn baseaddr(&self) -> BASEADDR_R {
                BASEADDR_R::new(((self.bits >> 28) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 28:31 - BASEADDR
            #[inline(always)]
            #[must_use]
            pub fn baseaddr(&mut self) -> BASEADDR_W<28> {
                BASEADDR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Fast Address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fibaddrr](index.html) module
        pub struct FIBADDRR_SPEC;
        impl crate::RegisterSpec for FIBADDRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fibaddrr::R](R) reader structure
        impl crate::Readable for FIBADDRR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fibaddrr::W](W) writer structure
        impl crate::Writable for FIBADDRR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIBADDRR to value 0
        impl crate::Resettable for FIBADDRR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR (rw) register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod cfgr {
        ///Register `CFGR` reader
        pub struct R(crate::R<CFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HWSTKCTRL` reader - HWSTKCTRL
        pub type HWSTKCTRL_R = crate::BitReader<HWSTKCTRL_A>;
        ///HWSTKCTRL
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum HWSTKCTRL_A {
            ///0: Hardware stack enabled
            Enabled = 0,
            ///1: Hardware stack disabled
            Disabled = 1,
        }
        impl From<HWSTKCTRL_A> for bool {
            #[inline(always)]
            fn from(variant: HWSTKCTRL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl HWSTKCTRL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HWSTKCTRL_A {
                match self.bits {
                    false => HWSTKCTRL_A::Enabled,
                    true => HWSTKCTRL_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == HWSTKCTRL_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == HWSTKCTRL_A::Disabled
            }
        }
        ///Field `HWSTKCTRL` writer - HWSTKCTRL
        pub type HWSTKCTRL_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, CFGR_SPEC, HWSTKCTRL_A, O>;
        impl<'a, const O: u8> HWSTKCTRL_W<'a, O> {
            ///Hardware stack enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(HWSTKCTRL_A::Enabled)
            }
            ///Hardware stack disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(HWSTKCTRL_A::Disabled)
            }
        }
        ///Field `NESTCTRL` reader - NESTCTRL
        pub type NESTCTRL_R = crate::BitReader<NESTCTRL_A>;
        ///NESTCTRL
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum NESTCTRL_A {
            ///0: Interrupt nesting enabled
            Enabled = 0,
            ///1: Interrupt nesting disabled
            Disabled = 1,
        }
        impl From<NESTCTRL_A> for bool {
            #[inline(always)]
            fn from(variant: NESTCTRL_A) -> Self {
                variant as u8 != 0
            }
        }
        impl NESTCTRL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> NESTCTRL_A {
                match self.bits {
                    false => NESTCTRL_A::Enabled,
                    true => NESTCTRL_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == NESTCTRL_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == NESTCTRL_A::Disabled
            }
        }
        ///Field `NESTCTRL` writer - NESTCTRL
        pub type NESTCTRL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, NESTCTRL_A, O>;
        impl<'a, const O: u8> NESTCTRL_W<'a, O> {
            ///Interrupt nesting enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NESTCTRL_A::Enabled)
            }
            ///Interrupt nesting disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NESTCTRL_A::Disabled)
            }
        }
        ///NMISET
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum NMISETW_AW {
            ///1: Set interrupt
            Set = 1,
        }
        impl From<NMISETW_AW> for bool {
            #[inline(always)]
            fn from(variant: NMISETW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `NMISET` writer - NMISET
        pub type NMISET_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, NMISETW_AW, O>;
        impl<'a, const O: u8> NMISET_W<'a, O> {
            ///Set interrupt
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(NMISETW_AW::Set)
            }
        }
        ///NMIRESET
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum NMIRESETW_AW {
            ///1: Reset the module
            Reset = 1,
        }
        impl From<NMIRESETW_AW> for bool {
            #[inline(always)]
            fn from(variant: NMIRESETW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `NMIRESET` writer - NMIRESET
        pub type NMIRESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, CFGR_SPEC, NMIRESETW_AW, O>;
        impl<'a, const O: u8> NMIRESET_W<'a, O> {
            ///Reset the module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(NMIRESETW_AW::Reset)
            }
        }
        ///Field `EXCRESET` writer - EXCRESET
        pub use NMIRESET_W as EXCRESET_W;
        ///Field `EXCSET` writer - EXCSET
        pub use NMISET_W as EXCSET_W;
        ///Field `PFICRSET` writer - PFICRSET
        pub type PFICRSET_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `SYSRESET` writer - SYSRESET
        pub use NMIRESET_W as SYSRESET_W;
        ///KEYCODE
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u16)]
        pub enum KEYCODEW_AW {
            ///64005: HWSTK and NEST key
            Key1 = 64005,
            ///48303: NMI and EXC key
            Key2 = 48303,
            ///48879: System Reset key
            Key3 = 48879,
        }
        impl From<KEYCODEW_AW> for u16 {
            #[inline(always)]
            fn from(variant: KEYCODEW_AW) -> Self {
                variant as _
            }
        }
        ///Field `KEYCODE` writer - KEYCODE
        pub type KEYCODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR_SPEC, u16, KEYCODEW_AW, 16, O>;
        impl<'a, const O: u8> KEYCODE_W<'a, O> {
            ///HWSTK and NEST key
            #[inline(always)]
            pub fn key1(self) -> &'a mut W {
                self.variant(KEYCODEW_AW::Key1)
            }
            ///NMI and EXC key
            #[inline(always)]
            pub fn key2(self) -> &'a mut W {
                self.variant(KEYCODEW_AW::Key2)
            }
            ///System Reset key
            #[inline(always)]
            pub fn key3(self) -> &'a mut W {
                self.variant(KEYCODEW_AW::Key3)
            }
        }
        impl R {
            ///Bit 0 - HWSTKCTRL
            #[inline(always)]
            pub fn hwstkctrl(&self) -> HWSTKCTRL_R {
                HWSTKCTRL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - NESTCTRL
            #[inline(always)]
            pub fn nestctrl(&self) -> NESTCTRL_R {
                NESTCTRL_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - HWSTKCTRL
            #[inline(always)]
            #[must_use]
            pub fn hwstkctrl(&mut self) -> HWSTKCTRL_W<0> {
                HWSTKCTRL_W::new(self)
            }
            ///Bit 1 - NESTCTRL
            #[inline(always)]
            #[must_use]
            pub fn nestctrl(&mut self) -> NESTCTRL_W<1> {
                NESTCTRL_W::new(self)
            }
            ///Bit 2 - NMISET
            #[inline(always)]
            #[must_use]
            pub fn nmiset(&mut self) -> NMISET_W<2> {
                NMISET_W::new(self)
            }
            ///Bit 3 - NMIRESET
            #[inline(always)]
            #[must_use]
            pub fn nmireset(&mut self) -> NMIRESET_W<3> {
                NMIRESET_W::new(self)
            }
            ///Bit 4 - EXCSET
            #[inline(always)]
            #[must_use]
            pub fn excset(&mut self) -> EXCSET_W<4> {
                EXCSET_W::new(self)
            }
            ///Bit 5 - EXCRESET
            #[inline(always)]
            #[must_use]
            pub fn excreset(&mut self) -> EXCRESET_W<5> {
                EXCRESET_W::new(self)
            }
            ///Bit 6 - PFICRSET
            #[inline(always)]
            #[must_use]
            pub fn pficrset(&mut self) -> PFICRSET_W<6> {
                PFICRSET_W::new(self)
            }
            ///Bit 7 - SYSRESET
            #[inline(always)]
            #[must_use]
            pub fn sysreset(&mut self) -> SYSRESET_W<7> {
                SYSRESET_W::new(self)
            }
            ///Bits 16:31 - KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<16> {
                KEYCODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr::R](R) reader structure
        impl crate::Readable for CFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///GISR (r) register accessor: an alias for `Reg<GISR_SPEC>`
    pub type GISR = crate::Reg<gisr::GISR_SPEC>;
    ///Interrupt Global Register
    pub mod gisr {
        ///Register `GISR` reader
        pub struct R(crate::R<GISR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GISR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GISR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GISR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `NESTSTA` reader - NESTSTA
        pub type NESTSTA_R = crate::FieldReader<u8, NESTSTAR_A>;
        ///NESTSTA
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum NESTSTAR_A {
            ///0: No interrupt ongoing
            NoInterrupt = 0,
            ///1: Primary interrupt ongoing
            Primary = 1,
            ///3: Secondary interrupt ongoing
            Secondary = 3,
        }
        impl From<NESTSTAR_A> for u8 {
            #[inline(always)]
            fn from(variant: NESTSTAR_A) -> Self {
                variant as _
            }
        }
        impl NESTSTA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<NESTSTAR_A> {
                match self.bits {
                    0 => Some(NESTSTAR_A::NoInterrupt),
                    1 => Some(NESTSTAR_A::Primary),
                    3 => Some(NESTSTAR_A::Secondary),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NoInterrupt`
            #[inline(always)]
            pub fn is_no_interrupt(&self) -> bool {
                *self == NESTSTAR_A::NoInterrupt
            }
            ///Checks if the value of the field is `Primary`
            #[inline(always)]
            pub fn is_primary(&self) -> bool {
                *self == NESTSTAR_A::Primary
            }
            ///Checks if the value of the field is `Secondary`
            #[inline(always)]
            pub fn is_secondary(&self) -> bool {
                *self == NESTSTAR_A::Secondary
            }
        }
        ///Field `GACTSTA` reader - GACTSTA
        pub type GACTSTA_R = crate::BitReader<GACTSTAR_A>;
        ///GACTSTA
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GACTSTAR_A {
            ///0: No interrupt ongoing
            NoInterrupt = 0,
            ///1: Interrupt ongoing
            HasInterrupt = 1,
        }
        impl From<GACTSTAR_A> for bool {
            #[inline(always)]
            fn from(variant: GACTSTAR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl GACTSTA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> GACTSTAR_A {
                match self.bits {
                    false => GACTSTAR_A::NoInterrupt,
                    true => GACTSTAR_A::HasInterrupt,
                }
            }
            ///Checks if the value of the field is `NoInterrupt`
            #[inline(always)]
            pub fn is_no_interrupt(&self) -> bool {
                *self == GACTSTAR_A::NoInterrupt
            }
            ///Checks if the value of the field is `HasInterrupt`
            #[inline(always)]
            pub fn is_has_interrupt(&self) -> bool {
                *self == GACTSTAR_A::HasInterrupt
            }
        }
        ///Field `GPENDSTA` reader - GPENDSTA
        pub type GPENDSTA_R = crate::BitReader<GPENDSTAR_A>;
        ///GPENDSTA
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum GPENDSTAR_A {
            ///0: No interrupt pending
            NoPendingInterrupt = 0,
            ///1: Has interrupt pending
            HasPendingInterrupt = 1,
        }
        impl From<GPENDSTAR_A> for bool {
            #[inline(always)]
            fn from(variant: GPENDSTAR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl GPENDSTA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> GPENDSTAR_A {
                match self.bits {
                    false => GPENDSTAR_A::NoPendingInterrupt,
                    true => GPENDSTAR_A::HasPendingInterrupt,
                }
            }
            ///Checks if the value of the field is `NoPendingInterrupt`
            #[inline(always)]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GPENDSTAR_A::NoPendingInterrupt
            }
            ///Checks if the value of the field is `HasPendingInterrupt`
            #[inline(always)]
            pub fn is_has_pending_interrupt(&self) -> bool {
                *self == GPENDSTAR_A::HasPendingInterrupt
            }
        }
        impl R {
            ///Bits 0:7 - NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [gisr](index.html) module
        pub struct GISR_SPEC;
        impl crate::RegisterSpec for GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [gisr::R](R) reader structure
        impl crate::Readable for GISR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets GISR to value 0
        impl crate::Resettable for GISR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIFOADDRR0 (rw) register accessor: an alias for `Reg<FIFOADDRR0_SPEC>`
    pub type FIFOADDRR0 = crate::Reg<fifoaddrr0::FIFOADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod fifoaddrr0 {
        ///Register `FIFOADDRR0` reader
        pub struct R(crate::R<FIFOADDRR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIFOADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIFOADDRR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIFOADDRR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIFOADDRR0` writer
        pub struct W(crate::W<FIFOADDRR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIFOADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIFOADDRR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIFOADDRR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OFFADDR0` reader - OFFADDR0
        pub type OFFADDR0_R = crate::FieldReader<u32, u32>;
        ///Field `OFFADDR0` writer - OFFADDR0
        pub type OFFADDR0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR0_SPEC, u32, u32, 24, O>;
        ///Field `IRQID0` reader - IRQID0
        pub type IRQID0_R = crate::FieldReader<u8, u8>;
        ///Field `IRQID0` writer - IRQID0
        pub type IRQID0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR0_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:23 - OFFADDR0
            #[inline(always)]
            pub fn offaddr0(&self) -> OFFADDR0_R {
                OFFADDR0_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID0
            #[inline(always)]
            pub fn irqid0(&self) -> IRQID0_R {
                IRQID0_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR0
            #[inline(always)]
            #[must_use]
            pub fn offaddr0(&mut self) -> OFFADDR0_W<0> {
                OFFADDR0_W::new(self)
            }
            ///Bits 24:31 - IRQID0
            #[inline(always)]
            #[must_use]
            pub fn irqid0(&mut self) -> IRQID0_W<24> {
                IRQID0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fifoaddrr0](index.html) module
        pub struct FIFOADDRR0_SPEC;
        impl crate::RegisterSpec for FIFOADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fifoaddrr0::R](R) reader structure
        impl crate::Readable for FIFOADDRR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fifoaddrr0::W](W) writer structure
        impl crate::Writable for FIFOADDRR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIFOADDRR0 to value 0
        impl crate::Resettable for FIFOADDRR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIFOADDRR1 (rw) register accessor: an alias for `Reg<FIFOADDRR1_SPEC>`
    pub type FIFOADDRR1 = crate::Reg<fifoaddrr1::FIFOADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod fifoaddrr1 {
        ///Register `FIFOADDRR1` reader
        pub struct R(crate::R<FIFOADDRR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIFOADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIFOADDRR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIFOADDRR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIFOADDRR1` writer
        pub struct W(crate::W<FIFOADDRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIFOADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIFOADDRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIFOADDRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OFFADDR1` reader - OFFADDR1
        pub type OFFADDR1_R = crate::FieldReader<u32, u32>;
        ///Field `OFFADDR1` writer - OFFADDR1
        pub type OFFADDR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR1_SPEC, u32, u32, 24, O>;
        ///Field `IRQID1` reader - IRQID1
        pub type IRQID1_R = crate::FieldReader<u8, u8>;
        ///Field `IRQID1` writer - IRQID1
        pub type IRQID1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR1_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:23 - OFFADDR1
            #[inline(always)]
            pub fn offaddr1(&self) -> OFFADDR1_R {
                OFFADDR1_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID1
            #[inline(always)]
            pub fn irqid1(&self) -> IRQID1_R {
                IRQID1_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR1
            #[inline(always)]
            #[must_use]
            pub fn offaddr1(&mut self) -> OFFADDR1_W<0> {
                OFFADDR1_W::new(self)
            }
            ///Bits 24:31 - IRQID1
            #[inline(always)]
            #[must_use]
            pub fn irqid1(&mut self) -> IRQID1_W<24> {
                IRQID1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fifoaddrr1](index.html) module
        pub struct FIFOADDRR1_SPEC;
        impl crate::RegisterSpec for FIFOADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fifoaddrr1::R](R) reader structure
        impl crate::Readable for FIFOADDRR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fifoaddrr1::W](W) writer structure
        impl crate::Writable for FIFOADDRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIFOADDRR1 to value 0
        impl crate::Resettable for FIFOADDRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIFOADDRR2 (rw) register accessor: an alias for `Reg<FIFOADDRR2_SPEC>`
    pub type FIFOADDRR2 = crate::Reg<fifoaddrr2::FIFOADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod fifoaddrr2 {
        ///Register `FIFOADDRR2` reader
        pub struct R(crate::R<FIFOADDRR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIFOADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIFOADDRR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIFOADDRR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIFOADDRR2` writer
        pub struct W(crate::W<FIFOADDRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIFOADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIFOADDRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIFOADDRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OFFADDR2` reader - OFFADDR2
        pub type OFFADDR2_R = crate::FieldReader<u32, u32>;
        ///Field `OFFADDR2` writer - OFFADDR2
        pub type OFFADDR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR2_SPEC, u32, u32, 24, O>;
        ///Field `IRQID2` reader - IRQID2
        pub type IRQID2_R = crate::FieldReader<u8, u8>;
        ///Field `IRQID2` writer - IRQID2
        pub type IRQID2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR2_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:23 - OFFADDR2
            #[inline(always)]
            pub fn offaddr2(&self) -> OFFADDR2_R {
                OFFADDR2_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID2
            #[inline(always)]
            pub fn irqid2(&self) -> IRQID2_R {
                IRQID2_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR2
            #[inline(always)]
            #[must_use]
            pub fn offaddr2(&mut self) -> OFFADDR2_W<0> {
                OFFADDR2_W::new(self)
            }
            ///Bits 24:31 - IRQID2
            #[inline(always)]
            #[must_use]
            pub fn irqid2(&mut self) -> IRQID2_W<24> {
                IRQID2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fifoaddrr2](index.html) module
        pub struct FIFOADDRR2_SPEC;
        impl crate::RegisterSpec for FIFOADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fifoaddrr2::R](R) reader structure
        impl crate::Readable for FIFOADDRR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fifoaddrr2::W](W) writer structure
        impl crate::Writable for FIFOADDRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIFOADDRR2 to value 0
        impl crate::Resettable for FIFOADDRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FIFOADDRR3 (rw) register accessor: an alias for `Reg<FIFOADDRR3_SPEC>`
    pub type FIFOADDRR3 = crate::Reg<fifoaddrr3::FIFOADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod fifoaddrr3 {
        ///Register `FIFOADDRR3` reader
        pub struct R(crate::R<FIFOADDRR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FIFOADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FIFOADDRR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FIFOADDRR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FIFOADDRR3` writer
        pub struct W(crate::W<FIFOADDRR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FIFOADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FIFOADDRR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FIFOADDRR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OFFADDR3` reader - OFFADDR3
        pub type OFFADDR3_R = crate::FieldReader<u32, u32>;
        ///Field `OFFADDR3` writer - OFFADDR3
        pub type OFFADDR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR3_SPEC, u32, u32, 24, O>;
        ///Field `IRQID3` reader - IRQID3
        pub type IRQID3_R = crate::FieldReader<u8, u8>;
        ///Field `IRQID3` writer - IRQID3
        pub type IRQID3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FIFOADDRR3_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:23 - OFFADDR3
            #[inline(always)]
            pub fn offaddr3(&self) -> OFFADDR3_R {
                OFFADDR3_R::new(self.bits & 0x00ff_ffff)
            }
            ///Bits 24:31 - IRQID3
            #[inline(always)]
            pub fn irqid3(&self) -> IRQID3_R {
                IRQID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:23 - OFFADDR3
            #[inline(always)]
            #[must_use]
            pub fn offaddr3(&mut self) -> OFFADDR3_W<0> {
                OFFADDR3_W::new(self)
            }
            ///Bits 24:31 - IRQID3
            #[inline(always)]
            #[must_use]
            pub fn irqid3(&mut self) -> IRQID3_W<24> {
                IRQID3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fifoaddrr3](index.html) module
        pub struct FIFOADDRR3_SPEC;
        impl crate::RegisterSpec for FIFOADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fifoaddrr3::R](R) reader structure
        impl crate::Readable for FIFOADDRR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fifoaddrr3::W](W) writer structure
        impl crate::Writable for FIFOADDRR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FIFOADDRR3 to value 0
        impl crate::Resettable for FIFOADDRR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR1 (rw) register accessor: an alias for `Reg<IENR1_SPEC>`
    pub type IENR1 = crate::Reg<ienr1::IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr1 {
        ///Register `IENR1` reader
        pub struct R(crate::R<IENR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IENR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IENR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IENR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IENR1` writer
        pub struct W(crate::W<IENR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` reader - INTEN
        pub type INTEN_R = crate::FieldReader<u32, u32>;
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IENR1_SPEC, u32, u32, 20, O>;
        impl R {
            ///Bits 12:31 - INTEN
            #[inline(always)]
            pub fn inten(&self) -> INTEN_R {
                INTEN_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<12> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr1](index.html) module
        pub struct IENR1_SPEC;
        impl crate::RegisterSpec for IENR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ienr1::R](R) reader structure
        impl crate::Readable for IENR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ienr1::W](W) writer structure
        impl crate::Writable for IENR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR1 to value 0
        impl crate::Resettable for IENR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR2 (rw) register accessor: an alias for `Reg<IENR2_SPEC>`
    pub type IENR2 = crate::Reg<ienr2::IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr2 {
        ///Register `IENR2` reader
        pub struct R(crate::R<IENR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IENR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IENR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IENR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IENR2` writer
        pub struct W(crate::W<IENR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` reader - INTEN
        pub type INTEN_R = crate::FieldReader<u32, u32>;
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IENR2_SPEC, u32, u32, 28, O>;
        impl R {
            ///Bits 0:27 - INTEN
            #[inline(always)]
            pub fn inten(&self) -> INTEN_R {
                INTEN_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<0> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr2](index.html) module
        pub struct IENR2_SPEC;
        impl crate::RegisterSpec for IENR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ienr2::R](R) reader structure
        impl crate::Readable for IENR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ienr2::W](W) writer structure
        impl crate::Writable for IENR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR2 to value 0
        impl crate::Resettable for IENR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER1 (rw) register accessor: an alias for `Reg<IRER1_SPEC>`
    pub type IRER1 = crate::Reg<irer1::IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod irer1 {
        ///Register `IRER1` reader
        pub struct R(crate::R<IRER1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IRER1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IRER1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IRER1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IRER1` writer
        pub struct W(crate::W<IRER1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRSET` reader - INTRSET
        pub type INTRSET_R = crate::FieldReader<u32, u32>;
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IRER1_SPEC, u32, u32, 20, O>;
        impl R {
            ///Bits 12:31 - INTRSET
            #[inline(always)]
            pub fn intrset(&self) -> INTRSET_R {
                INTRSET_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<12> {
                INTRSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer1](index.html) module
        pub struct IRER1_SPEC;
        impl crate::RegisterSpec for IRER1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [irer1::R](R) reader structure
        impl crate::Readable for IRER1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [irer1::W](W) writer structure
        impl crate::Writable for IRER1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER1 to value 0
        impl crate::Resettable for IRER1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER2 (rw) register accessor: an alias for `Reg<IRER2_SPEC>`
    pub type IRER2 = crate::Reg<irer2::IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod irer2 {
        ///Register `IRER2` reader
        pub struct R(crate::R<IRER2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IRER2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IRER2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IRER2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IRER2` writer
        pub struct W(crate::W<IRER2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRSET` reader - INTRSET
        pub type INTRSET_R = crate::FieldReader<u32, u32>;
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IRER2_SPEC, u32, u32, 28, O>;
        impl R {
            ///Bits 0:27 - INTRSET
            #[inline(always)]
            pub fn intrset(&self) -> INTRSET_R {
                INTRSET_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<0> {
                INTRSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer2](index.html) module
        pub struct IRER2_SPEC;
        impl crate::RegisterSpec for IRER2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [irer2::R](R) reader structure
        impl crate::Readable for IRER2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [irer2::W](W) writer structure
        impl crate::Writable for IRER2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER2 to value 0
        impl crate::Resettable for IRER2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR1 (rw) register accessor: an alias for `Reg<IPSR1_SPEC>`
    pub type IPSR1 = crate::Reg<ipsr1::IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr1 {
        ///Register `IPSR1` reader
        pub struct R(crate::R<IPSR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPSR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPSR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPSR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPSR1` writer
        pub struct W(crate::W<IPSR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET2_3` reader - PENDSET
        pub type PENDSET2_3_R = crate::FieldReader<u8, u8>;
        ///Field `PENDSET2_3` writer - PENDSET
        pub type PENDSET2_3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPSR1_SPEC, u8, u8, 2, O>;
        ///Field `PENDSET12_31` reader - PENDSET
        pub type PENDSET12_31_R = crate::FieldReader<u32, u32>;
        ///Field `PENDSET12_31` writer - PENDSET
        pub type PENDSET12_31_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPSR1_SPEC, u32, u32, 20, O>;
        impl R {
            ///Bits 2:3 - PENDSET
            #[inline(always)]
            pub fn pendset2_3(&self) -> PENDSET2_3_R {
                PENDSET2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 12:31 - PENDSET
            #[inline(always)]
            pub fn pendset12_31(&self) -> PENDSET12_31_R {
                PENDSET12_31_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 2:3 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset2_3(&mut self) -> PENDSET2_3_W<2> {
                PENDSET2_3_W::new(self)
            }
            ///Bits 12:31 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset12_31(&mut self) -> PENDSET12_31_W<12> {
                PENDSET12_31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr1](index.html) module
        pub struct IPSR1_SPEC;
        impl crate::RegisterSpec for IPSR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipsr1::R](R) reader structure
        impl crate::Readable for IPSR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ipsr1::W](W) writer structure
        impl crate::Writable for IPSR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR1 to value 0
        impl crate::Resettable for IPSR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR2 (rw) register accessor: an alias for `Reg<IPSR2_SPEC>`
    pub type IPSR2 = crate::Reg<ipsr2::IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr2 {
        ///Register `IPSR2` reader
        pub struct R(crate::R<IPSR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPSR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPSR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPSR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPSR2` writer
        pub struct W(crate::W<IPSR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` reader - PENDSET
        pub type PENDSET_R = crate::FieldReader<u32, u32>;
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPSR2_SPEC, u32, u32, 28, O>;
        impl R {
            ///Bits 0:27 - PENDSET
            #[inline(always)]
            pub fn pendset(&self) -> PENDSET_R {
                PENDSET_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<0> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr2](index.html) module
        pub struct IPSR2_SPEC;
        impl crate::RegisterSpec for IPSR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipsr2::R](R) reader structure
        impl crate::Readable for IPSR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ipsr2::W](W) writer structure
        impl crate::Writable for IPSR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR2 to value 0
        impl crate::Resettable for IPSR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR1 (rw) register accessor: an alias for `Reg<IPRR1_SPEC>`
    pub type IPRR1 = crate::Reg<iprr1::IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr1 {
        ///Register `IPRR1` reader
        pub struct R(crate::R<IPRR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRR1` writer
        pub struct W(crate::W<IPRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET2_3` reader - PENDRESET
        pub type PENDRESET2_3_R = crate::FieldReader<u8, u8>;
        ///Field `PENDRESET2_3` writer - PENDRESET
        pub type PENDRESET2_3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR1_SPEC, u8, u8, 2, O>;
        ///Field `PENDRESET12_31` reader - PENDRESET
        pub type PENDRESET12_31_R = crate::FieldReader<u32, u32>;
        ///Field `PENDRESET12_31` writer - PENDRESET
        pub type PENDRESET12_31_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR1_SPEC, u32, u32, 20, O>;
        impl R {
            ///Bits 2:3 - PENDRESET
            #[inline(always)]
            pub fn pendreset2_3(&self) -> PENDRESET2_3_R {
                PENDRESET2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 12:31 - PENDRESET
            #[inline(always)]
            pub fn pendreset12_31(&self) -> PENDRESET12_31_R {
                PENDRESET12_31_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 2:3 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset2_3(&mut self) -> PENDRESET2_3_W<2> {
                PENDRESET2_3_W::new(self)
            }
            ///Bits 12:31 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset12_31(&mut self) -> PENDRESET12_31_W<12> {
                PENDRESET12_31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr1](index.html) module
        pub struct IPRR1_SPEC;
        impl crate::RegisterSpec for IPRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprr1::R](R) reader structure
        impl crate::Readable for IPRR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprr1::W](W) writer structure
        impl crate::Writable for IPRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR1 to value 0
        impl crate::Resettable for IPRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR2 (rw) register accessor: an alias for `Reg<IPRR2_SPEC>`
    pub type IPRR2 = crate::Reg<iprr2::IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr2 {
        ///Register `IPRR2` reader
        pub struct R(crate::R<IPRR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRR2` writer
        pub struct W(crate::W<IPRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` reader - PENDRESET
        pub type PENDRESET_R = crate::FieldReader<u32, u32>;
        ///Field `PENDRESET` writer - PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR2_SPEC, u32, u32, 28, O>;
        impl R {
            ///Bits 0:27 - PENDRESET
            #[inline(always)]
            pub fn pendreset(&self) -> PENDRESET_R {
                PENDRESET_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<0> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr2](index.html) module
        pub struct IPRR2_SPEC;
        impl crate::RegisterSpec for IPRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iprr2::R](R) reader structure
        impl crate::Readable for IPRR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprr2::W](W) writer structure
        impl crate::Writable for IPRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR2 to value 0
        impl crate::Resettable for IPRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR1 (rw) register accessor: an alias for `Reg<IACTR1_SPEC>`
    pub type IACTR1 = crate::Reg<iactr1::IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr1 {
        ///Register `IACTR1` reader
        pub struct R(crate::R<IACTR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IACTR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IACTR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IACTR1` writer
        pub struct W(crate::W<IACTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - IACTS
        pub type IACTS_R = crate::FieldReader<u32, u32>;
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IACTR1_SPEC, u32, u32, 20, O>;
        impl R {
            ///Bits 12:31 - IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            ///Bits 12:31 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<12> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr1](index.html) module
        pub struct IACTR1_SPEC;
        impl crate::RegisterSpec for IACTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iactr1::R](R) reader structure
        impl crate::Readable for IACTR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iactr1::W](W) writer structure
        impl crate::Writable for IACTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR1 to value 0
        impl crate::Resettable for IACTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR2 (rw) register accessor: an alias for `Reg<IACTR2_SPEC>`
    pub type IACTR2 = crate::Reg<iactr2::IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr2 {
        ///Register `IACTR2` reader
        pub struct R(crate::R<IACTR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IACTR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IACTR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IACTR2` writer
        pub struct W(crate::W<IACTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` reader - IACTS
        pub type IACTS_R = crate::FieldReader<u32, u32>;
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IACTR2_SPEC, u32, u32, 28, O>;
        impl R {
            ///Bits 0:27 - IACTS
            #[inline(always)]
            pub fn iacts(&self) -> IACTS_R {
                IACTS_R::new(self.bits & 0x0fff_ffff)
            }
        }
        impl W {
            ///Bits 0:27 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<0> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr2](index.html) module
        pub struct IACTR2_SPEC;
        impl crate::RegisterSpec for IACTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iactr2::R](R) reader structure
        impl crate::Readable for IACTR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iactr2::W](W) writer structure
        impl crate::Writable for IACTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR2 to value 0
        impl crate::Resettable for IACTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SCTLR (rw) register accessor: an alias for `Reg<SCTLR_SPEC>`
    pub type SCTLR = crate::Reg<sctlr::SCTLR_SPEC>;
    ///System Control Register
    pub mod sctlr {
        ///Register `SCTLR` reader
        pub struct R(crate::R<SCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SCTLR` writer
        pub struct W(crate::W<SCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLEEPONEXIT` reader - SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader<SLEEPONEXIT_A>;
        ///SLEEPONEXIT
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SLEEPONEXIT_A {
            ///0: Don't sleep after exiting interrupt service
            Continue = 0,
            ///1: Enter sleep mode after exiting interrupt service
            Sleep = 1,
        }
        impl From<SLEEPONEXIT_A> for bool {
            #[inline(always)]
            fn from(variant: SLEEPONEXIT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SLEEPONEXIT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SLEEPONEXIT_A {
                match self.bits {
                    false => SLEEPONEXIT_A::Continue,
                    true => SLEEPONEXIT_A::Sleep,
                }
            }
            ///Checks if the value of the field is `Continue`
            #[inline(always)]
            pub fn is_continue(&self) -> bool {
                *self == SLEEPONEXIT_A::Continue
            }
            ///Checks if the value of the field is `Sleep`
            #[inline(always)]
            pub fn is_sleep(&self) -> bool {
                *self == SLEEPONEXIT_A::Sleep
            }
        }
        ///Field `SLEEPONEXIT` writer - SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, SCTLR_SPEC, SLEEPONEXIT_A, O>;
        impl<'a, const O: u8> SLEEPONEXIT_W<'a, O> {
            ///Don't sleep after exiting interrupt service
            #[inline(always)]
            pub fn continue_(self) -> &'a mut W {
                self.variant(SLEEPONEXIT_A::Continue)
            }
            ///Enter sleep mode after exiting interrupt service
            #[inline(always)]
            pub fn sleep(self) -> &'a mut W {
                self.variant(SLEEPONEXIT_A::Sleep)
            }
        }
        ///Field `SLEEPDEEP` reader - SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader<SLEEPDEEP_A>;
        ///SLEEPDEEP
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SLEEPDEEP_A {
            ///0: Sleep mode
            Sleep = 0,
            ///1: Deep Sleep mode
            DeepSleep = 1,
        }
        impl From<SLEEPDEEP_A> for bool {
            #[inline(always)]
            fn from(variant: SLEEPDEEP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SLEEPDEEP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SLEEPDEEP_A {
                match self.bits {
                    false => SLEEPDEEP_A::Sleep,
                    true => SLEEPDEEP_A::DeepSleep,
                }
            }
            ///Checks if the value of the field is `Sleep`
            #[inline(always)]
            pub fn is_sleep(&self) -> bool {
                *self == SLEEPDEEP_A::Sleep
            }
            ///Checks if the value of the field is `DeepSleep`
            #[inline(always)]
            pub fn is_deep_sleep(&self) -> bool {
                *self == SLEEPDEEP_A::DeepSleep
            }
        }
        ///Field `SLEEPDEEP` writer - SLEEPDEEP
        pub type SLEEPDEEP_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, SCTLR_SPEC, SLEEPDEEP_A, O>;
        impl<'a, const O: u8> SLEEPDEEP_W<'a, O> {
            ///Sleep mode
            #[inline(always)]
            pub fn sleep(self) -> &'a mut W {
                self.variant(SLEEPDEEP_A::Sleep)
            }
            ///Deep Sleep mode
            #[inline(always)]
            pub fn deep_sleep(self) -> &'a mut W {
                self.variant(SLEEPDEEP_A::DeepSleep)
            }
        }
        ///Field `WFITOWFE` reader - WFITOWFE
        pub type WFITOWFE_R = crate::BitReader<WFITOWFE_A>;
        ///WFITOWFE
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WFITOWFE_A {
            ///0: Nothing
            Normal = 0,
            ///1: WFI is treated as WFE
            Enabled = 1,
        }
        impl From<WFITOWFE_A> for bool {
            #[inline(always)]
            fn from(variant: WFITOWFE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WFITOWFE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WFITOWFE_A {
                match self.bits {
                    false => WFITOWFE_A::Normal,
                    true => WFITOWFE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Normal`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == WFITOWFE_A::Normal
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WFITOWFE_A::Enabled
            }
        }
        ///Field `WFITOWFE` writer - WFITOWFE
        pub type WFITOWFE_W<'a, const O: u8> = crate::BitWriter<'a, u32, SCTLR_SPEC, WFITOWFE_A, O>;
        impl<'a, const O: u8> WFITOWFE_W<'a, O> {
            ///Nothing
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(WFITOWFE_A::Normal)
            }
            ///WFI is treated as WFE
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WFITOWFE_A::Enabled)
            }
        }
        ///Field `SEVONPEND` reader - SEVONPEND
        pub type SEVONPEND_R = crate::BitReader<SEVONPEND_A>;
        ///SEVONPEND
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SEVONPEND_A {
            ///0: Only enabled events and interrupts can wake up the system
            OnlyEnabled = 0,
            ///1: Enabled events and all interrupts can wake up the system
            AllInterrupts = 1,
        }
        impl From<SEVONPEND_A> for bool {
            #[inline(always)]
            fn from(variant: SEVONPEND_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SEVONPEND_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SEVONPEND_A {
                match self.bits {
                    false => SEVONPEND_A::OnlyEnabled,
                    true => SEVONPEND_A::AllInterrupts,
                }
            }
            ///Checks if the value of the field is `OnlyEnabled`
            #[inline(always)]
            pub fn is_only_enabled(&self) -> bool {
                *self == SEVONPEND_A::OnlyEnabled
            }
            ///Checks if the value of the field is `AllInterrupts`
            #[inline(always)]
            pub fn is_all_interrupts(&self) -> bool {
                *self == SEVONPEND_A::AllInterrupts
            }
        }
        ///Field `SEVONPEND` writer - SEVONPEND
        pub type SEVONPEND_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, SCTLR_SPEC, SEVONPEND_A, O>;
        impl<'a, const O: u8> SEVONPEND_W<'a, O> {
            ///Only enabled events and interrupts can wake up the system
            #[inline(always)]
            pub fn only_enabled(self) -> &'a mut W {
                self.variant(SEVONPEND_A::OnlyEnabled)
            }
            ///Enabled events and all interrupts can wake up the system
            #[inline(always)]
            pub fn all_interrupts(self) -> &'a mut W {
                self.variant(SEVONPEND_A::AllInterrupts)
            }
        }
        ///Field `SETEVENT` reader - SETEVENT
        pub type SETEVENT_R = crate::BitReader<SETEVENTW_A>;
        ///SETEVENT
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETEVENTW_A {
            ///1: Set WFE event
            Set = 1,
        }
        impl From<SETEVENTW_A> for bool {
            #[inline(always)]
            fn from(variant: SETEVENTW_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETEVENT_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<SETEVENTW_A> {
                match self.bits {
                    true => Some(SETEVENTW_A::Set),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Set`
            #[inline(always)]
            pub fn is_set(&self) -> bool {
                *self == SETEVENTW_A::Set
            }
        }
        ///Field `SETEVENT` writer - SETEVENT
        pub type SETEVENT_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, SCTLR_SPEC, SETEVENTW_A, O>;
        impl<'a, const O: u8> SETEVENT_W<'a, O> {
            ///Set WFE event
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(SETEVENTW_A::Set)
            }
        }
        impl R {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<1> {
                SLEEPONEXIT_W::new(self)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<2> {
                SLEEPDEEP_W::new(self)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<3> {
                WFITOWFE_W::new(self)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<4> {
                SEVONPEND_W::new(self)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<5> {
                SETEVENT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System Control Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sctlr](index.html) module
        pub struct SCTLR_SPEC;
        impl crate::RegisterSpec for SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sctlr::R](R) reader structure
        impl crate::Readable for SCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sctlr::W](W) writer structure
        impl crate::Writable for SCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SCTLR to value 0
        impl crate::Resettable for SCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Universal serial bus full-speed device interface
pub struct USBD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USBD {}
impl USBD {
    ///Pointer to the register block
    pub const PTR: *const usbd::RegisterBlock = 0x4000_5c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usbd::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USBD {
    type Target = usbd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USBD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USBD").finish()
    }
}
///Universal serial bus full-speed device interface
pub mod usbd {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - endpoint 0 register
        pub ep0r: EP0R,
        _reserved1: [u8; 0x02],
        ///0x04 - endpoint 1 register
        pub ep1r: EP1R,
        _reserved2: [u8; 0x02],
        ///0x08 - endpoint 2 register
        pub ep2r: EP2R,
        _reserved3: [u8; 0x02],
        ///0x0c - endpoint 3 register
        pub ep3r: EP3R,
        _reserved4: [u8; 0x02],
        ///0x10 - endpoint 4 register
        pub ep4r: EP4R,
        _reserved5: [u8; 0x02],
        ///0x14 - endpoint 5 register
        pub ep5r: EP5R,
        _reserved6: [u8; 0x02],
        ///0x18 - endpoint 6 register
        pub ep6r: EP6R,
        _reserved7: [u8; 0x02],
        ///0x1c - endpoint 7 register
        pub ep7r: EP7R,
        _reserved8: [u8; 0x22],
        ///0x40 - control register
        pub cntr: CNTR,
        _reserved9: [u8; 0x02],
        ///0x44 - interrupt status register
        pub istr: ISTR,
        _reserved10: [u8; 0x02],
        ///0x48 - frame number register
        pub fnr: FNR,
        _reserved11: [u8; 0x02],
        ///0x4c - device address
        pub daddr: DADDR,
        _reserved12: [u8; 0x02],
        ///0x50 - Buffer table address
        pub btable: BTABLE,
    }
    ///EP0R (rw) register accessor: an alias for `Reg<EP0R_SPEC>`
    pub type EP0R = crate::Reg<ep0r::EP0R_SPEC>;
    ///endpoint 0 register
    pub mod ep0r {
        ///Register `EP0R` reader
        pub struct R(crate::R<EP0R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP0R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP0R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP0R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP0R` writer
        pub struct W(crate::W<EP0R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP0R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP0R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP0R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP0R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP0R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP0R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP0R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP0R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP0R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP0R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP0R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP0R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP0R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 0 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep0r](index.html) module
        pub struct EP0R_SPEC;
        impl crate::RegisterSpec for EP0R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep0r::R](R) reader structure
        impl crate::Readable for EP0R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep0r::W](W) writer structure
        impl crate::Writable for EP0R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP0R to value 0
        impl crate::Resettable for EP0R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EP1R (rw) register accessor: an alias for `Reg<EP1R_SPEC>`
    pub type EP1R = crate::Reg<ep1r::EP1R_SPEC>;
    ///endpoint 1 register
    pub mod ep1r {
        ///Register `EP1R` reader
        pub struct R(crate::R<EP1R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP1R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP1R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP1R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP1R` writer
        pub struct W(crate::W<EP1R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP1R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP1R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP1R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP1R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP1R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP1R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP1R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP1R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP1R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP1R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP1R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP1R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP1R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 1 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep1r](index.html) module
        pub struct EP1R_SPEC;
        impl crate::RegisterSpec for EP1R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep1r::R](R) reader structure
        impl crate::Readable for EP1R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep1r::W](W) writer structure
        impl crate::Writable for EP1R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP1R to value 0
        impl crate::Resettable for EP1R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EP2R (rw) register accessor: an alias for `Reg<EP2R_SPEC>`
    pub type EP2R = crate::Reg<ep2r::EP2R_SPEC>;
    ///endpoint 2 register
    pub mod ep2r {
        ///Register `EP2R` reader
        pub struct R(crate::R<EP2R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP2R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP2R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP2R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP2R` writer
        pub struct W(crate::W<EP2R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP2R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP2R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP2R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP2R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP2R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP2R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP2R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP2R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP2R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP2R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP2R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP2R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP2R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 2 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep2r](index.html) module
        pub struct EP2R_SPEC;
        impl crate::RegisterSpec for EP2R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep2r::R](R) reader structure
        impl crate::Readable for EP2R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep2r::W](W) writer structure
        impl crate::Writable for EP2R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP2R to value 0
        impl crate::Resettable for EP2R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EP3R (rw) register accessor: an alias for `Reg<EP3R_SPEC>`
    pub type EP3R = crate::Reg<ep3r::EP3R_SPEC>;
    ///endpoint 3 register
    pub mod ep3r {
        ///Register `EP3R` reader
        pub struct R(crate::R<EP3R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP3R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP3R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP3R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP3R` writer
        pub struct W(crate::W<EP3R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP3R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP3R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP3R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP3R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP3R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP3R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP3R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP3R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP3R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP3R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP3R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP3R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP3R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 3 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep3r](index.html) module
        pub struct EP3R_SPEC;
        impl crate::RegisterSpec for EP3R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep3r::R](R) reader structure
        impl crate::Readable for EP3R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep3r::W](W) writer structure
        impl crate::Writable for EP3R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP3R to value 0
        impl crate::Resettable for EP3R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EP4R (rw) register accessor: an alias for `Reg<EP4R_SPEC>`
    pub type EP4R = crate::Reg<ep4r::EP4R_SPEC>;
    ///endpoint 4 register
    pub mod ep4r {
        ///Register `EP4R` reader
        pub struct R(crate::R<EP4R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP4R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP4R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP4R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP4R` writer
        pub struct W(crate::W<EP4R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP4R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP4R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP4R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP4R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP4R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP4R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP4R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP4R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP4R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP4R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP4R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP4R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP4R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 4 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep4r](index.html) module
        pub struct EP4R_SPEC;
        impl crate::RegisterSpec for EP4R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep4r::R](R) reader structure
        impl crate::Readable for EP4R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep4r::W](W) writer structure
        impl crate::Writable for EP4R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP4R to value 0
        impl crate::Resettable for EP4R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EP5R (rw) register accessor: an alias for `Reg<EP5R_SPEC>`
    pub type EP5R = crate::Reg<ep5r::EP5R_SPEC>;
    ///endpoint 5 register
    pub mod ep5r {
        ///Register `EP5R` reader
        pub struct R(crate::R<EP5R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP5R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP5R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP5R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP5R` writer
        pub struct W(crate::W<EP5R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP5R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP5R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP5R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP5R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP5R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP5R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP5R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP5R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP5R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP5R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP5R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP5R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP5R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 5 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep5r](index.html) module
        pub struct EP5R_SPEC;
        impl crate::RegisterSpec for EP5R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep5r::R](R) reader structure
        impl crate::Readable for EP5R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep5r::W](W) writer structure
        impl crate::Writable for EP5R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP5R to value 0
        impl crate::Resettable for EP5R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EP6R (rw) register accessor: an alias for `Reg<EP6R_SPEC>`
    pub type EP6R = crate::Reg<ep6r::EP6R_SPEC>;
    ///endpoint 6 register
    pub mod ep6r {
        ///Register `EP6R` reader
        pub struct R(crate::R<EP6R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP6R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP6R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP6R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP6R` writer
        pub struct W(crate::W<EP6R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP6R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP6R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP6R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP6R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP6R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP6R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP6R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP6R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP6R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP6R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP6R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP6R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP6R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 6 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep6r](index.html) module
        pub struct EP6R_SPEC;
        impl crate::RegisterSpec for EP6R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep6r::R](R) reader structure
        impl crate::Readable for EP6R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep6r::W](W) writer structure
        impl crate::Writable for EP6R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP6R to value 0
        impl crate::Resettable for EP6R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EP7R (rw) register accessor: an alias for `Reg<EP7R_SPEC>`
    pub type EP7R = crate::Reg<ep7r::EP7R_SPEC>;
    ///endpoint 7 register
    pub mod ep7r {
        ///Register `EP7R` reader
        pub struct R(crate::R<EP7R_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EP7R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EP7R_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EP7R_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EP7R` writer
        pub struct W(crate::W<EP7R_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EP7R_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EP7R_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EP7R_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EA` reader - Endpoint address
        pub type EA_R = crate::FieldReader<u8, u8>;
        ///Field `EA` writer - Endpoint address
        pub type EA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, EP7R_SPEC, u8, u8, 4, O>;
        ///Field `STAT_TX` reader - Status bits, for transmission transfers
        pub type STAT_TX_R = crate::FieldReader<u8, STAT_TXR_A>;
        ///Status bits, for transmission transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_TXR_A {
            ///0: all transmission requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all transmission requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all transmission requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for transmission
            Valid = 3,
        }
        impl From<STAT_TXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_TXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_TX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_TXR_A {
                match self.bits {
                    0 => STAT_TXR_A::Disabled,
                    1 => STAT_TXR_A::Stall,
                    2 => STAT_TXR_A::Nak,
                    3 => STAT_TXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_TXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_TXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_TXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_TXR_A::Valid
            }
        }
        ///Field `STAT_TX` writer - Status bits, for transmission transfers
        pub type STAT_TX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP7R_SPEC, u8, STAT_TXR_A, 2, O>;
        impl<'a, const O: u8> STAT_TX_W<'a, O> {
            ///all transmission requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Disabled)
            }
            ///the endpoint is stalled and all transmission requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Stall)
            }
            ///the endpoint is naked and all transmission requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Nak)
            }
            ///this endpoint is enabled for transmission
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_TXR_A::Valid)
            }
        }
        ///Field `DTOG_TX` reader - Data Toggle, for transmission transfers
        pub type DTOG_TX_R = crate::BitReader<bool>;
        ///Field `DTOG_TX` writer - Data Toggle, for transmission transfers
        pub type DTOG_TX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP7R_SPEC, bool, O>;
        ///Field `CTR_TX` reader - Correct Transfer for transmission
        pub type CTR_TX_R = crate::BitReader<bool>;
        ///Field `CTR_TX` writer - Correct Transfer for transmission
        pub type CTR_TX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP7R_SPEC, bool, O>;
        ///Field `EP_KIND` reader - Endpoint kind
        pub type EP_KIND_R = crate::BitReader<bool>;
        ///Field `EP_KIND` writer - Endpoint kind
        pub type EP_KIND_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP7R_SPEC, bool, O>;
        ///Field `EP_TYPE` reader - Endpoint type
        pub type EP_TYPE_R = crate::FieldReader<u8, EP_TYPE_A>;
        ///Endpoint type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EP_TYPE_A {
            ///0: Bulk endpoint
            Bulk = 0,
            ///1: Control endpoint
            Control = 1,
            ///2: Iso endpoint
            Iso = 2,
            ///3: Interrupt endpoint
            Interrupt = 3,
        }
        impl From<EP_TYPE_A> for u8 {
            #[inline(always)]
            fn from(variant: EP_TYPE_A) -> Self {
                variant as _
            }
        }
        impl EP_TYPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EP_TYPE_A {
                match self.bits {
                    0 => EP_TYPE_A::Bulk,
                    1 => EP_TYPE_A::Control,
                    2 => EP_TYPE_A::Iso,
                    3 => EP_TYPE_A::Interrupt,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Bulk`
            #[inline(always)]
            pub fn is_bulk(&self) -> bool {
                *self == EP_TYPE_A::Bulk
            }
            ///Checks if the value of the field is `Control`
            #[inline(always)]
            pub fn is_control(&self) -> bool {
                *self == EP_TYPE_A::Control
            }
            ///Checks if the value of the field is `Iso`
            #[inline(always)]
            pub fn is_iso(&self) -> bool {
                *self == EP_TYPE_A::Iso
            }
            ///Checks if the value of the field is `Interrupt`
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == EP_TYPE_A::Interrupt
            }
        }
        ///Field `EP_TYPE` writer - Endpoint type
        pub type EP_TYPE_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP7R_SPEC, u8, EP_TYPE_A, 2, O>;
        impl<'a, const O: u8> EP_TYPE_W<'a, O> {
            ///Bulk endpoint
            #[inline(always)]
            pub fn bulk(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Bulk)
            }
            ///Control endpoint
            #[inline(always)]
            pub fn control(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Control)
            }
            ///Iso endpoint
            #[inline(always)]
            pub fn iso(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Iso)
            }
            ///Interrupt endpoint
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(EP_TYPE_A::Interrupt)
            }
        }
        ///Field `SETUP` reader - Setup transaction completed
        pub type SETUP_R = crate::BitReader<SETUPR_A>;
        ///Setup transaction completed
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SETUPR_A {
            ///0: Not setup
            NotSetup = 0,
            ///1: Setup
            Setup = 1,
        }
        impl From<SETUPR_A> for bool {
            #[inline(always)]
            fn from(variant: SETUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SETUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SETUPR_A {
                match self.bits {
                    false => SETUPR_A::NotSetup,
                    true => SETUPR_A::Setup,
                }
            }
            ///Checks if the value of the field is `NotSetup`
            #[inline(always)]
            pub fn is_not_setup(&self) -> bool {
                *self == SETUPR_A::NotSetup
            }
            ///Checks if the value of the field is `Setup`
            #[inline(always)]
            pub fn is_setup(&self) -> bool {
                *self == SETUPR_A::Setup
            }
        }
        ///Field `SETUP` writer - Setup transaction completed
        pub type SETUP_W<'a, const O: u8> = crate::BitWriter<'a, u16, EP7R_SPEC, SETUPR_A, O>;
        impl<'a, const O: u8> SETUP_W<'a, O> {
            ///Not setup
            #[inline(always)]
            pub fn not_setup(self) -> &'a mut W {
                self.variant(SETUPR_A::NotSetup)
            }
            ///Setup
            #[inline(always)]
            pub fn setup(self) -> &'a mut W {
                self.variant(SETUPR_A::Setup)
            }
        }
        ///Field `STAT_RX` reader - Status bits, for reception transfers
        pub type STAT_RX_R = crate::FieldReader<u8, STAT_RXR_A>;
        ///Status bits, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum STAT_RXR_A {
            ///0: all reception requests addressed to this endpoint are ignored
            Disabled = 0,
            ///1: the endpoint is stalled and all reception requests result in a STALL handshake
            Stall = 1,
            ///2: the endpoint is naked and all reception requests result in a NAK handshake
            Nak = 2,
            ///3: this endpoint is enabled for reception
            Valid = 3,
        }
        impl From<STAT_RXR_A> for u8 {
            #[inline(always)]
            fn from(variant: STAT_RXR_A) -> Self {
                variant as _
            }
        }
        impl STAT_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STAT_RXR_A {
                match self.bits {
                    0 => STAT_RXR_A::Disabled,
                    1 => STAT_RXR_A::Stall,
                    2 => STAT_RXR_A::Nak,
                    3 => STAT_RXR_A::Valid,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STAT_RXR_A::Disabled
            }
            ///Checks if the value of the field is `Stall`
            #[inline(always)]
            pub fn is_stall(&self) -> bool {
                *self == STAT_RXR_A::Stall
            }
            ///Checks if the value of the field is `Nak`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                *self == STAT_RXR_A::Nak
            }
            ///Checks if the value of the field is `Valid`
            #[inline(always)]
            pub fn is_valid(&self) -> bool {
                *self == STAT_RXR_A::Valid
            }
        }
        ///Field `STAT_RX` writer - Status bits, for reception transfers
        pub type STAT_RX_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, EP7R_SPEC, u8, STAT_RXR_A, 2, O>;
        impl<'a, const O: u8> STAT_RX_W<'a, O> {
            ///all reception requests addressed to this endpoint are ignored
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Disabled)
            }
            ///the endpoint is stalled and all reception requests result in a STALL handshake
            #[inline(always)]
            pub fn stall(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Stall)
            }
            ///the endpoint is naked and all reception requests result in a NAK handshake
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Nak)
            }
            ///this endpoint is enabled for reception
            #[inline(always)]
            pub fn valid(self) -> &'a mut W {
                self.variant(STAT_RXR_A::Valid)
            }
        }
        ///Field `DTOG_RX` reader - Data Toggle, for reception transfers
        pub type DTOG_RX_R = crate::BitReader<DTOG_RXR_A>;
        ///Data Toggle, for reception transfers
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTOG_RXR_A {
            ///0: Expect DATA0
            Data0 = 0,
            ///1: Expect DATA1
            Data1 = 1,
        }
        impl From<DTOG_RXR_A> for bool {
            #[inline(always)]
            fn from(variant: DTOG_RXR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTOG_RX_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DTOG_RXR_A {
                match self.bits {
                    false => DTOG_RXR_A::Data0,
                    true => DTOG_RXR_A::Data1,
                }
            }
            ///Checks if the value of the field is `Data0`
            #[inline(always)]
            pub fn is_data0(&self) -> bool {
                *self == DTOG_RXR_A::Data0
            }
            ///Checks if the value of the field is `Data1`
            #[inline(always)]
            pub fn is_data1(&self) -> bool {
                *self == DTOG_RXR_A::Data1
            }
        }
        ///Field `DTOG_RX` writer - Data Toggle, for reception transfers
        pub type DTOG_RX_W<'a, const O: u8> = crate::BitWriter1T<'a, u16, EP7R_SPEC, DTOG_RXR_A, O>;
        impl<'a, const O: u8> DTOG_RX_W<'a, O> {
            ///Expect DATA0
            #[inline(always)]
            pub fn data0(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data0)
            }
            ///Expect DATA1
            #[inline(always)]
            pub fn data1(self) -> &'a mut W {
                self.variant(DTOG_RXR_A::Data1)
            }
        }
        ///Field `CTR_RX` reader - Correct transfer for reception
        pub type CTR_RX_R = crate::BitReader<bool>;
        ///Field `CTR_RX` writer - Correct transfer for reception
        pub type CTR_RX_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, EP7R_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            pub fn ea(&self) -> EA_R {
                EA_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            pub fn stat_tx(&self) -> STAT_TX_R {
                STAT_TX_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            pub fn dtog_tx(&self) -> DTOG_TX_R {
                DTOG_TX_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            pub fn ctr_tx(&self) -> CTR_TX_R {
                CTR_TX_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            pub fn ep_kind(&self) -> EP_KIND_R {
                EP_KIND_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            pub fn ep_type(&self) -> EP_TYPE_R {
                EP_TYPE_R::new(((self.bits >> 9) & 3) as u8)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            pub fn setup(&self) -> SETUP_R {
                SETUP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            pub fn stat_rx(&self) -> STAT_RX_R {
                STAT_RX_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            pub fn dtog_rx(&self) -> DTOG_RX_R {
                DTOG_RX_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            pub fn ctr_rx(&self) -> CTR_RX_R {
                CTR_RX_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint address
            #[inline(always)]
            #[must_use]
            pub fn ea(&mut self) -> EA_W<0> {
                EA_W::new(self)
            }
            ///Bits 4:5 - Status bits, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_tx(&mut self) -> STAT_TX_W<4> {
                STAT_TX_W::new(self)
            }
            ///Bit 6 - Data Toggle, for transmission transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_tx(&mut self) -> DTOG_TX_W<6> {
                DTOG_TX_W::new(self)
            }
            ///Bit 7 - Correct Transfer for transmission
            #[inline(always)]
            #[must_use]
            pub fn ctr_tx(&mut self) -> CTR_TX_W<7> {
                CTR_TX_W::new(self)
            }
            ///Bit 8 - Endpoint kind
            #[inline(always)]
            #[must_use]
            pub fn ep_kind(&mut self) -> EP_KIND_W<8> {
                EP_KIND_W::new(self)
            }
            ///Bits 9:10 - Endpoint type
            #[inline(always)]
            #[must_use]
            pub fn ep_type(&mut self) -> EP_TYPE_W<9> {
                EP_TYPE_W::new(self)
            }
            ///Bit 11 - Setup transaction completed
            #[inline(always)]
            #[must_use]
            pub fn setup(&mut self) -> SETUP_W<11> {
                SETUP_W::new(self)
            }
            ///Bits 12:13 - Status bits, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn stat_rx(&mut self) -> STAT_RX_W<12> {
                STAT_RX_W::new(self)
            }
            ///Bit 14 - Data Toggle, for reception transfers
            #[inline(always)]
            #[must_use]
            pub fn dtog_rx(&mut self) -> DTOG_RX_W<14> {
                DTOG_RX_W::new(self)
            }
            ///Bit 15 - Correct transfer for reception
            #[inline(always)]
            #[must_use]
            pub fn ctr_rx(&mut self) -> CTR_RX_W<15> {
                CTR_RX_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///endpoint 7 register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ep7r](index.html) module
        pub struct EP7R_SPEC;
        impl crate::RegisterSpec for EP7R_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ep7r::R](R) reader structure
        impl crate::Readable for EP7R_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ep7r::W](W) writer structure
        impl crate::Writable for EP7R_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x8080;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7070;
        }
        ///`reset()` method sets EP7R to value 0
        impl crate::Resettable for EP7R_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR (rw) register accessor: an alias for `Reg<CNTR_SPEC>`
    pub type CNTR = crate::Reg<cntr::CNTR_SPEC>;
    ///control register
    pub mod cntr {
        ///Register `CNTR` reader
        pub struct R(crate::R<CNTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR` writer
        pub struct W(crate::W<CNTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FRES` reader - Force USB Reset
        pub type FRES_R = crate::BitReader<FRES_A>;
        ///Force USB Reset
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FRES_A {
            ///0: Clear USB reset
            NoReset = 0,
            ///1: Force a reset of the USB peripheral, exactly like a RESET signaling on the USB
            Reset = 1,
        }
        impl From<FRES_A> for bool {
            #[inline(always)]
            fn from(variant: FRES_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FRES_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> FRES_A {
                match self.bits {
                    false => FRES_A::NoReset,
                    true => FRES_A::Reset,
                }
            }
            ///Checks if the value of the field is `NoReset`
            #[inline(always)]
            pub fn is_no_reset(&self) -> bool {
                *self == FRES_A::NoReset
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == FRES_A::Reset
            }
        }
        ///Field `FRES` writer - Force USB Reset
        pub type FRES_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, FRES_A, O>;
        impl<'a, const O: u8> FRES_W<'a, O> {
            ///Clear USB reset
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(FRES_A::NoReset)
            }
            ///Force a reset of the USB peripheral, exactly like a RESET signaling on the USB
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(FRES_A::Reset)
            }
        }
        ///Field `PDWN` reader - Power down
        pub type PDWN_R = crate::BitReader<PDWN_A>;
        ///Power down
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PDWN_A {
            ///0: No power down
            Disabled = 0,
            ///1: Enter power down mode
            Enabled = 1,
        }
        impl From<PDWN_A> for bool {
            #[inline(always)]
            fn from(variant: PDWN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PDWN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PDWN_A {
                match self.bits {
                    false => PDWN_A::Disabled,
                    true => PDWN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PDWN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PDWN_A::Enabled
            }
        }
        ///Field `PDWN` writer - Power down
        pub type PDWN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, PDWN_A, O>;
        impl<'a, const O: u8> PDWN_W<'a, O> {
            ///No power down
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PDWN_A::Disabled)
            }
            ///Enter power down mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PDWN_A::Enabled)
            }
        }
        ///Field `LPMODE` reader - Low-power mode
        pub type LPMODE_R = crate::BitReader<LPMODE_A>;
        ///Low-power mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LPMODE_A {
            ///0: No low-power mode
            Disabled = 0,
            ///1: Enter low-power mode
            Enabled = 1,
        }
        impl From<LPMODE_A> for bool {
            #[inline(always)]
            fn from(variant: LPMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LPMODE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LPMODE_A {
                match self.bits {
                    false => LPMODE_A::Disabled,
                    true => LPMODE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == LPMODE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == LPMODE_A::Enabled
            }
        }
        ///Field `LPMODE` writer - Low-power mode
        pub type LPMODE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, LPMODE_A, O>;
        impl<'a, const O: u8> LPMODE_W<'a, O> {
            ///No low-power mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LPMODE_A::Disabled)
            }
            ///Enter low-power mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LPMODE_A::Enabled)
            }
        }
        ///Field `FSUSP` reader - Force suspend
        pub type FSUSP_R = crate::BitReader<FSUSP_A>;
        ///Force suspend
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FSUSP_A {
            ///0: No effect
            NoEffect = 0,
            ///1: Enter suspend mode. Clocks and static power dissipation in the analog transceiver are left unaffected
            Suspend = 1,
        }
        impl From<FSUSP_A> for bool {
            #[inline(always)]
            fn from(variant: FSUSP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FSUSP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> FSUSP_A {
                match self.bits {
                    false => FSUSP_A::NoEffect,
                    true => FSUSP_A::Suspend,
                }
            }
            ///Checks if the value of the field is `NoEffect`
            #[inline(always)]
            pub fn is_no_effect(&self) -> bool {
                *self == FSUSP_A::NoEffect
            }
            ///Checks if the value of the field is `Suspend`
            #[inline(always)]
            pub fn is_suspend(&self) -> bool {
                *self == FSUSP_A::Suspend
            }
        }
        ///Field `FSUSP` writer - Force suspend
        pub type FSUSP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, FSUSP_A, O>;
        impl<'a, const O: u8> FSUSP_W<'a, O> {
            ///No effect
            #[inline(always)]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(FSUSP_A::NoEffect)
            }
            ///Enter suspend mode. Clocks and static power dissipation in the analog transceiver are left unaffected
            #[inline(always)]
            pub fn suspend(self) -> &'a mut W {
                self.variant(FSUSP_A::Suspend)
            }
        }
        ///Field `RESUME` reader - Resume request
        pub type RESUME_R = crate::BitReader<RESUME_A>;
        ///Resume request
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RESUME_A {
            ///0: No action
            Idle = 0,
            ///1: Resume requested
            Requested = 1,
        }
        impl From<RESUME_A> for bool {
            #[inline(always)]
            fn from(variant: RESUME_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RESUME_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RESUME_A {
                match self.bits {
                    false => RESUME_A::Idle,
                    true => RESUME_A::Requested,
                }
            }
            ///Checks if the value of the field is `Idle`
            #[inline(always)]
            pub fn is_idle(&self) -> bool {
                *self == RESUME_A::Idle
            }
            ///Checks if the value of the field is `Requested`
            #[inline(always)]
            pub fn is_requested(&self) -> bool {
                *self == RESUME_A::Requested
            }
        }
        ///Field `RESUME` writer - Resume request
        pub type RESUME_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, RESUME_A, O>;
        impl<'a, const O: u8> RESUME_W<'a, O> {
            ///No action
            #[inline(always)]
            pub fn idle(self) -> &'a mut W {
                self.variant(RESUME_A::Idle)
            }
            ///Resume requested
            #[inline(always)]
            pub fn requested(self) -> &'a mut W {
                self.variant(RESUME_A::Requested)
            }
        }
        ///Field `ESOFM` reader - Expected start of frame interrupt mask
        pub type ESOFM_R = crate::BitReader<ESOFM_A>;
        ///Expected start of frame interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ESOFM_A {
            ///0: ESOF Interrupt disabled
            Disabled = 0,
            ///1: ESOF Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<ESOFM_A> for bool {
            #[inline(always)]
            fn from(variant: ESOFM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ESOFM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ESOFM_A {
                match self.bits {
                    false => ESOFM_A::Disabled,
                    true => ESOFM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ESOFM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ESOFM_A::Enabled
            }
        }
        ///Field `ESOFM` writer - Expected start of frame interrupt mask
        pub type ESOFM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, ESOFM_A, O>;
        impl<'a, const O: u8> ESOFM_W<'a, O> {
            ///ESOF Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ESOFM_A::Disabled)
            }
            ///ESOF Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ESOFM_A::Enabled)
            }
        }
        ///Field `SOFM` reader - Start of frame interrupt mask
        pub type SOFM_R = crate::BitReader<SOFM_A>;
        ///Start of frame interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SOFM_A {
            ///0: SOF Interrupt disabled
            Disabled = 0,
            ///1: SOF Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<SOFM_A> for bool {
            #[inline(always)]
            fn from(variant: SOFM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SOFM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SOFM_A {
                match self.bits {
                    false => SOFM_A::Disabled,
                    true => SOFM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SOFM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SOFM_A::Enabled
            }
        }
        ///Field `SOFM` writer - Start of frame interrupt mask
        pub type SOFM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, SOFM_A, O>;
        impl<'a, const O: u8> SOFM_W<'a, O> {
            ///SOF Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SOFM_A::Disabled)
            }
            ///SOF Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SOFM_A::Enabled)
            }
        }
        ///Field `RESETM` reader - USB reset interrupt mask
        pub type RESETM_R = crate::BitReader<RESETM_A>;
        ///USB reset interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RESETM_A {
            ///0: RESET Interrupt disabled
            Disabled = 0,
            ///1: RESET Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<RESETM_A> for bool {
            #[inline(always)]
            fn from(variant: RESETM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RESETM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RESETM_A {
                match self.bits {
                    false => RESETM_A::Disabled,
                    true => RESETM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == RESETM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == RESETM_A::Enabled
            }
        }
        ///Field `RESETM` writer - USB reset interrupt mask
        pub type RESETM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, RESETM_A, O>;
        impl<'a, const O: u8> RESETM_W<'a, O> {
            ///RESET Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RESETM_A::Disabled)
            }
            ///RESET Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RESETM_A::Enabled)
            }
        }
        ///Field `SUSPM` reader - Suspend mode interrupt mask
        pub type SUSPM_R = crate::BitReader<SUSPM_A>;
        ///Suspend mode interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SUSPM_A {
            ///0: Suspend Mode Request SUSP Interrupt disabled
            Disabled = 0,
            ///1: SUSP Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<SUSPM_A> for bool {
            #[inline(always)]
            fn from(variant: SUSPM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SUSPM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SUSPM_A {
                match self.bits {
                    false => SUSPM_A::Disabled,
                    true => SUSPM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == SUSPM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == SUSPM_A::Enabled
            }
        }
        ///Field `SUSPM` writer - Suspend mode interrupt mask
        pub type SUSPM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, SUSPM_A, O>;
        impl<'a, const O: u8> SUSPM_W<'a, O> {
            ///Suspend Mode Request SUSP Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SUSPM_A::Disabled)
            }
            ///SUSP Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SUSPM_A::Enabled)
            }
        }
        ///Field `WKUPM` reader - Wakeup interrupt mask
        pub type WKUPM_R = crate::BitReader<WKUPM_A>;
        ///Wakeup interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WKUPM_A {
            ///0: WKUP Interrupt disabled
            Disabled = 0,
            ///1: WKUP Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<WKUPM_A> for bool {
            #[inline(always)]
            fn from(variant: WKUPM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WKUPM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WKUPM_A {
                match self.bits {
                    false => WKUPM_A::Disabled,
                    true => WKUPM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WKUPM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WKUPM_A::Enabled
            }
        }
        ///Field `WKUPM` writer - Wakeup interrupt mask
        pub type WKUPM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, WKUPM_A, O>;
        impl<'a, const O: u8> WKUPM_W<'a, O> {
            ///WKUP Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WKUPM_A::Disabled)
            }
            ///WKUP Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WKUPM_A::Enabled)
            }
        }
        ///Field `ERRM` reader - Error interrupt mask
        pub type ERRM_R = crate::BitReader<ERRM_A>;
        ///Error interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERRM_A {
            ///0: ERR Interrupt disabled
            Disabled = 0,
            ///1: ERR Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<ERRM_A> for bool {
            #[inline(always)]
            fn from(variant: ERRM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERRM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ERRM_A {
                match self.bits {
                    false => ERRM_A::Disabled,
                    true => ERRM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ERRM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ERRM_A::Enabled
            }
        }
        ///Field `ERRM` writer - Error interrupt mask
        pub type ERRM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, ERRM_A, O>;
        impl<'a, const O: u8> ERRM_W<'a, O> {
            ///ERR Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ERRM_A::Disabled)
            }
            ///ERR Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ERRM_A::Enabled)
            }
        }
        ///Field `PMAOVRM` reader - Packet memory area over / underrun interrupt mask
        pub type PMAOVRM_R = crate::BitReader<PMAOVRM_A>;
        ///Packet memory area over / underrun interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PMAOVRM_A {
            ///0: PMAOVR Interrupt disabled
            Disabled = 0,
            ///1: PMAOVR Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<PMAOVRM_A> for bool {
            #[inline(always)]
            fn from(variant: PMAOVRM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PMAOVRM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PMAOVRM_A {
                match self.bits {
                    false => PMAOVRM_A::Disabled,
                    true => PMAOVRM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PMAOVRM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PMAOVRM_A::Enabled
            }
        }
        ///Field `PMAOVRM` writer - Packet memory area over / underrun interrupt mask
        pub type PMAOVRM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, PMAOVRM_A, O>;
        impl<'a, const O: u8> PMAOVRM_W<'a, O> {
            ///PMAOVR Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PMAOVRM_A::Disabled)
            }
            ///PMAOVR Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PMAOVRM_A::Enabled)
            }
        }
        ///Field `CTRM` reader - Correct transfer interrupt mask
        pub type CTRM_R = crate::BitReader<CTRM_A>;
        ///Correct transfer interrupt mask
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTRM_A {
            ///0: Correct Transfer (CTR) Interrupt disabled
            Disabled = 0,
            ///1: CTR Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            Enabled = 1,
        }
        impl From<CTRM_A> for bool {
            #[inline(always)]
            fn from(variant: CTRM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTRM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CTRM_A {
                match self.bits {
                    false => CTRM_A::Disabled,
                    true => CTRM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CTRM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CTRM_A::Enabled
            }
        }
        ///Field `CTRM` writer - Correct transfer interrupt mask
        pub type CTRM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CNTR_SPEC, CTRM_A, O>;
        impl<'a, const O: u8> CTRM_W<'a, O> {
            ///Correct Transfer (CTR) Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTRM_A::Disabled)
            }
            ///CTR Interrupt enabled, an interrupt request is generated when the corresponding bit in the ISTR register is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTRM_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - Force USB Reset
            #[inline(always)]
            pub fn fres(&self) -> FRES_R {
                FRES_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Power down
            #[inline(always)]
            pub fn pdwn(&self) -> PDWN_R {
                PDWN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Low-power mode
            #[inline(always)]
            pub fn lpmode(&self) -> LPMODE_R {
                LPMODE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Force suspend
            #[inline(always)]
            pub fn fsusp(&self) -> FSUSP_R {
                FSUSP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Resume request
            #[inline(always)]
            pub fn resume(&self) -> RESUME_R {
                RESUME_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 8 - Expected start of frame interrupt mask
            #[inline(always)]
            pub fn esofm(&self) -> ESOFM_R {
                ESOFM_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Start of frame interrupt mask
            #[inline(always)]
            pub fn sofm(&self) -> SOFM_R {
                SOFM_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - USB reset interrupt mask
            #[inline(always)]
            pub fn resetm(&self) -> RESETM_R {
                RESETM_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Suspend mode interrupt mask
            #[inline(always)]
            pub fn suspm(&self) -> SUSPM_R {
                SUSPM_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Wakeup interrupt mask
            #[inline(always)]
            pub fn wkupm(&self) -> WKUPM_R {
                WKUPM_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Error interrupt mask
            #[inline(always)]
            pub fn errm(&self) -> ERRM_R {
                ERRM_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Packet memory area over / underrun interrupt mask
            #[inline(always)]
            pub fn pmaovrm(&self) -> PMAOVRM_R {
                PMAOVRM_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer interrupt mask
            #[inline(always)]
            pub fn ctrm(&self) -> CTRM_R {
                CTRM_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Force USB Reset
            #[inline(always)]
            #[must_use]
            pub fn fres(&mut self) -> FRES_W<0> {
                FRES_W::new(self)
            }
            ///Bit 1 - Power down
            #[inline(always)]
            #[must_use]
            pub fn pdwn(&mut self) -> PDWN_W<1> {
                PDWN_W::new(self)
            }
            ///Bit 2 - Low-power mode
            #[inline(always)]
            #[must_use]
            pub fn lpmode(&mut self) -> LPMODE_W<2> {
                LPMODE_W::new(self)
            }
            ///Bit 3 - Force suspend
            #[inline(always)]
            #[must_use]
            pub fn fsusp(&mut self) -> FSUSP_W<3> {
                FSUSP_W::new(self)
            }
            ///Bit 4 - Resume request
            #[inline(always)]
            #[must_use]
            pub fn resume(&mut self) -> RESUME_W<4> {
                RESUME_W::new(self)
            }
            ///Bit 8 - Expected start of frame interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn esofm(&mut self) -> ESOFM_W<8> {
                ESOFM_W::new(self)
            }
            ///Bit 9 - Start of frame interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn sofm(&mut self) -> SOFM_W<9> {
                SOFM_W::new(self)
            }
            ///Bit 10 - USB reset interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn resetm(&mut self) -> RESETM_W<10> {
                RESETM_W::new(self)
            }
            ///Bit 11 - Suspend mode interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn suspm(&mut self) -> SUSPM_W<11> {
                SUSPM_W::new(self)
            }
            ///Bit 12 - Wakeup interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn wkupm(&mut self) -> WKUPM_W<12> {
                WKUPM_W::new(self)
            }
            ///Bit 13 - Error interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn errm(&mut self) -> ERRM_W<13> {
                ERRM_W::new(self)
            }
            ///Bit 14 - Packet memory area over / underrun interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn pmaovrm(&mut self) -> PMAOVRM_W<14> {
                PMAOVRM_W::new(self)
            }
            ///Bit 15 - Correct transfer interrupt mask
            #[inline(always)]
            #[must_use]
            pub fn ctrm(&mut self) -> CTRM_W<15> {
                CTRM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr](index.html) module
        pub struct CNTR_SPEC;
        impl crate::RegisterSpec for CNTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cntr::R](R) reader structure
        impl crate::Readable for CNTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr::W](W) writer structure
        impl crate::Writable for CNTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR to value 0x03
        impl crate::Resettable for CNTR_SPEC {
            const RESET_VALUE: Self::Ux = 0x03;
        }
    }
    ///ISTR (rw) register accessor: an alias for `Reg<ISTR_SPEC>`
    pub type ISTR = crate::Reg<istr::ISTR_SPEC>;
    ///interrupt status register
    pub mod istr {
        ///Register `ISTR` reader
        pub struct R(crate::R<ISTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ISTR` writer
        pub struct W(crate::W<ISTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ISTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ISTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ISTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EP_ID` reader - Endpoint Identifier
        pub type EP_ID_R = crate::FieldReader<u8, u8>;
        ///Field `EP_ID` writer - Endpoint Identifier
        pub type EP_ID_W<'a, const O: u8> = crate::FieldWriter<'a, u16, ISTR_SPEC, u8, u8, 4, O>;
        ///Field `DIR` reader - Direction of transaction
        pub type DIR_R = crate::BitReader<DIRR_A>;
        ///Direction of transaction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIRR_A {
            ///0: data transmitted by the USB peripheral to the host PC
            To = 0,
            ///1: data received by the USB peripheral from the host PC
            From = 1,
        }
        impl From<DIRR_A> for bool {
            #[inline(always)]
            fn from(variant: DIRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIRR_A {
                match self.bits {
                    false => DIRR_A::To,
                    true => DIRR_A::From,
                }
            }
            ///Checks if the value of the field is `To`
            #[inline(always)]
            pub fn is_to(&self) -> bool {
                *self == DIRR_A::To
            }
            ///Checks if the value of the field is `From`
            #[inline(always)]
            pub fn is_from(&self) -> bool {
                *self == DIRR_A::From
            }
        }
        ///Field `ESOF` reader - Expected start frame
        pub type ESOF_R = crate::BitReader<ESOFR_A>;
        ///Expected start frame
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ESOFR_A {
            ///0: NotExpectedStartOfFrame
            NotExpectedStartOfFrame = 0,
            ///1: an SOF packet is expected but not received
            ExpectedStartOfFrame = 1,
        }
        impl From<ESOFR_A> for bool {
            #[inline(always)]
            fn from(variant: ESOFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ESOF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ESOFR_A {
                match self.bits {
                    false => ESOFR_A::NotExpectedStartOfFrame,
                    true => ESOFR_A::ExpectedStartOfFrame,
                }
            }
            ///Checks if the value of the field is `NotExpectedStartOfFrame`
            #[inline(always)]
            pub fn is_not_expected_start_of_frame(&self) -> bool {
                *self == ESOFR_A::NotExpectedStartOfFrame
            }
            ///Checks if the value of the field is `ExpectedStartOfFrame`
            #[inline(always)]
            pub fn is_expected_start_of_frame(&self) -> bool {
                *self == ESOFR_A::ExpectedStartOfFrame
            }
        }
        ///Expected start frame
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ESOFW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<ESOFW_AW> for bool {
            #[inline(always)]
            fn from(variant: ESOFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ESOF` writer - Expected start frame
        pub type ESOF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, ISTR_SPEC, ESOFW_AW, O>;
        impl<'a, const O: u8> ESOF_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ESOFW_AW::Clear)
            }
        }
        ///Field `SOF` reader - start of frame
        pub type SOF_R = crate::BitReader<SOFR_A>;
        ///start of frame
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SOFR_A {
            ///0: NotStartOfFrame
            NotStartOfFrame = 0,
            ///1: beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus
            StartOfFrame = 1,
        }
        impl From<SOFR_A> for bool {
            #[inline(always)]
            fn from(variant: SOFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SOF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SOFR_A {
                match self.bits {
                    false => SOFR_A::NotStartOfFrame,
                    true => SOFR_A::StartOfFrame,
                }
            }
            ///Checks if the value of the field is `NotStartOfFrame`
            #[inline(always)]
            pub fn is_not_start_of_frame(&self) -> bool {
                *self == SOFR_A::NotStartOfFrame
            }
            ///Checks if the value of the field is `StartOfFrame`
            #[inline(always)]
            pub fn is_start_of_frame(&self) -> bool {
                *self == SOFR_A::StartOfFrame
            }
        }
        ///start of frame
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SOFW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<SOFW_AW> for bool {
            #[inline(always)]
            fn from(variant: SOFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SOF` writer - start of frame
        pub type SOF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, ISTR_SPEC, SOFW_AW, O>;
        impl<'a, const O: u8> SOF_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(SOFW_AW::Clear)
            }
        }
        ///Field `RESET` reader - reset request
        pub type RESET_R = crate::BitReader<RESETR_A>;
        ///reset request
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RESETR_A {
            ///0: NotReset
            NotReset = 0,
            ///1: peripheral detects an active USB RESET signal at its inputs
            Reset = 1,
        }
        impl From<RESETR_A> for bool {
            #[inline(always)]
            fn from(variant: RESETR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RESET_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RESETR_A {
                match self.bits {
                    false => RESETR_A::NotReset,
                    true => RESETR_A::Reset,
                }
            }
            ///Checks if the value of the field is `NotReset`
            #[inline(always)]
            pub fn is_not_reset(&self) -> bool {
                *self == RESETR_A::NotReset
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == RESETR_A::Reset
            }
        }
        ///reset request
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RESETW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<RESETW_AW> for bool {
            #[inline(always)]
            fn from(variant: RESETW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RESET` writer - reset request
        pub type RESET_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, ISTR_SPEC, RESETW_AW, O>;
        impl<'a, const O: u8> RESET_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RESETW_AW::Clear)
            }
        }
        ///Field `SUSP` reader - Suspend mode request
        pub type SUSP_R = crate::BitReader<SUSPR_A>;
        ///Suspend mode request
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SUSPR_A {
            ///0: NotSuspend
            NotSuspend = 0,
            ///1: no traffic has been received for 3 ms, indicating a suspend mode request from the USB bus
            Suspend = 1,
        }
        impl From<SUSPR_A> for bool {
            #[inline(always)]
            fn from(variant: SUSPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl SUSP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SUSPR_A {
                match self.bits {
                    false => SUSPR_A::NotSuspend,
                    true => SUSPR_A::Suspend,
                }
            }
            ///Checks if the value of the field is `NotSuspend`
            #[inline(always)]
            pub fn is_not_suspend(&self) -> bool {
                *self == SUSPR_A::NotSuspend
            }
            ///Checks if the value of the field is `Suspend`
            #[inline(always)]
            pub fn is_suspend(&self) -> bool {
                *self == SUSPR_A::Suspend
            }
        }
        ///Suspend mode request
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum SUSPW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<SUSPW_AW> for bool {
            #[inline(always)]
            fn from(variant: SUSPW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SUSP` writer - Suspend mode request
        pub type SUSP_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, ISTR_SPEC, SUSPW_AW, O>;
        impl<'a, const O: u8> SUSP_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(SUSPW_AW::Clear)
            }
        }
        ///Field `WKUP` reader - Wakeup
        pub type WKUP_R = crate::BitReader<WKUPR_A>;
        ///Wakeup
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WKUPR_A {
            ///0: NotWakeup
            NotWakeup = 0,
            ///1: activity is detected that wakes up the USB peripheral
            Wakeup = 1,
        }
        impl From<WKUPR_A> for bool {
            #[inline(always)]
            fn from(variant: WKUPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl WKUP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WKUPR_A {
                match self.bits {
                    false => WKUPR_A::NotWakeup,
                    true => WKUPR_A::Wakeup,
                }
            }
            ///Checks if the value of the field is `NotWakeup`
            #[inline(always)]
            pub fn is_not_wakeup(&self) -> bool {
                *self == WKUPR_A::NotWakeup
            }
            ///Checks if the value of the field is `Wakeup`
            #[inline(always)]
            pub fn is_wakeup(&self) -> bool {
                *self == WKUPR_A::Wakeup
            }
        }
        ///Wakeup
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum WKUPW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<WKUPW_AW> for bool {
            #[inline(always)]
            fn from(variant: WKUPW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WKUP` writer - Wakeup
        pub type WKUP_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, ISTR_SPEC, WKUPW_AW, O>;
        impl<'a, const O: u8> WKUP_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(WKUPW_AW::Clear)
            }
        }
        ///Field `ERR` reader - Error
        pub type ERR_R = crate::BitReader<ERRR_A>;
        ///Error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERRR_A {
            ///0: Errors are not occurred
            NotOverrun = 0,
            ///1: One of No ANSwer, Cyclic Redundancy Check, Bit Stuffing or Framing format Violation error occurred
            Error = 1,
        }
        impl From<ERRR_A> for bool {
            #[inline(always)]
            fn from(variant: ERRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ERRR_A {
                match self.bits {
                    false => ERRR_A::NotOverrun,
                    true => ERRR_A::Error,
                }
            }
            ///Checks if the value of the field is `NotOverrun`
            #[inline(always)]
            pub fn is_not_overrun(&self) -> bool {
                *self == ERRR_A::NotOverrun
            }
            ///Checks if the value of the field is `Error`
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == ERRR_A::Error
            }
        }
        ///Error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERRW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<ERRW_AW> for bool {
            #[inline(always)]
            fn from(variant: ERRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ERR` writer - Error
        pub type ERR_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, ISTR_SPEC, ERRW_AW, O>;
        impl<'a, const O: u8> ERR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(ERRW_AW::Clear)
            }
        }
        ///Field `PMAOVR` reader - Packet memory area over / underrun
        pub type PMAOVR_R = crate::BitReader<PMAOVRR_A>;
        ///Packet memory area over / underrun
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PMAOVRR_A {
            ///0: Overrun is not occurred
            NotOverrun = 0,
            ///1: microcontroller has not been able to respond in time to an USB memory request
            Overrun = 1,
        }
        impl From<PMAOVRR_A> for bool {
            #[inline(always)]
            fn from(variant: PMAOVRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PMAOVR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PMAOVRR_A {
                match self.bits {
                    false => PMAOVRR_A::NotOverrun,
                    true => PMAOVRR_A::Overrun,
                }
            }
            ///Checks if the value of the field is `NotOverrun`
            #[inline(always)]
            pub fn is_not_overrun(&self) -> bool {
                *self == PMAOVRR_A::NotOverrun
            }
            ///Checks if the value of the field is `Overrun`
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                *self == PMAOVRR_A::Overrun
            }
        }
        ///Packet memory area over / underrun
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PMAOVRW_AW {
            ///0: Clear this flag
            Clear = 0,
        }
        impl From<PMAOVRW_AW> for bool {
            #[inline(always)]
            fn from(variant: PMAOVRW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PMAOVR` writer - Packet memory area over / underrun
        pub type PMAOVR_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, ISTR_SPEC, PMAOVRW_AW, O>;
        impl<'a, const O: u8> PMAOVR_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PMAOVRW_AW::Clear)
            }
        }
        ///Field `CTR` reader - Correct transfer
        pub type CTR_R = crate::BitReader<CTRR_A>;
        ///Correct transfer
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTRR_A {
            ///0: not completed
            NotCompleted = 0,
            ///1: endpoint has successfully completed a transaction
            Completed = 1,
        }
        impl From<CTRR_A> for bool {
            #[inline(always)]
            fn from(variant: CTRR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CTRR_A {
                match self.bits {
                    false => CTRR_A::NotCompleted,
                    true => CTRR_A::Completed,
                }
            }
            ///Checks if the value of the field is `NotCompleted`
            #[inline(always)]
            pub fn is_not_completed(&self) -> bool {
                *self == CTRR_A::NotCompleted
            }
            ///Checks if the value of the field is `Completed`
            #[inline(always)]
            pub fn is_completed(&self) -> bool {
                *self == CTRR_A::Completed
            }
        }
        impl R {
            ///Bits 0:3 - Endpoint Identifier
            #[inline(always)]
            pub fn ep_id(&self) -> EP_ID_R {
                EP_ID_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 4 - Direction of transaction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 8 - Expected start frame
            #[inline(always)]
            pub fn esof(&self) -> ESOF_R {
                ESOF_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - start of frame
            #[inline(always)]
            pub fn sof(&self) -> SOF_R {
                SOF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - reset request
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Suspend mode request
            #[inline(always)]
            pub fn susp(&self) -> SUSP_R {
                SUSP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Wakeup
            #[inline(always)]
            pub fn wkup(&self) -> WKUP_R {
                WKUP_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Error
            #[inline(always)]
            pub fn err(&self) -> ERR_R {
                ERR_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Packet memory area over / underrun
            #[inline(always)]
            pub fn pmaovr(&self) -> PMAOVR_R {
                PMAOVR_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Correct transfer
            #[inline(always)]
            pub fn ctr(&self) -> CTR_R {
                CTR_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Endpoint Identifier
            #[inline(always)]
            #[must_use]
            pub fn ep_id(&mut self) -> EP_ID_W<0> {
                EP_ID_W::new(self)
            }
            ///Bit 8 - Expected start frame
            #[inline(always)]
            #[must_use]
            pub fn esof(&mut self) -> ESOF_W<8> {
                ESOF_W::new(self)
            }
            ///Bit 9 - start of frame
            #[inline(always)]
            #[must_use]
            pub fn sof(&mut self) -> SOF_W<9> {
                SOF_W::new(self)
            }
            ///Bit 10 - reset request
            #[inline(always)]
            #[must_use]
            pub fn reset(&mut self) -> RESET_W<10> {
                RESET_W::new(self)
            }
            ///Bit 11 - Suspend mode request
            #[inline(always)]
            #[must_use]
            pub fn susp(&mut self) -> SUSP_W<11> {
                SUSP_W::new(self)
            }
            ///Bit 12 - Wakeup
            #[inline(always)]
            #[must_use]
            pub fn wkup(&mut self) -> WKUP_W<12> {
                WKUP_W::new(self)
            }
            ///Bit 13 - Error
            #[inline(always)]
            #[must_use]
            pub fn err(&mut self) -> ERR_W<13> {
                ERR_W::new(self)
            }
            ///Bit 14 - Packet memory area over / underrun
            #[inline(always)]
            #[must_use]
            pub fn pmaovr(&mut self) -> PMAOVR_W<14> {
                PMAOVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///interrupt status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [istr](index.html) module
        pub struct ISTR_SPEC;
        impl crate::RegisterSpec for ISTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [istr::R](R) reader structure
        impl crate::Readable for ISTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [istr::W](W) writer structure
        impl crate::Writable for ISTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x7f00;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ISTR to value 0
        impl crate::Resettable for ISTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FNR (r) register accessor: an alias for `Reg<FNR_SPEC>`
    pub type FNR = crate::Reg<fnr::FNR_SPEC>;
    ///frame number register
    pub mod fnr {
        ///Register `FNR` reader
        pub struct R(crate::R<FNR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FNR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FNR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FNR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `FN` reader - Frame number
        pub type FN_R = crate::FieldReader<u16, u16>;
        ///Field `LSOF` reader - Lost SOF
        pub type LSOF_R = crate::FieldReader<u8, u8>;
        ///Field `LCK` reader - Locked
        pub type LCK_R = crate::BitReader<LCKR_A>;
        ///Locked
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LCKR_A {
            ///0: not locked
            NotLocked = 0,
            ///1: the frame timer remains in this state until an USB reset or USB suspend event occurs
            Locked = 1,
        }
        impl From<LCKR_A> for bool {
            #[inline(always)]
            fn from(variant: LCKR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LCK_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LCKR_A {
                match self.bits {
                    false => LCKR_A::NotLocked,
                    true => LCKR_A::Locked,
                }
            }
            ///Checks if the value of the field is `NotLocked`
            #[inline(always)]
            pub fn is_not_locked(&self) -> bool {
                *self == LCKR_A::NotLocked
            }
            ///Checks if the value of the field is `Locked`
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                *self == LCKR_A::Locked
            }
        }
        ///Field `RXDM` reader - Receive data - line status
        pub type RXDM_R = crate::BitReader<RXDMR_A>;
        ///Receive data - line status
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXDMR_A {
            ///0: not received
            NotReceived = 0,
            ///1: received data minus upstream port data line
            Received = 1,
        }
        impl From<RXDMR_A> for bool {
            #[inline(always)]
            fn from(variant: RXDMR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXDM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXDMR_A {
                match self.bits {
                    false => RXDMR_A::NotReceived,
                    true => RXDMR_A::Received,
                }
            }
            ///Checks if the value of the field is `NotReceived`
            #[inline(always)]
            pub fn is_not_received(&self) -> bool {
                *self == RXDMR_A::NotReceived
            }
            ///Checks if the value of the field is `Received`
            #[inline(always)]
            pub fn is_received(&self) -> bool {
                *self == RXDMR_A::Received
            }
        }
        ///Field `RXDP` reader - Receive data + line status
        pub type RXDP_R = crate::BitReader<RXDPR_A>;
        ///Receive data + line status
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RXDPR_A {
            ///0: not received
            NotReceived = 0,
            ///1: received data plus upstream port data line
            Received = 1,
        }
        impl From<RXDPR_A> for bool {
            #[inline(always)]
            fn from(variant: RXDPR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RXDP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXDPR_A {
                match self.bits {
                    false => RXDPR_A::NotReceived,
                    true => RXDPR_A::Received,
                }
            }
            ///Checks if the value of the field is `NotReceived`
            #[inline(always)]
            pub fn is_not_received(&self) -> bool {
                *self == RXDPR_A::NotReceived
            }
            ///Checks if the value of the field is `Received`
            #[inline(always)]
            pub fn is_received(&self) -> bool {
                *self == RXDPR_A::Received
            }
        }
        impl R {
            ///Bits 0:10 - Frame number
            #[inline(always)]
            pub fn fn_(&self) -> FN_R {
                FN_R::new(self.bits & 0x07ff)
            }
            ///Bits 11:12 - Lost SOF
            #[inline(always)]
            pub fn lsof(&self) -> LSOF_R {
                LSOF_R::new(((self.bits >> 11) & 3) as u8)
            }
            ///Bit 13 - Locked
            #[inline(always)]
            pub fn lck(&self) -> LCK_R {
                LCK_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Receive data - line status
            #[inline(always)]
            pub fn rxdm(&self) -> RXDM_R {
                RXDM_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Receive data + line status
            #[inline(always)]
            pub fn rxdp(&self) -> RXDP_R {
                RXDP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///frame number register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fnr](index.html) module
        pub struct FNR_SPEC;
        impl crate::RegisterSpec for FNR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [fnr::R](R) reader structure
        impl crate::Readable for FNR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets FNR to value 0
        impl crate::Resettable for FNR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DADDR (rw) register accessor: an alias for `Reg<DADDR_SPEC>`
    pub type DADDR = crate::Reg<daddr::DADDR_SPEC>;
    ///device address
    pub mod daddr {
        ///Register `DADDR` reader
        pub struct R(crate::R<DADDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DADDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DADDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DADDR` writer
        pub struct W(crate::W<DADDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DADDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DADDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADD` reader - Device address
        pub type ADD_R = crate::FieldReader<u8, u8>;
        ///Field `ADD` writer - Device address
        pub type ADD_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DADDR_SPEC, u8, u8, 7, O>;
        ///Field `EF` reader - Enable function
        pub type EF_R = crate::BitReader<EF_A>;
        ///Enable function
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EF_A {
            ///0: USB device disabled
            Disabled = 0,
            ///1: USB device enabled
            Enabled = 1,
        }
        impl From<EF_A> for bool {
            #[inline(always)]
            fn from(variant: EF_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EF_A {
                match self.bits {
                    false => EF_A::Disabled,
                    true => EF_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == EF_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == EF_A::Enabled
            }
        }
        ///Field `EF` writer - Enable function
        pub type EF_W<'a, const O: u8> = crate::BitWriter<'a, u16, DADDR_SPEC, EF_A, O>;
        impl<'a, const O: u8> EF_W<'a, O> {
            ///USB device disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EF_A::Disabled)
            }
            ///USB device enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EF_A::Enabled)
            }
        }
        impl R {
            ///Bits 0:6 - Device address
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Enable function
            #[inline(always)]
            pub fn ef(&self) -> EF_R {
                EF_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - Device address
            #[inline(always)]
            #[must_use]
            pub fn add(&mut self) -> ADD_W<0> {
                ADD_W::new(self)
            }
            ///Bit 7 - Enable function
            #[inline(always)]
            #[must_use]
            pub fn ef(&mut self) -> EF_W<7> {
                EF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///device address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [daddr](index.html) module
        pub struct DADDR_SPEC;
        impl crate::RegisterSpec for DADDR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [daddr::R](R) reader structure
        impl crate::Readable for DADDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [daddr::W](W) writer structure
        impl crate::Writable for DADDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DADDR to value 0
        impl crate::Resettable for DADDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BTABLE (rw) register accessor: an alias for `Reg<BTABLE_SPEC>`
    pub type BTABLE = crate::Reg<btable::BTABLE_SPEC>;
    ///Buffer table address
    pub mod btable {
        ///Register `BTABLE` reader
        pub struct R(crate::R<BTABLE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BTABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BTABLE_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BTABLE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BTABLE` writer
        pub struct W(crate::W<BTABLE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BTABLE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BTABLE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BTABLE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BTABLE` reader - Buffer table
        pub type BTABLE_R = crate::FieldReader<u16, u16>;
        ///Field `BTABLE` writer - Buffer table
        pub type BTABLE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, BTABLE_SPEC, u16, u16, 13, O>;
        impl R {
            ///Bits 3:15 - Buffer table
            #[inline(always)]
            pub fn btable(&self) -> BTABLE_R {
                BTABLE_R::new((self.bits >> 3) & 0x1fff)
            }
        }
        impl W {
            ///Bits 3:15 - Buffer table
            #[inline(always)]
            #[must_use]
            pub fn btable(&mut self) -> BTABLE_W<3> {
                BTABLE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Buffer table address
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [btable](index.html) module
        pub struct BTABLE_SPEC;
        impl crate::RegisterSpec for BTABLE_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [btable::R](R) reader structure
        impl crate::Readable for BTABLE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [btable::W](W) writer structure
        impl crate::Writable for BTABLE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BTABLE to value 0
        impl crate::Resettable for BTABLE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///General timer
pub struct TIM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM2 {}
impl TIM2 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM2 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM2").finish()
    }
}
///General timer
pub mod tim2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub ctlr1: CTLR1,
        _reserved1: [u8; 0x02],
        ///0x04 - control register 2
        pub ctlr2: CTLR2,
        _reserved2: [u8; 0x02],
        ///0x08 - slave mode control register
        pub smcfgr: SMCFGR,
        _reserved3: [u8; 0x02],
        ///0x0c - DMA/Interrupt enable register
        pub dmaintenr: DMAINTENR,
        _reserved4: [u8; 0x02],
        ///0x10 - status register
        pub intfr: INTFR,
        _reserved5: [u8; 0x02],
        ///0x14 - event generation register
        pub swevgr: SWEVGR,
        _reserved6: [u8; 0x02],
        _reserved_6_chctlr: [u8; 0x02],
        _reserved7: [u8; 0x02],
        _reserved_7_chctlr: [u8; 0x02],
        _reserved8: [u8; 0x02],
        ///0x20 - capture/compare enable register
        pub ccer: CCER,
        _reserved9: [u8; 0x02],
        ///0x24 - counter
        pub cnt: CNT,
        _reserved10: [u8; 0x02],
        ///0x28 - prescaler
        pub psc: PSC,
        _reserved11: [u8; 0x02],
        ///0x2c - auto-reload register
        pub atrlr: ATRLR,
        _reserved12: [u8; 0x02],
        ///0x30 - repetition counter register
        pub rptcr: RPTCR,
        _reserved13: [u8; 0x02],
        ///0x34 - capture/compare register 1
        pub ch1cvr: CH1CVR,
        _reserved14: [u8; 0x02],
        ///0x38 - capture/compare register 2
        pub ch2cvr: CH2CVR,
        _reserved15: [u8; 0x02],
        ///0x3c - capture/compare register 3
        pub ch3cvr: CH3CVR,
        _reserved16: [u8; 0x02],
        ///0x40 - capture/compare register 4
        pub ch4cvr: CH4CVR,
        _reserved17: [u8; 0x02],
        ///0x44 - break and dead-time register
        pub bdtr: BDTR,
        _reserved18: [u8; 0x02],
        ///0x48 - DMA control register
        pub dmacfgr: DMACFGR,
        _reserved19: [u8; 0x02],
        ///0x4c - DMA address for full transfer
        pub dmar: DMAR,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub const fn chctlr1i(&self) -> &CHCTLR1I {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr1o(&self) -> &CHCTLR1O {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub const fn chctlr2i(&self) -> &CHCTLR2I {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
        ///0x1c - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr2o(&self) -> &CHCTLR2O {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CEN` reader - Counter enable
        pub type CEN_R = crate::BitReader<CEN_A>;
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CEN_A {
            ///0: Counter disabled
            Disabled = 0,
            ///1: Counter enabled
            Enabled = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::Disabled,
                    true => CEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == CEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == CEN_A::Enabled
            }
        }
        ///Field `CEN` writer - Counter enable
        pub type CEN_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, CEN_A, O>;
        impl<'a, const O: u8> CEN_W<'a, O> {
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::Disabled)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::Enabled)
            }
        }
        ///Field `UDIS` reader - Update disable
        pub type UDIS_R = crate::BitReader<UDIS_A>;
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UDIS_A {
            ///0: UEV enabled
            Enabled = 0,
            ///1: UEV disabled
            Disabled = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UDIS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::Enabled,
                    true => UDIS_A::Disabled,
                }
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDIS_A::Enabled
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDIS_A::Disabled
            }
        }
        ///Field `UDIS` writer - Update disable
        pub type UDIS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, UDIS_A, O>;
        impl<'a, const O: u8> UDIS_W<'a, O> {
            ///UEV enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::Enabled)
            }
            ///UEV disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::Disabled)
            }
        }
        ///Field `URS` reader - Update request source
        pub type URS_R = crate::BitReader<URS_A>;
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum URS_A {
            ///0: Multiple source for update event
            Multiple = 0,
            ///1: Only overflow can trigger update event
            Overflow = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl URS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::Multiple,
                    true => URS_A::Overflow,
                }
            }
            ///Checks if the value of the field is `Multiple`
            #[inline(always)]
            pub fn is_multiple(&self) -> bool {
                *self == URS_A::Multiple
            }
            ///Checks if the value of the field is `Overflow`
            #[inline(always)]
            pub fn is_overflow(&self) -> bool {
                *self == URS_A::Overflow
            }
        }
        ///Field `URS` writer - Update request source
        pub type URS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, URS_A, O>;
        impl<'a, const O: u8> URS_W<'a, O> {
            ///Multiple source for update event
            #[inline(always)]
            pub fn multiple(self) -> &'a mut W {
                self.variant(URS_A::Multiple)
            }
            ///Only overflow can trigger update event
            #[inline(always)]
            pub fn overflow(self) -> &'a mut W {
                self.variant(URS_A::Overflow)
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub type OPM_R = crate::BitReader<OPM_A>;
        ///One-pulse mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OPM_A {
            ///0: One pulse mode disabled
            Disabled = 0,
            ///1: One pulse mode enabled
            Enabled = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OPM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::Disabled,
                    true => OPM_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OPM_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OPM_A::Enabled
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub type OPM_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, OPM_A, O>;
        impl<'a, const O: u8> OPM_W<'a, O> {
            ///One pulse mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::Disabled)
            }
            ///One pulse mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::Enabled)
            }
        }
        ///Field `DIR` reader - Direction
        pub type DIR_R = crate::BitReader<DIR_A>;
        ///Direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DIR_A {
            ///0: Decrement counter
            Decrement = 0,
            ///1: Increment counter
            Increment = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DIR_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::Decrement,
                    true => DIR_A::Increment,
                }
            }
            ///Checks if the value of the field is `Decrement`
            #[inline(always)]
            pub fn is_decrement(&self) -> bool {
                *self == DIR_A::Decrement
            }
            ///Checks if the value of the field is `Increment`
            #[inline(always)]
            pub fn is_increment(&self) -> bool {
                *self == DIR_A::Increment
            }
        }
        ///Field `DIR` writer - Direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, DIR_A, O>;
        impl<'a, const O: u8> DIR_W<'a, O> {
            ///Decrement counter
            #[inline(always)]
            pub fn decrement(self) -> &'a mut W {
                self.variant(DIR_A::Decrement)
            }
            ///Increment counter
            #[inline(always)]
            pub fn increment(self) -> &'a mut W {
                self.variant(DIR_A::Increment)
            }
        }
        ///Field `CMS` reader - Center-aligned mode selection
        pub type CMS_R = crate::FieldReader<u8, CMS_A>;
        ///Center-aligned mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CMS_A {
            ///0: Counter increment or dicrement according to DIR
            Edge = 0,
            ///1: Center alignment mode 1
            Center1 = 1,
            ///2: Center alignment mode 2
            Center2 = 2,
            ///3: Center alignment mode 3
            Center3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        impl CMS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::Edge,
                    1 => CMS_A::Center1,
                    2 => CMS_A::Center2,
                    3 => CMS_A::Center3,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Edge`
            #[inline(always)]
            pub fn is_edge(&self) -> bool {
                *self == CMS_A::Edge
            }
            ///Checks if the value of the field is `Center1`
            #[inline(always)]
            pub fn is_center1(&self) -> bool {
                *self == CMS_A::Center1
            }
            ///Checks if the value of the field is `Center2`
            #[inline(always)]
            pub fn is_center2(&self) -> bool {
                *self == CMS_A::Center2
            }
            ///Checks if the value of the field is `Center3`
            #[inline(always)]
            pub fn is_center3(&self) -> bool {
                *self == CMS_A::Center3
            }
        }
        ///Field `CMS` writer - Center-aligned mode selection
        pub type CMS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CTLR1_SPEC, u8, CMS_A, 2, O>;
        impl<'a, const O: u8> CMS_W<'a, O> {
            ///Counter increment or dicrement according to DIR
            #[inline(always)]
            pub fn edge(self) -> &'a mut W {
                self.variant(CMS_A::Edge)
            }
            ///Center alignment mode 1
            #[inline(always)]
            pub fn center1(self) -> &'a mut W {
                self.variant(CMS_A::Center1)
            }
            ///Center alignment mode 2
            #[inline(always)]
            pub fn center2(self) -> &'a mut W {
                self.variant(CMS_A::Center2)
            }
            ///Center alignment mode 3
            #[inline(always)]
            pub fn center3(self) -> &'a mut W {
                self.variant(CMS_A::Center3)
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub type ARPE_R = crate::BitReader<ARPE_A>;
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ARPE_A {
            ///0: Auto reload preset disabled
            Disabled = 0,
            ///1: Auto reload preset enabled
            Enabled = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ARPE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::Disabled,
                    true => ARPE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ARPE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ARPE_A::Enabled
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub type ARPE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR1_SPEC, ARPE_A, O>;
        impl<'a, const O: u8> ARPE_W<'a, O> {
            ///Auto reload preset disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::Disabled)
            }
            ///Auto reload preset enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::Enabled)
            }
        }
        ///Field `CKD` reader - Clock division
        pub type CKD_R = crate::FieldReader<u8, CKD_A>;
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: Tdts = Tck_int
            Tck = 0,
            ///1: Tdts = Tck_int * 2
            Tck2 = 1,
            ///2: Tdts = Tck_int * 4
            Tck4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        impl CKD_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::Tck),
                    1 => Some(CKD_A::Tck2),
                    2 => Some(CKD_A::Tck4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `Tck`
            #[inline(always)]
            pub fn is_tck(&self) -> bool {
                *self == CKD_A::Tck
            }
            ///Checks if the value of the field is `Tck2`
            #[inline(always)]
            pub fn is_tck2(&self) -> bool {
                *self == CKD_A::Tck2
            }
            ///Checks if the value of the field is `Tck4`
            #[inline(always)]
            pub fn is_tck4(&self) -> bool {
                *self == CKD_A::Tck4
            }
        }
        ///Field `CKD` writer - Clock division
        pub type CKD_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CTLR1_SPEC, u8, CKD_A, 2, O>;
        impl<'a, const O: u8> CKD_W<'a, O> {
            ///Tdts = Tck_int
            #[inline(always)]
            pub fn tck(self) -> &'a mut W {
                self.variant(CKD_A::Tck)
            }
            ///Tdts = Tck_int * 2
            #[inline(always)]
            pub fn tck2(self) -> &'a mut W {
                self.variant(CKD_A::Tck2)
            }
            ///Tdts = Tck_int * 4
            #[inline(always)]
            pub fn tck4(self) -> &'a mut W {
                self.variant(CKD_A::Tck4)
            }
        }
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 3) as u8)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            #[must_use]
            pub fn cen(&mut self) -> CEN_W<0> {
                CEN_W::new(self)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            #[must_use]
            pub fn udis(&mut self) -> UDIS_W<1> {
                UDIS_W::new(self)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            #[must_use]
            pub fn urs(&mut self) -> URS_W<2> {
                URS_W::new(self)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            #[must_use]
            pub fn opm(&mut self) -> OPM_W<3> {
                OPM_W::new(self)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            #[must_use]
            pub fn cms(&mut self) -> CMS_W<5> {
                CMS_W::new(self)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn arpe(&mut self) -> ARPE_W<7> {
                ARPE_W::new(self)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            #[must_use]
            pub fn ckd(&mut self) -> CKD_W<8> {
                CKD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCPC` reader - Capture/compare preloaded control
        pub type CCPC_R = crate::BitReader<CCPC_A>;
        ///Capture/compare preloaded control
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CCPC_A {
            ///0: CCxE CCxNE OCxM not preloaded
            NotPreloaded = 0,
            ///1: CCxE CCxNE OCxM preloaded
            Preloaded = 1,
        }
        impl From<CCPC_A> for bool {
            #[inline(always)]
            fn from(variant: CCPC_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CCPC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCPC_A {
                match self.bits {
                    false => CCPC_A::NotPreloaded,
                    true => CCPC_A::Preloaded,
                }
            }
            ///Checks if the value of the field is `NotPreloaded`
            #[inline(always)]
            pub fn is_not_preloaded(&self) -> bool {
                *self == CCPC_A::NotPreloaded
            }
            ///Checks if the value of the field is `Preloaded`
            #[inline(always)]
            pub fn is_preloaded(&self) -> bool {
                *self == CCPC_A::Preloaded
            }
        }
        ///Field `CCPC` writer - Capture/compare preloaded control
        pub type CCPC_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, CCPC_A, O>;
        impl<'a, const O: u8> CCPC_W<'a, O> {
            ///CCxE CCxNE OCxM not preloaded
            #[inline(always)]
            pub fn not_preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::NotPreloaded)
            }
            ///CCxE CCxNE OCxM preloaded
            #[inline(always)]
            pub fn preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::Preloaded)
            }
        }
        ///Field `CCUS` reader - Capture/compare control update selection
        pub type CCUS_R = crate::BitReader<CCUS_A>;
        ///Capture/compare control update selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CCUS_A {
            ///0: Only update on COM set
            Comonly = 0,
            ///1: Update on COM set or TRGI rising edge
            Multiple = 1,
        }
        impl From<CCUS_A> for bool {
            #[inline(always)]
            fn from(variant: CCUS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CCUS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCUS_A {
                match self.bits {
                    false => CCUS_A::Comonly,
                    true => CCUS_A::Multiple,
                }
            }
            ///Checks if the value of the field is `Comonly`
            #[inline(always)]
            pub fn is_comonly(&self) -> bool {
                *self == CCUS_A::Comonly
            }
            ///Checks if the value of the field is `Multiple`
            #[inline(always)]
            pub fn is_multiple(&self) -> bool {
                *self == CCUS_A::Multiple
            }
        }
        ///Field `CCUS` writer - Capture/compare control update selection
        pub type CCUS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, CCUS_A, O>;
        impl<'a, const O: u8> CCUS_W<'a, O> {
            ///Only update on COM set
            #[inline(always)]
            pub fn comonly(self) -> &'a mut W {
                self.variant(CCUS_A::Comonly)
            }
            ///Update on COM set or TRGI rising edge
            #[inline(always)]
            pub fn multiple(self) -> &'a mut W {
                self.variant(CCUS_A::Multiple)
            }
        }
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub type CCDS_R = crate::BitReader<CCDS_A>;
        ///Capture/compare DMA selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CCDS_A {
            ///0: Request DMA on CHxCVR
            ChxCvr = 0,
            ///1: Request DMA on update event
            Update = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CCDS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ChxCvr,
                    true => CCDS_A::Update,
                }
            }
            ///Checks if the value of the field is `ChxCvr`
            #[inline(always)]
            pub fn is_chx_cvr(&self) -> bool {
                *self == CCDS_A::ChxCvr
            }
            ///Checks if the value of the field is `Update`
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == CCDS_A::Update
            }
        }
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub type CCDS_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, CCDS_A, O>;
        impl<'a, const O: u8> CCDS_W<'a, O> {
            ///Request DMA on CHxCVR
            #[inline(always)]
            pub fn chx_cvr(self) -> &'a mut W {
                self.variant(CCDS_A::ChxCvr)
            }
            ///Request DMA on update event
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(CCDS_A::Update)
            }
        }
        ///Field `MMS` reader - Master mode selection
        pub type MMS_R = crate::FieldReader<u8, MMS_A>;
        ///Master mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MMS_A {
            ///0: TIMx_EGR register UG bit used as trigger output(TRG0)
            Reset = 0,
            ///1: CNT_EN bit used as trigger output(TRG0)
            Enable = 1,
            ///2: Update event used as trigger input(TRG0)
            Update = 2,
            ///3: Trigger output(TRG0) on CC1IF set
            CmpCc1if = 3,
            ///4: OC1REF signal used as trigger output(TRG0)
            CmpOc1ref = 4,
            ///5: OC2REF signal used as trigger output(TRG0)
            CmpOc2ref = 5,
            ///6: OC3REF signal used as trigger output(TRG0)
            CmpOc3ref = 6,
            ///7: OC4REF signal used as trigger output(TRG0)
            CmpOc4ref = 7,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        impl MMS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MMS_A {
                match self.bits {
                    0 => MMS_A::Reset,
                    1 => MMS_A::Enable,
                    2 => MMS_A::Update,
                    3 => MMS_A::CmpCc1if,
                    4 => MMS_A::CmpOc1ref,
                    5 => MMS_A::CmpOc2ref,
                    6 => MMS_A::CmpOc3ref,
                    7 => MMS_A::CmpOc4ref,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == MMS_A::Reset
            }
            ///Checks if the value of the field is `Enable`
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MMS_A::Enable
            }
            ///Checks if the value of the field is `Update`
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                *self == MMS_A::Update
            }
            ///Checks if the value of the field is `CmpCc1if`
            #[inline(always)]
            pub fn is_cmp_cc1if(&self) -> bool {
                *self == MMS_A::CmpCc1if
            }
            ///Checks if the value of the field is `CmpOc1ref`
            #[inline(always)]
            pub fn is_cmp_oc1ref(&self) -> bool {
                *self == MMS_A::CmpOc1ref
            }
            ///Checks if the value of the field is `CmpOc2ref`
            #[inline(always)]
            pub fn is_cmp_oc2ref(&self) -> bool {
                *self == MMS_A::CmpOc2ref
            }
            ///Checks if the value of the field is `CmpOc3ref`
            #[inline(always)]
            pub fn is_cmp_oc3ref(&self) -> bool {
                *self == MMS_A::CmpOc3ref
            }
            ///Checks if the value of the field is `CmpOc4ref`
            #[inline(always)]
            pub fn is_cmp_oc4ref(&self) -> bool {
                *self == MMS_A::CmpOc4ref
            }
        }
        ///Field `MMS` writer - Master mode selection
        pub type MMS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CTLR2_SPEC, u8, MMS_A, 3, O>;
        impl<'a, const O: u8> MMS_W<'a, O> {
            ///TIMx_EGR register UG bit used as trigger output(TRG0)
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::Reset)
            }
            ///CNT_EN bit used as trigger output(TRG0)
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::Enable)
            }
            ///Update event used as trigger input(TRG0)
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::Update)
            }
            ///Trigger output(TRG0) on CC1IF set
            #[inline(always)]
            pub fn cmp_cc1if(self) -> &'a mut W {
                self.variant(MMS_A::CmpCc1if)
            }
            ///OC1REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc1ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc1ref)
            }
            ///OC2REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc2ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc2ref)
            }
            ///OC3REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc3ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc3ref)
            }
            ///OC4REF signal used as trigger output(TRG0)
            #[inline(always)]
            pub fn cmp_oc4ref(self) -> &'a mut W {
                self.variant(MMS_A::CmpOc4ref)
            }
        }
        ///Field `TI1S` reader - TI1 selection
        pub type TI1S_R = crate::BitReader<TI1S_A>;
        ///TI1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TI1S_A {
            ///0: TIMx_CH1 connected directly to TI1
            Direct = 0,
            ///1: TIMx_CH1/2/3 connected to TI1 after xor
            Xor = 1,
        }
        impl From<TI1S_A> for bool {
            #[inline(always)]
            fn from(variant: TI1S_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TI1S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TI1S_A {
                match self.bits {
                    false => TI1S_A::Direct,
                    true => TI1S_A::Xor,
                }
            }
            ///Checks if the value of the field is `Direct`
            #[inline(always)]
            pub fn is_direct(&self) -> bool {
                *self == TI1S_A::Direct
            }
            ///Checks if the value of the field is `Xor`
            #[inline(always)]
            pub fn is_xor(&self) -> bool {
                *self == TI1S_A::Xor
            }
        }
        ///Field `TI1S` writer - TI1 selection
        pub type TI1S_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, TI1S_A, O>;
        impl<'a, const O: u8> TI1S_W<'a, O> {
            ///TIMx_CH1 connected directly to TI1
            #[inline(always)]
            pub fn direct(self) -> &'a mut W {
                self.variant(TI1S_A::Direct)
            }
            ///TIMx_CH1/2/3 connected to TI1 after xor
            #[inline(always)]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1S_A::Xor)
            }
        }
        ///Field `OIS1` reader - Output Idle state 1
        pub type OIS1_R = crate::BitReader<bool>;
        ///Field `OIS1` writer - Output Idle state 1
        pub type OIS1_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS1N` reader - Output Idle state 1
        pub type OIS1N_R = crate::BitReader<bool>;
        ///Field `OIS1N` writer - Output Idle state 1
        pub type OIS1N_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS2` reader - Output Idle state 2
        pub type OIS2_R = crate::BitReader<bool>;
        ///Field `OIS2` writer - Output Idle state 2
        pub type OIS2_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS2N` reader - Output Idle state 2
        pub type OIS2N_R = crate::BitReader<bool>;
        ///Field `OIS2N` writer - Output Idle state 2
        pub type OIS2N_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS3` reader - Output Idle state 3
        pub type OIS3_R = crate::BitReader<bool>;
        ///Field `OIS3` writer - Output Idle state 3
        pub type OIS3_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS3N` reader - Output Idle state 3
        pub type OIS3N_R = crate::BitReader<bool>;
        ///Field `OIS3N` writer - Output Idle state 3
        pub type OIS3N_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        ///Field `OIS4` reader - Output Idle state 4
        pub type OIS4_R = crate::BitReader<bool>;
        ///Field `OIS4` writer - Output Idle state 4
        pub type OIS4_W<'a, const O: u8> = crate::BitWriter<'a, u16, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            pub fn ois2n(&self) -> OIS2N_R {
                OIS2N_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            pub fn ois3(&self) -> OIS3_R {
                OIS3_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            pub fn ois3n(&self) -> OIS3N_R {
                OIS3N_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            pub fn ois4(&self) -> OIS4_R {
                OIS4_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            #[must_use]
            pub fn ccpc(&mut self) -> CCPC_W<0> {
                CCPC_W::new(self)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            #[must_use]
            pub fn ccus(&mut self) -> CCUS_W<2> {
                CCUS_W::new(self)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            #[must_use]
            pub fn ccds(&mut self) -> CCDS_W<3> {
                CCDS_W::new(self)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            #[must_use]
            pub fn mms(&mut self) -> MMS_W<4> {
                MMS_W::new(self)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            #[must_use]
            pub fn ti1s(&mut self) -> TI1S_W<7> {
                TI1S_W::new(self)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1(&mut self) -> OIS1_W<8> {
                OIS1_W::new(self)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1n(&mut self) -> OIS1N_W<9> {
                OIS1N_W::new(self)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2(&mut self) -> OIS2_W<10> {
                OIS2_W::new(self)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2n(&mut self) -> OIS2N_W<11> {
                OIS2N_W::new(self)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3(&mut self) -> OIS3_W<12> {
                OIS3_W::new(self)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3n(&mut self) -> OIS3N_W<13> {
                OIS3N_W::new(self)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            #[must_use]
            pub fn ois4(&mut self) -> OIS4_W<14> {
                OIS4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SMCFGR (rw) register accessor: an alias for `Reg<SMCFGR_SPEC>`
    pub type SMCFGR = crate::Reg<smcfgr::SMCFGR_SPEC>;
    ///slave mode control register
    pub mod smcfgr {
        ///Register `SMCFGR` reader
        pub struct R(crate::R<SMCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SMCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SMCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCFGR` writer
        pub struct W(crate::W<SMCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SMCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SMCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub type SMS_R = crate::FieldReader<u8, SMS_A>;
        ///Slave mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum SMS_A {
            ///0: Core counter driven by CK_INT
            Internal = 0,
            ///1: Core counter increment or decrement on TI1FP1 edge with respect to TI2FP2
            Encoder1 = 1,
            ///2: Core counter increment or decrement on TI2FP2 edge with respect to TI1FP1
            Encoder2 = 2,
            ///3: Core counter increment or decrement on TI1FP1/TI2FP2 edge with respect to another signal
            Encoder3 = 3,
            ///4: Rising edge on TRGI will reset the counter
            Reset = 4,
            ///5: Counter clock start/stop with respect to TRGI
            Gate = 5,
            ///6: Counter start on TRGI rising edge
            Trigger = 6,
            ///7: Counter driven by TRGI rising edge
            External = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        impl SMS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::Internal,
                    1 => SMS_A::Encoder1,
                    2 => SMS_A::Encoder2,
                    3 => SMS_A::Encoder3,
                    4 => SMS_A::Reset,
                    5 => SMS_A::Gate,
                    6 => SMS_A::Trigger,
                    7 => SMS_A::External,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Internal`
            #[inline(always)]
            pub fn is_internal(&self) -> bool {
                *self == SMS_A::Internal
            }
            ///Checks if the value of the field is `Encoder1`
            #[inline(always)]
            pub fn is_encoder1(&self) -> bool {
                *self == SMS_A::Encoder1
            }
            ///Checks if the value of the field is `Encoder2`
            #[inline(always)]
            pub fn is_encoder2(&self) -> bool {
                *self == SMS_A::Encoder2
            }
            ///Checks if the value of the field is `Encoder3`
            #[inline(always)]
            pub fn is_encoder3(&self) -> bool {
                *self == SMS_A::Encoder3
            }
            ///Checks if the value of the field is `Reset`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == SMS_A::Reset
            }
            ///Checks if the value of the field is `Gate`
            #[inline(always)]
            pub fn is_gate(&self) -> bool {
                *self == SMS_A::Gate
            }
            ///Checks if the value of the field is `Trigger`
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                *self == SMS_A::Trigger
            }
            ///Checks if the value of the field is `External`
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == SMS_A::External
            }
        }
        ///Field `SMS` writer - Slave mode selection
        pub type SMS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, SMS_A, 3, O>;
        impl<'a, const O: u8> SMS_W<'a, O> {
            ///Core counter driven by CK_INT
            #[inline(always)]
            pub fn internal(self) -> &'a mut W {
                self.variant(SMS_A::Internal)
            }
            ///Core counter increment or decrement on TI1FP1 edge with respect to TI2FP2
            #[inline(always)]
            pub fn encoder1(self) -> &'a mut W {
                self.variant(SMS_A::Encoder1)
            }
            ///Core counter increment or decrement on TI2FP2 edge with respect to TI1FP1
            #[inline(always)]
            pub fn encoder2(self) -> &'a mut W {
                self.variant(SMS_A::Encoder2)
            }
            ///Core counter increment or decrement on TI1FP1/TI2FP2 edge with respect to another signal
            #[inline(always)]
            pub fn encoder3(self) -> &'a mut W {
                self.variant(SMS_A::Encoder3)
            }
            ///Rising edge on TRGI will reset the counter
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SMS_A::Reset)
            }
            ///Counter clock start/stop with respect to TRGI
            #[inline(always)]
            pub fn gate(self) -> &'a mut W {
                self.variant(SMS_A::Gate)
            }
            ///Counter start on TRGI rising edge
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(SMS_A::Trigger)
            }
            ///Counter driven by TRGI rising edge
            #[inline(always)]
            pub fn external(self) -> &'a mut W {
                self.variant(SMS_A::External)
            }
        }
        ///Field `TS` reader - Trigger selection
        pub type TS_R = crate::FieldReader<u8, TS_A>;
        ///Trigger selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TS_A {
            ///0: ITR0 as trigger
            Internal0 = 0,
            ///1: ITR1 as trigger
            Internal1 = 1,
            ///2: ITR2 as trigger
            Internal2 = 2,
            ///3: ITR3 as trigger
            Internal3 = 3,
            ///4: TI1 edge dector
            Ti1edge = 4,
            ///5: Filtered timer input 1
            Ti1fp1 = 5,
            ///6: Filtered timer input 2
            Ti2fp2 = 6,
            ///7: External trigger input
            External = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        impl TS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TS_A {
                match self.bits {
                    0 => TS_A::Internal0,
                    1 => TS_A::Internal1,
                    2 => TS_A::Internal2,
                    3 => TS_A::Internal3,
                    4 => TS_A::Ti1edge,
                    5 => TS_A::Ti1fp1,
                    6 => TS_A::Ti2fp2,
                    7 => TS_A::External,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Internal0`
            #[inline(always)]
            pub fn is_internal0(&self) -> bool {
                *self == TS_A::Internal0
            }
            ///Checks if the value of the field is `Internal1`
            #[inline(always)]
            pub fn is_internal1(&self) -> bool {
                *self == TS_A::Internal1
            }
            ///Checks if the value of the field is `Internal2`
            #[inline(always)]
            pub fn is_internal2(&self) -> bool {
                *self == TS_A::Internal2
            }
            ///Checks if the value of the field is `Internal3`
            #[inline(always)]
            pub fn is_internal3(&self) -> bool {
                *self == TS_A::Internal3
            }
            ///Checks if the value of the field is `Ti1edge`
            #[inline(always)]
            pub fn is_ti1edge(&self) -> bool {
                *self == TS_A::Ti1edge
            }
            ///Checks if the value of the field is `Ti1fp1`
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TS_A::Ti1fp1
            }
            ///Checks if the value of the field is `Ti2fp2`
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TS_A::Ti2fp2
            }
            ///Checks if the value of the field is `External`
            #[inline(always)]
            pub fn is_external(&self) -> bool {
                *self == TS_A::External
            }
        }
        ///Field `TS` writer - Trigger selection
        pub type TS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, TS_A, 3, O>;
        impl<'a, const O: u8> TS_W<'a, O> {
            ///ITR0 as trigger
            #[inline(always)]
            pub fn internal0(self) -> &'a mut W {
                self.variant(TS_A::Internal0)
            }
            ///ITR1 as trigger
            #[inline(always)]
            pub fn internal1(self) -> &'a mut W {
                self.variant(TS_A::Internal1)
            }
            ///ITR2 as trigger
            #[inline(always)]
            pub fn internal2(self) -> &'a mut W {
                self.variant(TS_A::Internal2)
            }
            ///ITR3 as trigger
            #[inline(always)]
            pub fn internal3(self) -> &'a mut W {
                self.variant(TS_A::Internal3)
            }
            ///TI1 edge dector
            #[inline(always)]
            pub fn ti1edge(self) -> &'a mut W {
                self.variant(TS_A::Ti1edge)
            }
            ///Filtered timer input 1
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::Ti1fp1)
            }
            ///Filtered timer input 2
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::Ti2fp2)
            }
            ///External trigger input
            #[inline(always)]
            pub fn external(self) -> &'a mut W {
                self.variant(TS_A::External)
            }
        }
        ///Field `MSM` reader - Master/Slave mode
        pub type MSM_R = crate::BitReader<MSM_A>;
        ///Master/Slave mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum MSM_A {
            ///0: No effect
            NoEffect = 0,
            ///1: Trigger event on TRGI delayed
            Trgidelayed = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        impl MSM_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NoEffect,
                    true => MSM_A::Trgidelayed,
                }
            }
            ///Checks if the value of the field is `NoEffect`
            #[inline(always)]
            pub fn is_no_effect(&self) -> bool {
                *self == MSM_A::NoEffect
            }
            ///Checks if the value of the field is `Trgidelayed`
            #[inline(always)]
            pub fn is_trgidelayed(&self) -> bool {
                *self == MSM_A::Trgidelayed
            }
        }
        ///Field `MSM` writer - Master/Slave mode
        pub type MSM_W<'a, const O: u8> = crate::BitWriter<'a, u16, SMCFGR_SPEC, MSM_A, O>;
        impl<'a, const O: u8> MSM_W<'a, O> {
            ///No effect
            #[inline(always)]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(MSM_A::NoEffect)
            }
            ///Trigger event on TRGI delayed
            #[inline(always)]
            pub fn trgidelayed(self) -> &'a mut W {
                self.variant(MSM_A::Trgidelayed)
            }
        }
        ///Field `ETF` reader - External trigger filter
        pub type ETF_R = crate::FieldReader<u8, ETF_A>;
        ///External trigger filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ETF_A {
            ///0: No filter applied, sampling using Fdts
            NoFilter = 0,
            ///1: Fsampling = Fck_int, N=2
            FckN2 = 1,
            ///2: Fsampling = Fck_int, N=4
            FckN4 = 2,
            ///3: Fsampling = Fck_int, N=8
            FckN8 = 3,
            ///4: Fsampling = Fdts / 2, N=6
            Fdts2n6 = 4,
            ///5: Fsampling = Fdts / 2, N=8
            Fdts2n8 = 5,
            ///6: Fsampling = Fdts / 4, N=6
            Fdts4n6 = 6,
            ///7: Fsampling = Fdts / 4, N=8
            Fdts4n8 = 7,
            ///8: Fsampling = Fdts / 8, N=6
            Fdts8n6 = 8,
            ///9: Fsampling = Fdts / 8, N=8
            Fdts8n8 = 9,
            ///10: Fsampling = Fdts / 16, N=5
            Fdts16n5 = 10,
            ///11: Fsampling = Fdts / 16, N=6
            Fdts16n6 = 11,
            ///12: Fsampling = Fdts / 16, N=8
            Fdts16n8 = 12,
            ///13: Fsampling = Fdts / 32, N=5
            Fdts32n5 = 13,
            ///14: Fsampling = Fdts / 32, N=6
            Fdts32n6 = 14,
            ///15: Fsampling = Fdts / 32, N=8
            Fdts32n8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        impl ETF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NoFilter,
                    1 => ETF_A::FckN2,
                    2 => ETF_A::FckN4,
                    3 => ETF_A::FckN8,
                    4 => ETF_A::Fdts2n6,
                    5 => ETF_A::Fdts2n8,
                    6 => ETF_A::Fdts4n6,
                    7 => ETF_A::Fdts4n8,
                    8 => ETF_A::Fdts8n6,
                    9 => ETF_A::Fdts8n8,
                    10 => ETF_A::Fdts16n5,
                    11 => ETF_A::Fdts16n6,
                    12 => ETF_A::Fdts16n8,
                    13 => ETF_A::Fdts32n5,
                    14 => ETF_A::Fdts32n6,
                    15 => ETF_A::Fdts32n8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoFilter`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == ETF_A::NoFilter
            }
            ///Checks if the value of the field is `FckN2`
            #[inline(always)]
            pub fn is_fck_n2(&self) -> bool {
                *self == ETF_A::FckN2
            }
            ///Checks if the value of the field is `FckN4`
            #[inline(always)]
            pub fn is_fck_n4(&self) -> bool {
                *self == ETF_A::FckN4
            }
            ///Checks if the value of the field is `FckN8`
            #[inline(always)]
            pub fn is_fck_n8(&self) -> bool {
                *self == ETF_A::FckN8
            }
            ///Checks if the value of the field is `Fdts2n6`
            #[inline(always)]
            pub fn is_fdts2n6(&self) -> bool {
                *self == ETF_A::Fdts2n6
            }
            ///Checks if the value of the field is `Fdts2n8`
            #[inline(always)]
            pub fn is_fdts2n8(&self) -> bool {
                *self == ETF_A::Fdts2n8
            }
            ///Checks if the value of the field is `Fdts4n6`
            #[inline(always)]
            pub fn is_fdts4n6(&self) -> bool {
                *self == ETF_A::Fdts4n6
            }
            ///Checks if the value of the field is `Fdts4n8`
            #[inline(always)]
            pub fn is_fdts4n8(&self) -> bool {
                *self == ETF_A::Fdts4n8
            }
            ///Checks if the value of the field is `Fdts8n6`
            #[inline(always)]
            pub fn is_fdts8n6(&self) -> bool {
                *self == ETF_A::Fdts8n6
            }
            ///Checks if the value of the field is `Fdts8n8`
            #[inline(always)]
            pub fn is_fdts8n8(&self) -> bool {
                *self == ETF_A::Fdts8n8
            }
            ///Checks if the value of the field is `Fdts16n5`
            #[inline(always)]
            pub fn is_fdts16n5(&self) -> bool {
                *self == ETF_A::Fdts16n5
            }
            ///Checks if the value of the field is `Fdts16n6`
            #[inline(always)]
            pub fn is_fdts16n6(&self) -> bool {
                *self == ETF_A::Fdts16n6
            }
            ///Checks if the value of the field is `Fdts16n8`
            #[inline(always)]
            pub fn is_fdts16n8(&self) -> bool {
                *self == ETF_A::Fdts16n8
            }
            ///Checks if the value of the field is `Fdts32n5`
            #[inline(always)]
            pub fn is_fdts32n5(&self) -> bool {
                *self == ETF_A::Fdts32n5
            }
            ///Checks if the value of the field is `Fdts32n6`
            #[inline(always)]
            pub fn is_fdts32n6(&self) -> bool {
                *self == ETF_A::Fdts32n6
            }
            ///Checks if the value of the field is `Fdts32n8`
            #[inline(always)]
            pub fn is_fdts32n8(&self) -> bool {
                *self == ETF_A::Fdts32n8
            }
        }
        ///Field `ETF` writer - External trigger filter
        pub type ETF_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, ETF_A, 4, O>;
        impl<'a, const O: u8> ETF_W<'a, O> {
            ///No filter applied, sampling using Fdts
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NoFilter)
            }
            ///Fsampling = Fck_int, N=2
            #[inline(always)]
            pub fn fck_n2(self) -> &'a mut W {
                self.variant(ETF_A::FckN2)
            }
            ///Fsampling = Fck_int, N=4
            #[inline(always)]
            pub fn fck_n4(self) -> &'a mut W {
                self.variant(ETF_A::FckN4)
            }
            ///Fsampling = Fck_int, N=8
            #[inline(always)]
            pub fn fck_n8(self) -> &'a mut W {
                self.variant(ETF_A::FckN8)
            }
            ///Fsampling = Fdts / 2, N=6
            #[inline(always)]
            pub fn fdts2n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts2n6)
            }
            ///Fsampling = Fdts / 2, N=8
            #[inline(always)]
            pub fn fdts2n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts2n8)
            }
            ///Fsampling = Fdts / 4, N=6
            #[inline(always)]
            pub fn fdts4n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts4n6)
            }
            ///Fsampling = Fdts / 4, N=8
            #[inline(always)]
            pub fn fdts4n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts4n8)
            }
            ///Fsampling = Fdts / 8, N=6
            #[inline(always)]
            pub fn fdts8n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts8n6)
            }
            ///Fsampling = Fdts / 8, N=8
            #[inline(always)]
            pub fn fdts8n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts8n8)
            }
            ///Fsampling = Fdts / 16, N=5
            #[inline(always)]
            pub fn fdts16n5(self) -> &'a mut W {
                self.variant(ETF_A::Fdts16n5)
            }
            ///Fsampling = Fdts / 16, N=6
            #[inline(always)]
            pub fn fdts16n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts16n6)
            }
            ///Fsampling = Fdts / 16, N=8
            #[inline(always)]
            pub fn fdts16n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts16n8)
            }
            ///Fsampling = Fdts / 32, N=5
            #[inline(always)]
            pub fn fdts32n5(self) -> &'a mut W {
                self.variant(ETF_A::Fdts32n5)
            }
            ///Fsampling = Fdts / 32, N=6
            #[inline(always)]
            pub fn fdts32n6(self) -> &'a mut W {
                self.variant(ETF_A::Fdts32n6)
            }
            ///Fsampling = Fdts / 32, N=8
            #[inline(always)]
            pub fn fdts32n8(self) -> &'a mut W {
                self.variant(ETF_A::Fdts32n8)
            }
        }
        ///Field `ETPS` reader - External trigger prescaler
        pub type ETPS_R = crate::FieldReader<u8, ETPS_A>;
        ///External trigger prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum ETPS_A {
            ///0: Pre-division off
            Off = 0,
            ///1: ETRP / 2
            Div2 = 1,
            ///2: ETRP / 4
            Div4 = 2,
            ///3: ETRP / 8
            Div8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        impl ETPS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::Off,
                    1 => ETPS_A::Div2,
                    2 => ETPS_A::Div4,
                    3 => ETPS_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Off`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                *self == ETPS_A::Off
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == ETPS_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == ETPS_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == ETPS_A::Div8
            }
        }
        ///Field `ETPS` writer - External trigger prescaler
        pub type ETPS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, SMCFGR_SPEC, u8, ETPS_A, 2, O>;
        impl<'a, const O: u8> ETPS_W<'a, O> {
            ///Pre-division off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(ETPS_A::Off)
            }
            ///ETRP / 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::Div2)
            }
            ///ETRP / 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::Div4)
            }
            ///ETRP / 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::Div8)
            }
        }
        ///Field `ECE` reader - External clock enable
        pub type ECE_R = crate::BitReader<ECE_A>;
        ///External clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ECE_A {
            ///0: External Clock Mode 2 disabled
            Disabled = 0,
            ///1: External Clock Mode 2 enabled
            Enabled = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ECE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::Disabled,
                    true => ECE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == ECE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == ECE_A::Enabled
            }
        }
        ///Field `ECE` writer - External clock enable
        pub type ECE_W<'a, const O: u8> = crate::BitWriter<'a, u16, SMCFGR_SPEC, ECE_A, O>;
        impl<'a, const O: u8> ECE_W<'a, O> {
            ///External Clock Mode 2 disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::Disabled)
            }
            ///External Clock Mode 2 enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::Enabled)
            }
        }
        ///Field `ETP` reader - External trigger polarity
        pub type ETP_R = crate::BitReader<ETP_A>;
        ///External trigger polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ETP_A {
            ///0: Trigger on ETR high voltage or rising edge
            Direct = 0,
            ///1: Trigger on ETR low voltage or falling edge
            Inversed = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ETP_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::Direct,
                    true => ETP_A::Inversed,
                }
            }
            ///Checks if the value of the field is `Direct`
            #[inline(always)]
            pub fn is_direct(&self) -> bool {
                *self == ETP_A::Direct
            }
            ///Checks if the value of the field is `Inversed`
            #[inline(always)]
            pub fn is_inversed(&self) -> bool {
                *self == ETP_A::Inversed
            }
        }
        ///Field `ETP` writer - External trigger polarity
        pub type ETP_W<'a, const O: u8> = crate::BitWriter<'a, u16, SMCFGR_SPEC, ETP_A, O>;
        impl<'a, const O: u8> ETP_W<'a, O> {
            ///Trigger on ETR high voltage or rising edge
            #[inline(always)]
            pub fn direct(self) -> &'a mut W {
                self.variant(ETP_A::Direct)
            }
            ///Trigger on ETR low voltage or falling edge
            #[inline(always)]
            pub fn inversed(self) -> &'a mut W {
                self.variant(ETP_A::Inversed)
            }
        }
        impl R {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 7) as u8)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            #[must_use]
            pub fn sms(&mut self) -> SMS_W<0> {
                SMS_W::new(self)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            #[must_use]
            pub fn ts(&mut self) -> TS_W<4> {
                TS_W::new(self)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            #[must_use]
            pub fn msm(&mut self) -> MSM_W<7> {
                MSM_W::new(self)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            #[must_use]
            pub fn etf(&mut self) -> ETF_W<8> {
                ETF_W::new(self)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            #[must_use]
            pub fn etps(&mut self) -> ETPS_W<12> {
                ETPS_W::new(self)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            #[must_use]
            pub fn ece(&mut self) -> ECE_W<14> {
                ECE_W::new(self)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            #[must_use]
            pub fn etp(&mut self) -> ETP_W<15> {
                ETP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcfgr](index.html) module
        pub struct SMCFGR_SPEC;
        impl crate::RegisterSpec for SMCFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [smcfgr::R](R) reader structure
        impl crate::Readable for SMCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcfgr::W](W) writer structure
        impl crate::Writable for SMCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SMCFGR to value 0
        impl crate::Resettable for SMCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAINTENR (rw) register accessor: an alias for `Reg<DMAINTENR_SPEC>`
    pub type DMAINTENR = crate::Reg<dmaintenr::DMAINTENR_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dmaintenr {
        ///Register `DMAINTENR` reader
        pub struct R(crate::R<DMAINTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAINTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAINTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAINTENR` writer
        pub struct W(crate::W<DMAINTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAINTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAINTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub type UIE_R = crate::BitReader<UIE_A>;
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UIE_A {
            ///0: Interrupt disabled
            Disabled = 0,
            ///1: Interrupt enabled
            Enabled = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UIE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::Disabled,
                    true => UIE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UIE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UIE_A::Enabled
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub type UIE_W<'a, const O: u8> = crate::BitWriter<'a, u16, DMAINTENR_SPEC, UIE_A, O>;
        impl<'a, const O: u8> UIE_W<'a, O> {
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::Disabled)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::Enabled)
            }
        }
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub use UIE_R as CC1IE_R;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub use UIE_R as CC2IE_R;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub use UIE_R as CC3IE_R;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub use UIE_R as CC4IE_R;
        ///Field `COMIE` reader - COM interrupt enable
        pub use UIE_R as COMIE_R;
        ///Field `TIE` reader - Trigger interrupt enable
        pub use UIE_R as TIE_R;
        ///Field `BIE` reader - Break interrupt enable
        pub use UIE_R as BIE_R;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub use UIE_W as CC1IE_W;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub use UIE_W as CC2IE_W;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub use UIE_W as CC3IE_W;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub use UIE_W as CC4IE_W;
        ///Field `COMIE` writer - COM interrupt enable
        pub use UIE_W as COMIE_W;
        ///Field `TIE` writer - Trigger interrupt enable
        pub use UIE_W as TIE_W;
        ///Field `BIE` writer - Break interrupt enable
        pub use UIE_W as BIE_W;
        ///Field `UDE` reader - Update DMA request enable
        pub type UDE_R = crate::BitReader<UDE_A>;
        ///Update DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UDE_A {
            ///0: DMA disabled
            Disabled = 0,
            ///1: DMA enabled
            Enabled = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UDE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::Disabled,
                    true => UDE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == UDE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == UDE_A::Enabled
            }
        }
        ///Field `UDE` writer - Update DMA request enable
        pub type UDE_W<'a, const O: u8> = crate::BitWriter<'a, u16, DMAINTENR_SPEC, UDE_A, O>;
        impl<'a, const O: u8> UDE_W<'a, O> {
            ///DMA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::Disabled)
            }
            ///DMA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::Enabled)
            }
        }
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub use UDE_R as CC1DE_R;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub use UDE_R as CC2DE_R;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub use UDE_R as CC3DE_R;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub use UDE_R as CC4DE_R;
        ///Field `COMDE` reader - COM DMA request enable
        pub use UDE_R as COMDE_R;
        ///Field `TDE` reader - Trigger DMA request enable
        pub use UDE_R as TDE_R;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub use UDE_W as CC1DE_W;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub use UDE_W as CC2DE_W;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub use UDE_W as CC3DE_W;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub use UDE_W as CC4DE_W;
        ///Field `COMDE` writer - COM DMA request enable
        pub use UDE_W as COMDE_W;
        ///Field `TDE` writer - Trigger DMA request enable
        pub use UDE_W as TDE_W;
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            pub fn comde(&self) -> COMDE_R {
                COMDE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn uie(&mut self) -> UIE_W<0> {
                UIE_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ie(&mut self) -> CC1IE_W<1> {
                CC1IE_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ie(&mut self) -> CC2IE_W<2> {
                CC2IE_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ie(&mut self) -> CC3IE_W<3> {
                CC3IE_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc4ie(&mut self) -> CC4IE_W<4> {
                CC4IE_W::new(self)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn comie(&mut self) -> COMIE_W<5> {
                COMIE_W::new(self)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tie(&mut self) -> TIE_W<6> {
                TIE_W::new(self)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn bie(&mut self) -> BIE_W<7> {
                BIE_W::new(self)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn ude(&mut self) -> UDE_W<8> {
                UDE_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc1de(&mut self) -> CC1DE_W<9> {
                CC1DE_W::new(self)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc2de(&mut self) -> CC2DE_W<10> {
                CC2DE_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc3de(&mut self) -> CC3DE_W<11> {
                CC3DE_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc4de(&mut self) -> CC4DE_W<12> {
                CC4DE_W::new(self)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn comde(&mut self) -> COMDE_W<13> {
                COMDE_W::new(self)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn tde(&mut self) -> TDE_W<14> {
                TDE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmaintenr](index.html) module
        pub struct DMAINTENR_SPEC;
        impl crate::RegisterSpec for DMAINTENR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dmaintenr::R](R) reader structure
        impl crate::Readable for DMAINTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmaintenr::W](W) writer structure
        impl crate::Writable for DMAINTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAINTENR to value 0
        impl crate::Resettable for DMAINTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFR (rw) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///status register
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTFR` writer
        pub struct W(crate::W<INTFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub type UIF_R = crate::BitReader<UIFR_A>;
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UIFR_A {
            ///0: Not interrupted
            NotInterrupted = 0,
            ///1: Interrupted
            Interrupted = 1,
        }
        impl From<UIFR_A> for bool {
            #[inline(always)]
            fn from(variant: UIFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl UIF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIFR_A {
                match self.bits {
                    false => UIFR_A::NotInterrupted,
                    true => UIFR_A::Interrupted,
                }
            }
            ///Checks if the value of the field is `NotInterrupted`
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                *self == UIFR_A::NotInterrupted
            }
            ///Checks if the value of the field is `Interrupted`
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                *self == UIFR_A::Interrupted
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UIFW_AW {
            ///0: Clear interrupt flag
            Clear = 0,
        }
        impl From<UIFW_AW> for bool {
            #[inline(always)]
            fn from(variant: UIFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub type UIF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, INTFR_SPEC, UIFW_AW, O>;
        impl<'a, const O: u8> UIF_W<'a, O> {
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW_AW::Clear)
            }
        }
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub use UIF_R as CC1IF_R;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub use UIF_R as CC2IF_R;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub use UIF_R as CC3IF_R;
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub use UIF_R as CC4IF_R;
        ///Field `COMIF` reader - COM interrupt flag
        pub use UIF_R as COMIF_R;
        ///Field `TIF` reader - Trigger interrupt flag
        pub use UIF_R as TIF_R;
        ///Field `BIF` reader - Break interrupt flag
        pub use UIF_R as BIF_R;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub use UIF_W as CC1IF_W;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub use UIF_W as CC2IF_W;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub use UIF_W as CC3IF_W;
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub use UIF_W as CC4IF_W;
        ///Field `COMIF` writer - COM interrupt flag
        pub use UIF_W as COMIF_W;
        ///Field `TIF` writer - Trigger interrupt flag
        pub use UIF_W as TIF_W;
        ///Field `BIF` writer - Break interrupt flag
        pub use UIF_W as BIF_W;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = crate::BitReader<CC1OFR_A>;
        ///Capture/Compare 1 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CC1OFR_A {
            ///0: Not overcaptured
            NotOvercaptured = 0,
            ///1: Overcaptured
            Overcaptured = 1,
        }
        impl From<CC1OFR_A> for bool {
            #[inline(always)]
            fn from(variant: CC1OFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CC1OF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1OFR_A {
                match self.bits {
                    false => CC1OFR_A::NotOvercaptured,
                    true => CC1OFR_A::Overcaptured,
                }
            }
            ///Checks if the value of the field is `NotOvercaptured`
            #[inline(always)]
            pub fn is_not_overcaptured(&self) -> bool {
                *self == CC1OFR_A::NotOvercaptured
            }
            ///Checks if the value of the field is `Overcaptured`
            #[inline(always)]
            pub fn is_overcaptured(&self) -> bool {
                *self == CC1OFR_A::Overcaptured
            }
        }
        ///Capture/Compare 1 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CC1OFW_AW {
            ///0: Clear overcapture flag
            Clear = 0,
        }
        impl From<CC1OFW_AW> for bool {
            #[inline(always)]
            fn from(variant: CC1OFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub type CC1OF_W<'a, const O: u8> = crate::BitWriter0C<'a, u16, INTFR_SPEC, CC1OFW_AW, O>;
        impl<'a, const O: u8> CC1OF_W<'a, O> {
            ///Clear overcapture flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC1OFW_AW::Clear)
            }
        }
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub use CC1OF_R as CC2OF_R;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub use CC1OF_R as CC3OF_R;
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub use CC1OF_R as CC4OF_R;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub use CC1OF_W as CC2OF_W;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub use CC1OF_W as CC3OF_W;
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub use CC1OF_W as CC4OF_W;
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif(&mut self) -> UIF_W<0> {
                UIF_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc1if(&mut self) -> CC1IF_W<1> {
                CC1IF_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc2if(&mut self) -> CC2IF_W<2> {
                CC2IF_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc3if(&mut self) -> CC3IF_W<3> {
                CC3IF_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc4if(&mut self) -> CC4IF_W<4> {
                CC4IF_W::new(self)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn comif(&mut self) -> COMIF_W<5> {
                COMIF_W::new(self)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn tif(&mut self) -> TIF_W<6> {
                TIF_W::new(self)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn bif(&mut self) -> BIF_W<7> {
                BIF_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc1of(&mut self) -> CC1OF_W<9> {
                CC1OF_W::new(self)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc2of(&mut self) -> CC2OF_W<10> {
                CC2OF_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc3of(&mut self) -> CC3OF_W<11> {
                CC3OF_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc4of(&mut self) -> CC4OF_W<12> {
                CC4OF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intfr::W](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x1eff;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SWEVGR (w) register accessor: an alias for `Reg<SWEVGR_SPEC>`
    pub type SWEVGR = crate::Reg<swevgr::SWEVGR_SPEC>;
    ///event generation register
    pub mod swevgr {
        ///Register `SWEVGR` writer
        pub struct W(crate::W<SWEVGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWEVGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SWEVGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SWEVGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum UGW_AW {
            ///1: Generate event
            Generate = 1,
        }
        impl From<UGW_AW> for bool {
            #[inline(always)]
            fn from(variant: UGW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub type UG_W<'a, const O: u8> = crate::BitWriter<'a, u16, SWEVGR_SPEC, UGW_AW, O>;
        impl<'a, const O: u8> UG_W<'a, O> {
            ///Generate event
            #[inline(always)]
            pub fn generate(self) -> &'a mut W {
                self.variant(UGW_AW::Generate)
            }
        }
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub use UG_W as CC1G_W;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub use UG_W as CC2G_W;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub use UG_W as CC3G_W;
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub use UG_W as CC4G_W;
        ///Field `COMG` writer - Capture/Compare control update generation
        pub use UG_W as COMG_W;
        ///Field `TG` writer - Trigger generation
        pub use UG_W as TG_W;
        ///Field `BG` writer - Break generation
        pub use UG_W as BG_W;
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            #[must_use]
            pub fn ug(&mut self) -> UG_W<0> {
                UG_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            #[must_use]
            pub fn cc1g(&mut self) -> CC1G_W<1> {
                CC1G_W::new(self)
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            #[must_use]
            pub fn cc2g(&mut self) -> CC2G_W<2> {
                CC2G_W::new(self)
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            #[must_use]
            pub fn cc3g(&mut self) -> CC3G_W<3> {
                CC3G_W::new(self)
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            #[must_use]
            pub fn cc4g(&mut self) -> CC4G_W<4> {
                CC4G_W::new(self)
            }
            ///Bit 5 - Capture/Compare control update generation
            #[inline(always)]
            #[must_use]
            pub fn comg(&mut self) -> COMG_W<5> {
                COMG_W::new(self)
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            #[must_use]
            pub fn tg(&mut self) -> TG_W<6> {
                TG_W::new(self)
            }
            ///Bit 7 - Break generation
            #[inline(always)]
            #[must_use]
            pub fn bg(&mut self) -> BG_W<7> {
                BG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swevgr](index.html) module
        pub struct SWEVGR_SPEC;
        impl crate::RegisterSpec for SWEVGR_SPEC {
            type Ux = u16;
        }
        ///`write(|w| ..)` method takes [swevgr::W](W) writer structure
        impl crate::Writable for SWEVGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SWEVGR to value 0
        impl crate::Resettable for SWEVGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1O (rw) register accessor: an alias for `Reg<CHCTLR1O_SPEC>`
    pub type CHCTLR1O = crate::Reg<chctlr1o::CHCTLR1O_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr1o {
        ///Register `CHCTLR1O` reader
        pub struct R(crate::R<CHCTLR1O_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1O_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1O_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1O` writer
        pub struct W(crate::W<CHCTLR1O_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1O_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1O_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, CC1S_A>;
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///0: CC1 configured as input
            Input = 0,
            ///1: CC1 configured as output. IC1 mapped to TI1
            OutputTi1 = 1,
            ///2: CC1 configured as output. IC1 mapped to TI2
            OutputTi2 = 2,
            ///3: CC1 configured as output. IC1 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        impl CC1S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1S_A {
                match self.bits {
                    0 => CC1S_A::Input,
                    1 => CC1S_A::OutputTi1,
                    2 => CC1S_A::OutputTi2,
                    3 => CC1S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC1S_A::Input
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC1S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC1S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC1S_A::OutputTrc
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, CC1S_A, 2, O>;
        impl<'a, const O: u8> CC1S_W<'a, O> {
            ///CC1 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC1S_A::Input)
            }
            ///CC1 configured as output. IC1 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC1S_A::OutputTi1)
            }
            ///CC1 configured as output. IC1 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC1S_A::OutputTi2)
            }
            ///CC1 configured as output. IC1 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC1S_A::OutputTrc)
            }
        }
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub type OC1FE_R = crate::BitReader<OC1FE_A>;
        ///Output Compare 1 fast enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC1FE_A {
            ///0: Fast enabling disabled
            Disabled = 0,
            ///1: Fast enabling enabled
            Enabled = 1,
        }
        impl From<OC1FE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1FE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC1FE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1FE_A {
                match self.bits {
                    false => OC1FE_A::Disabled,
                    true => OC1FE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1FE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1FE_A::Enabled
            }
        }
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub type OC1FE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR1O_SPEC, OC1FE_A, O>;
        impl<'a, const O: u8> OC1FE_W<'a, O> {
            ///Fast enabling disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1FE_A::Disabled)
            }
            ///Fast enabling enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1FE_A::Enabled)
            }
        }
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub type OC1PE_R = crate::BitReader<OC1PE_A>;
        ///Output Compare 1 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC1PE_A {
            ///0: Preloading disabled
            Disabled = 0,
            ///1: Preloading enabled
            Enabled = 1,
        }
        impl From<OC1PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1PE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC1PE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1PE_A {
                match self.bits {
                    false => OC1PE_A::Disabled,
                    true => OC1PE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1PE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1PE_A::Enabled
            }
        }
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub type OC1PE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR1O_SPEC, OC1PE_A, O>;
        impl<'a, const O: u8> OC1PE_W<'a, O> {
            ///Preloading disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1PE_A::Disabled)
            }
            ///Preloading enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1PE_A::Enabled)
            }
        }
        ///Field `OC1M` reader - Output Compare 1 mode
        pub type OC1M_R = crate::FieldReader<u8, OC1M_A>;
        ///Output Compare 1 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC1M_A {
            ///0: No effect on OC1REF
            Frozen = 0,
            ///1: OC1REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC1REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC1REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC1REF set low
            ForceLow = 4,
            ///5: OC1REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC1M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC1M_A) -> Self {
                variant as _
            }
        }
        impl OC1M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1M_A {
                match self.bits {
                    0 => OC1M_A::Frozen,
                    1 => OC1M_A::ForceHighCmp,
                    2 => OC1M_A::ForceLowCmp,
                    3 => OC1M_A::FlipCmp,
                    4 => OC1M_A::ForceLow,
                    5 => OC1M_A::ForceHigh,
                    6 => OC1M_A::Pwm1,
                    7 => OC1M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC1M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC1M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC1M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC1M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC1M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC1M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC1M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC1M_A::Pwm2
            }
        }
        ///Field `OC1M` writer - Output Compare 1 mode
        pub type OC1M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, OC1M_A, 3, O>;
        impl<'a, const O: u8> OC1M_W<'a, O> {
            ///No effect on OC1REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC1M_A::Frozen)
            }
            ///OC1REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC1M_A::ForceHighCmp)
            }
            ///OC1REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC1M_A::ForceLowCmp)
            }
            ///OC1REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC1M_A::FlipCmp)
            }
            ///OC1REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC1M_A::ForceLow)
            }
            ///OC1REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC1M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC1M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC1M_A::Pwm2)
            }
        }
        ///Field `OC1CE` reader - Output Compare 1 clear enable
        pub type OC1CE_R = crate::BitReader<OC1CE_A>;
        ///Output Compare 1 clear enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC1CE_A {
            ///0: OCxREF reset on ETRF disabled
            Disabled = 0,
            ///1: OCxREF reset on ETRF enabled
            Enabled = 1,
        }
        impl From<OC1CE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1CE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC1CE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1CE_A {
                match self.bits {
                    false => OC1CE_A::Disabled,
                    true => OC1CE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC1CE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC1CE_A::Enabled
            }
        }
        ///Field `OC1CE` writer - Output Compare 1 clear enable
        pub type OC1CE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR1O_SPEC, OC1CE_A, O>;
        impl<'a, const O: u8> OC1CE_W<'a, O> {
            ///OCxREF reset on ETRF disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1CE_A::Disabled)
            }
            ///OCxREF reset on ETRF enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1CE_A::Enabled)
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, CC2S_A>;
        ///Capture/Compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///0: CC2 configured as input
            Input = 0,
            ///1: CC2 configured as output. IC2 mapped to TI2
            OutputTi2 = 1,
            ///2: CC2 configured as output. IC2 mapped to TI1
            OutputTi1 = 2,
            ///3: CC2 configured as output. IC2 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        impl CC2S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC2S_A {
                match self.bits {
                    0 => CC2S_A::Input,
                    1 => CC2S_A::OutputTi2,
                    2 => CC2S_A::OutputTi1,
                    3 => CC2S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC2S_A::Input
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC2S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC2S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC2S_A::OutputTrc
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, CC2S_A, 2, O>;
        impl<'a, const O: u8> CC2S_W<'a, O> {
            ///CC2 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC2S_A::Input)
            }
            ///CC2 configured as output. IC2 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC2S_A::OutputTi2)
            }
            ///CC2 configured as output. IC2 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC2S_A::OutputTi1)
            }
            ///CC2 configured as output. IC2 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC2S_A::OutputTrc)
            }
        }
        ///Field `OC2FE` reader - Output Compare 2 fast enable
        pub use OC1FE_R as OC2FE_R;
        ///Field `OC2FE` writer - Output Compare 2 fast enable
        pub use OC1FE_W as OC2FE_W;
        ///Field `OC2PE` reader - Output Compare 2 preload enable
        pub use OC1PE_R as OC2PE_R;
        ///Field `OC2PE` writer - Output Compare 2 preload enable
        pub use OC1PE_W as OC2PE_W;
        ///Field `OC2M` reader - Output Compare 2 mode
        pub type OC2M_R = crate::FieldReader<u8, OC2M_A>;
        ///Output Compare 2 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC2M_A {
            ///0: No effect on OC2REF
            Frozen = 0,
            ///1: OC2REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC2REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC2REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC2REF set low
            ForceLow = 4,
            ///5: OC2REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        impl OC2M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::Frozen,
                    1 => OC2M_A::ForceHighCmp,
                    2 => OC2M_A::ForceLowCmp,
                    3 => OC2M_A::FlipCmp,
                    4 => OC2M_A::ForceLow,
                    5 => OC2M_A::ForceHigh,
                    6 => OC2M_A::Pwm1,
                    7 => OC2M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC2M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC2M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC2M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC2M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC2M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC2M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC2M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC2M_A::Pwm2
            }
        }
        ///Field `OC2M` writer - Output Compare 2 mode
        pub type OC2M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1O_SPEC, u8, OC2M_A, 3, O>;
        impl<'a, const O: u8> OC2M_W<'a, O> {
            ///No effect on OC2REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::Frozen)
            }
            ///OC2REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC2M_A::ForceHighCmp)
            }
            ///OC2REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC2M_A::ForceLowCmp)
            }
            ///OC2REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC2M_A::FlipCmp)
            }
            ///OC2REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC2M_A::ForceLow)
            }
            ///OC2REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC2M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC2M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC2M_A::Pwm2)
            }
        }
        ///Field `OC2CE` reader - Output Compare 2 clear enable
        pub use OC1CE_R as OC2CE_R;
        ///Field `OC2CE` writer - Output Compare 2 clear enable
        pub use OC1CE_W as OC2CE_W;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc1fe(&mut self) -> OC1FE_W<2> {
                OC1FE_W::new(self)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc1pe(&mut self) -> OC1PE_W<3> {
                OC1PE_W::new(self)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            #[must_use]
            pub fn oc1m(&mut self) -> OC1M_W<4> {
                OC1M_W::new(self)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc1ce(&mut self) -> OC1CE_W<7> {
                OC1CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc2fe(&mut self) -> OC2FE_W<10> {
                OC2FE_W::new(self)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc2pe(&mut self) -> OC2PE_W<11> {
                OC2PE_W::new(self)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            #[must_use]
            pub fn oc2m(&mut self) -> OC2M_W<12> {
                OC2M_W::new(self)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc2ce(&mut self) -> OC2CE_W<15> {
                OC2CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1o](index.html) module
        pub struct CHCTLR1O_SPEC;
        impl crate::RegisterSpec for CHCTLR1O_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr1o::R](R) reader structure
        impl crate::Readable for CHCTLR1O_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1o::W](W) writer structure
        impl crate::Writable for CHCTLR1O_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1O to value 0
        impl crate::Resettable for CHCTLR1O_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1I (rw) register accessor: an alias for `Reg<CHCTLR1I_SPEC>`
    pub type CHCTLR1I = crate::Reg<chctlr1i::CHCTLR1I_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod chctlr1i {
        ///Register `CHCTLR1I` reader
        pub struct R(crate::R<CHCTLR1I_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1I_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1I_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1I` writer
        pub struct W(crate::W<CHCTLR1I_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1I_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1I_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, CC1S_A>;
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///0: CC1 configured as output
            Output = 0,
            ///1: CC1 configured as input. IC1 mapped to TI1
            InputTi1 = 1,
            ///2: CC1 configured as input. IC1 mapped to TI2
            InputTi2 = 2,
            ///3: CC1 configured as input. IC1 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        impl CC1S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1S_A {
                match self.bits {
                    0 => CC1S_A::Output,
                    1 => CC1S_A::InputTi1,
                    2 => CC1S_A::InputTi2,
                    3 => CC1S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC1S_A::Output
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC1S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC1S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC1S_A::InputTrc
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, CC1S_A, 2, O>;
        impl<'a, const O: u8> CC1S_W<'a, O> {
            ///CC1 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1S_A::Output)
            }
            ///CC1 configured as input. IC1 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC1S_A::InputTi1)
            }
            ///CC1 configured as input. IC1 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC1S_A::InputTi2)
            }
            ///CC1 configured as input. IC1 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC1S_A::InputTrc)
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub type IC1PSC_R = crate::FieldReader<u8, IC1PSC_A>;
        ///Input capture 1 prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC1PSC_A {
            ///0: Every capture input edge will trigger a capture
            NoDiv = 0,
            ///1: Every 2 capture input edges will trigger a capture
            Div2 = 1,
            ///2: Every 4 capture input edges will trigger a capture
            Div4 = 2,
            ///3: Every 8 capture input edges will trigger a capture
            Div8 = 3,
        }
        impl From<IC1PSC_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1PSC_A) -> Self {
                variant as _
            }
        }
        impl IC1PSC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC1PSC_A {
                match self.bits {
                    0 => IC1PSC_A::NoDiv,
                    1 => IC1PSC_A::Div2,
                    2 => IC1PSC_A::Div4,
                    3 => IC1PSC_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == IC1PSC_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == IC1PSC_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == IC1PSC_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == IC1PSC_A::Div8
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub type IC1PSC_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, IC1PSC_A, 2, O>;
        impl<'a, const O: u8> IC1PSC_W<'a, O> {
            ///Every capture input edge will trigger a capture
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(IC1PSC_A::NoDiv)
            }
            ///Every 2 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(IC1PSC_A::Div2)
            }
            ///Every 4 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(IC1PSC_A::Div4)
            }
            ///Every 8 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(IC1PSC_A::Div8)
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub type IC1F_R = crate::FieldReader<u8, IC1F_A>;
        ///Input capture 1 filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC1F_A {
            ///0: No filter applied. Sampling using Fdts
            NoFilter = 0,
            ///1: Fsampling = Fck_int, N=2
            FckN2 = 1,
            ///2: Fsampling = Fck_int, N=4
            FckN4 = 2,
            ///3: Fsampling = Fck_int, N=8
            FckN8 = 3,
            ///4: Fsampling = Fdts / 2, N=6
            Fdts2n6 = 4,
            ///5: Fsampling = Fdts / 2, N=8
            Fdts2n8 = 5,
            ///6: Fsampling = Fdts / 4, N=6
            Fdts4n6 = 6,
            ///7: Fsampling = Fdts / 4, N=8
            Fdts4n8 = 7,
            ///8: Fsampling = Fdts / 8, N=6
            Fdts8n6 = 8,
            ///9: Fsampling = Fdts / 8, N=8
            Fdts8n8 = 9,
            ///10: Fsampling = Fdts / 16, N=5
            Fdts16n5 = 10,
            ///11: Fsampling = Fdts / 16, N=6
            Fdts16n6 = 11,
            ///12: Fsampling = Fdts / 16, N=8
            Fdts16n8 = 12,
            ///13: Fsampling = Fdts / 32, N=5
            Fdts32n5 = 13,
            ///14: Fsampling = Fdts / 32, N=6
            Fdts32n6 = 14,
            ///15: Fsampling = Fdts / 32, N=8
            Fdts32n8 = 15,
        }
        impl From<IC1F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1F_A) -> Self {
                variant as _
            }
        }
        impl IC1F_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC1F_A {
                match self.bits {
                    0 => IC1F_A::NoFilter,
                    1 => IC1F_A::FckN2,
                    2 => IC1F_A::FckN4,
                    3 => IC1F_A::FckN8,
                    4 => IC1F_A::Fdts2n6,
                    5 => IC1F_A::Fdts2n8,
                    6 => IC1F_A::Fdts4n6,
                    7 => IC1F_A::Fdts4n8,
                    8 => IC1F_A::Fdts8n6,
                    9 => IC1F_A::Fdts8n8,
                    10 => IC1F_A::Fdts16n5,
                    11 => IC1F_A::Fdts16n6,
                    12 => IC1F_A::Fdts16n8,
                    13 => IC1F_A::Fdts32n5,
                    14 => IC1F_A::Fdts32n6,
                    15 => IC1F_A::Fdts32n8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoFilter`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC1F_A::NoFilter
            }
            ///Checks if the value of the field is `FckN2`
            #[inline(always)]
            pub fn is_fck_n2(&self) -> bool {
                *self == IC1F_A::FckN2
            }
            ///Checks if the value of the field is `FckN4`
            #[inline(always)]
            pub fn is_fck_n4(&self) -> bool {
                *self == IC1F_A::FckN4
            }
            ///Checks if the value of the field is `FckN8`
            #[inline(always)]
            pub fn is_fck_n8(&self) -> bool {
                *self == IC1F_A::FckN8
            }
            ///Checks if the value of the field is `Fdts2n6`
            #[inline(always)]
            pub fn is_fdts2n6(&self) -> bool {
                *self == IC1F_A::Fdts2n6
            }
            ///Checks if the value of the field is `Fdts2n8`
            #[inline(always)]
            pub fn is_fdts2n8(&self) -> bool {
                *self == IC1F_A::Fdts2n8
            }
            ///Checks if the value of the field is `Fdts4n6`
            #[inline(always)]
            pub fn is_fdts4n6(&self) -> bool {
                *self == IC1F_A::Fdts4n6
            }
            ///Checks if the value of the field is `Fdts4n8`
            #[inline(always)]
            pub fn is_fdts4n8(&self) -> bool {
                *self == IC1F_A::Fdts4n8
            }
            ///Checks if the value of the field is `Fdts8n6`
            #[inline(always)]
            pub fn is_fdts8n6(&self) -> bool {
                *self == IC1F_A::Fdts8n6
            }
            ///Checks if the value of the field is `Fdts8n8`
            #[inline(always)]
            pub fn is_fdts8n8(&self) -> bool {
                *self == IC1F_A::Fdts8n8
            }
            ///Checks if the value of the field is `Fdts16n5`
            #[inline(always)]
            pub fn is_fdts16n5(&self) -> bool {
                *self == IC1F_A::Fdts16n5
            }
            ///Checks if the value of the field is `Fdts16n6`
            #[inline(always)]
            pub fn is_fdts16n6(&self) -> bool {
                *self == IC1F_A::Fdts16n6
            }
            ///Checks if the value of the field is `Fdts16n8`
            #[inline(always)]
            pub fn is_fdts16n8(&self) -> bool {
                *self == IC1F_A::Fdts16n8
            }
            ///Checks if the value of the field is `Fdts32n5`
            #[inline(always)]
            pub fn is_fdts32n5(&self) -> bool {
                *self == IC1F_A::Fdts32n5
            }
            ///Checks if the value of the field is `Fdts32n6`
            #[inline(always)]
            pub fn is_fdts32n6(&self) -> bool {
                *self == IC1F_A::Fdts32n6
            }
            ///Checks if the value of the field is `Fdts32n8`
            #[inline(always)]
            pub fn is_fdts32n8(&self) -> bool {
                *self == IC1F_A::Fdts32n8
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub type IC1F_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, IC1F_A, 4, O>;
        impl<'a, const O: u8> IC1F_W<'a, O> {
            ///No filter applied. Sampling using Fdts
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1F_A::NoFilter)
            }
            ///Fsampling = Fck_int, N=2
            #[inline(always)]
            pub fn fck_n2(self) -> &'a mut W {
                self.variant(IC1F_A::FckN2)
            }
            ///Fsampling = Fck_int, N=4
            #[inline(always)]
            pub fn fck_n4(self) -> &'a mut W {
                self.variant(IC1F_A::FckN4)
            }
            ///Fsampling = Fck_int, N=8
            #[inline(always)]
            pub fn fck_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FckN8)
            }
            ///Fsampling = Fdts / 2, N=6
            #[inline(always)]
            pub fn fdts2n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts2n6)
            }
            ///Fsampling = Fdts / 2, N=8
            #[inline(always)]
            pub fn fdts2n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts2n8)
            }
            ///Fsampling = Fdts / 4, N=6
            #[inline(always)]
            pub fn fdts4n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts4n6)
            }
            ///Fsampling = Fdts / 4, N=8
            #[inline(always)]
            pub fn fdts4n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts4n8)
            }
            ///Fsampling = Fdts / 8, N=6
            #[inline(always)]
            pub fn fdts8n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts8n6)
            }
            ///Fsampling = Fdts / 8, N=8
            #[inline(always)]
            pub fn fdts8n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts8n8)
            }
            ///Fsampling = Fdts / 16, N=5
            #[inline(always)]
            pub fn fdts16n5(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts16n5)
            }
            ///Fsampling = Fdts / 16, N=6
            #[inline(always)]
            pub fn fdts16n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts16n6)
            }
            ///Fsampling = Fdts / 16, N=8
            #[inline(always)]
            pub fn fdts16n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts16n8)
            }
            ///Fsampling = Fdts / 32, N=5
            #[inline(always)]
            pub fn fdts32n5(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts32n5)
            }
            ///Fsampling = Fdts / 32, N=6
            #[inline(always)]
            pub fn fdts32n6(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts32n6)
            }
            ///Fsampling = Fdts / 32, N=8
            #[inline(always)]
            pub fn fdts32n8(self) -> &'a mut W {
                self.variant(IC1F_A::Fdts32n8)
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, CC2S_A>;
        ///Capture/Compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///0: CC2 configured as output
            Output = 0,
            ///1: CC2 configured as input. IC2 mapped to TI2
            InputTi2 = 1,
            ///2: CC2 configured as input. IC2 mapped to TI1
            InputTi1 = 2,
            ///3: CC2 configured as input. IC2 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        impl CC2S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC2S_A {
                match self.bits {
                    0 => CC2S_A::Output,
                    1 => CC2S_A::InputTi2,
                    2 => CC2S_A::InputTi1,
                    3 => CC2S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC2S_A::Output
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC2S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC2S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC2S_A::InputTrc
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR1I_SPEC, u8, CC2S_A, 2, O>;
        impl<'a, const O: u8> CC2S_W<'a, O> {
            ///CC2 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::Output)
            }
            ///CC2 configured as input. IC2 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC2S_A::InputTi2)
            }
            ///CC2 configured as input. IC2 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC2S_A::InputTi1)
            }
            ///CC2 configured as input. IC2 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC2S_A::InputTrc)
            }
        }
        ///Field `IC2F` reader - Input capture 2 filter
        pub use IC1F_R as IC2F_R;
        ///Field `IC2F` writer - Input capture 2 filter
        pub use IC1F_W as IC2F_W;
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub use IC1PSC_R as IC2PSC_R;
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub use IC1PSC_W as IC2PSC_W;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic1psc(&mut self) -> IC1PSC_W<2> {
                IC1PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            #[must_use]
            pub fn ic1f(&mut self) -> IC1F_W<4> {
                IC1F_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic2psc(&mut self) -> IC2PSC_W<10> {
                IC2PSC_W::new(self)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            #[must_use]
            pub fn ic2f(&mut self) -> IC2F_W<12> {
                IC2F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1i](index.html) module
        pub struct CHCTLR1I_SPEC;
        impl crate::RegisterSpec for CHCTLR1I_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr1i::R](R) reader structure
        impl crate::Readable for CHCTLR1I_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1i::W](W) writer structure
        impl crate::Writable for CHCTLR1I_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1I to value 0
        impl crate::Resettable for CHCTLR1I_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2O (rw) register accessor: an alias for `Reg<CHCTLR2O_SPEC>`
    pub type CHCTLR2O = crate::Reg<chctlr2o::CHCTLR2O_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr2o {
        ///Register `CHCTLR2O` reader
        pub struct R(crate::R<CHCTLR2O_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2O_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2O_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2O` writer
        pub struct W(crate::W<CHCTLR2O_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2O_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2O_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2O_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, CC3S_A>;
        ///Capture/Compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///0: CC3 configured as input
            Input = 0,
            ///1: CC3 configured as output. IC3 mapped to TI1
            OutputTi1 = 1,
            ///2: CC3 configured as output. IC3 mapped to TI2
            OutputTi2 = 2,
            ///3: CC3 configured as output. IC3 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        impl CC3S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC3S_A {
                match self.bits {
                    0 => CC3S_A::Input,
                    1 => CC3S_A::OutputTi1,
                    2 => CC3S_A::OutputTi2,
                    3 => CC3S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC3S_A::Input
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC3S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC3S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC3S_A::OutputTrc
            }
        }
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, CC3S_A, 2, O>;
        impl<'a, const O: u8> CC3S_W<'a, O> {
            ///CC3 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC3S_A::Input)
            }
            ///CC3 configured as output. IC3 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC3S_A::OutputTi1)
            }
            ///CC3 configured as output. IC3 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC3S_A::OutputTi2)
            }
            ///CC3 configured as output. IC3 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC3S_A::OutputTrc)
            }
        }
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub type OC3FE_R = crate::BitReader<OC3FE_A>;
        ///Output compare 3 fast enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC3FE_A {
            ///0: Fast enabling disabled
            Disabled = 0,
            ///1: Fast enabling enabled
            Enabled = 1,
        }
        impl From<OC3FE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3FE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC3FE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3FE_A {
                match self.bits {
                    false => OC3FE_A::Disabled,
                    true => OC3FE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3FE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3FE_A::Enabled
            }
        }
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub type OC3FE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR2O_SPEC, OC3FE_A, O>;
        impl<'a, const O: u8> OC3FE_W<'a, O> {
            ///Fast enabling disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3FE_A::Disabled)
            }
            ///Fast enabling enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3FE_A::Enabled)
            }
        }
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub type OC3PE_R = crate::BitReader<OC3PE_A>;
        ///Output compare 3 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC3PE_A {
            ///0: Preloading disabled
            Disabled = 0,
            ///1: Preloading enabled
            Enabled = 1,
        }
        impl From<OC3PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3PE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC3PE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3PE_A {
                match self.bits {
                    false => OC3PE_A::Disabled,
                    true => OC3PE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3PE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3PE_A::Enabled
            }
        }
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub type OC3PE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR2O_SPEC, OC3PE_A, O>;
        impl<'a, const O: u8> OC3PE_W<'a, O> {
            ///Preloading disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3PE_A::Disabled)
            }
            ///Preloading enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3PE_A::Enabled)
            }
        }
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = crate::FieldReader<u8, OC3M_A>;
        ///Output compare 3 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC3M_A {
            ///0: No effect on OC3REF
            Frozen = 0,
            ///1: OC3REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC3REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC3REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC3REF set low
            ForceLow = 4,
            ///5: OC3REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC3M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC3M_A) -> Self {
                variant as _
            }
        }
        impl OC3M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3M_A {
                match self.bits {
                    0 => OC3M_A::Frozen,
                    1 => OC3M_A::ForceHighCmp,
                    2 => OC3M_A::ForceLowCmp,
                    3 => OC3M_A::FlipCmp,
                    4 => OC3M_A::ForceLow,
                    5 => OC3M_A::ForceHigh,
                    6 => OC3M_A::Pwm1,
                    7 => OC3M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC3M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC3M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC3M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC3M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC3M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC3M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC3M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC3M_A::Pwm2
            }
        }
        ///Field `OC3M` writer - Output compare 3 mode
        pub type OC3M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, OC3M_A, 3, O>;
        impl<'a, const O: u8> OC3M_W<'a, O> {
            ///No effect on OC3REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC3M_A::Frozen)
            }
            ///OC3REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC3M_A::ForceHighCmp)
            }
            ///OC3REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC3M_A::ForceLowCmp)
            }
            ///OC3REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC3M_A::FlipCmp)
            }
            ///OC3REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC3M_A::ForceLow)
            }
            ///OC3REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC3M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC3M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC3M_A::Pwm2)
            }
        }
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub type OC3CE_R = crate::BitReader<OC3CE_A>;
        ///Output compare 3 clear enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OC3CE_A {
            ///0: OCxREF reset on ETRF disabled
            Disabled = 0,
            ///1: OCxREF reset on ETRF enabled
            Enabled = 1,
        }
        impl From<OC3CE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3CE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OC3CE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3CE_A {
                match self.bits {
                    false => OC3CE_A::Disabled,
                    true => OC3CE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == OC3CE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == OC3CE_A::Enabled
            }
        }
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub type OC3CE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CHCTLR2O_SPEC, OC3CE_A, O>;
        impl<'a, const O: u8> OC3CE_W<'a, O> {
            ///OCxREF reset on ETRF disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3CE_A::Disabled)
            }
            ///OCxREF reset on ETRF enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3CE_A::Enabled)
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, CC4S_A>;
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///0: CC4 configured as input
            Input = 0,
            ///1: CC4 configured as output. IC4 mapped to TI2
            OutputTi2 = 1,
            ///2: CC4 configured as output. IC4 mapped to TI1
            OutputTi1 = 2,
            ///3: CC4 configured as output. IC4 mapped to TRC
            OutputTrc = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        impl CC4S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC4S_A {
                match self.bits {
                    0 => CC4S_A::Input,
                    1 => CC4S_A::OutputTi2,
                    2 => CC4S_A::OutputTi1,
                    3 => CC4S_A::OutputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Input`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == CC4S_A::Input
            }
            ///Checks if the value of the field is `OutputTi2`
            #[inline(always)]
            pub fn is_output_ti2(&self) -> bool {
                *self == CC4S_A::OutputTi2
            }
            ///Checks if the value of the field is `OutputTi1`
            #[inline(always)]
            pub fn is_output_ti1(&self) -> bool {
                *self == CC4S_A::OutputTi1
            }
            ///Checks if the value of the field is `OutputTrc`
            #[inline(always)]
            pub fn is_output_trc(&self) -> bool {
                *self == CC4S_A::OutputTrc
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, CC4S_A, 2, O>;
        impl<'a, const O: u8> CC4S_W<'a, O> {
            ///CC4 configured as input
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(CC4S_A::Input)
            }
            ///CC4 configured as output. IC4 mapped to TI2
            #[inline(always)]
            pub fn output_ti2(self) -> &'a mut W {
                self.variant(CC4S_A::OutputTi2)
            }
            ///CC4 configured as output. IC4 mapped to TI1
            #[inline(always)]
            pub fn output_ti1(self) -> &'a mut W {
                self.variant(CC4S_A::OutputTi1)
            }
            ///CC4 configured as output. IC4 mapped to TRC
            #[inline(always)]
            pub fn output_trc(self) -> &'a mut W {
                self.variant(CC4S_A::OutputTrc)
            }
        }
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub use OC3FE_R as OC4FE_R;
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub use OC3FE_W as OC4FE_W;
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub use OC3PE_R as OC4PE_R;
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub use OC3PE_W as OC4PE_W;
        ///Field `OC4M` reader - Output compare 4 mode
        pub type OC4M_R = crate::FieldReader<u8, OC4M_A>;
        ///Output compare 4 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum OC4M_A {
            ///0: No effect on OC4REF
            Frozen = 0,
            ///1: OC4REF high when core counter = compare capture register
            ForceHighCmp = 1,
            ///2: OC4REF low when core counter = compare capture register
            ForceLowCmp = 2,
            ///3: OC4REF flipped when core counter = compare capture register
            FlipCmp = 3,
            ///4: OC4REF set low
            ForceLow = 4,
            ///5: OC4REF set high
            ForceHigh = 5,
            ///6: Before low after high
            Pwm1 = 6,
            ///7: Before high after low
            Pwm2 = 7,
        }
        impl From<OC4M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC4M_A) -> Self {
                variant as _
            }
        }
        impl OC4M_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC4M_A {
                match self.bits {
                    0 => OC4M_A::Frozen,
                    1 => OC4M_A::ForceHighCmp,
                    2 => OC4M_A::ForceLowCmp,
                    3 => OC4M_A::FlipCmp,
                    4 => OC4M_A::ForceLow,
                    5 => OC4M_A::ForceHigh,
                    6 => OC4M_A::Pwm1,
                    7 => OC4M_A::Pwm2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Frozen`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                *self == OC4M_A::Frozen
            }
            ///Checks if the value of the field is `ForceHighCmp`
            #[inline(always)]
            pub fn is_force_high_cmp(&self) -> bool {
                *self == OC4M_A::ForceHighCmp
            }
            ///Checks if the value of the field is `ForceLowCmp`
            #[inline(always)]
            pub fn is_force_low_cmp(&self) -> bool {
                *self == OC4M_A::ForceLowCmp
            }
            ///Checks if the value of the field is `FlipCmp`
            #[inline(always)]
            pub fn is_flip_cmp(&self) -> bool {
                *self == OC4M_A::FlipCmp
            }
            ///Checks if the value of the field is `ForceLow`
            #[inline(always)]
            pub fn is_force_low(&self) -> bool {
                *self == OC4M_A::ForceLow
            }
            ///Checks if the value of the field is `ForceHigh`
            #[inline(always)]
            pub fn is_force_high(&self) -> bool {
                *self == OC4M_A::ForceHigh
            }
            ///Checks if the value of the field is `Pwm1`
            #[inline(always)]
            pub fn is_pwm1(&self) -> bool {
                *self == OC4M_A::Pwm1
            }
            ///Checks if the value of the field is `Pwm2`
            #[inline(always)]
            pub fn is_pwm2(&self) -> bool {
                *self == OC4M_A::Pwm2
            }
        }
        ///Field `OC4M` writer - Output compare 4 mode
        pub type OC4M_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2O_SPEC, u8, OC4M_A, 3, O>;
        impl<'a, const O: u8> OC4M_W<'a, O> {
            ///No effect on OC4REF
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::Frozen)
            }
            ///OC4REF high when core counter = compare capture register
            #[inline(always)]
            pub fn force_high_cmp(self) -> &'a mut W {
                self.variant(OC4M_A::ForceHighCmp)
            }
            ///OC4REF low when core counter = compare capture register
            #[inline(always)]
            pub fn force_low_cmp(self) -> &'a mut W {
                self.variant(OC4M_A::ForceLowCmp)
            }
            ///OC4REF flipped when core counter = compare capture register
            #[inline(always)]
            pub fn flip_cmp(self) -> &'a mut W {
                self.variant(OC4M_A::FlipCmp)
            }
            ///OC4REF set low
            #[inline(always)]
            pub fn force_low(self) -> &'a mut W {
                self.variant(OC4M_A::ForceLow)
            }
            ///OC4REF set high
            #[inline(always)]
            pub fn force_high(self) -> &'a mut W {
                self.variant(OC4M_A::ForceHigh)
            }
            ///Before low after high
            #[inline(always)]
            pub fn pwm1(self) -> &'a mut W {
                self.variant(OC4M_A::Pwm1)
            }
            ///Before high after low
            #[inline(always)]
            pub fn pwm2(self) -> &'a mut W {
                self.variant(OC4M_A::Pwm2)
            }
        }
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub use OC3CE_R as OC4CE_R;
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub use OC3CE_W as OC4CE_W;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc3fe(&mut self) -> OC3FE_W<2> {
                OC3FE_W::new(self)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc3pe(&mut self) -> OC3PE_W<3> {
                OC3PE_W::new(self)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            #[must_use]
            pub fn oc3m(&mut self) -> OC3M_W<4> {
                OC3M_W::new(self)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc3ce(&mut self) -> OC3CE_W<7> {
                OC3CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc4fe(&mut self) -> OC4FE_W<10> {
                OC4FE_W::new(self)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc4pe(&mut self) -> OC4PE_W<11> {
                OC4PE_W::new(self)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            #[must_use]
            pub fn oc4m(&mut self) -> OC4M_W<12> {
                OC4M_W::new(self)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc4ce(&mut self) -> OC4CE_W<15> {
                OC4CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2o](index.html) module
        pub struct CHCTLR2O_SPEC;
        impl crate::RegisterSpec for CHCTLR2O_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr2o::R](R) reader structure
        impl crate::Readable for CHCTLR2O_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2o::W](W) writer structure
        impl crate::Writable for CHCTLR2O_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2O to value 0
        impl crate::Resettable for CHCTLR2O_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2I (rw) register accessor: an alias for `Reg<CHCTLR2I_SPEC>`
    pub type CHCTLR2I = crate::Reg<chctlr2i::CHCTLR2I_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod chctlr2i {
        ///Register `CHCTLR2I` reader
        pub struct R(crate::R<CHCTLR2I_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2I_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2I_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2I` writer
        pub struct W(crate::W<CHCTLR2I_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2I_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2I_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2I_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, CC3S_A>;
        ///Capture/compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///0: CC3 configured as output
            Output = 0,
            ///1: CC3 configured as input. IC3 mapped to TI1
            InputTi1 = 1,
            ///2: CC3 configured as input. IC3 mapped to TI2
            InputTi2 = 2,
            ///3: CC3 configured as input. IC3 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        impl CC3S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC3S_A {
                match self.bits {
                    0 => CC3S_A::Output,
                    1 => CC3S_A::InputTi1,
                    2 => CC3S_A::InputTi2,
                    3 => CC3S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC3S_A::Output
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC3S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC3S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC3S_A::InputTrc
            }
        }
        ///Field `CC3S` writer - Capture/compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, CC3S_A, 2, O>;
        impl<'a, const O: u8> CC3S_W<'a, O> {
            ///CC3 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3S_A::Output)
            }
            ///CC3 configured as input. IC3 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC3S_A::InputTi1)
            }
            ///CC3 configured as input. IC3 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC3S_A::InputTi2)
            }
            ///CC3 configured as input. IC3 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC3S_A::InputTrc)
            }
        }
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub type IC3PSC_R = crate::FieldReader<u8, IC3PSC_A>;
        ///Input capture 3 prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC3PSC_A {
            ///0: Every capture input edge will trigger a capture
            NoDiv = 0,
            ///1: Every 2 capture input edges will trigger a capture
            Div2 = 1,
            ///2: Every 4 capture input edges will trigger a capture
            Div4 = 2,
            ///3: Every 8 capture input edges will trigger a capture
            Div8 = 3,
        }
        impl From<IC3PSC_A> for u8 {
            #[inline(always)]
            fn from(variant: IC3PSC_A) -> Self {
                variant as _
            }
        }
        impl IC3PSC_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC3PSC_A {
                match self.bits {
                    0 => IC3PSC_A::NoDiv,
                    1 => IC3PSC_A::Div2,
                    2 => IC3PSC_A::Div4,
                    3 => IC3PSC_A::Div8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoDiv`
            #[inline(always)]
            pub fn is_no_div(&self) -> bool {
                *self == IC3PSC_A::NoDiv
            }
            ///Checks if the value of the field is `Div2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                *self == IC3PSC_A::Div2
            }
            ///Checks if the value of the field is `Div4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                *self == IC3PSC_A::Div4
            }
            ///Checks if the value of the field is `Div8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                *self == IC3PSC_A::Div8
            }
        }
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub type IC3PSC_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, IC3PSC_A, 2, O>;
        impl<'a, const O: u8> IC3PSC_W<'a, O> {
            ///Every capture input edge will trigger a capture
            #[inline(always)]
            pub fn no_div(self) -> &'a mut W {
                self.variant(IC3PSC_A::NoDiv)
            }
            ///Every 2 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(IC3PSC_A::Div2)
            }
            ///Every 4 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(IC3PSC_A::Div4)
            }
            ///Every 8 capture input edges will trigger a capture
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(IC3PSC_A::Div8)
            }
        }
        ///Field `IC3F` reader - Input capture 3 filter
        pub type IC3F_R = crate::FieldReader<u8, IC3F_A>;
        ///Input capture 3 filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IC3F_A {
            ///0: No filter applied. Sampling using Fdts
            NoFilter = 0,
            ///1: Fsampling = Fck_int, N=2
            FckN2 = 1,
            ///2: Fsampling = Fck_int, N=4
            FckN4 = 2,
            ///3: Fsampling = Fck_int, N=8
            FckN8 = 3,
            ///4: Fsampling = Fdts / 2, N=6
            Fdts2n6 = 4,
            ///5: Fsampling = Fdts / 2, N=8
            Fdts2n8 = 5,
            ///6: Fsampling = Fdts / 4, N=6
            Fdts4n6 = 6,
            ///7: Fsampling = Fdts / 4, N=8
            Fdts4n8 = 7,
            ///8: Fsampling = Fdts / 8, N=6
            Fdts8n6 = 8,
            ///9: Fsampling = Fdts / 8, N=8
            Fdts8n8 = 9,
            ///10: Fsampling = Fdts / 16, N=5
            Fdts16n5 = 10,
            ///11: Fsampling = Fdts / 16, N=6
            Fdts16n6 = 11,
            ///12: Fsampling = Fdts / 16, N=8
            Fdts16n8 = 12,
            ///13: Fsampling = Fdts / 32, N=5
            Fdts32n5 = 13,
            ///14: Fsampling = Fdts / 32, N=6
            Fdts32n6 = 14,
            ///15: Fsampling = Fdts / 32, N=8
            Fdts32n8 = 15,
        }
        impl From<IC3F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC3F_A) -> Self {
                variant as _
            }
        }
        impl IC3F_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC3F_A {
                match self.bits {
                    0 => IC3F_A::NoFilter,
                    1 => IC3F_A::FckN2,
                    2 => IC3F_A::FckN4,
                    3 => IC3F_A::FckN8,
                    4 => IC3F_A::Fdts2n6,
                    5 => IC3F_A::Fdts2n8,
                    6 => IC3F_A::Fdts4n6,
                    7 => IC3F_A::Fdts4n8,
                    8 => IC3F_A::Fdts8n6,
                    9 => IC3F_A::Fdts8n8,
                    10 => IC3F_A::Fdts16n5,
                    11 => IC3F_A::Fdts16n6,
                    12 => IC3F_A::Fdts16n8,
                    13 => IC3F_A::Fdts32n5,
                    14 => IC3F_A::Fdts32n6,
                    15 => IC3F_A::Fdts32n8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NoFilter`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                *self == IC3F_A::NoFilter
            }
            ///Checks if the value of the field is `FckN2`
            #[inline(always)]
            pub fn is_fck_n2(&self) -> bool {
                *self == IC3F_A::FckN2
            }
            ///Checks if the value of the field is `FckN4`
            #[inline(always)]
            pub fn is_fck_n4(&self) -> bool {
                *self == IC3F_A::FckN4
            }
            ///Checks if the value of the field is `FckN8`
            #[inline(always)]
            pub fn is_fck_n8(&self) -> bool {
                *self == IC3F_A::FckN8
            }
            ///Checks if the value of the field is `Fdts2n6`
            #[inline(always)]
            pub fn is_fdts2n6(&self) -> bool {
                *self == IC3F_A::Fdts2n6
            }
            ///Checks if the value of the field is `Fdts2n8`
            #[inline(always)]
            pub fn is_fdts2n8(&self) -> bool {
                *self == IC3F_A::Fdts2n8
            }
            ///Checks if the value of the field is `Fdts4n6`
            #[inline(always)]
            pub fn is_fdts4n6(&self) -> bool {
                *self == IC3F_A::Fdts4n6
            }
            ///Checks if the value of the field is `Fdts4n8`
            #[inline(always)]
            pub fn is_fdts4n8(&self) -> bool {
                *self == IC3F_A::Fdts4n8
            }
            ///Checks if the value of the field is `Fdts8n6`
            #[inline(always)]
            pub fn is_fdts8n6(&self) -> bool {
                *self == IC3F_A::Fdts8n6
            }
            ///Checks if the value of the field is `Fdts8n8`
            #[inline(always)]
            pub fn is_fdts8n8(&self) -> bool {
                *self == IC3F_A::Fdts8n8
            }
            ///Checks if the value of the field is `Fdts16n5`
            #[inline(always)]
            pub fn is_fdts16n5(&self) -> bool {
                *self == IC3F_A::Fdts16n5
            }
            ///Checks if the value of the field is `Fdts16n6`
            #[inline(always)]
            pub fn is_fdts16n6(&self) -> bool {
                *self == IC3F_A::Fdts16n6
            }
            ///Checks if the value of the field is `Fdts16n8`
            #[inline(always)]
            pub fn is_fdts16n8(&self) -> bool {
                *self == IC3F_A::Fdts16n8
            }
            ///Checks if the value of the field is `Fdts32n5`
            #[inline(always)]
            pub fn is_fdts32n5(&self) -> bool {
                *self == IC3F_A::Fdts32n5
            }
            ///Checks if the value of the field is `Fdts32n6`
            #[inline(always)]
            pub fn is_fdts32n6(&self) -> bool {
                *self == IC3F_A::Fdts32n6
            }
            ///Checks if the value of the field is `Fdts32n8`
            #[inline(always)]
            pub fn is_fdts32n8(&self) -> bool {
                *self == IC3F_A::Fdts32n8
            }
        }
        ///Field `IC3F` writer - Input capture 3 filter
        pub type IC3F_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, IC3F_A, 4, O>;
        impl<'a, const O: u8> IC3F_W<'a, O> {
            ///No filter applied. Sampling using Fdts
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC3F_A::NoFilter)
            }
            ///Fsampling = Fck_int, N=2
            #[inline(always)]
            pub fn fck_n2(self) -> &'a mut W {
                self.variant(IC3F_A::FckN2)
            }
            ///Fsampling = Fck_int, N=4
            #[inline(always)]
            pub fn fck_n4(self) -> &'a mut W {
                self.variant(IC3F_A::FckN4)
            }
            ///Fsampling = Fck_int, N=8
            #[inline(always)]
            pub fn fck_n8(self) -> &'a mut W {
                self.variant(IC3F_A::FckN8)
            }
            ///Fsampling = Fdts / 2, N=6
            #[inline(always)]
            pub fn fdts2n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts2n6)
            }
            ///Fsampling = Fdts / 2, N=8
            #[inline(always)]
            pub fn fdts2n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts2n8)
            }
            ///Fsampling = Fdts / 4, N=6
            #[inline(always)]
            pub fn fdts4n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts4n6)
            }
            ///Fsampling = Fdts / 4, N=8
            #[inline(always)]
            pub fn fdts4n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts4n8)
            }
            ///Fsampling = Fdts / 8, N=6
            #[inline(always)]
            pub fn fdts8n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts8n6)
            }
            ///Fsampling = Fdts / 8, N=8
            #[inline(always)]
            pub fn fdts8n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts8n8)
            }
            ///Fsampling = Fdts / 16, N=5
            #[inline(always)]
            pub fn fdts16n5(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts16n5)
            }
            ///Fsampling = Fdts / 16, N=6
            #[inline(always)]
            pub fn fdts16n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts16n6)
            }
            ///Fsampling = Fdts / 16, N=8
            #[inline(always)]
            pub fn fdts16n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts16n8)
            }
            ///Fsampling = Fdts / 32, N=5
            #[inline(always)]
            pub fn fdts32n5(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts32n5)
            }
            ///Fsampling = Fdts / 32, N=6
            #[inline(always)]
            pub fn fdts32n6(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts32n6)
            }
            ///Fsampling = Fdts / 32, N=8
            #[inline(always)]
            pub fn fdts32n8(self) -> &'a mut W {
                self.variant(IC3F_A::Fdts32n8)
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, CC4S_A>;
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///0: CC4 configured as output
            Output = 0,
            ///1: CC4 configured as input. IC4 mapped to TI2
            InputTi2 = 1,
            ///2: CC4 configured as input. IC4 mapped to TI1
            InputTi1 = 2,
            ///3: CC4 configured as input. IC4 mapped to TRC
            InputTrc = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        impl CC4S_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC4S_A {
                match self.bits {
                    0 => CC4S_A::Output,
                    1 => CC4S_A::InputTi2,
                    2 => CC4S_A::InputTi1,
                    3 => CC4S_A::InputTrc,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `Output`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == CC4S_A::Output
            }
            ///Checks if the value of the field is `InputTi2`
            #[inline(always)]
            pub fn is_input_ti2(&self) -> bool {
                *self == CC4S_A::InputTi2
            }
            ///Checks if the value of the field is `InputTi1`
            #[inline(always)]
            pub fn is_input_ti1(&self) -> bool {
                *self == CC4S_A::InputTi1
            }
            ///Checks if the value of the field is `InputTrc`
            #[inline(always)]
            pub fn is_input_trc(&self) -> bool {
                *self == CC4S_A::InputTrc
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u16, CHCTLR2I_SPEC, u8, CC4S_A, 2, O>;
        impl<'a, const O: u8> CC4S_W<'a, O> {
            ///CC4 configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4S_A::Output)
            }
            ///CC4 configured as input. IC4 mapped to TI2
            #[inline(always)]
            pub fn input_ti2(self) -> &'a mut W {
                self.variant(CC4S_A::InputTi2)
            }
            ///CC4 configured as input. IC4 mapped to TI1
            #[inline(always)]
            pub fn input_ti1(self) -> &'a mut W {
                self.variant(CC4S_A::InputTi1)
            }
            ///CC4 configured as input. IC4 mapped to TRC
            #[inline(always)]
            pub fn input_trc(self) -> &'a mut W {
                self.variant(CC4S_A::InputTrc)
            }
        }
        ///Field `IC4F` reader - Input capture 4 filter
        pub use IC3F_R as IC4F_R;
        ///Field `IC4F` writer - Input capture 4 filter
        pub use IC3F_W as IC4F_W;
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub use IC3PSC_R as IC4PSC_R;
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub use IC3PSC_W as IC4PSC_W;
        impl R {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic3psc(&mut self) -> IC3PSC_W<2> {
                IC3PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            #[must_use]
            pub fn ic3f(&mut self) -> IC3F_W<4> {
                IC3F_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic4psc(&mut self) -> IC4PSC_W<10> {
                IC4PSC_W::new(self)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            #[must_use]
            pub fn ic4f(&mut self) -> IC4F_W<12> {
                IC4F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2i](index.html) module
        pub struct CHCTLR2I_SPEC;
        impl crate::RegisterSpec for CHCTLR2I_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [chctlr2i::R](R) reader structure
        impl crate::Readable for CHCTLR2I_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2i::W](W) writer structure
        impl crate::Writable for CHCTLR2I_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2I to value 0
        impl crate::Resettable for CHCTLR2I_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CCER (rw) register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CCER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CCER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub type CC1E_R = crate::BitReader<bool>;
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub type CC1E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub type CC1P_R = crate::BitReader<bool>;
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub type CC1P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC1NE` reader - Capture/Compare 1 complementary output enable
        pub type CC1NE_R = crate::BitReader<bool>;
        ///Field `CC1NE` writer - Capture/Compare 1 complementary output enable
        pub type CC1NE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub type CC1NP_R = crate::BitReader<bool>;
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub type CC1NP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub type CC2E_R = crate::BitReader<bool>;
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub type CC2E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub type CC2P_R = crate::BitReader<bool>;
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub type CC2P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2NE` reader - Capture/Compare 2 complementary output enable
        pub type CC2NE_R = crate::BitReader<bool>;
        ///Field `CC2NE` writer - Capture/Compare 2 complementary output enable
        pub type CC2NE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC2NP` reader - Capture/Compare 2 output Polarity
        pub type CC2NP_R = crate::BitReader<bool>;
        ///Field `CC2NP` writer - Capture/Compare 2 output Polarity
        pub type CC2NP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub type CC3E_R = crate::BitReader<bool>;
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub type CC3E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub type CC3P_R = crate::BitReader<bool>;
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub type CC3P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3NE` reader - Capture/Compare 3 complementary output enable
        pub type CC3NE_R = crate::BitReader<bool>;
        ///Field `CC3NE` writer - Capture/Compare 3 complementary output enable
        pub type CC3NE_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC3NP` reader - Capture/Compare 3 output Polarity
        pub type CC3NP_R = crate::BitReader<bool>;
        ///Field `CC3NP` writer - Capture/Compare 3 output Polarity
        pub type CC3NP_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub type CC4E_R = crate::BitReader<bool>;
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub type CC4E_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub type CC4P_R = crate::BitReader<bool>;
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub type CC4P_W<'a, const O: u8> = crate::BitWriter<'a, u16, CCER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            pub fn cc2ne(&self) -> CC2NE_R {
                CC2NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            pub fn cc3ne(&self) -> CC3NE_R {
                CC3NE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3np(&self) -> CC3NP_R {
                CC3NP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1e(&mut self) -> CC1E_W<0> {
                CC1E_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1p(&mut self) -> CC1P_W<1> {
                CC1P_W::new(self)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ne(&mut self) -> CC1NE_W<2> {
                CC1NE_W::new(self)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1np(&mut self) -> CC1NP_W<3> {
                CC1NP_W::new(self)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2e(&mut self) -> CC2E_W<4> {
                CC2E_W::new(self)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2p(&mut self) -> CC2P_W<5> {
                CC2P_W::new(self)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ne(&mut self) -> CC2NE_W<6> {
                CC2NE_W::new(self)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2np(&mut self) -> CC2NP_W<7> {
                CC2NP_W::new(self)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3e(&mut self) -> CC3E_W<8> {
                CC3E_W::new(self)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3p(&mut self) -> CC3P_W<9> {
                CC3P_W::new(self)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ne(&mut self) -> CC3NE_W<10> {
                CC3NE_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3np(&mut self) -> CC3NP_W<11> {
                CC3NP_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc4e(&mut self) -> CC4E_W<12> {
                CC4E_W::new(self)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc4p(&mut self) -> CC4P_W<13> {
                CC4P_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub type CNT_R = crate::FieldReader<u16, u16>;
        ///Field `CNT` writer - counter value
        pub type CNT_W<'a, const O: u8> = crate::FieldWriter<'a, u16, CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            #[must_use]
            pub fn cnt(&mut self) -> CNT_W<0> {
                CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PSC (rw) register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PSC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u16, u16>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, const O: u8> = crate::FieldWriter<'a, u16, PSC_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<0> {
                PSC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ATRLR (rw) register accessor: an alias for `Reg<ATRLR_SPEC>`
    pub type ATRLR = crate::Reg<atrlr::ATRLR_SPEC>;
    ///auto-reload register
    pub mod atrlr {
        ///Register `ATRLR` reader
        pub struct R(crate::R<ATRLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ATRLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ATRLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ATRLR` writer
        pub struct W(crate::W<ATRLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ATRLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ATRLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub type ARR_R = crate::FieldReader<u16, u16>;
        ///Field `ARR` writer - Auto-reload value
        pub type ARR_W<'a, const O: u8> = crate::FieldWriter<'a, u16, ATRLR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            #[must_use]
            pub fn arr(&mut self) -> ARR_W<0> {
                ARR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [atrlr](index.html) module
        pub struct ATRLR_SPEC;
        impl crate::RegisterSpec for ATRLR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [atrlr::R](R) reader structure
        impl crate::Readable for ATRLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [atrlr::W](W) writer structure
        impl crate::Writable for ATRLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ATRLR to value 0
        impl crate::Resettable for ATRLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH1CVR (rw) register accessor: an alias for `Reg<CH1CVR_SPEC>`
    pub type CH1CVR = crate::Reg<ch1cvr::CH1CVR_SPEC>;
    ///capture/compare register 1
    pub mod ch1cvr {
        ///Register `CH1CVR` reader
        pub struct R(crate::R<CH1CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH1CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH1CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH1CVR` writer
        pub struct W(crate::W<CH1CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH1CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH1CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR1` reader - Capture/Compare 1 value
        pub type CCR1_R = crate::FieldReader<u16, u16>;
        ///Field `CCR1` writer - Capture/Compare 1 value
        pub type CCR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH1CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            #[must_use]
            pub fn ccr1(&mut self) -> CCR1_W<0> {
                CCR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch1cvr](index.html) module
        pub struct CH1CVR_SPEC;
        impl crate::RegisterSpec for CH1CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch1cvr::R](R) reader structure
        impl crate::Readable for CH1CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch1cvr::W](W) writer structure
        impl crate::Writable for CH1CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH1CVR to value 0
        impl crate::Resettable for CH1CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH2CVR (rw) register accessor: an alias for `Reg<CH2CVR_SPEC>`
    pub type CH2CVR = crate::Reg<ch2cvr::CH2CVR_SPEC>;
    ///capture/compare register 2
    pub mod ch2cvr {
        ///Register `CH2CVR` reader
        pub struct R(crate::R<CH2CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH2CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH2CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH2CVR` writer
        pub struct W(crate::W<CH2CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH2CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH2CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR2` reader - Capture/Compare 2 value
        pub type CCR2_R = crate::FieldReader<u16, u16>;
        ///Field `CCR2` writer - Capture/Compare 2 value
        pub type CCR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH2CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ccr2(&self) -> CCR2_R {
                CCR2_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            #[must_use]
            pub fn ccr2(&mut self) -> CCR2_W<0> {
                CCR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch2cvr](index.html) module
        pub struct CH2CVR_SPEC;
        impl crate::RegisterSpec for CH2CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch2cvr::R](R) reader structure
        impl crate::Readable for CH2CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch2cvr::W](W) writer structure
        impl crate::Writable for CH2CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH2CVR to value 0
        impl crate::Resettable for CH2CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH3CVR (rw) register accessor: an alias for `Reg<CH3CVR_SPEC>`
    pub type CH3CVR = crate::Reg<ch3cvr::CH3CVR_SPEC>;
    ///capture/compare register 3
    pub mod ch3cvr {
        ///Register `CH3CVR` reader
        pub struct R(crate::R<CH3CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH3CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH3CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH3CVR` writer
        pub struct W(crate::W<CH3CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH3CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH3CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR3` reader - Capture/Compare value
        pub type CCR3_R = crate::FieldReader<u16, u16>;
        ///Field `CCR3` writer - Capture/Compare value
        pub type CCR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH3CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr3(&self) -> CCR3_R {
                CCR3_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr3(&mut self) -> CCR3_W<0> {
                CCR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch3cvr](index.html) module
        pub struct CH3CVR_SPEC;
        impl crate::RegisterSpec for CH3CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch3cvr::R](R) reader structure
        impl crate::Readable for CH3CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch3cvr::W](W) writer structure
        impl crate::Writable for CH3CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH3CVR to value 0
        impl crate::Resettable for CH3CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH4CVR (rw) register accessor: an alias for `Reg<CH4CVR_SPEC>`
    pub type CH4CVR = crate::Reg<ch4cvr::CH4CVR_SPEC>;
    ///capture/compare register 4
    pub mod ch4cvr {
        ///Register `CH4CVR` reader
        pub struct R(crate::R<CH4CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH4CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH4CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH4CVR` writer
        pub struct W(crate::W<CH4CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH4CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH4CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR4` reader - Capture/Compare value
        pub type CCR4_R = crate::FieldReader<u16, u16>;
        ///Field `CCR4` writer - Capture/Compare value
        pub type CCR4_W<'a, const O: u8> =
            crate::FieldWriter<'a, u16, CH4CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ccr4(&self) -> CCR4_R {
                CCR4_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ccr4(&mut self) -> CCR4_W<0> {
                CCR4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch4cvr](index.html) module
        pub struct CH4CVR_SPEC;
        impl crate::RegisterSpec for CH4CVR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [ch4cvr::R](R) reader structure
        impl crate::Readable for CH4CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch4cvr::W](W) writer structure
        impl crate::Writable for CH4CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH4CVR to value 0
        impl crate::Resettable for CH4CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMACFGR (rw) register accessor: an alias for `Reg<DMACFGR_SPEC>`
    pub type DMACFGR = crate::Reg<dmacfgr::DMACFGR_SPEC>;
    ///DMA control register
    pub mod dmacfgr {
        ///Register `DMACFGR` reader
        pub struct R(crate::R<DMACFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMACFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMACFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMACFGR` writer
        pub struct W(crate::W<DMACFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMACFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMACFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBA` reader - DMA base address
        pub type DBA_R = crate::FieldReader<u8, u8>;
        ///Field `DBA` writer - DMA base address
        pub type DBA_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DMACFGR_SPEC, u8, u8, 5, O>;
        ///Field `DBL` reader - DMA burst length
        pub type DBL_R = crate::FieldReader<u8, u8>;
        ///Field `DBL` writer - DMA burst length
        pub type DBL_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DMACFGR_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            #[must_use]
            pub fn dba(&mut self) -> DBA_W<0> {
                DBA_W::new(self)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            #[must_use]
            pub fn dbl(&mut self) -> DBL_W<8> {
                DBL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmacfgr](index.html) module
        pub struct DMACFGR_SPEC;
        impl crate::RegisterSpec for DMACFGR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dmacfgr::R](R) reader structure
        impl crate::Readable for DMACFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmacfgr::W](W) writer structure
        impl crate::Writable for DMACFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMACFGR to value 0
        impl crate::Resettable for DMACFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAR (rw) register accessor: an alias for `Reg<DMAR_SPEC>`
    pub type DMAR = crate::Reg<dmar::DMAR_SPEC>;
    ///DMA address for full transfer
    pub mod dmar {
        ///Register `DMAR` reader
        pub struct R(crate::R<DMAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAR` writer
        pub struct W(crate::W<DMAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAB` reader - DMA register for burst accesses
        pub type DMAB_R = crate::FieldReader<u16, u16>;
        ///Field `DMAB` writer - DMA register for burst accesses
        pub type DMAB_W<'a, const O: u8> = crate::FieldWriter<'a, u16, DMAR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            #[must_use]
            pub fn dmab(&mut self) -> DMAB_W<0> {
                DMAB_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmar](index.html) module
        pub struct DMAR_SPEC;
        impl crate::RegisterSpec for DMAR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [dmar::R](R) reader structure
        impl crate::Readable for DMAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmar::W](W) writer structure
        impl crate::Writable for DMAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAR to value 0
        impl crate::Resettable for DMAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RPTCR (rw) register accessor: an alias for `Reg<RPTCR_SPEC>`
    pub type RPTCR = crate::Reg<rptcr::RPTCR_SPEC>;
    ///repetition counter register
    pub mod rptcr {
        ///Register `RPTCR` reader
        pub struct R(crate::R<RPTCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RPTCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RPTCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RPTCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RPTCR` writer
        pub struct W(crate::W<RPTCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RPTCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RPTCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RPTCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `REP` reader - Repetition counter value
        pub type REP_R = crate::FieldReader<u8, u8>;
        ///Field `REP` writer - Repetition counter value
        pub type REP_W<'a, const O: u8> = crate::FieldWriter<'a, u16, RPTCR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            #[must_use]
            pub fn rep(&mut self) -> REP_W<0> {
                REP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///repetition counter register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rptcr](index.html) module
        pub struct RPTCR_SPEC;
        impl crate::RegisterSpec for RPTCR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [rptcr::R](R) reader structure
        impl crate::Readable for RPTCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rptcr::W](W) writer structure
        impl crate::Writable for RPTCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RPTCR to value 0
        impl crate::Resettable for RPTCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BDTR (rw) register accessor: an alias for `Reg<BDTR_SPEC>`
    pub type BDTR = crate::Reg<bdtr::BDTR_SPEC>;
    ///break and dead-time register
    pub mod bdtr {
        ///Register `BDTR` reader
        pub struct R(crate::R<BDTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BDTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BDTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDTR` writer
        pub struct W(crate::W<BDTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BDTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BDTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DTG` reader - Dead-time generator setup
        pub type DTG_R = crate::FieldReader<u8, u8>;
        ///Field `DTG` writer - Dead-time generator setup
        pub type DTG_W<'a, const O: u8> = crate::FieldWriter<'a, u16, BDTR_SPEC, u8, u8, 8, O>;
        ///Field `LOCK` reader - Lock configuration
        pub type LOCK_R = crate::FieldReader<u8, u8>;
        ///Field `LOCK` writer - Lock configuration
        pub type LOCK_W<'a, const O: u8> = crate::FieldWriter<'a, u16, BDTR_SPEC, u8, u8, 2, O>;
        ///Field `OSSI` reader - Off-state selection for Idle mode
        pub type OSSI_R = crate::BitReader<bool>;
        ///Field `OSSI` writer - Off-state selection for Idle mode
        pub type OSSI_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, bool, O>;
        ///Field `OSSR` reader - Off-state selection for Run mode
        pub type OSSR_R = crate::BitReader<bool>;
        ///Field `OSSR` writer - Off-state selection for Run mode
        pub type OSSR_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, bool, O>;
        ///Field `BKE` reader - Break enable
        pub type BKE_R = crate::BitReader<bool>;
        ///Field `BKE` writer - Break enable
        pub type BKE_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, bool, O>;
        ///Field `BKP` reader - Break polarity
        pub type BKP_R = crate::BitReader<bool>;
        ///Field `BKP` writer - Break polarity
        pub type BKP_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, bool, O>;
        ///Field `AOE` reader - Automatic output enable
        pub type AOE_R = crate::BitReader<bool>;
        ///Field `AOE` writer - Automatic output enable
        pub type AOE_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, bool, O>;
        ///Field `MOE` reader - Main output enable
        pub type MOE_R = crate::BitReader<bool>;
        ///Field `MOE` writer - Main output enable
        pub type MOE_W<'a, const O: u8> = crate::BitWriter<'a, u16, BDTR_SPEC, bool, O>;
        impl R {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            #[must_use]
            pub fn dtg(&mut self) -> DTG_W<0> {
                DTG_W::new(self)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            #[must_use]
            pub fn lock(&mut self) -> LOCK_W<8> {
                LOCK_W::new(self)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            #[must_use]
            pub fn ossi(&mut self) -> OSSI_W<10> {
                OSSI_W::new(self)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            #[must_use]
            pub fn ossr(&mut self) -> OSSR_W<11> {
                OSSR_W::new(self)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            #[must_use]
            pub fn bke(&mut self) -> BKE_W<12> {
                BKE_W::new(self)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            #[must_use]
            pub fn bkp(&mut self) -> BKP_W<13> {
                BKP_W::new(self)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            #[must_use]
            pub fn aoe(&mut self) -> AOE_W<14> {
                AOE_W::new(self)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            #[must_use]
            pub fn moe(&mut self) -> MOE_W<15> {
                MOE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///break and dead-time register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdtr](index.html) module
        pub struct BDTR_SPEC;
        impl crate::RegisterSpec for BDTR_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [bdtr::R](R) reader structure
        impl crate::Readable for BDTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdtr::W](W) writer structure
        impl crate::Writable for BDTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BDTR to value 0
        impl crate::Resettable for BDTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///System Tick Peripheral
pub struct SYSTICK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSTICK {}
impl SYSTICK {
    ///Pointer to the register block
    pub const PTR: *const systick::RegisterBlock = 0xe000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const systick::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSTICK {
    type Target = systick::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSTICK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSTICK").finish()
    }
}
///System Tick Peripheral
pub mod systick {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - SysTick Control register
        pub ctlr: CTLR,
        ///0x04 - SysTick counter low bits
        pub cntl: CNTL,
        ///0x08 - SysTick counter high bits
        pub cnth: CNTH,
        ///0x0c - SysTick compare low bits
        pub cmplr: CMPLR,
        ///0x10 - SysTick compare high bits
        pub cmphr: CMPHR,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///SysTick Control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `STE` reader - SysTick enable state
        pub type STE_R = crate::BitReader<STE_A>;
        ///SysTick enable state
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STE_A {
            ///0: SysTick counter disabled
            Disabled = 0,
            ///1: SysTick counter enabled
            Enabled = 1,
        }
        impl From<STE_A> for bool {
            #[inline(always)]
            fn from(variant: STE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STE_A {
                match self.bits {
                    false => STE_A::Disabled,
                    true => STE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == STE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == STE_A::Enabled
            }
        }
        ///Field `STE` writer - SysTick enable state
        pub type STE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, STE_A, O>;
        impl<'a, const O: u8> STE_W<'a, O> {
            ///SysTick counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(STE_A::Disabled)
            }
            ///SysTick counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(STE_A::Enabled)
            }
        }
        impl R {
            ///Bit 0 - SysTick enable state
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - SysTick enable state
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<0> {
                STE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick Control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTL (rw) register accessor: an alias for `Reg<CNTL_SPEC>`
    pub type CNTL = crate::Reg<cntl::CNTL_SPEC>;
    ///SysTick counter low bits
    pub mod cntl {
        ///Register `CNTL` reader
        pub struct R(crate::R<CNTL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTL` writer
        pub struct W(crate::W<CNTL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - SysTick counter low bits
        pub type CNTL_R = crate::FieldReader<u32, u32>;
        ///Field `CNTL` writer - SysTick counter low bits
        pub type CNTL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTL_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - SysTick counter low bits
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - SysTick counter low bits
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick counter low bits
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntl](index.html) module
        pub struct CNTL_SPEC;
        impl crate::RegisterSpec for CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntl::R](R) reader structure
        impl crate::Readable for CNTL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntl::W](W) writer structure
        impl crate::Writable for CNTL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTL to value 0
        impl crate::Resettable for CNTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTH (rw) register accessor: an alias for `Reg<CNTH_SPEC>`
    pub type CNTH = crate::Reg<cnth::CNTH_SPEC>;
    ///SysTick counter high bits
    pub mod cnth {
        ///Register `CNTH` reader
        pub struct R(crate::R<CNTH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTH` writer
        pub struct W(crate::W<CNTH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - SysTick counter high bits
        pub type CNTL_R = crate::FieldReader<u32, u32>;
        ///Field `CNTL` writer - SysTick counter high bits
        pub type CNTL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTH_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - SysTick counter high bits
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - SysTick counter high bits
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick counter high bits
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnth](index.html) module
        pub struct CNTH_SPEC;
        impl crate::RegisterSpec for CNTH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnth::R](R) reader structure
        impl crate::Readable for CNTH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnth::W](W) writer structure
        impl crate::Writable for CNTH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTH to value 0
        impl crate::Resettable for CNTH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CMPLR (rw) register accessor: an alias for `Reg<CMPLR_SPEC>`
    pub type CMPLR = crate::Reg<cmplr::CMPLR_SPEC>;
    ///SysTick compare low bits
    pub mod cmplr {
        ///Register `CMPLR` reader
        pub struct R(crate::R<CMPLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CMPLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CMPLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CMPLR` writer
        pub struct W(crate::W<CMPLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CMPLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CMPLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - SysTick compare low bits
        pub type CNTL_R = crate::FieldReader<u32, u32>;
        ///Field `CNTL` writer - SysTick compare low bits
        pub type CNTL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CMPLR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - SysTick compare low bits
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - SysTick compare low bits
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick compare low bits
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cmplr](index.html) module
        pub struct CMPLR_SPEC;
        impl crate::RegisterSpec for CMPLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cmplr::R](R) reader structure
        impl crate::Readable for CMPLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cmplr::W](W) writer structure
        impl crate::Writable for CMPLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CMPLR to value 0
        impl crate::Resettable for CMPLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CMPHR (rw) register accessor: an alias for `Reg<CMPHR_SPEC>`
    pub type CMPHR = crate::Reg<cmphr::CMPHR_SPEC>;
    ///SysTick compare high bits
    pub mod cmphr {
        ///Register `CMPHR` reader
        pub struct R(crate::R<CMPHR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CMPHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CMPHR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CMPHR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CMPHR` writer
        pub struct W(crate::W<CMPHR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CMPHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CMPHR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CMPHR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - SysTick compare high bits
        pub type CNTL_R = crate::FieldReader<u32, u32>;
        ///Field `CNTL` writer - SysTick compare high bits
        pub type CNTL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CMPHR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - SysTick compare high bits
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - SysTick compare high bits
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick compare high bits
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cmphr](index.html) module
        pub struct CMPHR_SPEC;
        impl crate::RegisterSpec for CMPHR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cmphr::R](R) reader structure
        impl crate::Readable for CMPHR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cmphr::W](W) writer structure
        impl crate::Writable for CMPHR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CMPHR to value 0
        impl crate::Resettable for CMPHR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Touch Key Peripheral
pub struct TKEY {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TKEY {}
impl TKEY {
    ///Pointer to the register block
    pub const PTR: *const tkey::RegisterBlock = 0x4001_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tkey::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TKEY {
    type Target = tkey::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TKEY {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TKEY").finish()
    }
}
///Touch Key Peripheral
pub mod tkey {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x04],
        ///0x04 - TKEY_V control register
        pub vctlr: VCTLR,
        _reserved1: [u8; 0x04],
        ///0x0c - TKEY_F charge control register
        pub fcharge1: FCHARGE1,
        ///0x10 - TKEY_F charge control register
        pub fcharge2: FCHARGE2,
        _reserved3: [u8; 0x20],
        ///0x34 - TKEY_V channel register
        pub vchannel: VCHANNEL,
        _reserved4: [u8; 0x04],
        ///0x3c - TKEY_F charge control register
        pub fdischarge: FDISCHARGE,
        _reserved5: [u8; 0x0c],
        _reserved_5_fdr: [u8; 0x04],
    }
    impl RegisterBlock {
        ///0x4c - TKEY_V state data register
        #[inline(always)]
        pub const fn vsdr(&self) -> &VSDR {
            unsafe { &*(self as *const Self).cast::<u8>().add(76usize).cast() }
        }
        ///0x4c - TKEY_F data register
        #[inline(always)]
        pub const fn fdr(&self) -> &FDR {
            unsafe { &*(self as *const Self).cast::<u8>().add(76usize).cast() }
        }
        ///0x4c - TKEY_F act register
        #[inline(always)]
        pub const fn fact(&self) -> &FACT {
            unsafe { &*(self as *const Self).cast::<u8>().add(76usize).cast() }
        }
    }
    ///FCHARGE1 (rw) register accessor: an alias for `Reg<FCHARGE1_SPEC>`
    pub type FCHARGE1 = crate::Reg<fcharge1::FCHARGE1_SPEC>;
    ///TKEY_F charge control register
    pub mod fcharge1 {
        ///Register `FCHARGE1` reader
        pub struct R(crate::R<FCHARGE1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FCHARGE1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FCHARGE1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FCHARGE1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FCHARGE1` writer
        pub struct W(crate::W<FCHARGE1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FCHARGE1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FCHARGE1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FCHARGE1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKCG10` reader - Touch key configuration channel 10
        pub type TKCG10_R = crate::FieldReader<u8, TKCG10_A>;
        ///Touch key configuration channel 10
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TKCG10_A {
            ///0: 1.5T sampling rate
            T1p5 = 0,
            ///1: 7.5T sampling rate
            T7p5 = 1,
            ///2: 13.5T sampling rate
            T13p5 = 2,
            ///3: 28.5T sampling rate
            T28p5 = 3,
            ///4: 41.5T sampling rate
            T41p5 = 4,
            ///5: 55.5T sampling rate
            T55p5 = 5,
            ///6: 71.5T sampling rate
            T71p5 = 6,
            ///7: 239.5T sampling rate
            T239p5 = 7,
        }
        impl From<TKCG10_A> for u8 {
            #[inline(always)]
            fn from(variant: TKCG10_A) -> Self {
                variant as _
            }
        }
        impl TKCG10_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKCG10_A {
                match self.bits {
                    0 => TKCG10_A::T1p5,
                    1 => TKCG10_A::T7p5,
                    2 => TKCG10_A::T13p5,
                    3 => TKCG10_A::T28p5,
                    4 => TKCG10_A::T41p5,
                    5 => TKCG10_A::T55p5,
                    6 => TKCG10_A::T71p5,
                    7 => TKCG10_A::T239p5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `T1p5`
            #[inline(always)]
            pub fn is_t1p5(&self) -> bool {
                *self == TKCG10_A::T1p5
            }
            ///Checks if the value of the field is `T7p5`
            #[inline(always)]
            pub fn is_t7p5(&self) -> bool {
                *self == TKCG10_A::T7p5
            }
            ///Checks if the value of the field is `T13p5`
            #[inline(always)]
            pub fn is_t13p5(&self) -> bool {
                *self == TKCG10_A::T13p5
            }
            ///Checks if the value of the field is `T28p5`
            #[inline(always)]
            pub fn is_t28p5(&self) -> bool {
                *self == TKCG10_A::T28p5
            }
            ///Checks if the value of the field is `T41p5`
            #[inline(always)]
            pub fn is_t41p5(&self) -> bool {
                *self == TKCG10_A::T41p5
            }
            ///Checks if the value of the field is `T55p5`
            #[inline(always)]
            pub fn is_t55p5(&self) -> bool {
                *self == TKCG10_A::T55p5
            }
            ///Checks if the value of the field is `T71p5`
            #[inline(always)]
            pub fn is_t71p5(&self) -> bool {
                *self == TKCG10_A::T71p5
            }
            ///Checks if the value of the field is `T239p5`
            #[inline(always)]
            pub fn is_t239p5(&self) -> bool {
                *self == TKCG10_A::T239p5
            }
        }
        ///Field `TKCG10` writer - Touch key configuration channel 10
        pub type TKCG10_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, FCHARGE1_SPEC, u8, TKCG10_A, 3, O>;
        impl<'a, const O: u8> TKCG10_W<'a, O> {
            ///1.5T sampling rate
            #[inline(always)]
            pub fn t1p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T1p5)
            }
            ///7.5T sampling rate
            #[inline(always)]
            pub fn t7p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T7p5)
            }
            ///13.5T sampling rate
            #[inline(always)]
            pub fn t13p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T13p5)
            }
            ///28.5T sampling rate
            #[inline(always)]
            pub fn t28p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T28p5)
            }
            ///41.5T sampling rate
            #[inline(always)]
            pub fn t41p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T41p5)
            }
            ///55.5T sampling rate
            #[inline(always)]
            pub fn t55p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T55p5)
            }
            ///71.5T sampling rate
            #[inline(always)]
            pub fn t71p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T71p5)
            }
            ///239.5T sampling rate
            #[inline(always)]
            pub fn t239p5(self) -> &'a mut W {
                self.variant(TKCG10_A::T239p5)
            }
        }
        ///Field `TKCG11` reader - Touch key configuration channel 11
        pub use TKCG10_R as TKCG11_R;
        ///Field `TKCG12` reader - Touch key configuration channel 12
        pub use TKCG10_R as TKCG12_R;
        ///Field `TKCG13` reader - Touch key configuration channel 13
        pub use TKCG10_R as TKCG13_R;
        ///Field `TKCG14` reader - Touch key configuration channel 14
        pub use TKCG10_R as TKCG14_R;
        ///Field `TKCG15` reader - Touch key configuration channel 15
        pub use TKCG10_R as TKCG15_R;
        ///Field `TKCG16` reader - Touch key configuration channel 16
        pub use TKCG10_R as TKCG16_R;
        ///Field `TKCG17` reader - Touch key configuration channel 17
        pub use TKCG10_R as TKCG17_R;
        ///Field `TKCG11` writer - Touch key configuration channel 11
        pub use TKCG10_W as TKCG11_W;
        ///Field `TKCG12` writer - Touch key configuration channel 12
        pub use TKCG10_W as TKCG12_W;
        ///Field `TKCG13` writer - Touch key configuration channel 13
        pub use TKCG10_W as TKCG13_W;
        ///Field `TKCG14` writer - Touch key configuration channel 14
        pub use TKCG10_W as TKCG14_W;
        ///Field `TKCG15` writer - Touch key configuration channel 15
        pub use TKCG10_W as TKCG15_W;
        ///Field `TKCG16` writer - Touch key configuration channel 16
        pub use TKCG10_W as TKCG16_W;
        ///Field `TKCG17` writer - Touch key configuration channel 17
        pub use TKCG10_W as TKCG17_W;
        impl R {
            ///Bits 0:2 - Touch key configuration channel 10
            #[inline(always)]
            pub fn tkcg10(&self) -> TKCG10_R {
                TKCG10_R::new((self.bits & 7) as u8)
            }
            ///Bits 3:5 - Touch key configuration channel 11
            #[inline(always)]
            pub fn tkcg11(&self) -> TKCG11_R {
                TKCG11_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:8 - Touch key configuration channel 12
            #[inline(always)]
            pub fn tkcg12(&self) -> TKCG12_R {
                TKCG12_R::new(((self.bits >> 6) & 7) as u8)
            }
            ///Bits 9:11 - Touch key configuration channel 13
            #[inline(always)]
            pub fn tkcg13(&self) -> TKCG13_R {
                TKCG13_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bits 12:14 - Touch key configuration channel 14
            #[inline(always)]
            pub fn tkcg14(&self) -> TKCG14_R {
                TKCG14_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bits 15:17 - Touch key configuration channel 15
            #[inline(always)]
            pub fn tkcg15(&self) -> TKCG15_R {
                TKCG15_R::new(((self.bits >> 15) & 7) as u8)
            }
            ///Bits 18:20 - Touch key configuration channel 16
            #[inline(always)]
            pub fn tkcg16(&self) -> TKCG16_R {
                TKCG16_R::new(((self.bits >> 18) & 7) as u8)
            }
            ///Bits 21:23 - Touch key configuration channel 17
            #[inline(always)]
            pub fn tkcg17(&self) -> TKCG17_R {
                TKCG17_R::new(((self.bits >> 21) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Touch key configuration channel 10
            #[inline(always)]
            #[must_use]
            pub fn tkcg10(&mut self) -> TKCG10_W<0> {
                TKCG10_W::new(self)
            }
            ///Bits 3:5 - Touch key configuration channel 11
            #[inline(always)]
            #[must_use]
            pub fn tkcg11(&mut self) -> TKCG11_W<3> {
                TKCG11_W::new(self)
            }
            ///Bits 6:8 - Touch key configuration channel 12
            #[inline(always)]
            #[must_use]
            pub fn tkcg12(&mut self) -> TKCG12_W<6> {
                TKCG12_W::new(self)
            }
            ///Bits 9:11 - Touch key configuration channel 13
            #[inline(always)]
            #[must_use]
            pub fn tkcg13(&mut self) -> TKCG13_W<9> {
                TKCG13_W::new(self)
            }
            ///Bits 12:14 - Touch key configuration channel 14
            #[inline(always)]
            #[must_use]
            pub fn tkcg14(&mut self) -> TKCG14_W<12> {
                TKCG14_W::new(self)
            }
            ///Bits 15:17 - Touch key configuration channel 15
            #[inline(always)]
            #[must_use]
            pub fn tkcg15(&mut self) -> TKCG15_W<15> {
                TKCG15_W::new(self)
            }
            ///Bits 18:20 - Touch key configuration channel 16
            #[inline(always)]
            #[must_use]
            pub fn tkcg16(&mut self) -> TKCG16_W<18> {
                TKCG16_W::new(self)
            }
            ///Bits 21:23 - Touch key configuration channel 17
            #[inline(always)]
            #[must_use]
            pub fn tkcg17(&mut self) -> TKCG17_W<21> {
                TKCG17_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///TKEY_F charge control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fcharge1](index.html) module
        pub struct FCHARGE1_SPEC;
        impl crate::RegisterSpec for FCHARGE1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fcharge1::R](R) reader structure
        impl crate::Readable for FCHARGE1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fcharge1::W](W) writer structure
        impl crate::Writable for FCHARGE1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FCHARGE1 to value 0
        impl crate::Resettable for FCHARGE1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FCHARGE2 (rw) register accessor: an alias for `Reg<FCHARGE2_SPEC>`
    pub type FCHARGE2 = crate::Reg<fcharge2::FCHARGE2_SPEC>;
    ///TKEY_F charge control register
    pub mod fcharge2 {
        ///Register `FCHARGE2` reader
        pub struct R(crate::R<FCHARGE2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FCHARGE2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FCHARGE2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FCHARGE2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FCHARGE2` writer
        pub struct W(crate::W<FCHARGE2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FCHARGE2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FCHARGE2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FCHARGE2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKCG0` reader - Touch key configuration channel 0
        pub type TKCG0_R = crate::FieldReader<u8, TKCG0_A>;
        ///Touch key configuration channel 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TKCG0_A {
            ///0: 1.5T sampling rate
            T1p5 = 0,
            ///1: 7.5T sampling rate
            T7p5 = 1,
            ///2: 13.5T sampling rate
            T13p5 = 2,
            ///3: 28.5T sampling rate
            T28p5 = 3,
            ///4: 41.5T sampling rate
            T41p5 = 4,
            ///5: 55.5T sampling rate
            T55p5 = 5,
            ///6: 71.5T sampling rate
            T71p5 = 6,
            ///7: 239.5T sampling rate
            T239p5 = 7,
        }
        impl From<TKCG0_A> for u8 {
            #[inline(always)]
            fn from(variant: TKCG0_A) -> Self {
                variant as _
            }
        }
        impl TKCG0_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKCG0_A {
                match self.bits {
                    0 => TKCG0_A::T1p5,
                    1 => TKCG0_A::T7p5,
                    2 => TKCG0_A::T13p5,
                    3 => TKCG0_A::T28p5,
                    4 => TKCG0_A::T41p5,
                    5 => TKCG0_A::T55p5,
                    6 => TKCG0_A::T71p5,
                    7 => TKCG0_A::T239p5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `T1p5`
            #[inline(always)]
            pub fn is_t1p5(&self) -> bool {
                *self == TKCG0_A::T1p5
            }
            ///Checks if the value of the field is `T7p5`
            #[inline(always)]
            pub fn is_t7p5(&self) -> bool {
                *self == TKCG0_A::T7p5
            }
            ///Checks if the value of the field is `T13p5`
            #[inline(always)]
            pub fn is_t13p5(&self) -> bool {
                *self == TKCG0_A::T13p5
            }
            ///Checks if the value of the field is `T28p5`
            #[inline(always)]
            pub fn is_t28p5(&self) -> bool {
                *self == TKCG0_A::T28p5
            }
            ///Checks if the value of the field is `T41p5`
            #[inline(always)]
            pub fn is_t41p5(&self) -> bool {
                *self == TKCG0_A::T41p5
            }
            ///Checks if the value of the field is `T55p5`
            #[inline(always)]
            pub fn is_t55p5(&self) -> bool {
                *self == TKCG0_A::T55p5
            }
            ///Checks if the value of the field is `T71p5`
            #[inline(always)]
            pub fn is_t71p5(&self) -> bool {
                *self == TKCG0_A::T71p5
            }
            ///Checks if the value of the field is `T239p5`
            #[inline(always)]
            pub fn is_t239p5(&self) -> bool {
                *self == TKCG0_A::T239p5
            }
        }
        ///Field `TKCG0` writer - Touch key configuration channel 0
        pub type TKCG0_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, FCHARGE2_SPEC, u8, TKCG0_A, 3, O>;
        impl<'a, const O: u8> TKCG0_W<'a, O> {
            ///1.5T sampling rate
            #[inline(always)]
            pub fn t1p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T1p5)
            }
            ///7.5T sampling rate
            #[inline(always)]
            pub fn t7p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T7p5)
            }
            ///13.5T sampling rate
            #[inline(always)]
            pub fn t13p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T13p5)
            }
            ///28.5T sampling rate
            #[inline(always)]
            pub fn t28p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T28p5)
            }
            ///41.5T sampling rate
            #[inline(always)]
            pub fn t41p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T41p5)
            }
            ///55.5T sampling rate
            #[inline(always)]
            pub fn t55p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T55p5)
            }
            ///71.5T sampling rate
            #[inline(always)]
            pub fn t71p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T71p5)
            }
            ///239.5T sampling rate
            #[inline(always)]
            pub fn t239p5(self) -> &'a mut W {
                self.variant(TKCG0_A::T239p5)
            }
        }
        ///Field `TKCG1` reader - Touch key configuration channel 1
        pub use TKCG0_R as TKCG1_R;
        ///Field `TKCG2` reader - Touch key configuration channel 2
        pub use TKCG0_R as TKCG2_R;
        ///Field `TKCG3` reader - Touch key configuration channel 3
        pub use TKCG0_R as TKCG3_R;
        ///Field `TKCG4` reader - Touch key configuration channel 4
        pub use TKCG0_R as TKCG4_R;
        ///Field `TKCG5` reader - Touch key configuration channel 5
        pub use TKCG0_R as TKCG5_R;
        ///Field `TKCG6` reader - Touch key configuration channel 6
        pub use TKCG0_R as TKCG6_R;
        ///Field `TKCG7` reader - Touch key configuration channel 7
        pub use TKCG0_R as TKCG7_R;
        ///Field `TKCG8` reader - Touch key configuration channel 8
        pub use TKCG0_R as TKCG8_R;
        ///Field `TKCG9` reader - Touch key configuration channel 9
        pub use TKCG0_R as TKCG9_R;
        ///Field `TKCG1` writer - Touch key configuration channel 1
        pub use TKCG0_W as TKCG1_W;
        ///Field `TKCG2` writer - Touch key configuration channel 2
        pub use TKCG0_W as TKCG2_W;
        ///Field `TKCG3` writer - Touch key configuration channel 3
        pub use TKCG0_W as TKCG3_W;
        ///Field `TKCG4` writer - Touch key configuration channel 4
        pub use TKCG0_W as TKCG4_W;
        ///Field `TKCG5` writer - Touch key configuration channel 5
        pub use TKCG0_W as TKCG5_W;
        ///Field `TKCG6` writer - Touch key configuration channel 6
        pub use TKCG0_W as TKCG6_W;
        ///Field `TKCG7` writer - Touch key configuration channel 7
        pub use TKCG0_W as TKCG7_W;
        ///Field `TKCG8` writer - Touch key configuration channel 8
        pub use TKCG0_W as TKCG8_W;
        ///Field `TKCG9` writer - Touch key configuration channel 9
        pub use TKCG0_W as TKCG9_W;
        impl R {
            ///Bits 0:2 - Touch key configuration channel 0
            #[inline(always)]
            pub fn tkcg0(&self) -> TKCG0_R {
                TKCG0_R::new((self.bits & 7) as u8)
            }
            ///Bits 3:5 - Touch key configuration channel 1
            #[inline(always)]
            pub fn tkcg1(&self) -> TKCG1_R {
                TKCG1_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:8 - Touch key configuration channel 2
            #[inline(always)]
            pub fn tkcg2(&self) -> TKCG2_R {
                TKCG2_R::new(((self.bits >> 6) & 7) as u8)
            }
            ///Bits 9:11 - Touch key configuration channel 3
            #[inline(always)]
            pub fn tkcg3(&self) -> TKCG3_R {
                TKCG3_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bits 12:14 - Touch key configuration channel 4
            #[inline(always)]
            pub fn tkcg4(&self) -> TKCG4_R {
                TKCG4_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bits 15:17 - Touch key configuration channel 5
            #[inline(always)]
            pub fn tkcg5(&self) -> TKCG5_R {
                TKCG5_R::new(((self.bits >> 15) & 7) as u8)
            }
            ///Bits 18:20 - Touch key configuration channel 6
            #[inline(always)]
            pub fn tkcg6(&self) -> TKCG6_R {
                TKCG6_R::new(((self.bits >> 18) & 7) as u8)
            }
            ///Bits 21:23 - Touch key configuration channel 7
            #[inline(always)]
            pub fn tkcg7(&self) -> TKCG7_R {
                TKCG7_R::new(((self.bits >> 21) & 7) as u8)
            }
            ///Bits 24:26 - Touch key configuration channel 8
            #[inline(always)]
            pub fn tkcg8(&self) -> TKCG8_R {
                TKCG8_R::new(((self.bits >> 24) & 7) as u8)
            }
            ///Bits 27:29 - Touch key configuration channel 9
            #[inline(always)]
            pub fn tkcg9(&self) -> TKCG9_R {
                TKCG9_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Touch key configuration channel 0
            #[inline(always)]
            #[must_use]
            pub fn tkcg0(&mut self) -> TKCG0_W<0> {
                TKCG0_W::new(self)
            }
            ///Bits 3:5 - Touch key configuration channel 1
            #[inline(always)]
            #[must_use]
            pub fn tkcg1(&mut self) -> TKCG1_W<3> {
                TKCG1_W::new(self)
            }
            ///Bits 6:8 - Touch key configuration channel 2
            #[inline(always)]
            #[must_use]
            pub fn tkcg2(&mut self) -> TKCG2_W<6> {
                TKCG2_W::new(self)
            }
            ///Bits 9:11 - Touch key configuration channel 3
            #[inline(always)]
            #[must_use]
            pub fn tkcg3(&mut self) -> TKCG3_W<9> {
                TKCG3_W::new(self)
            }
            ///Bits 12:14 - Touch key configuration channel 4
            #[inline(always)]
            #[must_use]
            pub fn tkcg4(&mut self) -> TKCG4_W<12> {
                TKCG4_W::new(self)
            }
            ///Bits 15:17 - Touch key configuration channel 5
            #[inline(always)]
            #[must_use]
            pub fn tkcg5(&mut self) -> TKCG5_W<15> {
                TKCG5_W::new(self)
            }
            ///Bits 18:20 - Touch key configuration channel 6
            #[inline(always)]
            #[must_use]
            pub fn tkcg6(&mut self) -> TKCG6_W<18> {
                TKCG6_W::new(self)
            }
            ///Bits 21:23 - Touch key configuration channel 7
            #[inline(always)]
            #[must_use]
            pub fn tkcg7(&mut self) -> TKCG7_W<21> {
                TKCG7_W::new(self)
            }
            ///Bits 24:26 - Touch key configuration channel 8
            #[inline(always)]
            #[must_use]
            pub fn tkcg8(&mut self) -> TKCG8_W<24> {
                TKCG8_W::new(self)
            }
            ///Bits 27:29 - Touch key configuration channel 9
            #[inline(always)]
            #[must_use]
            pub fn tkcg9(&mut self) -> TKCG9_W<27> {
                TKCG9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///TKEY_F charge control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fcharge2](index.html) module
        pub struct FCHARGE2_SPEC;
        impl crate::RegisterSpec for FCHARGE2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fcharge2::R](R) reader structure
        impl crate::Readable for FCHARGE2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [fcharge2::W](W) writer structure
        impl crate::Writable for FCHARGE2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FCHARGE2 to value 0
        impl crate::Resettable for FCHARGE2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FDISCHARGE (w) register accessor: an alias for `Reg<FDISCHARGE_SPEC>`
    pub type FDISCHARGE = crate::Reg<fdischarge::FDISCHARGE_SPEC>;
    ///TKEY_F charge control register
    pub mod fdischarge {
        ///Register `FDISCHARGE` writer
        pub struct W(crate::W<FDISCHARGE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FDISCHARGE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FDISCHARGE_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FDISCHARGE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKDCRGT` writer - TKEY_F discharge time
        pub type TKDCRGT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FDISCHARGE_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - TKEY_F discharge time
            #[inline(always)]
            #[must_use]
            pub fn tkdcrgt(&mut self) -> TKDCRGT_W<0> {
                TKDCRGT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///TKEY_F charge control register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fdischarge](index.html) module
        pub struct FDISCHARGE_SPEC;
        impl crate::RegisterSpec for FDISCHARGE_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [fdischarge::W](W) writer structure
        impl crate::Writable for FDISCHARGE_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FDISCHARGE to value 0
        impl crate::Resettable for FDISCHARGE_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FACT (w) register accessor: an alias for `Reg<FACT_SPEC>`
    pub type FACT = crate::Reg<fact::FACT_SPEC>;
    ///TKEY_F act register
    pub mod fact {
        ///Register `FACT` writer
        pub struct W(crate::W<FACT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FACT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FACT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FACT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///TKEY_F action
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum TKACTW_AW {
            ///0: Start TKEY_F channel detection
            Launch = 0,
        }
        impl From<TKACTW_AW> for u8 {
            #[inline(always)]
            fn from(variant: TKACTW_AW) -> Self {
                variant as _
            }
        }
        ///Field `TKACT` writer - TKEY_F action
        pub type TKACT_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, FACT_SPEC, u8, TKACTW_AW, 8, O>;
        impl<'a, const O: u8> TKACT_W<'a, O> {
            ///Start TKEY_F channel detection
            #[inline(always)]
            pub fn launch(self) -> &'a mut W {
                self.variant(TKACTW_AW::Launch)
            }
        }
        impl W {
            ///Bits 0:7 - TKEY_F action
            #[inline(always)]
            #[must_use]
            pub fn tkact(&mut self) -> TKACT_W<0> {
                TKACT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///TKEY_F act register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fact](index.html) module
        pub struct FACT_SPEC;
        impl crate::RegisterSpec for FACT_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [fact::W](W) writer structure
        impl crate::Writable for FACT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FACT to value 0
        impl crate::Resettable for FACT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FDR (r) register accessor: an alias for `Reg<FDR_SPEC>`
    pub type FDR = crate::Reg<fdr::FDR_SPEC>;
    ///TKEY_F data register
    pub mod fdr {
        ///Register `FDR` reader
        pub struct R(crate::R<FDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DATA` reader - Converted data
        pub type DATA_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - Converted data
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        ///TKEY_F data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [fdr](index.html) module
        pub struct FDR_SPEC;
        impl crate::RegisterSpec for FDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [fdr::R](R) reader structure
        impl crate::Readable for FDR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets FDR to value 0
        impl crate::Resettable for FDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VCTLR (rw) register accessor: an alias for `Reg<VCTLR_SPEC>`
    pub type VCTLR = crate::Reg<vctlr::VCTLR_SPEC>;
    ///TKEY_V control register
    pub mod vctlr {
        ///Register `VCTLR` reader
        pub struct R(crate::R<VCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VCTLR` writer
        pub struct W(crate::W<VCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<VCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<VCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TKENABLE` reader - TKEY module enable state
        pub type TKENABLE_R = crate::BitReader<TKENABLE_A>;
        ///TKEY module enable state
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TKENABLE_A {
            ///0: TKEY module disabled
            Disabled = 0,
            ///1: TKEY module enabled
            Enabled = 1,
        }
        impl From<TKENABLE_A> for bool {
            #[inline(always)]
            fn from(variant: TKENABLE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TKENABLE_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKENABLE_A {
                match self.bits {
                    false => TKENABLE_A::Disabled,
                    true => TKENABLE_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TKENABLE_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TKENABLE_A::Enabled
            }
        }
        ///Field `TKENABLE` writer - TKEY module enable state
        pub type TKENABLE_W<'a, const O: u8> = crate::BitWriter<'a, u32, VCTLR_SPEC, TKENABLE_A, O>;
        impl<'a, const O: u8> TKENABLE_W<'a, O> {
            ///TKEY module disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TKENABLE_A::Disabled)
            }
            ///TKEY module enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TKENABLE_A::Enabled)
            }
        }
        ///Field `TKIEN` reader - TKEY counting complete interrupt enable state
        pub type TKIEN_R = crate::BitReader<TKIEN_A>;
        ///TKEY counting complete interrupt enable state
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TKIEN_A {
            ///0: TKEY_V interrupt disabled
            Disabled = 0,
            ///1: TKEY_V interrupt enabled
            Enabled = 1,
        }
        impl From<TKIEN_A> for bool {
            #[inline(always)]
            fn from(variant: TKIEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TKIEN_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKIEN_A {
                match self.bits {
                    false => TKIEN_A::Disabled,
                    true => TKIEN_A::Enabled,
                }
            }
            ///Checks if the value of the field is `Disabled`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == TKIEN_A::Disabled
            }
            ///Checks if the value of the field is `Enabled`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == TKIEN_A::Enabled
            }
        }
        ///Field `TKIEN` writer - TKEY counting complete interrupt enable state
        pub type TKIEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, VCTLR_SPEC, TKIEN_A, O>;
        impl<'a, const O: u8> TKIEN_W<'a, O> {
            ///TKEY_V interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TKIEN_A::Disabled)
            }
            ///TKEY_V interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TKIEN_A::Enabled)
            }
        }
        ///Field `TKCPS` reader - TKEY counting period selection
        pub type TKCPS_R = crate::BitReader<TKCPS_A>;
        ///TKEY counting period selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TKCPS_A {
            ///0: Counting conversion period 500us
            T500us = 0,
            ///1: Counting conversion period 1ms
            T1ms = 1,
        }
        impl From<TKCPS_A> for bool {
            #[inline(always)]
            fn from(variant: TKCPS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TKCPS_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKCPS_A {
                match self.bits {
                    false => TKCPS_A::T500us,
                    true => TKCPS_A::T1ms,
                }
            }
            ///Checks if the value of the field is `T500us`
            #[inline(always)]
            pub fn is_t500us(&self) -> bool {
                *self == TKCPS_A::T500us
            }
            ///Checks if the value of the field is `T1ms`
            #[inline(always)]
            pub fn is_t1ms(&self) -> bool {
                *self == TKCPS_A::T1ms
            }
        }
        ///Field `TKCPS` writer - TKEY counting period selection
        pub type TKCPS_W<'a, const O: u8> = crate::BitWriter<'a, u32, VCTLR_SPEC, TKCPS_A, O>;
        impl<'a, const O: u8> TKCPS_W<'a, O> {
            ///Counting conversion period 500us
            #[inline(always)]
            pub fn t500us(self) -> &'a mut W {
                self.variant(TKCPS_A::T500us)
            }
            ///Counting conversion period 1ms
            #[inline(always)]
            pub fn t1ms(self) -> &'a mut W {
                self.variant(TKCPS_A::T1ms)
            }
        }
        ///Field `TKIF` reader - TKEY counting complete flag
        pub type TKIF_R = crate::BitReader<TKIFR_A>;
        ///TKEY counting complete flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TKIFR_A {
            ///0: TKEY_V counting in progress
            InProgress = 0,
            ///1: TKEY_V counting done
            Done = 1,
        }
        impl From<TKIFR_A> for bool {
            #[inline(always)]
            fn from(variant: TKIFR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TKIF_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKIFR_A {
                match self.bits {
                    false => TKIFR_A::InProgress,
                    true => TKIFR_A::Done,
                }
            }
            ///Checks if the value of the field is `InProgress`
            #[inline(always)]
            pub fn is_in_progress(&self) -> bool {
                *self == TKIFR_A::InProgress
            }
            ///Checks if the value of the field is `Done`
            #[inline(always)]
            pub fn is_done(&self) -> bool {
                *self == TKIFR_A::Done
            }
        }
        ///TKEY counting complete flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TKIFW_AW {
            ///1: Clear this flag
            Clear = 1,
        }
        impl From<TKIFW_AW> for bool {
            #[inline(always)]
            fn from(variant: TKIFW_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TKIF` writer - TKEY counting complete flag
        pub type TKIF_W<'a, const O: u8> = crate::BitWriter1C<'a, u32, VCTLR_SPEC, TKIFW_AW, O>;
        impl<'a, const O: u8> TKIF_W<'a, O> {
            ///Clear this flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TKIFW_AW::Clear)
            }
        }
        ///Field `CCSEL` reader - TKEY_V counting period base frequency
        pub type CCSEL_R = crate::FieldReader<u8, CCSEL_A>;
        ///TKEY_V counting period base frequency
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CCSEL_A {
            ///0: TKEY_V counting period base frequency 8MHz
            T8mhz = 0,
            ///1: TKEY_V counting period base frequency 12MHz
            T12mhz = 1,
            ///2: TKEY_V counting period base frequency 24MHz
            T24mhz = 2,
            ///3: TKEY_V counting period base frequency 36MHz
            T36mhz = 3,
            ///4: TKEY_V counting period base frequency 48MHz
            T48mhz = 4,
            ///5: TKEY_V counting period base frequency 56MHz
            T56mhz = 5,
        }
        impl From<CCSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: CCSEL_A) -> Self {
                variant as _
            }
        }
        impl CCSEL_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CCSEL_A> {
                match self.bits {
                    0 => Some(CCSEL_A::T8mhz),
                    1 => Some(CCSEL_A::T12mhz),
                    2 => Some(CCSEL_A::T24mhz),
                    3 => Some(CCSEL_A::T36mhz),
                    4 => Some(CCSEL_A::T48mhz),
                    5 => Some(CCSEL_A::T56mhz),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `T8mhz`
            #[inline(always)]
            pub fn is_t8mhz(&self) -> bool {
                *self == CCSEL_A::T8mhz
            }
            ///Checks if the value of the field is `T12mhz`
            #[inline(always)]
            pub fn is_t12mhz(&self) -> bool {
                *self == CCSEL_A::T12mhz
            }
            ///Checks if the value of the field is `T24mhz`
            #[inline(always)]
            pub fn is_t24mhz(&self) -> bool {
                *self == CCSEL_A::T24mhz
            }
            ///Checks if the value of the field is `T36mhz`
            #[inline(always)]
            pub fn is_t36mhz(&self) -> bool {
                *self == CCSEL_A::T36mhz
            }
            ///Checks if the value of the field is `T48mhz`
            #[inline(always)]
            pub fn is_t48mhz(&self) -> bool {
                *self == CCSEL_A::T48mhz
            }
            ///Checks if the value of the field is `T56mhz`
            #[inline(always)]
            pub fn is_t56mhz(&self) -> bool {
                *self == CCSEL_A::T56mhz
            }
        }
        ///Field `CCSEL` writer - TKEY_V counting period base frequency
        pub type CCSEL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, VCTLR_SPEC, u8, CCSEL_A, 3, O>;
        impl<'a, const O: u8> CCSEL_W<'a, O> {
            ///TKEY_V counting period base frequency 8MHz
            #[inline(always)]
            pub fn t8mhz(self) -> &'a mut W {
                self.variant(CCSEL_A::T8mhz)
            }
            ///TKEY_V counting period base frequency 12MHz
            #[inline(always)]
            pub fn t12mhz(self) -> &'a mut W {
                self.variant(CCSEL_A::T12mhz)
            }
            ///TKEY_V counting period base frequency 24MHz
            #[inline(always)]
            pub fn t24mhz(self) -> &'a mut W {
                self.variant(CCSEL_A::T24mhz)
            }
            ///TKEY_V counting period base frequency 36MHz
            #[inline(always)]
            pub fn t36mhz(self) -> &'a mut W {
                self.variant(CCSEL_A::T36mhz)
            }
            ///TKEY_V counting period base frequency 48MHz
            #[inline(always)]
            pub fn t48mhz(self) -> &'a mut W {
                self.variant(CCSEL_A::T48mhz)
            }
            ///TKEY_V counting period base frequency 56MHz
            #[inline(always)]
            pub fn t56mhz(self) -> &'a mut W {
                self.variant(CCSEL_A::T56mhz)
            }
        }
        impl R {
            ///Bit 24 - TKEY module enable state
            #[inline(always)]
            pub fn tkenable(&self) -> TKENABLE_R {
                TKENABLE_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - TKEY counting complete interrupt enable state
            #[inline(always)]
            pub fn tkien(&self) -> TKIEN_R {
                TKIEN_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - TKEY counting period selection
            #[inline(always)]
            pub fn tkcps(&self) -> TKCPS_R {
                TKCPS_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - TKEY counting complete flag
            #[inline(always)]
            pub fn tkif(&self) -> TKIF_R {
                TKIF_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bits 28:30 - TKEY_V counting period base frequency
            #[inline(always)]
            pub fn ccsel(&self) -> CCSEL_R {
                CCSEL_R::new(((self.bits >> 28) & 7) as u8)
            }
        }
        impl W {
            ///Bit 24 - TKEY module enable state
            #[inline(always)]
            #[must_use]
            pub fn tkenable(&mut self) -> TKENABLE_W<24> {
                TKENABLE_W::new(self)
            }
            ///Bit 25 - TKEY counting complete interrupt enable state
            #[inline(always)]
            #[must_use]
            pub fn tkien(&mut self) -> TKIEN_W<25> {
                TKIEN_W::new(self)
            }
            ///Bit 26 - TKEY counting period selection
            #[inline(always)]
            #[must_use]
            pub fn tkcps(&mut self) -> TKCPS_W<26> {
                TKCPS_W::new(self)
            }
            ///Bit 27 - TKEY counting complete flag
            #[inline(always)]
            #[must_use]
            pub fn tkif(&mut self) -> TKIF_W<27> {
                TKIF_W::new(self)
            }
            ///Bits 28:30 - TKEY_V counting period base frequency
            #[inline(always)]
            #[must_use]
            pub fn ccsel(&mut self) -> CCSEL_W<28> {
                CCSEL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///TKEY_V control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vctlr](index.html) module
        pub struct VCTLR_SPEC;
        impl crate::RegisterSpec for VCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vctlr::R](R) reader structure
        impl crate::Readable for VCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [vctlr::W](W) writer structure
        impl crate::Writable for VCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0x0800_0000;
        }
        ///`reset()` method sets VCTLR to value 0
        impl crate::Resettable for VCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VCHANNEL (rw) register accessor: an alias for `Reg<VCHANNEL_SPEC>`
    pub type VCHANNEL = crate::Reg<vchannel::VCHANNEL_SPEC>;
    ///TKEY_V channel register
    pub mod vchannel {
        ///Register `VCHANNEL` reader
        pub struct R(crate::R<VCHANNEL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VCHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VCHANNEL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VCHANNEL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VCHANNEL` writer
        pub struct W(crate::W<VCHANNEL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VCHANNEL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<VCHANNEL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<VCHANNEL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CHSEL` reader - TKEY_V channel selection
        pub type CHSEL_R = crate::FieldReader<u8, u8>;
        ///Field `CHSEL` writer - TKEY_V channel selection
        pub type CHSEL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, VCHANNEL_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - TKEY_V channel selection
            #[inline(always)]
            pub fn chsel(&self) -> CHSEL_R {
                CHSEL_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - TKEY_V channel selection
            #[inline(always)]
            #[must_use]
            pub fn chsel(&mut self) -> CHSEL_W<0> {
                CHSEL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///TKEY_V channel register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vchannel](index.html) module
        pub struct VCHANNEL_SPEC;
        impl crate::RegisterSpec for VCHANNEL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vchannel::R](R) reader structure
        impl crate::Readable for VCHANNEL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [vchannel::W](W) writer structure
        impl crate::Writable for VCHANNEL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets VCHANNEL to value 0
        impl crate::Resettable for VCHANNEL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VSDR (r) register accessor: an alias for `Reg<VSDR_SPEC>`
    pub type VSDR = crate::Reg<vsdr::VSDR_SPEC>;
    ///TKEY_V state data register
    pub mod vsdr {
        ///Register `VSDR` reader
        pub struct R(crate::R<VSDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VSDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VSDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VSDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TKDR` reader - TKEY_V counting conversion value
        pub type TKDR_R = crate::FieldReader<u16, u16>;
        ///Field `TKSTA` reader - TKEY_V operation state
        pub type TKSTA_R = crate::BitReader<TKSTAR_A>;
        ///TKEY_V operation state
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TKSTAR_A {
            ///0: Counting paused, TKDR availabe
            Paused = 0,
            ///1: Counting in progress, TKDR unavailabe
            InProgress = 1,
        }
        impl From<TKSTAR_A> for bool {
            #[inline(always)]
            fn from(variant: TKSTAR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TKSTA_R {
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TKSTAR_A {
                match self.bits {
                    false => TKSTAR_A::Paused,
                    true => TKSTAR_A::InProgress,
                }
            }
            ///Checks if the value of the field is `Paused`
            #[inline(always)]
            pub fn is_paused(&self) -> bool {
                *self == TKSTAR_A::Paused
            }
            ///Checks if the value of the field is `InProgress`
            #[inline(always)]
            pub fn is_in_progress(&self) -> bool {
                *self == TKSTAR_A::InProgress
            }
        }
        impl R {
            ///Bits 0:13 - TKEY_V counting conversion value
            #[inline(always)]
            pub fn tkdr(&self) -> TKDR_R {
                TKDR_R::new((self.bits & 0x3fff) as u16)
            }
            ///Bit 15 - TKEY_V operation state
            #[inline(always)]
            pub fn tksta(&self) -> TKSTA_R {
                TKSTA_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        ///TKEY_V state data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vsdr](index.html) module
        pub struct VSDR_SPEC;
        impl crate::RegisterSpec for VSDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vsdr::R](R) reader structure
        impl crate::Readable for VSDR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets VSDR to value 0x8000
        impl crate::Resettable for VSDR_SPEC {
            const RESET_VALUE: Self::Ux = 0x8000;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///PWR
    pub PWR: PWR,
    ///RCC
    pub RCC: RCC,
    ///EXTEND
    pub EXTEND: EXTEND,
    ///GPIOA
    pub GPIOA: GPIOA,
    ///GPIOB
    pub GPIOB: GPIOB,
    ///GPIOC
    pub GPIOC: GPIOC,
    ///GPIOD
    pub GPIOD: GPIOD,
    ///AFIO
    pub AFIO: AFIO,
    ///EXTI
    pub EXTI: EXTI,
    ///DMA
    pub DMA: DMA,
    ///RTC
    pub RTC: RTC,
    ///BKP
    pub BKP: BKP,
    ///IWDG
    pub IWDG: IWDG,
    ///WWDG
    pub WWDG: WWDG,
    ///TIM1
    pub TIM1: TIM1,
    ///TIM3
    pub TIM3: TIM3,
    ///TIM4
    pub TIM4: TIM4,
    ///I2C1
    pub I2C1: I2C1,
    ///I2C2
    pub I2C2: I2C2,
    ///SPI1
    pub SPI1: SPI1,
    ///SPI2
    pub SPI2: SPI2,
    ///USART1
    pub USART1: USART1,
    ///USART2
    pub USART2: USART2,
    ///USART3
    pub USART3: USART3,
    ///ADC
    pub ADC: ADC,
    ///DAC1
    pub DAC1: DAC1,
    ///DBG
    pub DBG: DBG,
    ///USBHD
    pub USBHD: USBHD,
    ///CRC
    pub CRC: CRC,
    ///FLASH
    pub FLASH: FLASH,
    ///PFIC
    pub PFIC: PFIC,
    ///USBD
    pub USBD: USBD,
    ///TIM2
    pub TIM2: TIM2,
    ///SYSTICK
    pub SYSTICK: SYSTICK,
    ///TKEY
    pub TKEY: TKEY,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PWR: PWR {
                _marker: PhantomData,
            },
            RCC: RCC {
                _marker: PhantomData,
            },
            EXTEND: EXTEND {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            AFIO: AFIO {
                _marker: PhantomData,
            },
            EXTI: EXTI {
                _marker: PhantomData,
            },
            DMA: DMA {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            BKP: BKP {
                _marker: PhantomData,
            },
            IWDG: IWDG {
                _marker: PhantomData,
            },
            WWDG: WWDG {
                _marker: PhantomData,
            },
            TIM1: TIM1 {
                _marker: PhantomData,
            },
            TIM3: TIM3 {
                _marker: PhantomData,
            },
            TIM4: TIM4 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            USART1: USART1 {
                _marker: PhantomData,
            },
            USART2: USART2 {
                _marker: PhantomData,
            },
            USART3: USART3 {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            DAC1: DAC1 {
                _marker: PhantomData,
            },
            DBG: DBG {
                _marker: PhantomData,
            },
            USBHD: USBHD {
                _marker: PhantomData,
            },
            CRC: CRC {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
            USBD: USBD {
                _marker: PhantomData,
            },
            TIM2: TIM2 {
                _marker: PhantomData,
            },
            SYSTICK: SYSTICK {
                _marker: PhantomData,
            },
            TKEY: TKEY {
                _marker: PhantomData,
            },
        }
    }
}
