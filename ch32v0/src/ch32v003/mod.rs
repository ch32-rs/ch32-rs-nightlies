//!Peripheral access API for CH32V00XXX microcontrollers (generated using svd2rust v0.28.0 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
use core::marker::PhantomData;
use core::ops::Deref;
#[cfg(feature = "rt")]
extern "C" {
    fn WWDG();
    fn PVD();
    fn FLASH();
    fn RCC();
    fn EXTI7_0();
    fn AWU();
    fn DMA1_CHANNEL1();
    fn DMA1_CHANNEL2();
    fn DMA1_CHANNEL3();
    fn DMA1_CHANNEL4();
    fn DMA1_CHANNEL5();
    fn DMA1_CHANNEL6();
    fn DMA1_CHANNEL7();
    fn ADC();
    fn I2C1_EV();
    fn I2C1_ER();
    fn USART1();
    fn SPI1();
    fn TIM1_BRK();
    fn TIM1_UP();
    fn TIM1_TRG_COM();
    fn TIM1_CC();
    fn TIM2();
}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 39] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: WWDG },
    Vector { _handler: PVD },
    Vector { _handler: FLASH },
    Vector { _handler: RCC },
    Vector { _handler: EXTI7_0 },
    Vector { _handler: AWU },
    Vector {
        _handler: DMA1_CHANNEL1,
    },
    Vector {
        _handler: DMA1_CHANNEL2,
    },
    Vector {
        _handler: DMA1_CHANNEL3,
    },
    Vector {
        _handler: DMA1_CHANNEL4,
    },
    Vector {
        _handler: DMA1_CHANNEL5,
    },
    Vector {
        _handler: DMA1_CHANNEL6,
    },
    Vector {
        _handler: DMA1_CHANNEL7,
    },
    Vector { _handler: ADC },
    Vector { _handler: I2C1_EV },
    Vector { _handler: I2C1_ER },
    Vector { _handler: USART1 },
    Vector { _handler: SPI1 },
    Vector { _handler: TIM1_BRK },
    Vector { _handler: TIM1_UP },
    Vector {
        _handler: TIM1_TRG_COM,
    },
    Vector { _handler: TIM1_CC },
    Vector { _handler: TIM2 },
];
#[doc(hidden)]
pub mod interrupt {
    ///Enumeration of all the interrupts.
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        ///16 - Window Watchdog interrupt
        WWDG = 16,
        ///17 - PVD through EXTI line detection interrupt
        PVD = 17,
        ///18 - Flash global interrupt
        FLASH = 18,
        ///19 - RCC global interrupt
        RCC = 19,
        ///20 - EXTI Line\[7:0\]
        ///interrupt
        EXTI7_0 = 20,
        ///21 - AWU global interrupt
        AWU = 21,
        ///22 - DMA1 Channel1 global interrupt
        DMA1_CHANNEL1 = 22,
        ///23 - DMA1 Channel2 global interrupt
        DMA1_CHANNEL2 = 23,
        ///24 - DMA1 Channel3 global interrupt
        DMA1_CHANNEL3 = 24,
        ///25 - DMA1 Channel4 global interrupt
        DMA1_CHANNEL4 = 25,
        ///26 - DMA1 Channel5 global interrupt
        DMA1_CHANNEL5 = 26,
        ///27 - DMA1 Channel6 global interrupt
        DMA1_CHANNEL6 = 27,
        ///28 - DMA1 Channel7 global interrupt
        DMA1_CHANNEL7 = 28,
        ///29 - ADC global interrupt
        ADC = 29,
        ///30 - I2C1 event interrupt
        I2C1_EV = 30,
        ///31 - I2C1 error interrupt
        I2C1_ER = 31,
        ///32 - USART1 global interrupt
        USART1 = 32,
        ///33 - SPI1 global interrupt
        SPI1 = 33,
        ///34 - TIM1 Break interrupt
        TIM1_BRK = 34,
        ///35 - TIM1 Update interrupt
        TIM1_UP = 35,
        ///36 - TIM1 Trigger and Commutation interrupts
        TIM1_TRG_COM = 36,
        ///37 - TIM1 Capture Compare interrupt
        TIM1_CC = 37,
        ///38 - TIM2 global interrupt
        TIM2 = 38,
    }
    /// TryFromInterruptError
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        /// Attempt to convert a given value into an `Interrupt`
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                16 => Ok(Interrupt::WWDG),
                17 => Ok(Interrupt::PVD),
                18 => Ok(Interrupt::FLASH),
                19 => Ok(Interrupt::RCC),
                20 => Ok(Interrupt::EXTI7_0),
                21 => Ok(Interrupt::AWU),
                22 => Ok(Interrupt::DMA1_CHANNEL1),
                23 => Ok(Interrupt::DMA1_CHANNEL2),
                24 => Ok(Interrupt::DMA1_CHANNEL3),
                25 => Ok(Interrupt::DMA1_CHANNEL4),
                26 => Ok(Interrupt::DMA1_CHANNEL5),
                27 => Ok(Interrupt::DMA1_CHANNEL6),
                28 => Ok(Interrupt::DMA1_CHANNEL7),
                29 => Ok(Interrupt::ADC),
                30 => Ok(Interrupt::I2C1_EV),
                31 => Ok(Interrupt::I2C1_ER),
                32 => Ok(Interrupt::USART1),
                33 => Ok(Interrupt::SPI1),
                34 => Ok(Interrupt::TIM1_BRK),
                35 => Ok(Interrupt::TIM1_UP),
                36 => Ok(Interrupt::TIM1_TRG_COM),
                37 => Ok(Interrupt::TIM1_CC),
                38 => Ok(Interrupt::TIM2),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    /// Assigns a handler to an interrupt
    ///
    /// This macro takes two arguments: the name of an interrupt and the path to the
    /// function that will be used as the handler of that interrupt. That function
    /// must have signature `fn()`.
    ///
    /// Optionally, a third argument may be used to declare interrupt local data.
    /// The handler will have exclusive access to these *local* variables on each
    /// invocation. If the third argument is used then the signature of the handler
    /// function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument
    /// passed to the macro.
    ///
    /// # Example
    ///
    /// ``` ignore
    /// interrupt!(TIM2, periodic);
    ///
    /// fn periodic() {
    ///     print!(".");
    /// }
    ///
    /// interrupt!(TIM3, tick, locals: {
    ///     tick: bool = false;
    /// });
    ///
    /// fn tick(locals: &mut TIM3::Locals) {
    ///     locals.tick = !locals.tick;
    ///
    ///     if locals.tick {
    ///         println!("Tick");
    ///     } else {
    ///         println!("Tock");
    ///     }
    /// }
    /// ```
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
///Power control
pub struct PWR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWR {}
impl PWR {
    ///Pointer to the register block
    pub const PTR: *const pwr::RegisterBlock = 0x4000_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWR {
    type Target = pwr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWR").finish()
    }
}
///Power control
pub mod pwr {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Power control register (PWR_CTRL)
        pub ctlr: CTLR,
        ///0x04 - Power control state register (PWR_CSR)
        pub csr: CSR,
        ///0x08 - Automatic wake-up control state register (PWR_AWUCSR)
        pub awucsr: AWUCSR,
        ///0x0c - Automatic wake window comparison value register (PWR_AWUAPR)
        pub awuapr: AWUAPR,
        ///0x10 - Automatic wake-up prescaler register (PWR_AWUPSC)
        pub awupsc: AWUPSC,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Power control register (PWR_CTRL)
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PDDS` reader - Power Down Deep Sleep
        pub type PDDS_R = crate::BitReader<bool>;
        ///Field `PDDS` writer - Power Down Deep Sleep
        pub type PDDS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PVDE` reader - Power Voltage Detector Enable
        pub type PVDE_R = crate::BitReader<bool>;
        ///Field `PVDE` writer - Power Voltage Detector Enable
        pub type PVDE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PLS` reader - PVD Level Selection
        pub type PLS_R = crate::FieldReader<u8, u8>;
        ///Field `PLS` writer - PVD Level Selection
        pub type PLS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            pub fn pdds(&self) -> PDDS_R {
                PDDS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            pub fn pvde(&self) -> PVDE_R {
                PVDE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            pub fn pls(&self) -> PLS_R {
                PLS_R::new(((self.bits >> 5) & 7) as u8)
            }
        }
        impl W {
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            #[must_use]
            pub fn pdds(&mut self) -> PDDS_W<1> {
                PDDS_W::new(self)
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            #[must_use]
            pub fn pvde(&mut self) -> PVDE_W<4> {
                PVDE_W::new(self)
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            #[must_use]
            pub fn pls(&mut self) -> PLS_W<5> {
                PLS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Power control register (PWR_CTRL)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CSR (r) register accessor: an alias for `Reg<CSR_SPEC>`
    pub type CSR = crate::Reg<csr::CSR_SPEC>;
    ///Power control state register (PWR_CSR)
    pub mod csr {
        ///Register `CSR` reader
        pub struct R(crate::R<CSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PVDO` reader - PVD Output
        pub type PVDO_R = crate::BitReader<bool>;
        impl R {
            ///Bit 2 - PVD Output
            #[inline(always)]
            pub fn pvdo(&self) -> PVDO_R {
                PVDO_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        ///Power control state register (PWR_CSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [csr](index.html) module
        pub struct CSR_SPEC;
        impl crate::RegisterSpec for CSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [csr::R](R) reader structure
        impl crate::Readable for CSR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets CSR to value 0
        impl crate::Resettable for CSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///AWUCSR (rw) register accessor: an alias for `Reg<AWUCSR_SPEC>`
    pub type AWUCSR = crate::Reg<awucsr::AWUCSR_SPEC>;
    ///Automatic wake-up control state register (PWR_AWUCSR)
    pub mod awucsr {
        ///Register `AWUCSR` reader
        pub struct R(crate::R<AWUCSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AWUCSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AWUCSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AWUCSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AWUCSR` writer
        pub struct W(crate::W<AWUCSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AWUCSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AWUCSR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AWUCSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AWUEN` reader - Automatic wake-up enable
        pub type AWUEN_R = crate::BitReader<bool>;
        ///Field `AWUEN` writer - Automatic wake-up enable
        pub type AWUEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, AWUCSR_SPEC, bool, O>;
        impl R {
            ///Bit 1 - Automatic wake-up enable
            #[inline(always)]
            pub fn awuen(&self) -> AWUEN_R {
                AWUEN_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - Automatic wake-up enable
            #[inline(always)]
            #[must_use]
            pub fn awuen(&mut self) -> AWUEN_W<1> {
                AWUEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Automatic wake-up control state register (PWR_AWUCSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [awucsr](index.html) module
        pub struct AWUCSR_SPEC;
        impl crate::RegisterSpec for AWUCSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [awucsr::R](R) reader structure
        impl crate::Readable for AWUCSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [awucsr::W](W) writer structure
        impl crate::Writable for AWUCSR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AWUCSR to value 0
        impl crate::Resettable for AWUCSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///AWUAPR (rw) register accessor: an alias for `Reg<AWUAPR_SPEC>`
    pub type AWUAPR = crate::Reg<awuapr::AWUAPR_SPEC>;
    ///Automatic wake window comparison value register (PWR_AWUAPR)
    pub mod awuapr {
        ///Register `AWUAPR` reader
        pub struct R(crate::R<AWUAPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AWUAPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AWUAPR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AWUAPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AWUAPR` writer
        pub struct W(crate::W<AWUAPR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AWUAPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AWUAPR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AWUAPR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AWUAPR` reader - AWU window value
        pub type AWUAPR_R = crate::FieldReader<u8, u8>;
        ///Field `AWUAPR` writer - AWU window value
        pub type AWUAPR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, AWUAPR_SPEC, u8, u8, 6, O>;
        impl R {
            ///Bits 0:5 - AWU window value
            #[inline(always)]
            pub fn awuapr(&self) -> AWUAPR_R {
                AWUAPR_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - AWU window value
            #[inline(always)]
            #[must_use]
            pub fn awuapr(&mut self) -> AWUAPR_W<0> {
                AWUAPR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Automatic wake window comparison value register (PWR_AWUAPR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [awuapr](index.html) module
        pub struct AWUAPR_SPEC;
        impl crate::RegisterSpec for AWUAPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [awuapr::R](R) reader structure
        impl crate::Readable for AWUAPR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [awuapr::W](W) writer structure
        impl crate::Writable for AWUAPR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AWUAPR to value 0x3f
        impl crate::Resettable for AWUAPR_SPEC {
            const RESET_VALUE: Self::Ux = 0x3f;
        }
    }
    ///AWUPSC (rw) register accessor: an alias for `Reg<AWUPSC_SPEC>`
    pub type AWUPSC = crate::Reg<awupsc::AWUPSC_SPEC>;
    ///Automatic wake-up prescaler register (PWR_AWUPSC)
    pub mod awupsc {
        ///Register `AWUPSC` reader
        pub struct R(crate::R<AWUPSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AWUPSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AWUPSC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AWUPSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AWUPSC` writer
        pub struct W(crate::W<AWUPSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AWUPSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AWUPSC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AWUPSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AWUPSC` reader - Wake-up prescaler
        pub type AWUPSC_R = crate::FieldReader<u8, u8>;
        ///Field `AWUPSC` writer - Wake-up prescaler
        pub type AWUPSC_W<'a, const O: u8> = crate::FieldWriter<'a, u32, AWUPSC_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:3 - Wake-up prescaler
            #[inline(always)]
            pub fn awupsc(&self) -> AWUPSC_R {
                AWUPSC_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - Wake-up prescaler
            #[inline(always)]
            #[must_use]
            pub fn awupsc(&mut self) -> AWUPSC_W<0> {
                AWUPSC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Automatic wake-up prescaler register (PWR_AWUPSC)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [awupsc](index.html) module
        pub struct AWUPSC_SPEC;
        impl crate::RegisterSpec for AWUPSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [awupsc::R](R) reader structure
        impl crate::Readable for AWUPSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [awupsc::W](W) writer structure
        impl crate::Writable for AWUPSC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AWUPSC to value 0
        impl crate::Resettable for AWUPSC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Reset and clock control
pub struct RCC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RCC {}
impl RCC {
    ///Pointer to the register block
    pub const PTR: *const rcc::RegisterBlock = 0x4002_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rcc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RCC {
    type Target = rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RCC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RCC").finish()
    }
}
///Reset and clock control
pub mod rcc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Clock control register
        pub ctlr: CTLR,
        ///0x04 - Clock configuration register (RCC_CFGR0)
        pub cfgr0: CFGR0,
        ///0x08 - Clock interrupt register (RCC_INTR)
        pub intr: INTR,
        ///0x0c - APB2 peripheral reset register (RCC_APB2PRSTR)
        pub apb2prstr: APB2PRSTR,
        ///0x10 - APB1 peripheral reset register (RCC_APB1PRSTR)
        pub apb1prstr: APB1PRSTR,
        ///0x14 - AHB Peripheral Clock enable register (RCC_AHBPCENR)
        pub ahbpcenr: AHBPCENR,
        ///0x18 - APB2 peripheral clock enable register (RCC_APB2PCENR)
        pub apb2pcenr: APB2PCENR,
        ///0x1c - APB1 peripheral clock enable register (RCC_APB1PCENR)
        pub apb1pcenr: APB1PCENR,
        _reserved8: [u8; 0x04],
        ///0x24 - Control/status register (RCC_RSTSCKR)
        pub rstsckr: RSTSCKR,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Clock control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HSION` reader - Internal High Speed clock enable
        pub type HSION_R = crate::BitReader<bool>;
        ///Field `HSION` writer - Internal High Speed clock enable
        pub type HSION_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `HSIRDY` reader - Internal High Speed clock ready flag
        pub type HSIRDY_R = crate::BitReader<bool>;
        ///Field `HSITRIM` reader - Internal High Speed clock trimming
        pub type HSITRIM_R = crate::FieldReader<u8, u8>;
        ///Field `HSITRIM` writer - Internal High Speed clock trimming
        pub type HSITRIM_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR_SPEC, u8, u8, 5, O>;
        ///Field `HSICAL` reader - Internal High Speed clock Calibration
        pub type HSICAL_R = crate::FieldReader<u8, u8>;
        ///Field `HSEON` reader - External High Speed clock enable
        pub type HSEON_R = crate::BitReader<bool>;
        ///Field `HSEON` writer - External High Speed clock enable
        pub type HSEON_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `HSERDY` reader - External High Speed clock ready flag
        pub type HSERDY_R = crate::BitReader<bool>;
        ///Field `HSEBYP` reader - External High Speed clock Bypass
        pub type HSEBYP_R = crate::BitReader<bool>;
        ///Field `HSEBYP` writer - External High Speed clock Bypass
        pub type HSEBYP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `CSSON` reader - Clock Security System enable
        pub type CSSON_R = crate::BitReader<bool>;
        ///Field `CSSON` writer - Clock Security System enable
        pub type CSSON_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PLLON` reader - PLL enable
        pub type PLLON_R = crate::BitReader<bool>;
        ///Field `PLLON` writer - PLL enable
        pub type PLLON_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PLLRDY` reader - PLL clock ready flag
        pub type PLLRDY_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            pub fn hsion(&self) -> HSION_R {
                HSION_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Internal High Speed clock ready flag
            #[inline(always)]
            pub fn hsirdy(&self) -> HSIRDY_R {
                HSIRDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            pub fn hsitrim(&self) -> HSITRIM_R {
                HSITRIM_R::new(((self.bits >> 3) & 0x1f) as u8)
            }
            ///Bits 8:15 - Internal High Speed clock Calibration
            #[inline(always)]
            pub fn hsical(&self) -> HSICAL_R {
                HSICAL_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            pub fn hseon(&self) -> HSEON_R {
                HSEON_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - External High Speed clock ready flag
            #[inline(always)]
            pub fn hserdy(&self) -> HSERDY_R {
                HSERDY_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            pub fn hsebyp(&self) -> HSEBYP_R {
                HSEBYP_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            pub fn csson(&self) -> CSSON_R {
                CSSON_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            pub fn pllon(&self) -> PLLON_R {
                PLLON_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - PLL clock ready flag
            #[inline(always)]
            pub fn pllrdy(&self) -> PLLRDY_R {
                PLLRDY_R::new(((self.bits >> 25) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            #[must_use]
            pub fn hsion(&mut self) -> HSION_W<0> {
                HSION_W::new(self)
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            #[must_use]
            pub fn hsitrim(&mut self) -> HSITRIM_W<3> {
                HSITRIM_W::new(self)
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            #[must_use]
            pub fn hseon(&mut self) -> HSEON_W<16> {
                HSEON_W::new(self)
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            #[must_use]
            pub fn hsebyp(&mut self) -> HSEBYP_W<18> {
                HSEBYP_W::new(self)
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            #[must_use]
            pub fn csson(&mut self) -> CSSON_W<19> {
                CSSON_W::new(self)
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            #[must_use]
            pub fn pllon(&mut self) -> PLLON_W<24> {
                PLLON_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0x83
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x83;
        }
    }
    ///CFGR0 (rw) register accessor: an alias for `Reg<CFGR0_SPEC>`
    pub type CFGR0 = crate::Reg<cfgr0::CFGR0_SPEC>;
    ///Clock configuration register (RCC_CFGR0)
    pub mod cfgr0 {
        ///Register `CFGR0` reader
        pub struct R(crate::R<CFGR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR0` writer
        pub struct W(crate::W<CFGR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SW` reader - System clock Switch
        pub type SW_R = crate::FieldReader<u8, u8>;
        ///Field `SW` writer - System clock Switch
        pub type SW_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, u8, 2, O>;
        ///Field `SWS` reader - System Clock Switch Status
        pub type SWS_R = crate::FieldReader<u8, u8>;
        ///Field `HPRE` reader - AHB prescaler
        pub type HPRE_R = crate::FieldReader<u8, u8>;
        ///Field `HPRE` writer - AHB prescaler
        pub type HPRE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, u8, 4, O>;
        ///Field `PPRE1` reader - APB Low speed prescaler (APB1)
        pub type PPRE1_R = crate::FieldReader<u8, u8>;
        ///Field `PPRE1` writer - APB Low speed prescaler (APB1)
        pub type PPRE1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, u8, 3, O>;
        ///Field `PPRE2` reader - APB High speed prescaler (APB2)
        pub type PPRE2_R = crate::FieldReader<u8, u8>;
        ///Field `PPRE2` writer - APB High speed prescaler (APB2)
        pub type PPRE2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, u8, 3, O>;
        ///Field `ADCPRE` reader - ADC prescaler
        pub type ADCPRE_R = crate::FieldReader<u8, u8>;
        ///Field `ADCPRE` writer - ADC prescaler
        pub type ADCPRE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, u8, 2, O>;
        ///Field `PLLSRC` reader - PLL entry clock source
        pub type PLLSRC_R = crate::BitReader<bool>;
        ///Field `PLLSRC` writer - PLL entry clock source
        pub type PLLSRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR0_SPEC, bool, O>;
        ///Field `MCO` reader - Microcontroller clock output
        pub type MCO_R = crate::FieldReader<u8, u8>;
        ///Field `MCO` writer - Microcontroller clock output
        pub type MCO_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR0_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            pub fn sw(&self) -> SW_R {
                SW_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - System Clock Switch Status
            #[inline(always)]
            pub fn sws(&self) -> SWS_R {
                SWS_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            pub fn hpre(&self) -> HPRE_R {
                HPRE_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:10 - APB Low speed prescaler (APB1)
            #[inline(always)]
            pub fn ppre1(&self) -> PPRE1_R {
                PPRE1_R::new(((self.bits >> 8) & 7) as u8)
            }
            ///Bits 11:13 - APB High speed prescaler (APB2)
            #[inline(always)]
            pub fn ppre2(&self) -> PPRE2_R {
                PPRE2_R::new(((self.bits >> 11) & 7) as u8)
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            pub fn adcpre(&self) -> ADCPRE_R {
                ADCPRE_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            pub fn pllsrc(&self) -> PLLSRC_R {
                PLLSRC_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            pub fn mco(&self) -> MCO_R {
                MCO_R::new(((self.bits >> 24) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            #[must_use]
            pub fn sw(&mut self) -> SW_W<0> {
                SW_W::new(self)
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            #[must_use]
            pub fn hpre(&mut self) -> HPRE_W<4> {
                HPRE_W::new(self)
            }
            ///Bits 8:10 - APB Low speed prescaler (APB1)
            #[inline(always)]
            #[must_use]
            pub fn ppre1(&mut self) -> PPRE1_W<8> {
                PPRE1_W::new(self)
            }
            ///Bits 11:13 - APB High speed prescaler (APB2)
            #[inline(always)]
            #[must_use]
            pub fn ppre2(&mut self) -> PPRE2_W<11> {
                PPRE2_W::new(self)
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            #[must_use]
            pub fn adcpre(&mut self) -> ADCPRE_W<14> {
                ADCPRE_W::new(self)
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            #[must_use]
            pub fn pllsrc(&mut self) -> PLLSRC_W<16> {
                PLLSRC_W::new(self)
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            #[must_use]
            pub fn mco(&mut self) -> MCO_W<24> {
                MCO_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock configuration register (RCC_CFGR0)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr0](index.html) module
        pub struct CFGR0_SPEC;
        impl crate::RegisterSpec for CFGR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr0::R](R) reader structure
        impl crate::Readable for CFGR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr0::W](W) writer structure
        impl crate::Writable for CFGR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR0 to value 0
        impl crate::Resettable for CFGR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTR (rw) register accessor: an alias for `Reg<INTR_SPEC>`
    pub type INTR = crate::Reg<intr::INTR_SPEC>;
    ///Clock interrupt register (RCC_INTR)
    pub mod intr {
        ///Register `INTR` reader
        pub struct R(crate::R<INTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTR` writer
        pub struct W(crate::W<INTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LSIRDYF` reader - LSI Ready Interrupt flag
        pub type LSIRDYF_R = crate::BitReader<bool>;
        ///Field `HSIRDYF` reader - HSI Ready Interrupt flag
        pub type HSIRDYF_R = crate::BitReader<bool>;
        ///Field `HSERDYF` reader - HSE Ready Interrupt flag
        pub type HSERDYF_R = crate::BitReader<bool>;
        ///Field `PLLRDYF` reader - PLL Ready Interrupt flag
        pub type PLLRDYF_R = crate::BitReader<bool>;
        ///Field `CSSF` reader - Clock Security System Interrupt flag
        pub type CSSF_R = crate::BitReader<bool>;
        ///Field `LSIRDYIE` reader - LSI Ready Interrupt Enable
        pub type LSIRDYIE_R = crate::BitReader<bool>;
        ///Field `LSIRDYIE` writer - LSI Ready Interrupt Enable
        pub type LSIRDYIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `HSIRDYIE` reader - HSI Ready Interrupt Enable
        pub type HSIRDYIE_R = crate::BitReader<bool>;
        ///Field `HSIRDYIE` writer - HSI Ready Interrupt Enable
        pub type HSIRDYIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `HSERDYIE` reader - HSE Ready Interrupt Enable
        pub type HSERDYIE_R = crate::BitReader<bool>;
        ///Field `HSERDYIE` writer - HSE Ready Interrupt Enable
        pub type HSERDYIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `PLLRDYIE` reader - PLL Ready Interrupt Enable
        pub type PLLRDYIE_R = crate::BitReader<bool>;
        ///Field `PLLRDYIE` writer - PLL Ready Interrupt Enable
        pub type PLLRDYIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `LSIRDYC` writer - LSI Ready Interrupt Clear
        pub type LSIRDYC_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `HSIRDYC` writer - HSI Ready Interrupt Clear
        pub type HSIRDYC_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `HSERDYC` writer - HSE Ready Interrupt Clear
        pub type HSERDYC_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `PLLRDYC` writer - PLL Ready Interrupt Clear
        pub type PLLRDYC_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        ///Field `CSSC` writer - Clock security system interrupt clear
        pub type CSSC_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - LSI Ready Interrupt flag
            #[inline(always)]
            pub fn lsirdyf(&self) -> LSIRDYF_R {
                LSIRDYF_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - HSI Ready Interrupt flag
            #[inline(always)]
            pub fn hsirdyf(&self) -> HSIRDYF_R {
                HSIRDYF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - HSE Ready Interrupt flag
            #[inline(always)]
            pub fn hserdyf(&self) -> HSERDYF_R {
                HSERDYF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - PLL Ready Interrupt flag
            #[inline(always)]
            pub fn pllrdyf(&self) -> PLLRDYF_R {
                PLLRDYF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - Clock Security System Interrupt flag
            #[inline(always)]
            pub fn cssf(&self) -> CSSF_R {
                CSSF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            pub fn lsirdyie(&self) -> LSIRDYIE_R {
                LSIRDYIE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            pub fn hsirdyie(&self) -> HSIRDYIE_R {
                HSIRDYIE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            pub fn hserdyie(&self) -> HSERDYIE_R {
                HSERDYIE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            pub fn pllrdyie(&self) -> PLLRDYIE_R {
                PLLRDYIE_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn lsirdyie(&mut self) -> LSIRDYIE_W<8> {
                LSIRDYIE_W::new(self)
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn hsirdyie(&mut self) -> HSIRDYIE_W<10> {
                HSIRDYIE_W::new(self)
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn hserdyie(&mut self) -> HSERDYIE_W<11> {
                HSERDYIE_W::new(self)
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            #[must_use]
            pub fn pllrdyie(&mut self) -> PLLRDYIE_W<12> {
                PLLRDYIE_W::new(self)
            }
            ///Bit 16 - LSI Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn lsirdyc(&mut self) -> LSIRDYC_W<16> {
                LSIRDYC_W::new(self)
            }
            ///Bit 18 - HSI Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn hsirdyc(&mut self) -> HSIRDYC_W<18> {
                HSIRDYC_W::new(self)
            }
            ///Bit 19 - HSE Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn hserdyc(&mut self) -> HSERDYC_W<19> {
                HSERDYC_W::new(self)
            }
            ///Bit 20 - PLL Ready Interrupt Clear
            #[inline(always)]
            #[must_use]
            pub fn pllrdyc(&mut self) -> PLLRDYC_W<20> {
                PLLRDYC_W::new(self)
            }
            ///Bit 23 - Clock security system interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cssc(&mut self) -> CSSC_W<23> {
                CSSC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock interrupt register (RCC_INTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intr](index.html) module
        pub struct INTR_SPEC;
        impl crate::RegisterSpec for INTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intr::R](R) reader structure
        impl crate::Readable for INTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intr::W](W) writer structure
        impl crate::Writable for INTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTR to value 0
        impl crate::Resettable for INTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///APB2PRSTR (rw) register accessor: an alias for `Reg<APB2PRSTR_SPEC>`
    pub type APB2PRSTR = crate::Reg<apb2prstr::APB2PRSTR_SPEC>;
    ///APB2 peripheral reset register (RCC_APB2PRSTR)
    pub mod apb2prstr {
        ///Register `APB2PRSTR` reader
        pub struct R(crate::R<APB2PRSTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB2PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB2PRSTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB2PRSTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB2PRSTR` writer
        pub struct W(crate::W<APB2PRSTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB2PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB2PRSTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB2PRSTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AFIORST` reader - Alternate function I/O reset
        pub type AFIORST_R = crate::BitReader<bool>;
        ///Field `AFIORST` writer - Alternate function I/O reset
        pub type AFIORST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        ///Field `IOPARST` reader - IO port A reset
        pub type IOPARST_R = crate::BitReader<bool>;
        ///Field `IOPARST` writer - IO port A reset
        pub type IOPARST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        ///Field `IOPCRST` reader - IO port C reset
        pub type IOPCRST_R = crate::BitReader<bool>;
        ///Field `IOPCRST` writer - IO port C reset
        pub type IOPCRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        ///Field `IOPDRST` reader - IO port D reset
        pub type IOPDRST_R = crate::BitReader<bool>;
        ///Field `IOPDRST` writer - IO port D reset
        pub type IOPDRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        ///Field `ADC1RST` reader - ADC 1 interface reset
        pub type ADC1RST_R = crate::BitReader<bool>;
        ///Field `ADC1RST` writer - ADC 1 interface reset
        pub type ADC1RST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        ///Field `TIM1RST` reader - TIM1 timer reset
        pub type TIM1RST_R = crate::BitReader<bool>;
        ///Field `TIM1RST` writer - TIM1 timer reset
        pub type TIM1RST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        ///Field `SPI1RST` reader - SPI 1 reset
        pub type SPI1RST_R = crate::BitReader<bool>;
        ///Field `SPI1RST` writer - SPI 1 reset
        pub type SPI1RST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        ///Field `USART1RST` reader - USART1 reset
        pub type USART1RST_R = crate::BitReader<bool>;
        ///Field `USART1RST` writer - USART1 reset
        pub type USART1RST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PRSTR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            pub fn afiorst(&self) -> AFIORST_R {
                AFIORST_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            pub fn ioparst(&self) -> IOPARST_R {
                IOPARST_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            pub fn iopcrst(&self) -> IOPCRST_R {
                IOPCRST_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            pub fn iopdrst(&self) -> IOPDRST_R {
                IOPDRST_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 9 - ADC 1 interface reset
            #[inline(always)]
            pub fn adc1rst(&self) -> ADC1RST_R {
                ADC1RST_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            pub fn tim1rst(&self) -> TIM1RST_R {
                TIM1RST_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            pub fn spi1rst(&self) -> SPI1RST_R {
                SPI1RST_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            pub fn usart1rst(&self) -> USART1RST_R {
                USART1RST_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            #[must_use]
            pub fn afiorst(&mut self) -> AFIORST_W<0> {
                AFIORST_W::new(self)
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            #[must_use]
            pub fn ioparst(&mut self) -> IOPARST_W<2> {
                IOPARST_W::new(self)
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            #[must_use]
            pub fn iopcrst(&mut self) -> IOPCRST_W<4> {
                IOPCRST_W::new(self)
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            #[must_use]
            pub fn iopdrst(&mut self) -> IOPDRST_W<5> {
                IOPDRST_W::new(self)
            }
            ///Bit 9 - ADC 1 interface reset
            #[inline(always)]
            #[must_use]
            pub fn adc1rst(&mut self) -> ADC1RST_W<9> {
                ADC1RST_W::new(self)
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            #[must_use]
            pub fn tim1rst(&mut self) -> TIM1RST_W<11> {
                TIM1RST_W::new(self)
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            #[must_use]
            pub fn spi1rst(&mut self) -> SPI1RST_W<12> {
                SPI1RST_W::new(self)
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            #[must_use]
            pub fn usart1rst(&mut self) -> USART1RST_W<14> {
                USART1RST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB2 peripheral reset register (RCC_APB2PRSTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb2prstr](index.html) module
        pub struct APB2PRSTR_SPEC;
        impl crate::RegisterSpec for APB2PRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb2prstr::R](R) reader structure
        impl crate::Readable for APB2PRSTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb2prstr::W](W) writer structure
        impl crate::Writable for APB2PRSTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB2PRSTR to value 0
        impl crate::Resettable for APB2PRSTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///APB1PRSTR (rw) register accessor: an alias for `Reg<APB1PRSTR_SPEC>`
    pub type APB1PRSTR = crate::Reg<apb1prstr::APB1PRSTR_SPEC>;
    ///APB1 peripheral reset register (RCC_APB1PRSTR)
    pub mod apb1prstr {
        ///Register `APB1PRSTR` reader
        pub struct R(crate::R<APB1PRSTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB1PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB1PRSTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB1PRSTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB1PRSTR` writer
        pub struct W(crate::W<APB1PRSTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB1PRSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB1PRSTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB1PRSTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WWDGRST` reader - Window watchdog reset
        pub type WWDGRST_R = crate::BitReader<bool>;
        ///Field `WWDGRST` writer - Window watchdog reset
        pub type WWDGRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PRSTR_SPEC, bool, O>;
        ///Field `I2C1RST` reader - I2C1 reset
        pub type I2C1RST_R = crate::BitReader<bool>;
        ///Field `I2C1RST` writer - I2C1 reset
        pub type I2C1RST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PRSTR_SPEC, bool, O>;
        ///Field `PWRRST` reader - Power interface reset
        pub type PWRRST_R = crate::BitReader<bool>;
        ///Field `PWRRST` writer - Power interface reset
        pub type PWRRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PRSTR_SPEC, bool, O>;
        impl R {
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            pub fn wwdgrst(&self) -> WWDGRST_R {
                WWDGRST_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            pub fn i2c1rst(&self) -> I2C1RST_R {
                I2C1RST_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            pub fn pwrrst(&self) -> PWRRST_R {
                PWRRST_R::new(((self.bits >> 28) & 1) != 0)
            }
        }
        impl W {
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            #[must_use]
            pub fn wwdgrst(&mut self) -> WWDGRST_W<11> {
                WWDGRST_W::new(self)
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            #[must_use]
            pub fn i2c1rst(&mut self) -> I2C1RST_W<21> {
                I2C1RST_W::new(self)
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            #[must_use]
            pub fn pwrrst(&mut self) -> PWRRST_W<28> {
                PWRRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB1 peripheral reset register (RCC_APB1PRSTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb1prstr](index.html) module
        pub struct APB1PRSTR_SPEC;
        impl crate::RegisterSpec for APB1PRSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb1prstr::R](R) reader structure
        impl crate::Readable for APB1PRSTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb1prstr::W](W) writer structure
        impl crate::Writable for APB1PRSTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB1PRSTR to value 0
        impl crate::Resettable for APB1PRSTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///AHBPCENR (rw) register accessor: an alias for `Reg<AHBPCENR_SPEC>`
    pub type AHBPCENR = crate::Reg<ahbpcenr::AHBPCENR_SPEC>;
    ///AHB Peripheral Clock enable register (RCC_AHBPCENR)
    pub mod ahbpcenr {
        ///Register `AHBPCENR` reader
        pub struct R(crate::R<AHBPCENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AHBPCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<AHBPCENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<AHBPCENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AHBPCENR` writer
        pub struct W(crate::W<AHBPCENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AHBPCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<AHBPCENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<AHBPCENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMA1EN` reader - DMA clock enable
        pub type DMA1EN_R = crate::BitReader<bool>;
        ///Field `DMA1EN` writer - DMA clock enable
        pub type DMA1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, AHBPCENR_SPEC, bool, O>;
        ///Field `SRAMEN` reader - SRAM interface clock enable
        pub type SRAMEN_R = crate::BitReader<bool>;
        ///Field `SRAMEN` writer - SRAM interface clock enable
        pub type SRAMEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, AHBPCENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DMA clock enable
            #[inline(always)]
            pub fn dma1en(&self) -> DMA1EN_R {
                DMA1EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            pub fn sramen(&self) -> SRAMEN_R {
                SRAMEN_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA clock enable
            #[inline(always)]
            #[must_use]
            pub fn dma1en(&mut self) -> DMA1EN_W<0> {
                DMA1EN_W::new(self)
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn sramen(&mut self) -> SRAMEN_W<2> {
                SRAMEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AHB Peripheral Clock enable register (RCC_AHBPCENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ahbpcenr](index.html) module
        pub struct AHBPCENR_SPEC;
        impl crate::RegisterSpec for AHBPCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ahbpcenr::R](R) reader structure
        impl crate::Readable for AHBPCENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ahbpcenr::W](W) writer structure
        impl crate::Writable for AHBPCENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets AHBPCENR to value 0x04
        impl crate::Resettable for AHBPCENR_SPEC {
            const RESET_VALUE: Self::Ux = 0x04;
        }
    }
    ///APB2PCENR (rw) register accessor: an alias for `Reg<APB2PCENR_SPEC>`
    pub type APB2PCENR = crate::Reg<apb2pcenr::APB2PCENR_SPEC>;
    ///APB2 peripheral clock enable register (RCC_APB2PCENR)
    pub mod apb2pcenr {
        ///Register `APB2PCENR` reader
        pub struct R(crate::R<APB2PCENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB2PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB2PCENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB2PCENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB2PCENR` writer
        pub struct W(crate::W<APB2PCENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB2PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB2PCENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB2PCENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AFIOEN` reader - Alternate function I/O clock enable
        pub type AFIOEN_R = crate::BitReader<bool>;
        ///Field `AFIOEN` writer - Alternate function I/O clock enable
        pub type AFIOEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        ///Field `IOPAEN` reader - I/O port A clock enable
        pub type IOPAEN_R = crate::BitReader<bool>;
        ///Field `IOPAEN` writer - I/O port A clock enable
        pub type IOPAEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        ///Field `IOPCEN` reader - I/O port C clock enable
        pub type IOPCEN_R = crate::BitReader<bool>;
        ///Field `IOPCEN` writer - I/O port C clock enable
        pub type IOPCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        ///Field `IOPDEN` reader - I/O port D clock enable
        pub type IOPDEN_R = crate::BitReader<bool>;
        ///Field `IOPDEN` writer - I/O port D clock enable
        pub type IOPDEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        ///Field `ADC1EN` reader - ADC1 interface clock enable
        pub type ADC1EN_R = crate::BitReader<bool>;
        ///Field `ADC1EN` writer - ADC1 interface clock enable
        pub type ADC1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        ///Field `TIM1EN` reader - TIM1 Timer clock enable
        pub type TIM1EN_R = crate::BitReader<bool>;
        ///Field `TIM1EN` writer - TIM1 Timer clock enable
        pub type TIM1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        ///Field `SPI1EN` reader - SPI 1 clock enable
        pub type SPI1EN_R = crate::BitReader<bool>;
        ///Field `SPI1EN` writer - SPI 1 clock enable
        pub type SPI1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        ///Field `USART1EN` reader - USART1 clock enable
        pub type USART1EN_R = crate::BitReader<bool>;
        ///Field `USART1EN` writer - USART1 clock enable
        pub type USART1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB2PCENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            pub fn afioen(&self) -> AFIOEN_R {
                AFIOEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            pub fn iopaen(&self) -> IOPAEN_R {
                IOPAEN_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            pub fn iopcen(&self) -> IOPCEN_R {
                IOPCEN_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            pub fn iopden(&self) -> IOPDEN_R {
                IOPDEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 9 - ADC1 interface clock enable
            #[inline(always)]
            pub fn adc1en(&self) -> ADC1EN_R {
                ADC1EN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            pub fn tim1en(&self) -> TIM1EN_R {
                TIM1EN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            pub fn spi1en(&self) -> SPI1EN_R {
                SPI1EN_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            pub fn usart1en(&self) -> USART1EN_R {
                USART1EN_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            #[must_use]
            pub fn afioen(&mut self) -> AFIOEN_W<0> {
                AFIOEN_W::new(self)
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopaen(&mut self) -> IOPAEN_W<2> {
                IOPAEN_W::new(self)
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopcen(&mut self) -> IOPCEN_W<4> {
                IOPCEN_W::new(self)
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            #[must_use]
            pub fn iopden(&mut self) -> IOPDEN_W<5> {
                IOPDEN_W::new(self)
            }
            ///Bit 9 - ADC1 interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn adc1en(&mut self) -> ADC1EN_W<9> {
                ADC1EN_W::new(self)
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim1en(&mut self) -> TIM1EN_W<11> {
                TIM1EN_W::new(self)
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn spi1en(&mut self) -> SPI1EN_W<12> {
                SPI1EN_W::new(self)
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn usart1en(&mut self) -> USART1EN_W<14> {
                USART1EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB2 peripheral clock enable register (RCC_APB2PCENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb2pcenr](index.html) module
        pub struct APB2PCENR_SPEC;
        impl crate::RegisterSpec for APB2PCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb2pcenr::R](R) reader structure
        impl crate::Readable for APB2PCENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb2pcenr::W](W) writer structure
        impl crate::Writable for APB2PCENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB2PCENR to value 0
        impl crate::Resettable for APB2PCENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///APB1PCENR (rw) register accessor: an alias for `Reg<APB1PCENR_SPEC>`
    pub type APB1PCENR = crate::Reg<apb1pcenr::APB1PCENR_SPEC>;
    ///APB1 peripheral clock enable register (RCC_APB1PCENR)
    pub mod apb1pcenr {
        ///Register `APB1PCENR` reader
        pub struct R(crate::R<APB1PCENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB1PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<APB1PCENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<APB1PCENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB1PCENR` writer
        pub struct W(crate::W<APB1PCENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB1PCENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<APB1PCENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<APB1PCENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TIM2EN` reader - Timer 2 clock enable
        pub type TIM2EN_R = crate::BitReader<bool>;
        ///Field `TIM2EN` writer - Timer 2 clock enable
        pub type TIM2EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PCENR_SPEC, bool, O>;
        ///Field `WWDGEN` reader - Window watchdog clock enable
        pub type WWDGEN_R = crate::BitReader<bool>;
        ///Field `WWDGEN` writer - Window watchdog clock enable
        pub type WWDGEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PCENR_SPEC, bool, O>;
        ///Field `I2C1EN` reader - I2C 1 clock enable
        pub type I2C1EN_R = crate::BitReader<bool>;
        ///Field `I2C1EN` writer - I2C 1 clock enable
        pub type I2C1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PCENR_SPEC, bool, O>;
        ///Field `PWREN` reader - Power interface clock enable
        pub type PWREN_R = crate::BitReader<bool>;
        ///Field `PWREN` writer - Power interface clock enable
        pub type PWREN_W<'a, const O: u8> = crate::BitWriter<'a, u32, APB1PCENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            pub fn tim2en(&self) -> TIM2EN_R {
                TIM2EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            pub fn wwdgen(&self) -> WWDGEN_R {
                WWDGEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            pub fn i2c1en(&self) -> I2C1EN_R {
                I2C1EN_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            pub fn pwren(&self) -> PWREN_R {
                PWREN_R::new(((self.bits >> 28) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            #[must_use]
            pub fn tim2en(&mut self) -> TIM2EN_W<0> {
                TIM2EN_W::new(self)
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            #[must_use]
            pub fn wwdgen(&mut self) -> WWDGEN_W<11> {
                WWDGEN_W::new(self)
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            #[must_use]
            pub fn i2c1en(&mut self) -> I2C1EN_W<21> {
                I2C1EN_W::new(self)
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            #[must_use]
            pub fn pwren(&mut self) -> PWREN_W<28> {
                PWREN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB1 peripheral clock enable register (RCC_APB1PCENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb1pcenr](index.html) module
        pub struct APB1PCENR_SPEC;
        impl crate::RegisterSpec for APB1PCENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb1pcenr::R](R) reader structure
        impl crate::Readable for APB1PCENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb1pcenr::W](W) writer structure
        impl crate::Writable for APB1PCENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets APB1PCENR to value 0
        impl crate::Resettable for APB1PCENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSTSCKR (rw) register accessor: an alias for `Reg<RSTSCKR_SPEC>`
    pub type RSTSCKR = crate::Reg<rstsckr::RSTSCKR_SPEC>;
    ///Control/status register (RCC_RSTSCKR)
    pub mod rstsckr {
        ///Register `RSTSCKR` reader
        pub struct R(crate::R<RSTSCKR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSTSCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSTSCKR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSTSCKR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSTSCKR` writer
        pub struct W(crate::W<RSTSCKR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSTSCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSTSCKR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSTSCKR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LSION` reader - Internal low speed oscillator enable
        pub type LSION_R = crate::BitReader<bool>;
        ///Field `LSION` writer - Internal low speed oscillator enable
        pub type LSION_W<'a, const O: u8> = crate::BitWriter<'a, u32, RSTSCKR_SPEC, bool, O>;
        ///Field `LSIRDY` reader - Internal low speed oscillator ready
        pub type LSIRDY_R = crate::BitReader<bool>;
        ///Field `RMVF` reader - Remove reset flag
        pub type RMVF_R = crate::BitReader<bool>;
        ///Field `RMVF` writer - Remove reset flag
        pub type RMVF_W<'a, const O: u8> = crate::BitWriter<'a, u32, RSTSCKR_SPEC, bool, O>;
        ///Field `PINRSTF` reader - PIN reset flag
        pub type PINRSTF_R = crate::BitReader<bool>;
        ///Field `PORRSTF` reader - POR/PDR reset flag
        pub type PORRSTF_R = crate::BitReader<bool>;
        ///Field `SFTRSTF` reader - Software reset flag
        pub type SFTRSTF_R = crate::BitReader<bool>;
        ///Field `IWDGRSTF` reader - Independent watchdog reset flag
        pub type IWDGRSTF_R = crate::BitReader<bool>;
        ///Field `WWDGRSTF` reader - Window watchdog reset flag
        pub type WWDGRSTF_R = crate::BitReader<bool>;
        ///Field `LPWRRSTF` reader - Low-power reset flag
        pub type LPWRRSTF_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            pub fn lsion(&self) -> LSION_R {
                LSION_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Internal low speed oscillator ready
            #[inline(always)]
            pub fn lsirdy(&self) -> LSIRDY_R {
                LSIRDY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            pub fn rmvf(&self) -> RMVF_R {
                RMVF_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 26 - PIN reset flag
            #[inline(always)]
            pub fn pinrstf(&self) -> PINRSTF_R {
                PINRSTF_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - POR/PDR reset flag
            #[inline(always)]
            pub fn porrstf(&self) -> PORRSTF_R {
                PORRSTF_R::new(((self.bits >> 27) & 1) != 0)
            }
            ///Bit 28 - Software reset flag
            #[inline(always)]
            pub fn sftrstf(&self) -> SFTRSTF_R {
                SFTRSTF_R::new(((self.bits >> 28) & 1) != 0)
            }
            ///Bit 29 - Independent watchdog reset flag
            #[inline(always)]
            pub fn iwdgrstf(&self) -> IWDGRSTF_R {
                IWDGRSTF_R::new(((self.bits >> 29) & 1) != 0)
            }
            ///Bit 30 - Window watchdog reset flag
            #[inline(always)]
            pub fn wwdgrstf(&self) -> WWDGRSTF_R {
                WWDGRSTF_R::new(((self.bits >> 30) & 1) != 0)
            }
            ///Bit 31 - Low-power reset flag
            #[inline(always)]
            pub fn lpwrrstf(&self) -> LPWRRSTF_R {
                LPWRRSTF_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            #[must_use]
            pub fn lsion(&mut self) -> LSION_W<0> {
                LSION_W::new(self)
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            #[must_use]
            pub fn rmvf(&mut self) -> RMVF_W<24> {
                RMVF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control/status register (RCC_RSTSCKR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rstsckr](index.html) module
        pub struct RSTSCKR_SPEC;
        impl crate::RegisterSpec for RSTSCKR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rstsckr::R](R) reader structure
        impl crate::Readable for RSTSCKR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rstsckr::W](W) writer structure
        impl crate::Writable for RSTSCKR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RSTSCKR to value 0x0c00_0000
        impl crate::Resettable for RSTSCKR_SPEC {
            const RESET_VALUE: Self::Ux = 0x0c00_0000;
        }
    }
}
///Extend configuration
pub struct EXTEND {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTEND {}
impl EXTEND {
    ///Pointer to the register block
    pub const PTR: *const extend::RegisterBlock = 0x4002_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const extend::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EXTEND {
    type Target = extend::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTEND {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTEND").finish()
    }
}
///Extend configuration
pub mod extend {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Configure the extended control register
        pub extend_ctr: EXTEND_CTR,
        ///0x04 - Configure the extended key register
        pub extend_kr: EXTEND_KR,
    }
    ///EXTEND_CTR (rw) register accessor: an alias for `Reg<EXTEND_CTR_SPEC>`
    pub type EXTEND_CTR = crate::Reg<extend_ctr::EXTEND_CTR_SPEC>;
    ///Configure the extended control register
    pub mod extend_ctr {
        ///Register `EXTEND_CTR` reader
        pub struct R(crate::R<EXTEND_CTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTEND_CTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EXTEND_CTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EXTEND_CTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTEND_CTR` writer
        pub struct W(crate::W<EXTEND_CTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTEND_CTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTEND_CTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTEND_CTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PLL_CFG` reader - Configure the PLL clock delay time
        pub type PLL_CFG_R = crate::FieldReader<u8, u8>;
        ///Field `PLL_CFG` writer - Configure the PLL clock delay time
        pub type PLL_CFG_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTEND_CTR_SPEC, u8, u8, 4, O>;
        ///Field `LOCKUP_EN` reader - LOCKUP_Enable
        pub type LOCKUP_EN_R = crate::BitReader<bool>;
        ///Field `LOCKUP_EN` writer - LOCKUP_Enable
        pub type LOCKUP_EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        ///Field `LOCKUP_RESET` reader - LOCKUP RESET
        pub type LOCKUP_RESET_R = crate::BitReader<bool>;
        ///Field `LOCKUP_RESET` writer - LOCKUP RESET
        pub type LOCKUP_RESET_W<'a, const O: u8> =
            crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        ///Field `LDO_TRIM` reader - LDO_TRIM
        pub type LDO_TRIM_R = crate::BitReader<bool>;
        ///Field `LDO_TRIM` writer - LDO_TRIM
        pub type LDO_TRIM_W<'a, const O: u8> = crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        ///Field `FLASH_CLK_TRIM` reader - FLASH clock trimming
        pub type FLASH_CLK_TRIM_R = crate::FieldReader<u8, u8>;
        ///Field `FLASH_CLK_TRIM` writer - FLASH clock trimming
        pub type FLASH_CLK_TRIM_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTEND_CTR_SPEC, u8, u8, 3, O>;
        ///Field `WR_EN` reader - Control Register write enable
        pub type WR_EN_R = crate::BitReader<bool>;
        ///Field `WR_EN` writer - Control Register write enable
        pub type WR_EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        ///Field `WR_LOCK` reader - Control Register write lock
        pub type WR_LOCK_R = crate::BitReader<bool>;
        ///Field `WR_LOCK` writer - Control Register write lock
        pub type WR_LOCK_W<'a, const O: u8> = crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        ///Field `OPA_EN` reader - OPA Enalbe
        pub type OPA_EN_R = crate::BitReader<bool>;
        ///Field `OPA_EN` writer - OPA Enalbe
        pub type OPA_EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        ///Field `OPA_NSEL` reader - OPA negative end channel selection
        pub type OPA_NSEL_R = crate::BitReader<bool>;
        ///Field `OPA_NSEL` writer - OPA negative end channel selection
        pub type OPA_NSEL_W<'a, const O: u8> = crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        ///Field `OPA_PSEL` reader - OPA positive end channel selection
        pub type OPA_PSEL_R = crate::BitReader<bool>;
        ///Field `OPA_PSEL` writer - OPA positive end channel selection
        pub type OPA_PSEL_W<'a, const O: u8> = crate::BitWriter<'a, u32, EXTEND_CTR_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Configure the PLL clock delay time
            #[inline(always)]
            pub fn pll_cfg(&self) -> PLL_CFG_R {
                PLL_CFG_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 6 - LOCKUP_Enable
            #[inline(always)]
            pub fn lockup_en(&self) -> LOCKUP_EN_R {
                LOCKUP_EN_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - LOCKUP RESET
            #[inline(always)]
            pub fn lockup_reset(&self) -> LOCKUP_RESET_R {
                LOCKUP_RESET_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 10 - LDO_TRIM
            #[inline(always)]
            pub fn ldo_trim(&self) -> LDO_TRIM_R {
                LDO_TRIM_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bits 11:13 - FLASH clock trimming
            #[inline(always)]
            pub fn flash_clk_trim(&self) -> FLASH_CLK_TRIM_R {
                FLASH_CLK_TRIM_R::new(((self.bits >> 11) & 7) as u8)
            }
            ///Bit 14 - Control Register write enable
            #[inline(always)]
            pub fn wr_en(&self) -> WR_EN_R {
                WR_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Control Register write lock
            #[inline(always)]
            pub fn wr_lock(&self) -> WR_LOCK_R {
                WR_LOCK_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - OPA Enalbe
            #[inline(always)]
            pub fn opa_en(&self) -> OPA_EN_R {
                OPA_EN_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - OPA negative end channel selection
            #[inline(always)]
            pub fn opa_nsel(&self) -> OPA_NSEL_R {
                OPA_NSEL_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - OPA positive end channel selection
            #[inline(always)]
            pub fn opa_psel(&self) -> OPA_PSEL_R {
                OPA_PSEL_R::new(((self.bits >> 18) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Configure the PLL clock delay time
            #[inline(always)]
            #[must_use]
            pub fn pll_cfg(&mut self) -> PLL_CFG_W<0> {
                PLL_CFG_W::new(self)
            }
            ///Bit 6 - LOCKUP_Enable
            #[inline(always)]
            #[must_use]
            pub fn lockup_en(&mut self) -> LOCKUP_EN_W<6> {
                LOCKUP_EN_W::new(self)
            }
            ///Bit 7 - LOCKUP RESET
            #[inline(always)]
            #[must_use]
            pub fn lockup_reset(&mut self) -> LOCKUP_RESET_W<7> {
                LOCKUP_RESET_W::new(self)
            }
            ///Bit 10 - LDO_TRIM
            #[inline(always)]
            #[must_use]
            pub fn ldo_trim(&mut self) -> LDO_TRIM_W<10> {
                LDO_TRIM_W::new(self)
            }
            ///Bits 11:13 - FLASH clock trimming
            #[inline(always)]
            #[must_use]
            pub fn flash_clk_trim(&mut self) -> FLASH_CLK_TRIM_W<11> {
                FLASH_CLK_TRIM_W::new(self)
            }
            ///Bit 14 - Control Register write enable
            #[inline(always)]
            #[must_use]
            pub fn wr_en(&mut self) -> WR_EN_W<14> {
                WR_EN_W::new(self)
            }
            ///Bit 15 - Control Register write lock
            #[inline(always)]
            #[must_use]
            pub fn wr_lock(&mut self) -> WR_LOCK_W<15> {
                WR_LOCK_W::new(self)
            }
            ///Bit 16 - OPA Enalbe
            #[inline(always)]
            #[must_use]
            pub fn opa_en(&mut self) -> OPA_EN_W<16> {
                OPA_EN_W::new(self)
            }
            ///Bit 17 - OPA negative end channel selection
            #[inline(always)]
            #[must_use]
            pub fn opa_nsel(&mut self) -> OPA_NSEL_W<17> {
                OPA_NSEL_W::new(self)
            }
            ///Bit 18 - OPA positive end channel selection
            #[inline(always)]
            #[must_use]
            pub fn opa_psel(&mut self) -> OPA_PSEL_W<18> {
                OPA_PSEL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Configure the extended control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [extend_ctr](index.html) module
        pub struct EXTEND_CTR_SPEC;
        impl crate::RegisterSpec for EXTEND_CTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [extend_ctr::R](R) reader structure
        impl crate::Readable for EXTEND_CTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [extend_ctr::W](W) writer structure
        impl crate::Writable for EXTEND_CTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EXTEND_CTR to value 0x40
        impl crate::Resettable for EXTEND_CTR_SPEC {
            const RESET_VALUE: Self::Ux = 0x40;
        }
    }
    ///EXTEND_KR (w) register accessor: an alias for `Reg<EXTEND_KR_SPEC>`
    pub type EXTEND_KR = crate::Reg<extend_kr::EXTEND_KR_SPEC>;
    ///Configure the extended key register
    pub mod extend_kr {
        ///Register `EXTEND_KR` writer
        pub struct W(crate::W<EXTEND_KR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTEND_KR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTEND_KR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTEND_KR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `KEY` writer - Write key value
        pub type KEY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, EXTEND_KR_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - Write key value
            #[inline(always)]
            #[must_use]
            pub fn key(&mut self) -> KEY_W<0> {
                KEY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Configure the extended key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [extend_kr](index.html) module
        pub struct EXTEND_KR_SPEC;
        impl crate::RegisterSpec for EXTEND_KR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [extend_kr::W](W) writer structure
        impl crate::Writable for EXTEND_KR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EXTEND_KR to value 0
        impl crate::Resettable for EXTEND_KR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///General purpose I/O
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_0800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA").finish()
    }
}
///General purpose I/O
pub mod gpioa {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Port configuration register low (GPIOn_CFGLR)
        pub cfglr: CFGLR,
        _reserved1: [u8; 0x04],
        ///0x08 - Port input data register (GPIOn_INDR)
        pub indr: INDR,
        ///0x0c - Port output data register (GPIOn_OUTDR)
        pub outdr: OUTDR,
        ///0x10 - Port bit set/reset register (GPIOn_BSHR)
        pub bshr: BSHR,
        ///0x14 - Port bit reset register (GPIOn_BCR)
        pub bcr: BCR,
        ///0x18 - Port configuration lock register
        pub lckr: LCKR,
    }
    ///CFGLR (rw) register accessor: an alias for `Reg<CFGLR_SPEC>`
    pub type CFGLR = crate::Reg<cfglr::CFGLR_SPEC>;
    ///Port configuration register low (GPIOn_CFGLR)
    pub mod cfglr {
        ///Register `CFGLR` reader
        pub struct R(crate::R<CFGLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGLR` writer
        pub struct W(crate::W<CFGLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MODE0` reader - Port n.0 mode bits
        pub type MODE0_R = crate::FieldReader<u8, u8>;
        ///Field `MODE0` writer - Port n.0 mode bits
        pub type MODE0_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF0` reader - Port n.0 configuration bits
        pub type CNF0_R = crate::FieldReader<u8, u8>;
        ///Field `CNF0` writer - Port n.0 configuration bits
        pub type CNF0_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `MODE1` reader - Port n.1 mode bits
        pub type MODE1_R = crate::FieldReader<u8, u8>;
        ///Field `MODE1` writer - Port n.1 mode bits
        pub type MODE1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF1` reader - Port n.1 configuration bits
        pub type CNF1_R = crate::FieldReader<u8, u8>;
        ///Field `CNF1` writer - Port n.1 configuration bits
        pub type CNF1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `MODE2` reader - Port n.2 mode bits
        pub type MODE2_R = crate::FieldReader<u8, u8>;
        ///Field `MODE2` writer - Port n.2 mode bits
        pub type MODE2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF2` reader - Port n.2 configuration bits
        pub type CNF2_R = crate::FieldReader<u8, u8>;
        ///Field `CNF2` writer - Port n.2 configuration bits
        pub type CNF2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `MODE3` reader - Port n.3 mode bits
        pub type MODE3_R = crate::FieldReader<u8, u8>;
        ///Field `MODE3` writer - Port n.3 mode bits
        pub type MODE3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF3` reader - Port n.3 configuration bits
        pub type CNF3_R = crate::FieldReader<u8, u8>;
        ///Field `CNF3` writer - Port n.3 configuration bits
        pub type CNF3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `MODE4` reader - Port n.4 mode bits
        pub type MODE4_R = crate::FieldReader<u8, u8>;
        ///Field `MODE4` writer - Port n.4 mode bits
        pub type MODE4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF4` reader - Port n.4 configuration bits
        pub type CNF4_R = crate::FieldReader<u8, u8>;
        ///Field `CNF4` writer - Port n.4 configuration bits
        pub type CNF4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `MODE5` reader - Port n.5 mode bits
        pub type MODE5_R = crate::FieldReader<u8, u8>;
        ///Field `MODE5` writer - Port n.5 mode bits
        pub type MODE5_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF5` reader - Port n.5 configuration bits
        pub type CNF5_R = crate::FieldReader<u8, u8>;
        ///Field `CNF5` writer - Port n.5 configuration bits
        pub type CNF5_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `MODE6` reader - Port n.6 mode bits
        pub type MODE6_R = crate::FieldReader<u8, u8>;
        ///Field `MODE6` writer - Port n.6 mode bits
        pub type MODE6_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF6` reader - Port n.6 configuration bits
        pub type CNF6_R = crate::FieldReader<u8, u8>;
        ///Field `CNF6` writer - Port n.6 configuration bits
        pub type CNF6_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `MODE7` reader - Port n.7 mode bits
        pub type MODE7_R = crate::FieldReader<u8, u8>;
        ///Field `MODE7` writer - Port n.7 mode bits
        pub type MODE7_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        ///Field `CNF7` reader - Port n.7 configuration bits
        pub type CNF7_R = crate::FieldReader<u8, u8>;
        ///Field `CNF7` writer - Port n.7 configuration bits
        pub type CNF7_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGLR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            pub fn mode0(&self) -> MODE0_R {
                MODE0_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            pub fn cnf0(&self) -> CNF0_R {
                CNF0_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            pub fn cnf1(&self) -> CNF1_R {
                CNF1_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            pub fn cnf2(&self) -> CNF2_R {
                CNF2_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            pub fn cnf3(&self) -> CNF3_R {
                CNF3_R::new(((self.bits >> 14) & 3) as u8)
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            pub fn mode4(&self) -> MODE4_R {
                MODE4_R::new(((self.bits >> 16) & 3) as u8)
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            pub fn cnf4(&self) -> CNF4_R {
                CNF4_R::new(((self.bits >> 18) & 3) as u8)
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            pub fn mode5(&self) -> MODE5_R {
                MODE5_R::new(((self.bits >> 20) & 3) as u8)
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            pub fn cnf5(&self) -> CNF5_R {
                CNF5_R::new(((self.bits >> 22) & 3) as u8)
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            pub fn mode6(&self) -> MODE6_R {
                MODE6_R::new(((self.bits >> 24) & 3) as u8)
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            pub fn cnf6(&self) -> CNF6_R {
                CNF6_R::new(((self.bits >> 26) & 3) as u8)
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            pub fn mode7(&self) -> MODE7_R {
                MODE7_R::new(((self.bits >> 28) & 3) as u8)
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            pub fn cnf7(&self) -> CNF7_R {
                CNF7_R::new(((self.bits >> 30) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode0(&mut self) -> MODE0_W<0> {
                MODE0_W::new(self)
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf0(&mut self) -> CNF0_W<2> {
                CNF0_W::new(self)
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode1(&mut self) -> MODE1_W<4> {
                MODE1_W::new(self)
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf1(&mut self) -> CNF1_W<6> {
                CNF1_W::new(self)
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode2(&mut self) -> MODE2_W<8> {
                MODE2_W::new(self)
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf2(&mut self) -> CNF2_W<10> {
                CNF2_W::new(self)
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode3(&mut self) -> MODE3_W<12> {
                MODE3_W::new(self)
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf3(&mut self) -> CNF3_W<14> {
                CNF3_W::new(self)
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode4(&mut self) -> MODE4_W<16> {
                MODE4_W::new(self)
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf4(&mut self) -> CNF4_W<18> {
                CNF4_W::new(self)
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode5(&mut self) -> MODE5_W<20> {
                MODE5_W::new(self)
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf5(&mut self) -> CNF5_W<22> {
                CNF5_W::new(self)
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode6(&mut self) -> MODE6_W<24> {
                MODE6_W::new(self)
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf6(&mut self) -> CNF6_W<26> {
                CNF6_W::new(self)
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            #[must_use]
            pub fn mode7(&mut self) -> MODE7_W<28> {
                MODE7_W::new(self)
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            #[must_use]
            pub fn cnf7(&mut self) -> CNF7_W<30> {
                CNF7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration register low (GPIOn_CFGLR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfglr](index.html) module
        pub struct CFGLR_SPEC;
        impl crate::RegisterSpec for CFGLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfglr::R](R) reader structure
        impl crate::Readable for CFGLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfglr::W](W) writer structure
        impl crate::Writable for CFGLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGLR to value 0x4444_4444
        impl crate::Resettable for CFGLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x4444_4444;
        }
    }
    ///INDR (r) register accessor: an alias for `Reg<INDR_SPEC>`
    pub type INDR = crate::Reg<indr::INDR_SPEC>;
    ///Port input data register (GPIOn_INDR)
    pub mod indr {
        ///Register `INDR` reader
        pub struct R(crate::R<INDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDR0` reader - Port input data
        pub type IDR0_R = crate::BitReader<bool>;
        ///Field `IDR1` reader - Port input data
        pub type IDR1_R = crate::BitReader<bool>;
        ///Field `IDR2` reader - Port input data
        pub type IDR2_R = crate::BitReader<bool>;
        ///Field `IDR3` reader - Port input data
        pub type IDR3_R = crate::BitReader<bool>;
        ///Field `IDR4` reader - Port input data
        pub type IDR4_R = crate::BitReader<bool>;
        ///Field `IDR5` reader - Port input data
        pub type IDR5_R = crate::BitReader<bool>;
        ///Field `IDR6` reader - Port input data
        pub type IDR6_R = crate::BitReader<bool>;
        ///Field `IDR7` reader - Port input data
        pub type IDR7_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Port input data
            #[inline(always)]
            pub fn idr0(&self) -> IDR0_R {
                IDR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port input data
            #[inline(always)]
            pub fn idr1(&self) -> IDR1_R {
                IDR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port input data
            #[inline(always)]
            pub fn idr2(&self) -> IDR2_R {
                IDR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port input data
            #[inline(always)]
            pub fn idr3(&self) -> IDR3_R {
                IDR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port input data
            #[inline(always)]
            pub fn idr4(&self) -> IDR4_R {
                IDR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port input data
            #[inline(always)]
            pub fn idr5(&self) -> IDR5_R {
                IDR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port input data
            #[inline(always)]
            pub fn idr6(&self) -> IDR6_R {
                IDR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port input data
            #[inline(always)]
            pub fn idr7(&self) -> IDR7_R {
                IDR7_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        ///Port input data register (GPIOn_INDR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [indr](index.html) module
        pub struct INDR_SPEC;
        impl crate::RegisterSpec for INDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [indr::R](R) reader structure
        impl crate::Readable for INDR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets INDR to value 0
        impl crate::Resettable for INDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OUTDR (rw) register accessor: an alias for `Reg<OUTDR_SPEC>`
    pub type OUTDR = crate::Reg<outdr::OUTDR_SPEC>;
    ///Port output data register (GPIOn_OUTDR)
    pub mod outdr {
        ///Register `OUTDR` reader
        pub struct R(crate::R<OUTDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OUTDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OUTDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OUTDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OUTDR` writer
        pub struct W(crate::W<OUTDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OUTDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OUTDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OUTDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ODR0` reader - Port output data
        pub type ODR0_R = crate::BitReader<bool>;
        ///Field `ODR0` writer - Port output data
        pub type ODR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR1` reader - Port output data
        pub type ODR1_R = crate::BitReader<bool>;
        ///Field `ODR1` writer - Port output data
        pub type ODR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR2` reader - Port output data
        pub type ODR2_R = crate::BitReader<bool>;
        ///Field `ODR2` writer - Port output data
        pub type ODR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR3` reader - Port output data
        pub type ODR3_R = crate::BitReader<bool>;
        ///Field `ODR3` writer - Port output data
        pub type ODR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR4` reader - Port output data
        pub type ODR4_R = crate::BitReader<bool>;
        ///Field `ODR4` writer - Port output data
        pub type ODR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR5` reader - Port output data
        pub type ODR5_R = crate::BitReader<bool>;
        ///Field `ODR5` writer - Port output data
        pub type ODR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR6` reader - Port output data
        pub type ODR6_R = crate::BitReader<bool>;
        ///Field `ODR6` writer - Port output data
        pub type ODR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        ///Field `ODR7` reader - Port output data
        pub type ODR7_R = crate::BitReader<bool>;
        ///Field `ODR7` writer - Port output data
        pub type ODR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, OUTDR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Port output data
            #[inline(always)]
            pub fn odr0(&self) -> ODR0_R {
                ODR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            pub fn odr1(&self) -> ODR1_R {
                ODR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            pub fn odr2(&self) -> ODR2_R {
                ODR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            pub fn odr3(&self) -> ODR3_R {
                ODR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            pub fn odr4(&self) -> ODR4_R {
                ODR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            pub fn odr5(&self) -> ODR5_R {
                ODR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            pub fn odr6(&self) -> ODR6_R {
                ODR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            pub fn odr7(&self) -> ODR7_R {
                ODR7_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr0(&mut self) -> ODR0_W<0> {
                ODR0_W::new(self)
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr1(&mut self) -> ODR1_W<1> {
                ODR1_W::new(self)
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr2(&mut self) -> ODR2_W<2> {
                ODR2_W::new(self)
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr3(&mut self) -> ODR3_W<3> {
                ODR3_W::new(self)
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr4(&mut self) -> ODR4_W<4> {
                ODR4_W::new(self)
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr5(&mut self) -> ODR5_W<5> {
                ODR5_W::new(self)
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr6(&mut self) -> ODR6_W<6> {
                ODR6_W::new(self)
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            #[must_use]
            pub fn odr7(&mut self) -> ODR7_W<7> {
                ODR7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port output data register (GPIOn_OUTDR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [outdr](index.html) module
        pub struct OUTDR_SPEC;
        impl crate::RegisterSpec for OUTDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [outdr::R](R) reader structure
        impl crate::Readable for OUTDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [outdr::W](W) writer structure
        impl crate::Writable for OUTDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OUTDR to value 0
        impl crate::Resettable for OUTDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BSHR (w) register accessor: an alias for `Reg<BSHR_SPEC>`
    pub type BSHR = crate::Reg<bshr::BSHR_SPEC>;
    ///Port bit set/reset register (GPIOn_BSHR)
    pub mod bshr {
        ///Register `BSHR` writer
        pub struct W(crate::W<BSHR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BSHR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BSHR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BSHR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BS0` writer - Set bit 0
        pub type BS0_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BS1` writer - Set bit 1
        pub type BS1_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BS2` writer - Set bit 1
        pub type BS2_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BS3` writer - Set bit 3
        pub type BS3_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BS4` writer - Set bit 4
        pub type BS4_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BS5` writer - Set bit 5
        pub type BS5_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BS6` writer - Set bit 6
        pub type BS6_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BS7` writer - Set bit 7
        pub type BS7_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR0` writer - Reset bit 0
        pub type BR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR1` writer - Reset bit 1
        pub type BR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR2` writer - Reset bit 2
        pub type BR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR3` writer - Reset bit 3
        pub type BR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR4` writer - Reset bit 4
        pub type BR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR5` writer - Reset bit 5
        pub type BR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR6` writer - Reset bit 6
        pub type BR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        ///Field `BR7` writer - Reset bit 7
        pub type BR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, BSHR_SPEC, bool, O>;
        impl W {
            ///Bit 0 - Set bit 0
            #[inline(always)]
            #[must_use]
            pub fn bs0(&mut self) -> BS0_W<0> {
                BS0_W::new(self)
            }
            ///Bit 1 - Set bit 1
            #[inline(always)]
            #[must_use]
            pub fn bs1(&mut self) -> BS1_W<1> {
                BS1_W::new(self)
            }
            ///Bit 2 - Set bit 1
            #[inline(always)]
            #[must_use]
            pub fn bs2(&mut self) -> BS2_W<2> {
                BS2_W::new(self)
            }
            ///Bit 3 - Set bit 3
            #[inline(always)]
            #[must_use]
            pub fn bs3(&mut self) -> BS3_W<3> {
                BS3_W::new(self)
            }
            ///Bit 4 - Set bit 4
            #[inline(always)]
            #[must_use]
            pub fn bs4(&mut self) -> BS4_W<4> {
                BS4_W::new(self)
            }
            ///Bit 5 - Set bit 5
            #[inline(always)]
            #[must_use]
            pub fn bs5(&mut self) -> BS5_W<5> {
                BS5_W::new(self)
            }
            ///Bit 6 - Set bit 6
            #[inline(always)]
            #[must_use]
            pub fn bs6(&mut self) -> BS6_W<6> {
                BS6_W::new(self)
            }
            ///Bit 7 - Set bit 7
            #[inline(always)]
            #[must_use]
            pub fn bs7(&mut self) -> BS7_W<7> {
                BS7_W::new(self)
            }
            ///Bit 16 - Reset bit 0
            #[inline(always)]
            #[must_use]
            pub fn br0(&mut self) -> BR0_W<16> {
                BR0_W::new(self)
            }
            ///Bit 17 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br1(&mut self) -> BR1_W<17> {
                BR1_W::new(self)
            }
            ///Bit 18 - Reset bit 2
            #[inline(always)]
            #[must_use]
            pub fn br2(&mut self) -> BR2_W<18> {
                BR2_W::new(self)
            }
            ///Bit 19 - Reset bit 3
            #[inline(always)]
            #[must_use]
            pub fn br3(&mut self) -> BR3_W<19> {
                BR3_W::new(self)
            }
            ///Bit 20 - Reset bit 4
            #[inline(always)]
            #[must_use]
            pub fn br4(&mut self) -> BR4_W<20> {
                BR4_W::new(self)
            }
            ///Bit 21 - Reset bit 5
            #[inline(always)]
            #[must_use]
            pub fn br5(&mut self) -> BR5_W<21> {
                BR5_W::new(self)
            }
            ///Bit 22 - Reset bit 6
            #[inline(always)]
            #[must_use]
            pub fn br6(&mut self) -> BR6_W<22> {
                BR6_W::new(self)
            }
            ///Bit 23 - Reset bit 7
            #[inline(always)]
            #[must_use]
            pub fn br7(&mut self) -> BR7_W<23> {
                BR7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port bit set/reset register (GPIOn_BSHR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bshr](index.html) module
        pub struct BSHR_SPEC;
        impl crate::RegisterSpec for BSHR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [bshr::W](W) writer structure
        impl crate::Writable for BSHR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BSHR to value 0
        impl crate::Resettable for BSHR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BCR (w) register accessor: an alias for `Reg<BCR_SPEC>`
    pub type BCR = crate::Reg<bcr::BCR_SPEC>;
    ///Port bit reset register (GPIOn_BCR)
    pub mod bcr {
        ///Register `BCR` writer
        pub struct W(crate::W<BCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BR0` writer - Reset bit 0
        pub type BR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        ///Field `BR1` writer - Reset bit 1
        pub type BR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        ///Field `BR2` writer - Reset bit 1
        pub type BR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        ///Field `BR3` writer - Reset bit 3
        pub type BR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        ///Field `BR4` writer - Reset bit 4
        pub type BR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        ///Field `BR5` writer - Reset bit 5
        pub type BR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        ///Field `BR6` writer - Reset bit 6
        pub type BR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        ///Field `BR7` writer - Reset bit 7
        pub type BR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, BCR_SPEC, bool, O>;
        impl W {
            ///Bit 0 - Reset bit 0
            #[inline(always)]
            #[must_use]
            pub fn br0(&mut self) -> BR0_W<0> {
                BR0_W::new(self)
            }
            ///Bit 1 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br1(&mut self) -> BR1_W<1> {
                BR1_W::new(self)
            }
            ///Bit 2 - Reset bit 1
            #[inline(always)]
            #[must_use]
            pub fn br2(&mut self) -> BR2_W<2> {
                BR2_W::new(self)
            }
            ///Bit 3 - Reset bit 3
            #[inline(always)]
            #[must_use]
            pub fn br3(&mut self) -> BR3_W<3> {
                BR3_W::new(self)
            }
            ///Bit 4 - Reset bit 4
            #[inline(always)]
            #[must_use]
            pub fn br4(&mut self) -> BR4_W<4> {
                BR4_W::new(self)
            }
            ///Bit 5 - Reset bit 5
            #[inline(always)]
            #[must_use]
            pub fn br5(&mut self) -> BR5_W<5> {
                BR5_W::new(self)
            }
            ///Bit 6 - Reset bit 6
            #[inline(always)]
            #[must_use]
            pub fn br6(&mut self) -> BR6_W<6> {
                BR6_W::new(self)
            }
            ///Bit 7 - Reset bit 7
            #[inline(always)]
            #[must_use]
            pub fn br7(&mut self) -> BR7_W<7> {
                BR7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port bit reset register (GPIOn_BCR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bcr](index.html) module
        pub struct BCR_SPEC;
        impl crate::RegisterSpec for BCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [bcr::W](W) writer structure
        impl crate::Writable for BCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BCR to value 0
        impl crate::Resettable for BCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///LCKR (rw) register accessor: an alias for `Reg<LCKR_SPEC>`
    pub type LCKR = crate::Reg<lckr::LCKR_SPEC>;
    ///Port configuration lock register
    pub mod lckr {
        ///Register `LCKR` reader
        pub struct R(crate::R<LCKR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LCKR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LCKR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `LCKR` writer
        pub struct W(crate::W<LCKR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<LCKR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<LCKR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LCK0` reader - Port A Lock bit 0
        pub type LCK0_R = crate::BitReader<bool>;
        ///Field `LCK0` writer - Port A Lock bit 0
        pub type LCK0_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCK1` reader - Port A Lock bit 1
        pub type LCK1_R = crate::BitReader<bool>;
        ///Field `LCK1` writer - Port A Lock bit 1
        pub type LCK1_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCK2` reader - Port A Lock bit 2
        pub type LCK2_R = crate::BitReader<bool>;
        ///Field `LCK2` writer - Port A Lock bit 2
        pub type LCK2_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCK3` reader - Port A Lock bit 3
        pub type LCK3_R = crate::BitReader<bool>;
        ///Field `LCK3` writer - Port A Lock bit 3
        pub type LCK3_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCK4` reader - Port A Lock bit 4
        pub type LCK4_R = crate::BitReader<bool>;
        ///Field `LCK4` writer - Port A Lock bit 4
        pub type LCK4_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCK5` reader - Port A Lock bit 5
        pub type LCK5_R = crate::BitReader<bool>;
        ///Field `LCK5` writer - Port A Lock bit 5
        pub type LCK5_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCK6` reader - Port A Lock bit 6
        pub type LCK6_R = crate::BitReader<bool>;
        ///Field `LCK6` writer - Port A Lock bit 6
        pub type LCK6_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCK7` reader - Port A Lock bit 7
        pub type LCK7_R = crate::BitReader<bool>;
        ///Field `LCK7` writer - Port A Lock bit 7
        pub type LCK7_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        ///Field `LCKK` reader - Lock key
        pub type LCKK_R = crate::BitReader<bool>;
        ///Field `LCKK` writer - Lock key
        pub type LCKK_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCKR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            pub fn lck0(&self) -> LCK0_R {
                LCK0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            pub fn lck1(&self) -> LCK1_R {
                LCK1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            pub fn lck2(&self) -> LCK2_R {
                LCK2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            pub fn lck3(&self) -> LCK3_R {
                LCK3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            pub fn lck4(&self) -> LCK4_R {
                LCK4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            pub fn lck5(&self) -> LCK5_R {
                LCK5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            pub fn lck6(&self) -> LCK6_R {
                LCK6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            pub fn lck7(&self) -> LCK7_R {
                LCK7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Lock key
            #[inline(always)]
            pub fn lckk(&self) -> LCKK_R {
                LCKK_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            #[must_use]
            pub fn lck0(&mut self) -> LCK0_W<0> {
                LCK0_W::new(self)
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            #[must_use]
            pub fn lck1(&mut self) -> LCK1_W<1> {
                LCK1_W::new(self)
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            #[must_use]
            pub fn lck2(&mut self) -> LCK2_W<2> {
                LCK2_W::new(self)
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            #[must_use]
            pub fn lck3(&mut self) -> LCK3_W<3> {
                LCK3_W::new(self)
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            #[must_use]
            pub fn lck4(&mut self) -> LCK4_W<4> {
                LCK4_W::new(self)
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            #[must_use]
            pub fn lck5(&mut self) -> LCK5_W<5> {
                LCK5_W::new(self)
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            #[must_use]
            pub fn lck6(&mut self) -> LCK6_W<6> {
                LCK6_W::new(self)
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            #[must_use]
            pub fn lck7(&mut self) -> LCK7_W<7> {
                LCK7_W::new(self)
            }
            ///Bit 8 - Lock key
            #[inline(always)]
            #[must_use]
            pub fn lckk(&mut self) -> LCKK_W<8> {
                LCKK_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration lock register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [lckr](index.html) module
        pub struct LCKR_SPEC;
        impl crate::RegisterSpec for LCKR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [lckr::R](R) reader structure
        impl crate::Readable for LCKR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [lckr::W](W) writer structure
        impl crate::Writable for LCKR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets LCKR to value 0
        impl crate::Resettable for LCKR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///General purpose I/O
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOC {}
impl GPIOC {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOC {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOC").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpioc;
///General purpose I/O
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOD {}
impl GPIOD {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOD {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOD").finish()
    }
}
///General purpose I/O
pub use self::gpioa as gpiod;
///Alternate function I/O
pub struct AFIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AFIO {}
impl AFIO {
    ///Pointer to the register block
    pub const PTR: *const afio::RegisterBlock = 0x4001_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const afio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AFIO {
    type Target = afio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AFIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AFIO").finish()
    }
}
///Alternate function I/O
pub mod afio {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x04],
        ///0x04 - AF remap and debug I/O configuration register (AFIO_PCFR)
        pub pcfr: PCFR,
        ///0x08 - External interrupt configuration register (AFIO_EXTICR)
        pub exticr: EXTICR,
    }
    ///PCFR (rw) register accessor: an alias for `Reg<PCFR_SPEC>`
    pub type PCFR = crate::Reg<pcfr::PCFR_SPEC>;
    ///AF remap and debug I/O configuration register (AFIO_PCFR)
    pub mod pcfr {
        ///Register `PCFR` reader
        pub struct R(crate::R<PCFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PCFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PCFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PCFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PCFR` writer
        pub struct W(crate::W<PCFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PCFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PCFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PCFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI1RM` reader - SPI1 remapping
        pub type SPI1RM_R = crate::BitReader<bool>;
        ///Field `SPI1RM` writer - SPI1 remapping
        pub type SPI1RM_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `I2C1RM` reader - I2C1 remapping
        pub type I2C1RM_R = crate::BitReader<bool>;
        ///Field `I2C1RM` writer - I2C1 remapping
        pub type I2C1RM_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `USART1RM` reader - USART1 remapping
        pub type USART1RM_R = crate::BitReader<bool>;
        ///Field `USART1RM` writer - USART1 remapping
        pub type USART1RM_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `TIM1RM` reader - TIM1 remapping
        pub type TIM1RM_R = crate::FieldReader<u8, u8>;
        ///Field `TIM1RM` writer - TIM1 remapping
        pub type TIM1RM_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PCFR_SPEC, u8, u8, 2, O>;
        ///Field `TIM2RM` reader - TIM2 remapping
        pub type TIM2RM_R = crate::FieldReader<u8, u8>;
        ///Field `TIM2RM` writer - TIM2 remapping
        pub type TIM2RM_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PCFR_SPEC, u8, u8, 2, O>;
        ///Field `PA12RM` reader - Port A1/Port A2 mapping on OSCIN/OSCOUT
        pub type PA12RM_R = crate::BitReader<bool>;
        ///Field `PA12RM` writer - Port A1/Port A2 mapping on OSCIN/OSCOUT
        pub type PA12RM_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `ADC1_ETRGINJ_RM` reader - ADC 1 External trigger injected conversion remapping
        pub type ADC1_ETRGINJ_RM_R = crate::BitReader<bool>;
        ///Field `ADC1_ETRGINJ_RM` writer - ADC 1 External trigger injected conversion remapping
        pub type ADC1_ETRGINJ_RM_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `ADC1_ETRGREG_RM` reader - ADC 1 external trigger regular conversion remapping
        pub type ADC1_ETRGREG_RM_R = crate::BitReader<bool>;
        ///Field `ADC1_ETRGREG_RM` writer - ADC 1 external trigger regular conversion remapping
        pub type ADC1_ETRGREG_RM_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `USART1REMAP1` reader - USART1 remapping
        pub type USART1REMAP1_R = crate::BitReader<bool>;
        ///Field `USART1REMAP1` writer - USART1 remapping
        pub type USART1REMAP1_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `I2C1REMAP1` reader - I2C1 remapping
        pub type I2C1REMAP1_R = crate::BitReader<bool>;
        ///Field `I2C1REMAP1` writer - I2C1 remapping
        pub type I2C1REMAP1_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `TIM1_IREMAP` reader - TIM1_CH1 channel selection
        pub type TIM1_IREMAP_R = crate::BitReader<bool>;
        ///Field `TIM1_IREMAP` writer - TIM1_CH1 channel selection
        pub type TIM1_IREMAP_W<'a, const O: u8> = crate::BitWriter<'a, u32, PCFR_SPEC, bool, O>;
        ///Field `SWCFG` writer - Serial wire JTAG configuration
        pub type SWCFG_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PCFR_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            pub fn spi1rm(&self) -> SPI1RM_R {
                SPI1RM_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            pub fn i2c1rm(&self) -> I2C1RM_R {
                I2C1RM_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            pub fn usart1rm(&self) -> USART1RM_R {
                USART1RM_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            pub fn tim1rm(&self) -> TIM1RM_R {
                TIM1RM_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            pub fn tim2rm(&self) -> TIM2RM_R {
                TIM2RM_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 15 - Port A1/Port A2 mapping on OSCIN/OSCOUT
            #[inline(always)]
            pub fn pa12rm(&self) -> PA12RM_R {
                PA12RM_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 17 - ADC 1 External trigger injected conversion remapping
            #[inline(always)]
            pub fn adc1_etrginj_rm(&self) -> ADC1_ETRGINJ_RM_R {
                ADC1_ETRGINJ_RM_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - ADC 1 external trigger regular conversion remapping
            #[inline(always)]
            pub fn adc1_etrgreg_rm(&self) -> ADC1_ETRGREG_RM_R {
                ADC1_ETRGREG_RM_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 21 - USART1 remapping
            #[inline(always)]
            pub fn usart1remap1(&self) -> USART1REMAP1_R {
                USART1REMAP1_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - I2C1 remapping
            #[inline(always)]
            pub fn i2c1remap1(&self) -> I2C1REMAP1_R {
                I2C1REMAP1_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - TIM1_CH1 channel selection
            #[inline(always)]
            pub fn tim1_iremap(&self) -> TIM1_IREMAP_R {
                TIM1_IREMAP_R::new(((self.bits >> 23) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            #[must_use]
            pub fn spi1rm(&mut self) -> SPI1RM_W<0> {
                SPI1RM_W::new(self)
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            #[must_use]
            pub fn i2c1rm(&mut self) -> I2C1RM_W<1> {
                I2C1RM_W::new(self)
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart1rm(&mut self) -> USART1RM_W<2> {
                USART1RM_W::new(self)
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim1rm(&mut self) -> TIM1RM_W<6> {
                TIM1RM_W::new(self)
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            #[must_use]
            pub fn tim2rm(&mut self) -> TIM2RM_W<8> {
                TIM2RM_W::new(self)
            }
            ///Bit 15 - Port A1/Port A2 mapping on OSCIN/OSCOUT
            #[inline(always)]
            #[must_use]
            pub fn pa12rm(&mut self) -> PA12RM_W<15> {
                PA12RM_W::new(self)
            }
            ///Bit 17 - ADC 1 External trigger injected conversion remapping
            #[inline(always)]
            #[must_use]
            pub fn adc1_etrginj_rm(&mut self) -> ADC1_ETRGINJ_RM_W<17> {
                ADC1_ETRGINJ_RM_W::new(self)
            }
            ///Bit 18 - ADC 1 external trigger regular conversion remapping
            #[inline(always)]
            #[must_use]
            pub fn adc1_etrgreg_rm(&mut self) -> ADC1_ETRGREG_RM_W<18> {
                ADC1_ETRGREG_RM_W::new(self)
            }
            ///Bit 21 - USART1 remapping
            #[inline(always)]
            #[must_use]
            pub fn usart1remap1(&mut self) -> USART1REMAP1_W<21> {
                USART1REMAP1_W::new(self)
            }
            ///Bit 22 - I2C1 remapping
            #[inline(always)]
            #[must_use]
            pub fn i2c1remap1(&mut self) -> I2C1REMAP1_W<22> {
                I2C1REMAP1_W::new(self)
            }
            ///Bit 23 - TIM1_CH1 channel selection
            #[inline(always)]
            #[must_use]
            pub fn tim1_iremap(&mut self) -> TIM1_IREMAP_W<23> {
                TIM1_IREMAP_W::new(self)
            }
            ///Bits 24:26 - Serial wire JTAG configuration
            #[inline(always)]
            #[must_use]
            pub fn swcfg(&mut self) -> SWCFG_W<24> {
                SWCFG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AF remap and debug I/O configuration register (AFIO_PCFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pcfr](index.html) module
        pub struct PCFR_SPEC;
        impl crate::RegisterSpec for PCFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pcfr::R](R) reader structure
        impl crate::Readable for PCFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pcfr::W](W) writer structure
        impl crate::Writable for PCFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PCFR to value 0
        impl crate::Resettable for PCFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EXTICR (rw) register accessor: an alias for `Reg<EXTICR_SPEC>`
    pub type EXTICR = crate::Reg<exticr::EXTICR_SPEC>;
    ///External interrupt configuration register (AFIO_EXTICR)
    pub mod exticr {
        ///Register `EXTICR` reader
        pub struct R(crate::R<EXTICR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EXTICR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EXTICR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR` writer
        pub struct W(crate::W<EXTICR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EXTICR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EXTICR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI0` reader - EXTI0 configuration
        pub type EXTI0_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI0` writer - EXTI0 configuration
        pub type EXTI0_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        ///Field `EXTI1` reader - EXTI1 configuration
        pub type EXTI1_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI1` writer - EXTI1 configuration
        pub type EXTI1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        ///Field `EXTI2` reader - EXTI2 configuration
        pub type EXTI2_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI2` writer - EXTI2 configuration
        pub type EXTI2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        ///Field `EXTI3` reader - EXTI3 configuration
        pub type EXTI3_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI3` writer - EXTI3 configuration
        pub type EXTI3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        ///Field `EXTI4` reader - EXTI4 configuration
        pub type EXTI4_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI4` writer - EXTI4 configuration
        pub type EXTI4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        ///Field `EXTI5` reader - EXTI5 configuration
        pub type EXTI5_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI5` writer - EXTI5 configuration
        pub type EXTI5_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        ///Field `EXTI6` reader - EXTI6 configuration
        pub type EXTI6_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI6` writer - EXTI6 configuration
        pub type EXTI6_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        ///Field `EXTI7` reader - EXTI7 configuration
        pub type EXTI7_R = crate::FieldReader<u8, u8>;
        ///Field `EXTI7` writer - EXTI7 configuration
        pub type EXTI7_W<'a, const O: u8> = crate::FieldWriter<'a, u32, EXTICR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:1 - EXTI0 configuration
            #[inline(always)]
            pub fn exti0(&self) -> EXTI0_R {
                EXTI0_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - EXTI1 configuration
            #[inline(always)]
            pub fn exti1(&self) -> EXTI1_R {
                EXTI1_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:5 - EXTI2 configuration
            #[inline(always)]
            pub fn exti2(&self) -> EXTI2_R {
                EXTI2_R::new(((self.bits >> 4) & 3) as u8)
            }
            ///Bits 6:7 - EXTI3 configuration
            #[inline(always)]
            pub fn exti3(&self) -> EXTI3_R {
                EXTI3_R::new(((self.bits >> 6) & 3) as u8)
            }
            ///Bits 8:9 - EXTI4 configuration
            #[inline(always)]
            pub fn exti4(&self) -> EXTI4_R {
                EXTI4_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - EXTI5 configuration
            #[inline(always)]
            pub fn exti5(&self) -> EXTI5_R {
                EXTI5_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - EXTI6 configuration
            #[inline(always)]
            pub fn exti6(&self) -> EXTI6_R {
                EXTI6_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bits 14:15 - EXTI7 configuration
            #[inline(always)]
            pub fn exti7(&self) -> EXTI7_R {
                EXTI7_R::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - EXTI0 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti0(&mut self) -> EXTI0_W<0> {
                EXTI0_W::new(self)
            }
            ///Bits 2:3 - EXTI1 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti1(&mut self) -> EXTI1_W<2> {
                EXTI1_W::new(self)
            }
            ///Bits 4:5 - EXTI2 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti2(&mut self) -> EXTI2_W<4> {
                EXTI2_W::new(self)
            }
            ///Bits 6:7 - EXTI3 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti3(&mut self) -> EXTI3_W<6> {
                EXTI3_W::new(self)
            }
            ///Bits 8:9 - EXTI4 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti4(&mut self) -> EXTI4_W<8> {
                EXTI4_W::new(self)
            }
            ///Bits 10:11 - EXTI5 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti5(&mut self) -> EXTI5_W<10> {
                EXTI5_W::new(self)
            }
            ///Bits 12:13 - EXTI6 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti6(&mut self) -> EXTI6_W<12> {
                EXTI6_W::new(self)
            }
            ///Bits 14:15 - EXTI7 configuration
            #[inline(always)]
            #[must_use]
            pub fn exti7(&mut self) -> EXTI7_W<14> {
                EXTI7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register (AFIO_EXTICR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr](index.html) module
        pub struct EXTICR_SPEC;
        impl crate::RegisterSpec for EXTICR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr::R](R) reader structure
        impl crate::Readable for EXTICR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr::W](W) writer structure
        impl crate::Writable for EXTICR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EXTICR to value 0
        impl crate::Resettable for EXTICR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///EXTI
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTI {}
impl EXTI {
    ///Pointer to the register block
    pub const PTR: *const exti::RegisterBlock = 0x4001_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const exti::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTI").finish()
    }
}
///EXTI
pub mod exti {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Interrupt mask register (EXTI_INTENR)
        pub intenr: INTENR,
        ///0x04 - Event mask register (EXTI_EVENR)
        pub evenr: EVENR,
        ///0x08 - Rising Trigger selection register (EXTI_RTENR)
        pub rtenr: RTENR,
        ///0x0c - Falling Trigger selection register (EXTI_FTENR)
        pub ftenr: FTENR,
        ///0x10 - Software interrupt event register (EXTI_SWIEVR)
        pub swievr: SWIEVR,
        ///0x14 - Pending register (EXTI_INTFR)
        pub intfr: INTFR,
    }
    ///INTENR (rw) register accessor: an alias for `Reg<INTENR_SPEC>`
    pub type INTENR = crate::Reg<intenr::INTENR_SPEC>;
    ///Interrupt mask register (EXTI_INTENR)
    pub mod intenr {
        ///Register `INTENR` reader
        pub struct R(crate::R<INTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTENR` writer
        pub struct W(crate::W<INTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MR0` reader - Interrupt Mask on line 0
        pub type MR0_R = crate::BitReader<bool>;
        ///Field `MR0` writer - Interrupt Mask on line 0
        pub type MR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR1` reader - Interrupt Mask on line 1
        pub type MR1_R = crate::BitReader<bool>;
        ///Field `MR1` writer - Interrupt Mask on line 1
        pub type MR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR2` reader - Interrupt Mask on line 2
        pub type MR2_R = crate::BitReader<bool>;
        ///Field `MR2` writer - Interrupt Mask on line 2
        pub type MR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR3` reader - Interrupt Mask on line 3
        pub type MR3_R = crate::BitReader<bool>;
        ///Field `MR3` writer - Interrupt Mask on line 3
        pub type MR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR4` reader - Interrupt Mask on line 4
        pub type MR4_R = crate::BitReader<bool>;
        ///Field `MR4` writer - Interrupt Mask on line 4
        pub type MR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR5` reader - Interrupt Mask on line 5
        pub type MR5_R = crate::BitReader<bool>;
        ///Field `MR5` writer - Interrupt Mask on line 5
        pub type MR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR6` reader - Interrupt Mask on line 6
        pub type MR6_R = crate::BitReader<bool>;
        ///Field `MR6` writer - Interrupt Mask on line 6
        pub type MR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR7` reader - Interrupt Mask on line 7
        pub type MR7_R = crate::BitReader<bool>;
        ///Field `MR7` writer - Interrupt Mask on line 7
        pub type MR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR8` reader - Interrupt Mask on line 8
        pub type MR8_R = crate::BitReader<bool>;
        ///Field `MR8` writer - Interrupt Mask on line 8
        pub type MR8_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        ///Field `MR9` reader - Interrupt Mask on line 9
        pub type MR9_R = crate::BitReader<bool>;
        ///Field `MR9` writer - Interrupt Mask on line 9
        pub type MR9_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            #[must_use]
            pub fn mr0(&mut self) -> MR0_W<0> {
                MR0_W::new(self)
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            #[must_use]
            pub fn mr1(&mut self) -> MR1_W<1> {
                MR1_W::new(self)
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            #[must_use]
            pub fn mr2(&mut self) -> MR2_W<2> {
                MR2_W::new(self)
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            #[must_use]
            pub fn mr3(&mut self) -> MR3_W<3> {
                MR3_W::new(self)
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            #[must_use]
            pub fn mr4(&mut self) -> MR4_W<4> {
                MR4_W::new(self)
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            #[must_use]
            pub fn mr5(&mut self) -> MR5_W<5> {
                MR5_W::new(self)
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            #[must_use]
            pub fn mr6(&mut self) -> MR6_W<6> {
                MR6_W::new(self)
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            #[must_use]
            pub fn mr7(&mut self) -> MR7_W<7> {
                MR7_W::new(self)
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            #[must_use]
            pub fn mr8(&mut self) -> MR8_W<8> {
                MR8_W::new(self)
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            #[must_use]
            pub fn mr9(&mut self) -> MR9_W<9> {
                MR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt mask register (EXTI_INTENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intenr](index.html) module
        pub struct INTENR_SPEC;
        impl crate::RegisterSpec for INTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intenr::R](R) reader structure
        impl crate::Readable for INTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intenr::W](W) writer structure
        impl crate::Writable for INTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTENR to value 0
        impl crate::Resettable for INTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///EVENR (rw) register accessor: an alias for `Reg<EVENR_SPEC>`
    pub type EVENR = crate::Reg<evenr::EVENR_SPEC>;
    ///Event mask register (EXTI_EVENR)
    pub mod evenr {
        ///Register `EVENR` reader
        pub struct R(crate::R<EVENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EVENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<EVENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<EVENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EVENR` writer
        pub struct W(crate::W<EVENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EVENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<EVENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<EVENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MR0` reader - Event Mask on line 0
        pub type MR0_R = crate::BitReader<bool>;
        ///Field `MR0` writer - Event Mask on line 0
        pub type MR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR1` reader - Event Mask on line 1
        pub type MR1_R = crate::BitReader<bool>;
        ///Field `MR1` writer - Event Mask on line 1
        pub type MR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR2` reader - Event Mask on line 2
        pub type MR2_R = crate::BitReader<bool>;
        ///Field `MR2` writer - Event Mask on line 2
        pub type MR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR3` reader - Event Mask on line 3
        pub type MR3_R = crate::BitReader<bool>;
        ///Field `MR3` writer - Event Mask on line 3
        pub type MR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR4` reader - Event Mask on line 4
        pub type MR4_R = crate::BitReader<bool>;
        ///Field `MR4` writer - Event Mask on line 4
        pub type MR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR5` reader - Event Mask on line 5
        pub type MR5_R = crate::BitReader<bool>;
        ///Field `MR5` writer - Event Mask on line 5
        pub type MR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR6` reader - Event Mask on line 6
        pub type MR6_R = crate::BitReader<bool>;
        ///Field `MR6` writer - Event Mask on line 6
        pub type MR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR7` reader - Event Mask on line 7
        pub type MR7_R = crate::BitReader<bool>;
        ///Field `MR7` writer - Event Mask on line 7
        pub type MR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR8` reader - Event Mask on line 8
        pub type MR8_R = crate::BitReader<bool>;
        ///Field `MR8` writer - Event Mask on line 8
        pub type MR8_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        ///Field `MR9` reader - Event Mask on line 9
        pub type MR9_R = crate::BitReader<bool>;
        ///Field `MR9` writer - Event Mask on line 9
        pub type MR9_W<'a, const O: u8> = crate::BitWriter<'a, u32, EVENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            #[must_use]
            pub fn mr0(&mut self) -> MR0_W<0> {
                MR0_W::new(self)
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            #[must_use]
            pub fn mr1(&mut self) -> MR1_W<1> {
                MR1_W::new(self)
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            #[must_use]
            pub fn mr2(&mut self) -> MR2_W<2> {
                MR2_W::new(self)
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            #[must_use]
            pub fn mr3(&mut self) -> MR3_W<3> {
                MR3_W::new(self)
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            #[must_use]
            pub fn mr4(&mut self) -> MR4_W<4> {
                MR4_W::new(self)
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            #[must_use]
            pub fn mr5(&mut self) -> MR5_W<5> {
                MR5_W::new(self)
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            #[must_use]
            pub fn mr6(&mut self) -> MR6_W<6> {
                MR6_W::new(self)
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            #[must_use]
            pub fn mr7(&mut self) -> MR7_W<7> {
                MR7_W::new(self)
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            #[must_use]
            pub fn mr8(&mut self) -> MR8_W<8> {
                MR8_W::new(self)
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            #[must_use]
            pub fn mr9(&mut self) -> MR9_W<9> {
                MR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Event mask register (EXTI_EVENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [evenr](index.html) module
        pub struct EVENR_SPEC;
        impl crate::RegisterSpec for EVENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [evenr::R](R) reader structure
        impl crate::Readable for EVENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [evenr::W](W) writer structure
        impl crate::Writable for EVENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets EVENR to value 0
        impl crate::Resettable for EVENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RTENR (rw) register accessor: an alias for `Reg<RTENR_SPEC>`
    pub type RTENR = crate::Reg<rtenr::RTENR_SPEC>;
    ///Rising Trigger selection register (EXTI_RTENR)
    pub mod rtenr {
        ///Register `RTENR` reader
        pub struct R(crate::R<RTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTENR` writer
        pub struct W(crate::W<RTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TR0` reader - Rising trigger event configuration of line 0
        pub type TR0_R = crate::BitReader<bool>;
        ///Field `TR0` writer - Rising trigger event configuration of line 0
        pub type TR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR1` reader - Rising trigger event configuration of line 1
        pub type TR1_R = crate::BitReader<bool>;
        ///Field `TR1` writer - Rising trigger event configuration of line 1
        pub type TR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR2` reader - Rising trigger event configuration of line 2
        pub type TR2_R = crate::BitReader<bool>;
        ///Field `TR2` writer - Rising trigger event configuration of line 2
        pub type TR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR3` reader - Rising trigger event configuration of line 3
        pub type TR3_R = crate::BitReader<bool>;
        ///Field `TR3` writer - Rising trigger event configuration of line 3
        pub type TR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR4` reader - Rising trigger event configuration of line 4
        pub type TR4_R = crate::BitReader<bool>;
        ///Field `TR4` writer - Rising trigger event configuration of line 4
        pub type TR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR5` reader - Rising trigger event configuration of line 5
        pub type TR5_R = crate::BitReader<bool>;
        ///Field `TR5` writer - Rising trigger event configuration of line 5
        pub type TR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR6` reader - Rising trigger event configuration of line 6
        pub type TR6_R = crate::BitReader<bool>;
        ///Field `TR6` writer - Rising trigger event configuration of line 6
        pub type TR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR7` reader - Rising trigger event configuration of line 7
        pub type TR7_R = crate::BitReader<bool>;
        ///Field `TR7` writer - Rising trigger event configuration of line 7
        pub type TR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR8` reader - Rising trigger event configuration of line 8
        pub type TR8_R = crate::BitReader<bool>;
        ///Field `TR8` writer - Rising trigger event configuration of line 8
        pub type TR8_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        ///Field `TR9` reader - Rising trigger event configuration of line 9
        pub type TR9_R = crate::BitReader<bool>;
        ///Field `TR9` writer - Rising trigger event configuration of line 9
        pub type TR9_W<'a, const O: u8> = crate::BitWriter<'a, u32, RTENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            #[must_use]
            pub fn tr0(&mut self) -> TR0_W<0> {
                TR0_W::new(self)
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            #[must_use]
            pub fn tr1(&mut self) -> TR1_W<1> {
                TR1_W::new(self)
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            #[must_use]
            pub fn tr2(&mut self) -> TR2_W<2> {
                TR2_W::new(self)
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            #[must_use]
            pub fn tr3(&mut self) -> TR3_W<3> {
                TR3_W::new(self)
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            #[must_use]
            pub fn tr4(&mut self) -> TR4_W<4> {
                TR4_W::new(self)
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            #[must_use]
            pub fn tr5(&mut self) -> TR5_W<5> {
                TR5_W::new(self)
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            #[must_use]
            pub fn tr6(&mut self) -> TR6_W<6> {
                TR6_W::new(self)
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            #[must_use]
            pub fn tr7(&mut self) -> TR7_W<7> {
                TR7_W::new(self)
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            #[must_use]
            pub fn tr8(&mut self) -> TR8_W<8> {
                TR8_W::new(self)
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            #[must_use]
            pub fn tr9(&mut self) -> TR9_W<9> {
                TR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Rising Trigger selection register (EXTI_RTENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtenr](index.html) module
        pub struct RTENR_SPEC;
        impl crate::RegisterSpec for RTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rtenr::R](R) reader structure
        impl crate::Readable for RTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtenr::W](W) writer structure
        impl crate::Writable for RTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RTENR to value 0
        impl crate::Resettable for RTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///FTENR (rw) register accessor: an alias for `Reg<FTENR_SPEC>`
    pub type FTENR = crate::Reg<ftenr::FTENR_SPEC>;
    ///Falling Trigger selection register (EXTI_FTENR)
    pub mod ftenr {
        ///Register `FTENR` reader
        pub struct R(crate::R<FTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FTENR` writer
        pub struct W(crate::W<FTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TR0` reader - Falling trigger event configuration of line 0
        pub type TR0_R = crate::BitReader<bool>;
        ///Field `TR0` writer - Falling trigger event configuration of line 0
        pub type TR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR1` reader - Falling trigger event configuration of line 1
        pub type TR1_R = crate::BitReader<bool>;
        ///Field `TR1` writer - Falling trigger event configuration of line 1
        pub type TR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR2` reader - Falling trigger event configuration of line 2
        pub type TR2_R = crate::BitReader<bool>;
        ///Field `TR2` writer - Falling trigger event configuration of line 2
        pub type TR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR3` reader - Falling trigger event configuration of line 3
        pub type TR3_R = crate::BitReader<bool>;
        ///Field `TR3` writer - Falling trigger event configuration of line 3
        pub type TR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR4` reader - Falling trigger event configuration of line 4
        pub type TR4_R = crate::BitReader<bool>;
        ///Field `TR4` writer - Falling trigger event configuration of line 4
        pub type TR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR5` reader - Falling trigger event configuration of line 5
        pub type TR5_R = crate::BitReader<bool>;
        ///Field `TR5` writer - Falling trigger event configuration of line 5
        pub type TR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR6` reader - Falling trigger event configuration of line 6
        pub type TR6_R = crate::BitReader<bool>;
        ///Field `TR6` writer - Falling trigger event configuration of line 6
        pub type TR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR7` reader - Falling trigger event configuration of line 7
        pub type TR7_R = crate::BitReader<bool>;
        ///Field `TR7` writer - Falling trigger event configuration of line 7
        pub type TR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR8` reader - Falling trigger event configuration of line 8
        pub type TR8_R = crate::BitReader<bool>;
        ///Field `TR8` writer - Falling trigger event configuration of line 8
        pub type TR8_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        ///Field `TR9` reader - Falling trigger event configuration of line 9
        pub type TR9_R = crate::BitReader<bool>;
        ///Field `TR9` writer - Falling trigger event configuration of line 9
        pub type TR9_W<'a, const O: u8> = crate::BitWriter<'a, u32, FTENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            #[must_use]
            pub fn tr0(&mut self) -> TR0_W<0> {
                TR0_W::new(self)
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            #[must_use]
            pub fn tr1(&mut self) -> TR1_W<1> {
                TR1_W::new(self)
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            #[must_use]
            pub fn tr2(&mut self) -> TR2_W<2> {
                TR2_W::new(self)
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            #[must_use]
            pub fn tr3(&mut self) -> TR3_W<3> {
                TR3_W::new(self)
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            #[must_use]
            pub fn tr4(&mut self) -> TR4_W<4> {
                TR4_W::new(self)
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            #[must_use]
            pub fn tr5(&mut self) -> TR5_W<5> {
                TR5_W::new(self)
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            #[must_use]
            pub fn tr6(&mut self) -> TR6_W<6> {
                TR6_W::new(self)
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            #[must_use]
            pub fn tr7(&mut self) -> TR7_W<7> {
                TR7_W::new(self)
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            #[must_use]
            pub fn tr8(&mut self) -> TR8_W<8> {
                TR8_W::new(self)
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            #[must_use]
            pub fn tr9(&mut self) -> TR9_W<9> {
                TR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Falling Trigger selection register (EXTI_FTENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ftenr](index.html) module
        pub struct FTENR_SPEC;
        impl crate::RegisterSpec for FTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ftenr::R](R) reader structure
        impl crate::Readable for FTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ftenr::W](W) writer structure
        impl crate::Writable for FTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets FTENR to value 0
        impl crate::Resettable for FTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SWIEVR (rw) register accessor: an alias for `Reg<SWIEVR_SPEC>`
    pub type SWIEVR = crate::Reg<swievr::SWIEVR_SPEC>;
    ///Software interrupt event register (EXTI_SWIEVR)
    pub mod swievr {
        ///Register `SWIEVR` reader
        pub struct R(crate::R<SWIEVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SWIEVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SWIEVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SWIEVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SWIEVR` writer
        pub struct W(crate::W<SWIEVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWIEVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SWIEVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SWIEVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SWIER0` reader - Software Interrupt on line 0
        pub type SWIER0_R = crate::BitReader<bool>;
        ///Field `SWIER0` writer - Software Interrupt on line 0
        pub type SWIER0_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER1` reader - Software Interrupt on line 1
        pub type SWIER1_R = crate::BitReader<bool>;
        ///Field `SWIER1` writer - Software Interrupt on line 1
        pub type SWIER1_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER2` reader - Software Interrupt on line 2
        pub type SWIER2_R = crate::BitReader<bool>;
        ///Field `SWIER2` writer - Software Interrupt on line 2
        pub type SWIER2_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER3` reader - Software Interrupt on line 3
        pub type SWIER3_R = crate::BitReader<bool>;
        ///Field `SWIER3` writer - Software Interrupt on line 3
        pub type SWIER3_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER4` reader - Software Interrupt on line 4
        pub type SWIER4_R = crate::BitReader<bool>;
        ///Field `SWIER4` writer - Software Interrupt on line 4
        pub type SWIER4_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER5` reader - Software Interrupt on line 5
        pub type SWIER5_R = crate::BitReader<bool>;
        ///Field `SWIER5` writer - Software Interrupt on line 5
        pub type SWIER5_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER6` reader - Software Interrupt on line 6
        pub type SWIER6_R = crate::BitReader<bool>;
        ///Field `SWIER6` writer - Software Interrupt on line 6
        pub type SWIER6_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER7` reader - Software Interrupt on line 7
        pub type SWIER7_R = crate::BitReader<bool>;
        ///Field `SWIER7` writer - Software Interrupt on line 7
        pub type SWIER7_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER8` reader - Software Interrupt on line 8
        pub type SWIER8_R = crate::BitReader<bool>;
        ///Field `SWIER8` writer - Software Interrupt on line 8
        pub type SWIER8_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        ///Field `SWIER9` reader - Software Interrupt on line 9
        pub type SWIER9_R = crate::BitReader<bool>;
        ///Field `SWIER9` writer - Software Interrupt on line 9
        pub type SWIER9_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWIEVR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            pub fn swier0(&self) -> SWIER0_R {
                SWIER0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            pub fn swier1(&self) -> SWIER1_R {
                SWIER1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            pub fn swier2(&self) -> SWIER2_R {
                SWIER2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            pub fn swier3(&self) -> SWIER3_R {
                SWIER3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            pub fn swier4(&self) -> SWIER4_R {
                SWIER4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            pub fn swier5(&self) -> SWIER5_R {
                SWIER5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            pub fn swier6(&self) -> SWIER6_R {
                SWIER6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            pub fn swier7(&self) -> SWIER7_R {
                SWIER7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            pub fn swier8(&self) -> SWIER8_R {
                SWIER8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            pub fn swier9(&self) -> SWIER9_R {
                SWIER9_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            #[must_use]
            pub fn swier0(&mut self) -> SWIER0_W<0> {
                SWIER0_W::new(self)
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            #[must_use]
            pub fn swier1(&mut self) -> SWIER1_W<1> {
                SWIER1_W::new(self)
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            #[must_use]
            pub fn swier2(&mut self) -> SWIER2_W<2> {
                SWIER2_W::new(self)
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            #[must_use]
            pub fn swier3(&mut self) -> SWIER3_W<3> {
                SWIER3_W::new(self)
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            #[must_use]
            pub fn swier4(&mut self) -> SWIER4_W<4> {
                SWIER4_W::new(self)
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            #[must_use]
            pub fn swier5(&mut self) -> SWIER5_W<5> {
                SWIER5_W::new(self)
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            #[must_use]
            pub fn swier6(&mut self) -> SWIER6_W<6> {
                SWIER6_W::new(self)
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            #[must_use]
            pub fn swier7(&mut self) -> SWIER7_W<7> {
                SWIER7_W::new(self)
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            #[must_use]
            pub fn swier8(&mut self) -> SWIER8_W<8> {
                SWIER8_W::new(self)
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            #[must_use]
            pub fn swier9(&mut self) -> SWIER9_W<9> {
                SWIER9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Software interrupt event register (EXTI_SWIEVR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swievr](index.html) module
        pub struct SWIEVR_SPEC;
        impl crate::RegisterSpec for SWIEVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [swievr::R](R) reader structure
        impl crate::Readable for SWIEVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [swievr::W](W) writer structure
        impl crate::Writable for SWIEVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SWIEVR to value 0
        impl crate::Resettable for SWIEVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFR (rw) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///Pending register (EXTI_INTFR)
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTFR` writer
        pub struct W(crate::W<INTFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PR0` reader - Pending bit 0
        pub type PR0_R = crate::BitReader<bool>;
        ///Field `PR0` writer - Pending bit 0
        pub type PR0_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR1` reader - Pending bit 1
        pub type PR1_R = crate::BitReader<bool>;
        ///Field `PR1` writer - Pending bit 1
        pub type PR1_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR2` reader - Pending bit 2
        pub type PR2_R = crate::BitReader<bool>;
        ///Field `PR2` writer - Pending bit 2
        pub type PR2_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR3` reader - Pending bit 3
        pub type PR3_R = crate::BitReader<bool>;
        ///Field `PR3` writer - Pending bit 3
        pub type PR3_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR4` reader - Pending bit 4
        pub type PR4_R = crate::BitReader<bool>;
        ///Field `PR4` writer - Pending bit 4
        pub type PR4_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR5` reader - Pending bit 5
        pub type PR5_R = crate::BitReader<bool>;
        ///Field `PR5` writer - Pending bit 5
        pub type PR5_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR6` reader - Pending bit 6
        pub type PR6_R = crate::BitReader<bool>;
        ///Field `PR6` writer - Pending bit 6
        pub type PR6_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR7` reader - Pending bit 7
        pub type PR7_R = crate::BitReader<bool>;
        ///Field `PR7` writer - Pending bit 7
        pub type PR7_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR8` reader - Pending bit 8
        pub type PR8_R = crate::BitReader<bool>;
        ///Field `PR8` writer - Pending bit 8
        pub type PR8_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `PR9` reader - Pending bit 9
        pub type PR9_R = crate::BitReader<bool>;
        ///Field `PR9` writer - Pending bit 9
        pub type PR9_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Pending bit 0
            #[inline(always)]
            pub fn pr0(&self) -> PR0_R {
                PR0_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Pending bit 1
            #[inline(always)]
            pub fn pr1(&self) -> PR1_R {
                PR1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Pending bit 2
            #[inline(always)]
            pub fn pr2(&self) -> PR2_R {
                PR2_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Pending bit 3
            #[inline(always)]
            pub fn pr3(&self) -> PR3_R {
                PR3_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Pending bit 4
            #[inline(always)]
            pub fn pr4(&self) -> PR4_R {
                PR4_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Pending bit 5
            #[inline(always)]
            pub fn pr5(&self) -> PR5_R {
                PR5_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Pending bit 6
            #[inline(always)]
            pub fn pr6(&self) -> PR6_R {
                PR6_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Pending bit 7
            #[inline(always)]
            pub fn pr7(&self) -> PR7_R {
                PR7_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Pending bit 8
            #[inline(always)]
            pub fn pr8(&self) -> PR8_R {
                PR8_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Pending bit 9
            #[inline(always)]
            pub fn pr9(&self) -> PR9_R {
                PR9_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Pending bit 0
            #[inline(always)]
            #[must_use]
            pub fn pr0(&mut self) -> PR0_W<0> {
                PR0_W::new(self)
            }
            ///Bit 1 - Pending bit 1
            #[inline(always)]
            #[must_use]
            pub fn pr1(&mut self) -> PR1_W<1> {
                PR1_W::new(self)
            }
            ///Bit 2 - Pending bit 2
            #[inline(always)]
            #[must_use]
            pub fn pr2(&mut self) -> PR2_W<2> {
                PR2_W::new(self)
            }
            ///Bit 3 - Pending bit 3
            #[inline(always)]
            #[must_use]
            pub fn pr3(&mut self) -> PR3_W<3> {
                PR3_W::new(self)
            }
            ///Bit 4 - Pending bit 4
            #[inline(always)]
            #[must_use]
            pub fn pr4(&mut self) -> PR4_W<4> {
                PR4_W::new(self)
            }
            ///Bit 5 - Pending bit 5
            #[inline(always)]
            #[must_use]
            pub fn pr5(&mut self) -> PR5_W<5> {
                PR5_W::new(self)
            }
            ///Bit 6 - Pending bit 6
            #[inline(always)]
            #[must_use]
            pub fn pr6(&mut self) -> PR6_W<6> {
                PR6_W::new(self)
            }
            ///Bit 7 - Pending bit 7
            #[inline(always)]
            #[must_use]
            pub fn pr7(&mut self) -> PR7_W<7> {
                PR7_W::new(self)
            }
            ///Bit 8 - Pending bit 8
            #[inline(always)]
            #[must_use]
            pub fn pr8(&mut self) -> PR8_W<8> {
                PR8_W::new(self)
            }
            ///Bit 9 - Pending bit 9
            #[inline(always)]
            #[must_use]
            pub fn pr9(&mut self) -> PR9_W<9> {
                PR9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Pending register (EXTI_INTFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intfr::W](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///DMA1 controller
pub struct DMA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA1 {}
impl DMA1 {
    ///Pointer to the register block
    pub const PTR: *const dma1::RegisterBlock = 0x4002_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dma1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA1 {
    type Target = dma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA1").finish()
    }
}
///DMA1 controller
pub mod dma1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - DMA interrupt status register (DMA_INTFR)
        pub intfr: INTFR,
        ///0x04 - DMA interrupt flag clear register (DMA_INTFCR)
        pub intfcr: INTFCR,
        ///0x08 - DMA channel configuration register (DMA_CFGR)
        pub cfgr1: CFGR1,
        ///0x0c - DMA channel 1 number of data register
        pub cntr1: CNTR1,
        ///0x10 - DMA channel 1 peripheral address register
        pub paddr1: PADDR1,
        ///0x14 - DMA channel 1 memory address register
        pub maddr1: MADDR1,
        _reserved6: [u8; 0x04],
        ///0x1c - DMA channel configuration register (DMA_CFGR)
        pub cfgr2: CFGR2,
        ///0x20 - DMA channel 2 number of data register
        pub cntr2: CNTR2,
        ///0x24 - DMA channel 2 peripheral address register
        pub paddr2: PADDR2,
        ///0x28 - DMA channel 2 memory address register
        pub maddr2: MADDR2,
        _reserved10: [u8; 0x04],
        ///0x30 - DMA channel configuration register (DMA_CFGR)
        pub cfgr3: CFGR3,
        ///0x34 - DMA channel 3 number of data register
        pub cntr3: CNTR3,
        ///0x38 - DMA channel 3 peripheral address register
        pub paddr3: PADDR3,
        ///0x3c - DMA channel 3 memory address register
        pub maddr3: MADDR3,
        _reserved14: [u8; 0x04],
        ///0x44 - DMA channel configuration register (DMA_CFGR)
        pub cfgr4: CFGR4,
        ///0x48 - DMA channel 4 number of data register
        pub cntr4: CNTR4,
        ///0x4c - DMA channel 4 peripheral address register
        pub paddr4: PADDR4,
        ///0x50 - DMA channel 4 memory address register
        pub maddr4: MADDR4,
        _reserved18: [u8; 0x04],
        ///0x58 - DMA channel configuration register (DMA_CFGR)
        pub cfgr5: CFGR5,
        ///0x5c - DMA channel 5 number of data register
        pub cntr5: CNTR5,
        ///0x60 - DMA channel 5 peripheral address register
        pub paddr5: PADDR5,
        ///0x64 - DMA channel 5 memory address register
        pub maddr5: MADDR5,
        _reserved22: [u8; 0x04],
        ///0x6c - DMA channel configuration register (DMA_CFGR)
        pub cfgr6: CFGR6,
        ///0x70 - DMA channel 6 number of data register
        pub cntr6: CNTR6,
        ///0x74 - DMA channel 6 peripheral address register
        pub paddr6: PADDR6,
        ///0x78 - DMA channel 6 memory address register
        pub maddr6: MADDR6,
        _reserved26: [u8; 0x04],
        ///0x80 - DMA channel configuration register (DMA_CFGR)
        pub cfgr7: CFGR7,
        ///0x84 - DMA channel 7 number of data register
        pub cntr7: CNTR7,
        ///0x88 - DMA channel 7 peripheral address register
        pub paddr7: PADDR7,
        ///0x8c - DMA channel 7 memory address register
        pub maddr7: MADDR7,
    }
    ///INTFR (r) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///DMA interrupt status register (DMA_INTFR)
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `GIF1` reader - Channel 1 Global interrupt flag
        pub type GIF1_R = crate::BitReader<bool>;
        ///Field `TCIF1` reader - Channel 1 Transfer Complete flag
        pub type TCIF1_R = crate::BitReader<bool>;
        ///Field `HTIF1` reader - Channel 1 Half Transfer Complete flag
        pub type HTIF1_R = crate::BitReader<bool>;
        ///Field `TEIF1` reader - Channel 1 Transfer Error flag
        pub type TEIF1_R = crate::BitReader<bool>;
        ///Field `GIF2` reader - Channel 2 Global interrupt flag
        pub type GIF2_R = crate::BitReader<bool>;
        ///Field `TCIF2` reader - Channel 2 Transfer Complete flag
        pub type TCIF2_R = crate::BitReader<bool>;
        ///Field `HTIF2` reader - Channel 2 Half Transfer Complete flag
        pub type HTIF2_R = crate::BitReader<bool>;
        ///Field `TEIF2` reader - Channel 2 Transfer Error flag
        pub type TEIF2_R = crate::BitReader<bool>;
        ///Field `GIF3` reader - Channel 3 Global interrupt flag
        pub type GIF3_R = crate::BitReader<bool>;
        ///Field `TCIF3` reader - Channel 3 Transfer Complete flag
        pub type TCIF3_R = crate::BitReader<bool>;
        ///Field `HTIF3` reader - Channel 3 Half Transfer Complete flag
        pub type HTIF3_R = crate::BitReader<bool>;
        ///Field `TEIF3` reader - Channel 3 Transfer Error flag
        pub type TEIF3_R = crate::BitReader<bool>;
        ///Field `GIF4` reader - Channel 4 Global interrupt flag
        pub type GIF4_R = crate::BitReader<bool>;
        ///Field `TCIF4` reader - Channel 4 Transfer Complete flag
        pub type TCIF4_R = crate::BitReader<bool>;
        ///Field `HTIF4` reader - Channel 4 Half Transfer Complete flag
        pub type HTIF4_R = crate::BitReader<bool>;
        ///Field `TEIF4` reader - Channel 4 Transfer Error flag
        pub type TEIF4_R = crate::BitReader<bool>;
        ///Field `GIF5` reader - Channel 5 Global interrupt flag
        pub type GIF5_R = crate::BitReader<bool>;
        ///Field `TCIF5` reader - Channel 5 Transfer Complete flag
        pub type TCIF5_R = crate::BitReader<bool>;
        ///Field `HTIF5` reader - Channel 5 Half Transfer Complete flag
        pub type HTIF5_R = crate::BitReader<bool>;
        ///Field `TEIF5` reader - Channel 5 Transfer Error flag
        pub type TEIF5_R = crate::BitReader<bool>;
        ///Field `GIF6` reader - Channel 6 Global interrupt flag
        pub type GIF6_R = crate::BitReader<bool>;
        ///Field `TCIF6` reader - Channel 6 Transfer Complete flag
        pub type TCIF6_R = crate::BitReader<bool>;
        ///Field `HTIF6` reader - Channel 6 Half Transfer Complete flag
        pub type HTIF6_R = crate::BitReader<bool>;
        ///Field `TEIF6` reader - Channel 6 Transfer Error flag
        pub type TEIF6_R = crate::BitReader<bool>;
        ///Field `GIF7` reader - Channel 7 Global interrupt flag
        pub type GIF7_R = crate::BitReader<bool>;
        ///Field `TCIF7` reader - Channel 7 Transfer Complete flag
        pub type TCIF7_R = crate::BitReader<bool>;
        ///Field `HTIF7` reader - Channel 7 Half Transfer Complete flag
        pub type HTIF7_R = crate::BitReader<bool>;
        ///Field `TEIF7` reader - Channel 7 Transfer Error flag
        pub type TEIF7_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Channel 1 Global interrupt flag
            #[inline(always)]
            pub fn gif1(&self) -> GIF1_R {
                GIF1_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Channel 1 Transfer Complete flag
            #[inline(always)]
            pub fn tcif1(&self) -> TCIF1_R {
                TCIF1_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Channel 1 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif1(&self) -> HTIF1_R {
                HTIF1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Channel 1 Transfer Error flag
            #[inline(always)]
            pub fn teif1(&self) -> TEIF1_R {
                TEIF1_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Channel 2 Global interrupt flag
            #[inline(always)]
            pub fn gif2(&self) -> GIF2_R {
                GIF2_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Channel 2 Transfer Complete flag
            #[inline(always)]
            pub fn tcif2(&self) -> TCIF2_R {
                TCIF2_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Channel 2 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif2(&self) -> HTIF2_R {
                HTIF2_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Channel 2 Transfer Error flag
            #[inline(always)]
            pub fn teif2(&self) -> TEIF2_R {
                TEIF2_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Channel 3 Global interrupt flag
            #[inline(always)]
            pub fn gif3(&self) -> GIF3_R {
                GIF3_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Channel 3 Transfer Complete flag
            #[inline(always)]
            pub fn tcif3(&self) -> TCIF3_R {
                TCIF3_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Channel 3 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif3(&self) -> HTIF3_R {
                HTIF3_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Channel 3 Transfer Error flag
            #[inline(always)]
            pub fn teif3(&self) -> TEIF3_R {
                TEIF3_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Channel 4 Global interrupt flag
            #[inline(always)]
            pub fn gif4(&self) -> GIF4_R {
                GIF4_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Channel 4 Transfer Complete flag
            #[inline(always)]
            pub fn tcif4(&self) -> TCIF4_R {
                TCIF4_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Channel 4 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif4(&self) -> HTIF4_R {
                HTIF4_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Channel 4 Transfer Error flag
            #[inline(always)]
            pub fn teif4(&self) -> TEIF4_R {
                TEIF4_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Channel 5 Global interrupt flag
            #[inline(always)]
            pub fn gif5(&self) -> GIF5_R {
                GIF5_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Channel 5 Transfer Complete flag
            #[inline(always)]
            pub fn tcif5(&self) -> TCIF5_R {
                TCIF5_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Channel 5 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif5(&self) -> HTIF5_R {
                HTIF5_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Channel 5 Transfer Error flag
            #[inline(always)]
            pub fn teif5(&self) -> TEIF5_R {
                TEIF5_R::new(((self.bits >> 19) & 1) != 0)
            }
            ///Bit 20 - Channel 6 Global interrupt flag
            #[inline(always)]
            pub fn gif6(&self) -> GIF6_R {
                GIF6_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Channel 6 Transfer Complete flag
            #[inline(always)]
            pub fn tcif6(&self) -> TCIF6_R {
                TCIF6_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Channel 6 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif6(&self) -> HTIF6_R {
                HTIF6_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Channel 6 Transfer Error flag
            #[inline(always)]
            pub fn teif6(&self) -> TEIF6_R {
                TEIF6_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bit 24 - Channel 7 Global interrupt flag
            #[inline(always)]
            pub fn gif7(&self) -> GIF7_R {
                GIF7_R::new(((self.bits >> 24) & 1) != 0)
            }
            ///Bit 25 - Channel 7 Transfer Complete flag
            #[inline(always)]
            pub fn tcif7(&self) -> TCIF7_R {
                TCIF7_R::new(((self.bits >> 25) & 1) != 0)
            }
            ///Bit 26 - Channel 7 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif7(&self) -> HTIF7_R {
                HTIF7_R::new(((self.bits >> 26) & 1) != 0)
            }
            ///Bit 27 - Channel 7 Transfer Error flag
            #[inline(always)]
            pub fn teif7(&self) -> TEIF7_R {
                TEIF7_R::new(((self.bits >> 27) & 1) != 0)
            }
        }
        ///DMA interrupt status register (DMA_INTFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFCR (w) register accessor: an alias for `Reg<INTFCR_SPEC>`
    pub type INTFCR = crate::Reg<intfcr::INTFCR_SPEC>;
    ///DMA interrupt flag clear register (DMA_INTFCR)
    pub mod intfcr {
        ///Register `INTFCR` writer
        pub struct W(crate::W<INTFCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CGIF1` writer - Channel 1 Global interrupt clear
        pub type CGIF1_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTCIF1` writer - Channel 1 Transfer Complete clear
        pub type CTCIF1_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CHTIF1` writer - Channel 1 Half Transfer clear
        pub type CHTIF1_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTEIF1` writer - Channel 1 Transfer Error clear
        pub type CTEIF1_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CGIF2` writer - Channel 2 Global interrupt clear
        pub type CGIF2_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTCIF2` writer - Channel 2 Transfer Complete clear
        pub type CTCIF2_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CHTIF2` writer - Channel 2 Half Transfer clear
        pub type CHTIF2_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTEIF2` writer - Channel 2 Transfer Error clear
        pub type CTEIF2_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CGIF3` writer - Channel 3 Global interrupt clear
        pub type CGIF3_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTCIF3` writer - Channel 3 Transfer Complete clear
        pub type CTCIF3_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CHTIF3` writer - Channel 3 Half Transfer clear
        pub type CHTIF3_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTEIF3` writer - Channel 3 Transfer Error clear
        pub type CTEIF3_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CGIF4` writer - Channel 4 Global interrupt clear
        pub type CGIF4_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTCIF4` writer - Channel 4 Transfer Complete clear
        pub type CTCIF4_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CHTIF4` writer - Channel 4 Half Transfer clear
        pub type CHTIF4_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTEIF4` writer - Channel 4 Transfer Error clear
        pub type CTEIF4_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CGIF5` writer - Channel 5 Global interrupt clear
        pub type CGIF5_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTCIF5` writer - Channel 5 Transfer Complete clear
        pub type CTCIF5_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CHTIF5` writer - Channel 5 Half Transfer clear
        pub type CHTIF5_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTEIF5` writer - Channel 5 Transfer Error clear
        pub type CTEIF5_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CGIF6` writer - Channel 6 Global interrupt clear
        pub type CGIF6_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTCIF6` writer - Channel 6 Transfer Complete clear
        pub type CTCIF6_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CHTIF6` writer - Channel 6 Half Transfer clear
        pub type CHTIF6_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTEIF6` writer - Channel 6 Transfer Error clear
        pub type CTEIF6_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CGIF7` writer - Channel 7 Global interrupt clear
        pub type CGIF7_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTCIF7` writer - Channel 7 Transfer Complete clear
        pub type CTCIF7_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CHTIF7` writer - Channel 7 Half Transfer clear
        pub type CHTIF7_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        ///Field `CTEIF7` writer - Channel 7 Transfer Error clear
        pub type CTEIF7_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFCR_SPEC, bool, O>;
        impl W {
            ///Bit 0 - Channel 1 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif1(&mut self) -> CGIF1_W<0> {
                CGIF1_W::new(self)
            }
            ///Bit 1 - Channel 1 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif1(&mut self) -> CTCIF1_W<1> {
                CTCIF1_W::new(self)
            }
            ///Bit 2 - Channel 1 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif1(&mut self) -> CHTIF1_W<2> {
                CHTIF1_W::new(self)
            }
            ///Bit 3 - Channel 1 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif1(&mut self) -> CTEIF1_W<3> {
                CTEIF1_W::new(self)
            }
            ///Bit 4 - Channel 2 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif2(&mut self) -> CGIF2_W<4> {
                CGIF2_W::new(self)
            }
            ///Bit 5 - Channel 2 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif2(&mut self) -> CTCIF2_W<5> {
                CTCIF2_W::new(self)
            }
            ///Bit 6 - Channel 2 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif2(&mut self) -> CHTIF2_W<6> {
                CHTIF2_W::new(self)
            }
            ///Bit 7 - Channel 2 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif2(&mut self) -> CTEIF2_W<7> {
                CTEIF2_W::new(self)
            }
            ///Bit 8 - Channel 3 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif3(&mut self) -> CGIF3_W<8> {
                CGIF3_W::new(self)
            }
            ///Bit 9 - Channel 3 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif3(&mut self) -> CTCIF3_W<9> {
                CTCIF3_W::new(self)
            }
            ///Bit 10 - Channel 3 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif3(&mut self) -> CHTIF3_W<10> {
                CHTIF3_W::new(self)
            }
            ///Bit 11 - Channel 3 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif3(&mut self) -> CTEIF3_W<11> {
                CTEIF3_W::new(self)
            }
            ///Bit 12 - Channel 4 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif4(&mut self) -> CGIF4_W<12> {
                CGIF4_W::new(self)
            }
            ///Bit 13 - Channel 4 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif4(&mut self) -> CTCIF4_W<13> {
                CTCIF4_W::new(self)
            }
            ///Bit 14 - Channel 4 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif4(&mut self) -> CHTIF4_W<14> {
                CHTIF4_W::new(self)
            }
            ///Bit 15 - Channel 4 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif4(&mut self) -> CTEIF4_W<15> {
                CTEIF4_W::new(self)
            }
            ///Bit 16 - Channel 5 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif5(&mut self) -> CGIF5_W<16> {
                CGIF5_W::new(self)
            }
            ///Bit 17 - Channel 5 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif5(&mut self) -> CTCIF5_W<17> {
                CTCIF5_W::new(self)
            }
            ///Bit 18 - Channel 5 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif5(&mut self) -> CHTIF5_W<18> {
                CHTIF5_W::new(self)
            }
            ///Bit 19 - Channel 5 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif5(&mut self) -> CTEIF5_W<19> {
                CTEIF5_W::new(self)
            }
            ///Bit 20 - Channel 6 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif6(&mut self) -> CGIF6_W<20> {
                CGIF6_W::new(self)
            }
            ///Bit 21 - Channel 6 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif6(&mut self) -> CTCIF6_W<21> {
                CTCIF6_W::new(self)
            }
            ///Bit 22 - Channel 6 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif6(&mut self) -> CHTIF6_W<22> {
                CHTIF6_W::new(self)
            }
            ///Bit 23 - Channel 6 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif6(&mut self) -> CTEIF6_W<23> {
                CTEIF6_W::new(self)
            }
            ///Bit 24 - Channel 7 Global interrupt clear
            #[inline(always)]
            #[must_use]
            pub fn cgif7(&mut self) -> CGIF7_W<24> {
                CGIF7_W::new(self)
            }
            ///Bit 25 - Channel 7 Transfer Complete clear
            #[inline(always)]
            #[must_use]
            pub fn ctcif7(&mut self) -> CTCIF7_W<25> {
                CTCIF7_W::new(self)
            }
            ///Bit 26 - Channel 7 Half Transfer clear
            #[inline(always)]
            #[must_use]
            pub fn chtif7(&mut self) -> CHTIF7_W<26> {
                CHTIF7_W::new(self)
            }
            ///Bit 27 - Channel 7 Transfer Error clear
            #[inline(always)]
            #[must_use]
            pub fn cteif7(&mut self) -> CTEIF7_W<27> {
                CTEIF7_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA interrupt flag clear register (DMA_INTFCR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfcr](index.html) module
        pub struct INTFCR_SPEC;
        impl crate::RegisterSpec for INTFCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [intfcr::W](W) writer structure
        impl crate::Writable for INTFCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTFCR to value 0
        impl crate::Resettable for INTFCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR1 (rw) register accessor: an alias for `Reg<CFGR1_SPEC>`
    pub type CFGR1 = crate::Reg<cfgr1::CFGR1_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr1 {
        ///Register `CFGR1` reader
        pub struct R(crate::R<CFGR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR1` writer
        pub struct W(crate::W<CFGR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<bool>;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader<bool>;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader<bool>;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<bool>;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<bool>;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<bool>;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR1_SPEC, u8, u8, 2, O>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR1_SPEC, u8, u8, 2, O>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, u8>;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR1_SPEC, u8, u8, 2, O>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<bool>;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr1](index.html) module
        pub struct CFGR1_SPEC;
        impl crate::RegisterSpec for CFGR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr1::R](R) reader structure
        impl crate::Readable for CFGR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr1::W](W) writer structure
        impl crate::Writable for CFGR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR1 to value 0
        impl crate::Resettable for CFGR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR1 (rw) register accessor: an alias for `Reg<CNTR1_SPEC>`
    pub type CNTR1 = crate::Reg<cntr1::CNTR1_SPEC>;
    ///DMA channel 1 number of data register
    pub mod cntr1 {
        ///Register `CNTR1` reader
        pub struct R(crate::R<CNTR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR1` writer
        pub struct W(crate::W<CNTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR1_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 1 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr1](index.html) module
        pub struct CNTR1_SPEC;
        impl crate::RegisterSpec for CNTR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr1::R](R) reader structure
        impl crate::Readable for CNTR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr1::W](W) writer structure
        impl crate::Writable for CNTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR1 to value 0
        impl crate::Resettable for CNTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR1 (rw) register accessor: an alias for `Reg<PADDR1_SPEC>`
    pub type PADDR1 = crate::Reg<paddr1::PADDR1_SPEC>;
    ///DMA channel 1 peripheral address register
    pub mod paddr1 {
        ///Register `PADDR1` reader
        pub struct R(crate::R<PADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR1` writer
        pub struct W(crate::W<PADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR1_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 1 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr1](index.html) module
        pub struct PADDR1_SPEC;
        impl crate::RegisterSpec for PADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr1::R](R) reader structure
        impl crate::Readable for PADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr1::W](W) writer structure
        impl crate::Writable for PADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR1 to value 0
        impl crate::Resettable for PADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR1 (rw) register accessor: an alias for `Reg<MADDR1_SPEC>`
    pub type MADDR1 = crate::Reg<maddr1::MADDR1_SPEC>;
    ///DMA channel 1 memory address register
    pub mod maddr1 {
        ///Register `MADDR1` reader
        pub struct R(crate::R<MADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR1` writer
        pub struct W(crate::W<MADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR1_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 1 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr1](index.html) module
        pub struct MADDR1_SPEC;
        impl crate::RegisterSpec for MADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr1::R](R) reader structure
        impl crate::Readable for MADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr1::W](W) writer structure
        impl crate::Writable for MADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR1 to value 0
        impl crate::Resettable for MADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR2 (rw) register accessor: an alias for `Reg<CFGR2_SPEC>`
    pub type CFGR2 = crate::Reg<cfgr2::CFGR2_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr2 {
        ///Register `CFGR2` reader
        pub struct R(crate::R<CFGR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR2` writer
        pub struct W(crate::W<CFGR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<bool>;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader<bool>;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader<bool>;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<bool>;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<bool>;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<bool>;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR2_SPEC, u8, u8, 2, O>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR2_SPEC, u8, u8, 2, O>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, u8>;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR2_SPEC, u8, u8, 2, O>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<bool>;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr2](index.html) module
        pub struct CFGR2_SPEC;
        impl crate::RegisterSpec for CFGR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr2::R](R) reader structure
        impl crate::Readable for CFGR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr2::W](W) writer structure
        impl crate::Writable for CFGR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR2 to value 0
        impl crate::Resettable for CFGR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR2 (rw) register accessor: an alias for `Reg<CNTR2_SPEC>`
    pub type CNTR2 = crate::Reg<cntr2::CNTR2_SPEC>;
    ///DMA channel 2 number of data register
    pub mod cntr2 {
        ///Register `CNTR2` reader
        pub struct R(crate::R<CNTR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR2` writer
        pub struct W(crate::W<CNTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR2_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 2 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr2](index.html) module
        pub struct CNTR2_SPEC;
        impl crate::RegisterSpec for CNTR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr2::R](R) reader structure
        impl crate::Readable for CNTR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr2::W](W) writer structure
        impl crate::Writable for CNTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR2 to value 0
        impl crate::Resettable for CNTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR2 (rw) register accessor: an alias for `Reg<PADDR2_SPEC>`
    pub type PADDR2 = crate::Reg<paddr2::PADDR2_SPEC>;
    ///DMA channel 2 peripheral address register
    pub mod paddr2 {
        ///Register `PADDR2` reader
        pub struct R(crate::R<PADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR2` writer
        pub struct W(crate::W<PADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR2_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 2 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr2](index.html) module
        pub struct PADDR2_SPEC;
        impl crate::RegisterSpec for PADDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr2::R](R) reader structure
        impl crate::Readable for PADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr2::W](W) writer structure
        impl crate::Writable for PADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR2 to value 0
        impl crate::Resettable for PADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR2 (rw) register accessor: an alias for `Reg<MADDR2_SPEC>`
    pub type MADDR2 = crate::Reg<maddr2::MADDR2_SPEC>;
    ///DMA channel 2 memory address register
    pub mod maddr2 {
        ///Register `MADDR2` reader
        pub struct R(crate::R<MADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR2` writer
        pub struct W(crate::W<MADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR2_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 2 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr2](index.html) module
        pub struct MADDR2_SPEC;
        impl crate::RegisterSpec for MADDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr2::R](R) reader structure
        impl crate::Readable for MADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr2::W](W) writer structure
        impl crate::Writable for MADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR2 to value 0
        impl crate::Resettable for MADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR3 (rw) register accessor: an alias for `Reg<CFGR3_SPEC>`
    pub type CFGR3 = crate::Reg<cfgr3::CFGR3_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr3 {
        ///Register `CFGR3` reader
        pub struct R(crate::R<CFGR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR3` writer
        pub struct W(crate::W<CFGR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<bool>;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader<bool>;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader<bool>;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<bool>;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<bool>;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<bool>;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR3_SPEC, u8, u8, 2, O>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR3_SPEC, u8, u8, 2, O>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, u8>;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR3_SPEC, u8, u8, 2, O>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<bool>;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR3_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr3](index.html) module
        pub struct CFGR3_SPEC;
        impl crate::RegisterSpec for CFGR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr3::R](R) reader structure
        impl crate::Readable for CFGR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr3::W](W) writer structure
        impl crate::Writable for CFGR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR3 to value 0
        impl crate::Resettable for CFGR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR3 (rw) register accessor: an alias for `Reg<CNTR3_SPEC>`
    pub type CNTR3 = crate::Reg<cntr3::CNTR3_SPEC>;
    ///DMA channel 3 number of data register
    pub mod cntr3 {
        ///Register `CNTR3` reader
        pub struct R(crate::R<CNTR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR3` writer
        pub struct W(crate::W<CNTR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR3_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 3 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr3](index.html) module
        pub struct CNTR3_SPEC;
        impl crate::RegisterSpec for CNTR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr3::R](R) reader structure
        impl crate::Readable for CNTR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr3::W](W) writer structure
        impl crate::Writable for CNTR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR3 to value 0
        impl crate::Resettable for CNTR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR3 (rw) register accessor: an alias for `Reg<PADDR3_SPEC>`
    pub type PADDR3 = crate::Reg<paddr3::PADDR3_SPEC>;
    ///DMA channel 3 peripheral address register
    pub mod paddr3 {
        ///Register `PADDR3` reader
        pub struct R(crate::R<PADDR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR3` writer
        pub struct W(crate::W<PADDR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR3_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 3 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr3](index.html) module
        pub struct PADDR3_SPEC;
        impl crate::RegisterSpec for PADDR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr3::R](R) reader structure
        impl crate::Readable for PADDR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr3::W](W) writer structure
        impl crate::Writable for PADDR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR3 to value 0
        impl crate::Resettable for PADDR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR3 (rw) register accessor: an alias for `Reg<MADDR3_SPEC>`
    pub type MADDR3 = crate::Reg<maddr3::MADDR3_SPEC>;
    ///DMA channel 3 memory address register
    pub mod maddr3 {
        ///Register `MADDR3` reader
        pub struct R(crate::R<MADDR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR3` writer
        pub struct W(crate::W<MADDR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR3_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 3 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr3](index.html) module
        pub struct MADDR3_SPEC;
        impl crate::RegisterSpec for MADDR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr3::R](R) reader structure
        impl crate::Readable for MADDR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr3::W](W) writer structure
        impl crate::Writable for MADDR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR3 to value 0
        impl crate::Resettable for MADDR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR4 (rw) register accessor: an alias for `Reg<CFGR4_SPEC>`
    pub type CFGR4 = crate::Reg<cfgr4::CFGR4_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr4 {
        ///Register `CFGR4` reader
        pub struct R(crate::R<CFGR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR4` writer
        pub struct W(crate::W<CFGR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<bool>;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader<bool>;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader<bool>;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<bool>;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<bool>;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<bool>;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR4_SPEC, u8, u8, 2, O>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR4_SPEC, u8, u8, 2, O>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, u8>;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR4_SPEC, u8, u8, 2, O>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<bool>;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR4_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr4](index.html) module
        pub struct CFGR4_SPEC;
        impl crate::RegisterSpec for CFGR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr4::R](R) reader structure
        impl crate::Readable for CFGR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr4::W](W) writer structure
        impl crate::Writable for CFGR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR4 to value 0
        impl crate::Resettable for CFGR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR4 (rw) register accessor: an alias for `Reg<CNTR4_SPEC>`
    pub type CNTR4 = crate::Reg<cntr4::CNTR4_SPEC>;
    ///DMA channel 4 number of data register
    pub mod cntr4 {
        ///Register `CNTR4` reader
        pub struct R(crate::R<CNTR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR4` writer
        pub struct W(crate::W<CNTR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR4_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 4 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr4](index.html) module
        pub struct CNTR4_SPEC;
        impl crate::RegisterSpec for CNTR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr4::R](R) reader structure
        impl crate::Readable for CNTR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr4::W](W) writer structure
        impl crate::Writable for CNTR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR4 to value 0
        impl crate::Resettable for CNTR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR4 (rw) register accessor: an alias for `Reg<PADDR4_SPEC>`
    pub type PADDR4 = crate::Reg<paddr4::PADDR4_SPEC>;
    ///DMA channel 4 peripheral address register
    pub mod paddr4 {
        ///Register `PADDR4` reader
        pub struct R(crate::R<PADDR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR4` writer
        pub struct W(crate::W<PADDR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR4_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 4 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr4](index.html) module
        pub struct PADDR4_SPEC;
        impl crate::RegisterSpec for PADDR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr4::R](R) reader structure
        impl crate::Readable for PADDR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr4::W](W) writer structure
        impl crate::Writable for PADDR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR4 to value 0
        impl crate::Resettable for PADDR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR4 (rw) register accessor: an alias for `Reg<MADDR4_SPEC>`
    pub type MADDR4 = crate::Reg<maddr4::MADDR4_SPEC>;
    ///DMA channel 4 memory address register
    pub mod maddr4 {
        ///Register `MADDR4` reader
        pub struct R(crate::R<MADDR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR4` writer
        pub struct W(crate::W<MADDR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR4_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 4 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr4](index.html) module
        pub struct MADDR4_SPEC;
        impl crate::RegisterSpec for MADDR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr4::R](R) reader structure
        impl crate::Readable for MADDR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr4::W](W) writer structure
        impl crate::Writable for MADDR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR4 to value 0
        impl crate::Resettable for MADDR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR5 (rw) register accessor: an alias for `Reg<CFGR5_SPEC>`
    pub type CFGR5 = crate::Reg<cfgr5::CFGR5_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr5 {
        ///Register `CFGR5` reader
        pub struct R(crate::R<CFGR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR5` writer
        pub struct W(crate::W<CFGR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<bool>;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader<bool>;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader<bool>;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<bool>;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<bool>;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<bool>;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR5_SPEC, u8, u8, 2, O>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR5_SPEC, u8, u8, 2, O>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, u8>;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR5_SPEC, u8, u8, 2, O>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<bool>;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR5_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr5](index.html) module
        pub struct CFGR5_SPEC;
        impl crate::RegisterSpec for CFGR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr5::R](R) reader structure
        impl crate::Readable for CFGR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr5::W](W) writer structure
        impl crate::Writable for CFGR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR5 to value 0
        impl crate::Resettable for CFGR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR5 (rw) register accessor: an alias for `Reg<CNTR5_SPEC>`
    pub type CNTR5 = crate::Reg<cntr5::CNTR5_SPEC>;
    ///DMA channel 5 number of data register
    pub mod cntr5 {
        ///Register `CNTR5` reader
        pub struct R(crate::R<CNTR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR5` writer
        pub struct W(crate::W<CNTR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR5_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 5 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr5](index.html) module
        pub struct CNTR5_SPEC;
        impl crate::RegisterSpec for CNTR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr5::R](R) reader structure
        impl crate::Readable for CNTR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr5::W](W) writer structure
        impl crate::Writable for CNTR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR5 to value 0
        impl crate::Resettable for CNTR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR5 (rw) register accessor: an alias for `Reg<PADDR5_SPEC>`
    pub type PADDR5 = crate::Reg<paddr5::PADDR5_SPEC>;
    ///DMA channel 5 peripheral address register
    pub mod paddr5 {
        ///Register `PADDR5` reader
        pub struct R(crate::R<PADDR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR5` writer
        pub struct W(crate::W<PADDR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR5_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 5 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr5](index.html) module
        pub struct PADDR5_SPEC;
        impl crate::RegisterSpec for PADDR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr5::R](R) reader structure
        impl crate::Readable for PADDR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr5::W](W) writer structure
        impl crate::Writable for PADDR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR5 to value 0
        impl crate::Resettable for PADDR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR5 (rw) register accessor: an alias for `Reg<MADDR5_SPEC>`
    pub type MADDR5 = crate::Reg<maddr5::MADDR5_SPEC>;
    ///DMA channel 5 memory address register
    pub mod maddr5 {
        ///Register `MADDR5` reader
        pub struct R(crate::R<MADDR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR5` writer
        pub struct W(crate::W<MADDR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR5_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR5_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 5 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr5](index.html) module
        pub struct MADDR5_SPEC;
        impl crate::RegisterSpec for MADDR5_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr5::R](R) reader structure
        impl crate::Readable for MADDR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr5::W](W) writer structure
        impl crate::Writable for MADDR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR5 to value 0
        impl crate::Resettable for MADDR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR6 (rw) register accessor: an alias for `Reg<CFGR6_SPEC>`
    pub type CFGR6 = crate::Reg<cfgr6::CFGR6_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr6 {
        ///Register `CFGR6` reader
        pub struct R(crate::R<CFGR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR6` writer
        pub struct W(crate::W<CFGR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<bool>;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader<bool>;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader<bool>;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<bool>;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<bool>;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<bool>;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR6_SPEC, u8, u8, 2, O>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR6_SPEC, u8, u8, 2, O>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, u8>;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR6_SPEC, u8, u8, 2, O>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<bool>;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR6_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr6](index.html) module
        pub struct CFGR6_SPEC;
        impl crate::RegisterSpec for CFGR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr6::R](R) reader structure
        impl crate::Readable for CFGR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr6::W](W) writer structure
        impl crate::Writable for CFGR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR6 to value 0
        impl crate::Resettable for CFGR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR6 (rw) register accessor: an alias for `Reg<CNTR6_SPEC>`
    pub type CNTR6 = crate::Reg<cntr6::CNTR6_SPEC>;
    ///DMA channel 6 number of data register
    pub mod cntr6 {
        ///Register `CNTR6` reader
        pub struct R(crate::R<CNTR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR6` writer
        pub struct W(crate::W<CNTR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR6_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 6 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr6](index.html) module
        pub struct CNTR6_SPEC;
        impl crate::RegisterSpec for CNTR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr6::R](R) reader structure
        impl crate::Readable for CNTR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr6::W](W) writer structure
        impl crate::Writable for CNTR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR6 to value 0
        impl crate::Resettable for CNTR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR6 (rw) register accessor: an alias for `Reg<PADDR6_SPEC>`
    pub type PADDR6 = crate::Reg<paddr6::PADDR6_SPEC>;
    ///DMA channel 6 peripheral address register
    pub mod paddr6 {
        ///Register `PADDR6` reader
        pub struct R(crate::R<PADDR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR6` writer
        pub struct W(crate::W<PADDR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR6_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 6 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr6](index.html) module
        pub struct PADDR6_SPEC;
        impl crate::RegisterSpec for PADDR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr6::R](R) reader structure
        impl crate::Readable for PADDR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr6::W](W) writer structure
        impl crate::Writable for PADDR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR6 to value 0
        impl crate::Resettable for PADDR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR6 (rw) register accessor: an alias for `Reg<MADDR6_SPEC>`
    pub type MADDR6 = crate::Reg<maddr6::MADDR6_SPEC>;
    ///DMA channel 6 memory address register
    pub mod maddr6 {
        ///Register `MADDR6` reader
        pub struct R(crate::R<MADDR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR6` writer
        pub struct W(crate::W<MADDR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR6_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR6_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 6 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr6](index.html) module
        pub struct MADDR6_SPEC;
        impl crate::RegisterSpec for MADDR6_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr6::R](R) reader structure
        impl crate::Readable for MADDR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr6::W](W) writer structure
        impl crate::Writable for MADDR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR6 to value 0
        impl crate::Resettable for MADDR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR7 (rw) register accessor: an alias for `Reg<CFGR7_SPEC>`
    pub type CFGR7 = crate::Reg<cfgr7::CFGR7_SPEC>;
    ///DMA channel configuration register (DMA_CFGR)
    pub mod cfgr7 {
        ///Register `CFGR7` reader
        pub struct R(crate::R<CFGR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR7` writer
        pub struct W(crate::W<CFGR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EN` reader - Channel enable
        pub type EN_R = crate::BitReader<bool>;
        ///Field `EN` writer - Channel enable
        pub type EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `TCIE` reader - Transfer complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transfer complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `HTIE` reader - Half Transfer interrupt enable
        pub type HTIE_R = crate::BitReader<bool>;
        ///Field `HTIE` writer - Half Transfer interrupt enable
        pub type HTIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `TEIE` reader - Transfer error interrupt enable
        pub type TEIE_R = crate::BitReader<bool>;
        ///Field `TEIE` writer - Transfer error interrupt enable
        pub type TEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `DIR` reader - Data transfer direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Data transfer direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `CIRC` reader - Circular mode
        pub type CIRC_R = crate::BitReader<bool>;
        ///Field `CIRC` writer - Circular mode
        pub type CIRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `PINC` reader - Peripheral increment mode
        pub type PINC_R = crate::BitReader<bool>;
        ///Field `PINC` writer - Peripheral increment mode
        pub type PINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `MINC` reader - Memory increment mode
        pub type MINC_R = crate::BitReader<bool>;
        ///Field `MINC` writer - Memory increment mode
        pub type MINC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        ///Field `PSIZE` reader - Peripheral size
        pub type PSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `PSIZE` writer - Peripheral size
        pub type PSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR7_SPEC, u8, u8, 2, O>;
        ///Field `MSIZE` reader - Memory size
        pub type MSIZE_R = crate::FieldReader<u8, u8>;
        ///Field `MSIZE` writer - Memory size
        pub type MSIZE_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR7_SPEC, u8, u8, 2, O>;
        ///Field `PL` reader - Channel Priority level
        pub type PL_R = crate::FieldReader<u8, u8>;
        ///Field `PL` writer - Channel Priority level
        pub type PL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR7_SPEC, u8, u8, 2, O>;
        ///Field `MEM2MEM` reader - Memory to memory mode
        pub type MEM2MEM_R = crate::BitReader<bool>;
        ///Field `MEM2MEM` writer - Memory to memory mode
        pub type MEM2MEM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR7_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Channel enable
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            pub fn htie(&self) -> HTIE_R {
                HTIE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            pub fn teie(&self) -> TEIE_R {
                TEIE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            pub fn circ(&self) -> CIRC_R {
                CIRC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            pub fn pinc(&self) -> PINC_R {
                PINC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            pub fn minc(&self) -> MINC_R {
                MINC_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            pub fn psize(&self) -> PSIZE_R {
                PSIZE_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            pub fn msize(&self) -> MSIZE_R {
                MSIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            pub fn pl(&self) -> PL_R {
                PL_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            pub fn mem2mem(&self) -> MEM2MEM_R {
                MEM2MEM_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Channel enable
            #[inline(always)]
            #[must_use]
            pub fn en(&mut self) -> EN_W<0> {
                EN_W::new(self)
            }
            ///Bit 1 - Transfer complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<1> {
                TCIE_W::new(self)
            }
            ///Bit 2 - Half Transfer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn htie(&mut self) -> HTIE_W<2> {
                HTIE_W::new(self)
            }
            ///Bit 3 - Transfer error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn teie(&mut self) -> TEIE_W<3> {
                TEIE_W::new(self)
            }
            ///Bit 4 - Data transfer direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bit 5 - Circular mode
            #[inline(always)]
            #[must_use]
            pub fn circ(&mut self) -> CIRC_W<5> {
                CIRC_W::new(self)
            }
            ///Bit 6 - Peripheral increment mode
            #[inline(always)]
            #[must_use]
            pub fn pinc(&mut self) -> PINC_W<6> {
                PINC_W::new(self)
            }
            ///Bit 7 - Memory increment mode
            #[inline(always)]
            #[must_use]
            pub fn minc(&mut self) -> MINC_W<7> {
                MINC_W::new(self)
            }
            ///Bits 8:9 - Peripheral size
            #[inline(always)]
            #[must_use]
            pub fn psize(&mut self) -> PSIZE_W<8> {
                PSIZE_W::new(self)
            }
            ///Bits 10:11 - Memory size
            #[inline(always)]
            #[must_use]
            pub fn msize(&mut self) -> MSIZE_W<10> {
                MSIZE_W::new(self)
            }
            ///Bits 12:13 - Channel Priority level
            #[inline(always)]
            #[must_use]
            pub fn pl(&mut self) -> PL_W<12> {
                PL_W::new(self)
            }
            ///Bit 14 - Memory to memory mode
            #[inline(always)]
            #[must_use]
            pub fn mem2mem(&mut self) -> MEM2MEM_W<14> {
                MEM2MEM_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel configuration register (DMA_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr7](index.html) module
        pub struct CFGR7_SPEC;
        impl crate::RegisterSpec for CFGR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr7::R](R) reader structure
        impl crate::Readable for CFGR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr7::W](W) writer structure
        impl crate::Writable for CFGR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR7 to value 0
        impl crate::Resettable for CFGR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNTR7 (rw) register accessor: an alias for `Reg<CNTR7_SPEC>`
    pub type CNTR7 = crate::Reg<cntr7::CNTR7_SPEC>;
    ///DMA channel 7 number of data register
    pub mod cntr7 {
        ///Register `CNTR7` reader
        pub struct R(crate::R<CNTR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNTR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNTR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTR7` writer
        pub struct W(crate::W<CNTR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNTR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNTR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `NDT` reader - Number of data to transfer
        pub type NDT_R = crate::FieldReader<u16, u16>;
        ///Field `NDT` writer - Number of data to transfer
        pub type NDT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNTR7_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            pub fn ndt(&self) -> NDT_R {
                NDT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Number of data to transfer
            #[inline(always)]
            #[must_use]
            pub fn ndt(&mut self) -> NDT_W<0> {
                NDT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 7 number of data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntr7](index.html) module
        pub struct CNTR7_SPEC;
        impl crate::RegisterSpec for CNTR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntr7::R](R) reader structure
        impl crate::Readable for CNTR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntr7::W](W) writer structure
        impl crate::Writable for CNTR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNTR7 to value 0
        impl crate::Resettable for CNTR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PADDR7 (rw) register accessor: an alias for `Reg<PADDR7_SPEC>`
    pub type PADDR7 = crate::Reg<paddr7::PADDR7_SPEC>;
    ///DMA channel 7 peripheral address register
    pub mod paddr7 {
        ///Register `PADDR7` reader
        pub struct R(crate::R<PADDR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PADDR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PADDR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PADDR7` writer
        pub struct W(crate::W<PADDR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PADDR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PADDR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PA` reader - Peripheral address
        pub type PA_R = crate::FieldReader<u32, u32>;
        ///Field `PA` writer - Peripheral address
        pub type PA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PADDR7_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            pub fn pa(&self) -> PA_R {
                PA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Peripheral address
            #[inline(always)]
            #[must_use]
            pub fn pa(&mut self) -> PA_W<0> {
                PA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 7 peripheral address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [paddr7](index.html) module
        pub struct PADDR7_SPEC;
        impl crate::RegisterSpec for PADDR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [paddr7::R](R) reader structure
        impl crate::Readable for PADDR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [paddr7::W](W) writer structure
        impl crate::Writable for PADDR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PADDR7 to value 0
        impl crate::Resettable for PADDR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///MADDR7 (rw) register accessor: an alias for `Reg<MADDR7_SPEC>`
    pub type MADDR7 = crate::Reg<maddr7::MADDR7_SPEC>;
    ///DMA channel 7 memory address register
    pub mod maddr7 {
        ///Register `MADDR7` reader
        pub struct R(crate::R<MADDR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MADDR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MADDR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MADDR7` writer
        pub struct W(crate::W<MADDR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MADDR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MADDR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MADDR7_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MA` reader - Memory address
        pub type MA_R = crate::FieldReader<u32, u32>;
        ///Field `MA` writer - Memory address
        pub type MA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MADDR7_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            pub fn ma(&self) -> MA_R {
                MA_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - Memory address
            #[inline(always)]
            #[must_use]
            pub fn ma(&mut self) -> MA_W<0> {
                MA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA channel 7 memory address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [maddr7](index.html) module
        pub struct MADDR7_SPEC;
        impl crate::RegisterSpec for MADDR7_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [maddr7::R](R) reader structure
        impl crate::Readable for MADDR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [maddr7::W](W) writer structure
        impl crate::Writable for MADDR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MADDR7 to value 0
        impl crate::Resettable for MADDR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Independent watchdog
pub struct IWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IWDG {}
impl IWDG {
    ///Pointer to the register block
    pub const PTR: *const iwdg::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const iwdg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for IWDG {
    type Target = iwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IWDG").finish()
    }
}
///Independent watchdog
pub mod iwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Key register (IWDG_CTLR)
        pub ctlr: CTLR,
        ///0x04 - Prescaler register (IWDG_PSCR)
        pub pscr: PSCR,
        ///0x08 - Reload register (IWDG_RLDR)
        pub rldr: RLDR,
        ///0x0c - Status register (IWDG_SR)
        pub statr: STATR,
    }
    ///CTLR (w) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Key register (IWDG_CTLR)
    pub mod ctlr {
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `KEY` writer - Key value
        pub type KEY_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR_SPEC, u16, u16, 16, O>;
        impl W {
            ///Bits 0:15 - Key value
            #[inline(always)]
            #[must_use]
            pub fn key(&mut self) -> KEY_W<0> {
                KEY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Key register (IWDG_CTLR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PSCR (rw) register accessor: an alias for `Reg<PSCR_SPEC>`
    pub type PSCR = crate::Reg<pscr::PSCR_SPEC>;
    ///Prescaler register (IWDG_PSCR)
    pub mod pscr {
        ///Register `PSCR` reader
        pub struct R(crate::R<PSCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PSCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PSCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSCR` writer
        pub struct W(crate::W<PSCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PR` reader - Prescaler divider
        pub type PR_R = crate::FieldReader<u8, u8>;
        ///Field `PR` writer - Prescaler divider
        pub type PR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PSCR_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            pub fn pr(&self) -> PR_R {
                PR_R::new((self.bits & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            #[must_use]
            pub fn pr(&mut self) -> PR_W<0> {
                PR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Prescaler register (IWDG_PSCR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pscr](index.html) module
        pub struct PSCR_SPEC;
        impl crate::RegisterSpec for PSCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pscr::R](R) reader structure
        impl crate::Readable for PSCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pscr::W](W) writer structure
        impl crate::Writable for PSCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSCR to value 0
        impl crate::Resettable for PSCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RLDR (rw) register accessor: an alias for `Reg<RLDR_SPEC>`
    pub type RLDR = crate::Reg<rldr::RLDR_SPEC>;
    ///Reload register (IWDG_RLDR)
    pub mod rldr {
        ///Register `RLDR` reader
        pub struct R(crate::R<RLDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RLDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RLDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RLDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RLDR` writer
        pub struct W(crate::W<RLDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RLDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RLDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RLDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RL` reader - Watchdog counter reload value
        pub type RL_R = crate::FieldReader<u16, u16>;
        ///Field `RL` writer - Watchdog counter reload value
        pub type RL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RLDR_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            pub fn rl(&self) -> RL_R {
                RL_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            #[must_use]
            pub fn rl(&mut self) -> RL_W<0> {
                RL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Reload register (IWDG_RLDR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rldr](index.html) module
        pub struct RLDR_SPEC;
        impl crate::RegisterSpec for RLDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rldr::R](R) reader structure
        impl crate::Readable for RLDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rldr::W](W) writer structure
        impl crate::Writable for RLDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RLDR to value 0x0fff
        impl crate::Resettable for RLDR_SPEC {
            const RESET_VALUE: Self::Ux = 0x0fff;
        }
    }
    ///STATR (r) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register (IWDG_SR)
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PVU` reader - Watchdog prescaler value update
        pub type PVU_R = crate::BitReader<bool>;
        ///Field `RVU` reader - Watchdog counter reload value update
        pub type RVU_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Watchdog prescaler value update
            #[inline(always)]
            pub fn pvu(&self) -> PVU_R {
                PVU_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Watchdog counter reload value update
            #[inline(always)]
            pub fn rvu(&self) -> RVU_R {
                RVU_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        ///Status register (IWDG_SR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Window watchdog
pub struct WWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDG {}
impl WWDG {
    ///Pointer to the register block
    pub const PTR: *const wwdg::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const wwdg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WWDG {
    type Target = wwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WWDG").finish()
    }
}
///Window watchdog
pub mod wwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register (WWDG_CR)
        pub ctlr: CTLR,
        ///0x04 - Configuration register (WWDG_CFR)
        pub cfgr: CFGR,
        ///0x08 - Status register (WWDG_SR)
        pub statr: STATR,
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register (WWDG_CR)
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `T` reader - 7-bit counter (MSB to LSB)
        pub type T_R = crate::FieldReader<u8, u8>;
        ///Field `T` writer - 7-bit counter (MSB to LSB)
        pub type T_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR_SPEC, u8, u8, 7, O>;
        ///Field `WDGA` reader - Activation bit
        pub type WDGA_R = crate::BitReader<bool>;
        ///Field `WDGA` writer - Activation bit
        pub type WDGA_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            pub fn t(&self) -> T_R {
                T_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            pub fn wdga(&self) -> WDGA_R {
                WDGA_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            #[must_use]
            pub fn t(&mut self) -> T_W<0> {
                T_W::new(self)
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            #[must_use]
            pub fn wdga(&mut self) -> WDGA_W<7> {
                WDGA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register (WWDG_CR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0x7f
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x7f;
        }
    }
    ///CFGR (rw) register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Configuration register (WWDG_CFR)
    pub mod cfgr {
        ///Register `CFGR` reader
        pub struct R(crate::R<CFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `W` reader - 7-bit window value
        pub type W_R = crate::FieldReader<u8, u8>;
        ///Field `W` writer - 7-bit window value
        pub type W_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR_SPEC, u8, u8, 7, O>;
        ///Field `WDGTB` reader - Timer Base
        pub type WDGTB_R = crate::FieldReader<u8, u8>;
        ///Field `WDGTB` writer - Timer Base
        pub type WDGTB_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CFGR_SPEC, u8, u8, 2, O>;
        ///Field `EWI` reader - Early Wakeup Interrupt
        pub type EWI_R = crate::BitReader<bool>;
        ///Field `EWI` writer - Early Wakeup Interrupt
        pub type EWI_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        impl R {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            pub fn w(&self) -> W_R {
                W_R::new((self.bits & 0x7f) as u8)
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            pub fn wdgtb(&self) -> WDGTB_R {
                WDGTB_R::new(((self.bits >> 7) & 3) as u8)
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            pub fn ewi(&self) -> EWI_R {
                EWI_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            #[must_use]
            pub fn w(&mut self) -> W_W<0> {
                W_W::new(self)
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            #[must_use]
            pub fn wdgtb(&mut self) -> WDGTB_W<7> {
                WDGTB_W::new(self)
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            #[must_use]
            pub fn ewi(&mut self) -> EWI_W<9> {
                EWI_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Configuration register (WWDG_CFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr::R](R) reader structure
        impl crate::Readable for CFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR to value 0x7f
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0x7f;
        }
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register (WWDG_SR)
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WEIF` reader - Early Wakeup Interrupt Flag
        pub type WEIF_R = crate::BitReader<bool>;
        ///Field `WEIF` writer - Early Wakeup Interrupt Flag
        pub type WEIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Early Wakeup Interrupt Flag
            #[inline(always)]
            pub fn weif(&self) -> WEIF_R {
                WEIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Early Wakeup Interrupt Flag
            #[inline(always)]
            #[must_use]
            pub fn weif(&mut self) -> WEIF_W<0> {
                WEIF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register (WWDG_SR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Advanced timer
pub struct TIM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM1 {}
impl TIM1 {
    ///Pointer to the register block
    pub const PTR: *const tim1::RegisterBlock = 0x4001_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM1 {
    type Target = tim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM1").finish()
    }
}
///Advanced timer
pub mod tim1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub ctlr1: CTLR1,
        ///0x04 - control register 2
        pub ctlr2: CTLR2,
        ///0x08 - slave mode control register
        pub smcfgr: SMCFGR,
        ///0x0c - DMA/Interrupt enable register
        pub dmaintenr: DMAINTENR,
        ///0x10 - status register
        pub intfr: INTFR,
        ///0x14 - event generation register
        pub swevgr: SWEVGR,
        _reserved_6_chctlr1: [u8; 0x04],
        _reserved_7_chctlr2: [u8; 0x04],
        ///0x20 - capture/compare enable register
        pub ccer: CCER,
        ///0x24 - counter
        pub cnt: CNT,
        ///0x28 - prescaler
        pub psc: PSC,
        ///0x2c - auto-reload register
        pub atrlr: ATRLR,
        ///0x30 - repetition counter register
        pub rptcr: RPTCR,
        ///0x34 - capture/compare register 1
        pub ch1cvr: CH1CVR,
        ///0x38 - capture/compare register 2
        pub ch2cvr: CH2CVR,
        ///0x3c - capture/compare register 3
        pub ch3cvr: CH3CVR,
        ///0x40 - capture/compare register 4
        pub ch4cvr: CH4CVR,
        ///0x44 - break and dead-time register
        pub bdtr: BDTR,
        ///0x48 - DMA control register
        pub dmacfgr: DMACFGR,
        ///0x4c - DMA address for full transfer
        pub dmaadr: DMAADR,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub const fn chctlr1_input(&self) -> &CHCTLR1_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr1_output(&self) -> &CHCTLR1_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub const fn chctlr2_input(&self) -> &CHCTLR2_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
        ///0x1c - capture/compare mode register (output mode)
        #[inline(always)]
        pub const fn chctlr2_output(&self) -> &CHCTLR2_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CEN` reader - Counter enable
        pub type CEN_R = crate::BitReader<bool>;
        ///Field `CEN` writer - Counter enable
        pub type CEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `UDIS` reader - Update disable
        pub type UDIS_R = crate::BitReader<bool>;
        ///Field `UDIS` writer - Update disable
        pub type UDIS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `URS` reader - Update request source
        pub type URS_R = crate::BitReader<bool>;
        ///Field `URS` writer - Update request source
        pub type URS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `OPM` reader - One-pulse mode
        pub type OPM_R = crate::BitReader<bool>;
        ///Field `OPM` writer - One-pulse mode
        pub type OPM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `DIR` reader - Direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `CMS` reader - Center-aligned mode selection
        pub type CMS_R = crate::FieldReader<u8, u8>;
        ///Field `CMS` writer - Center-aligned mode selection
        pub type CMS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 2, O>;
        ///Field `ARPE` reader - Auto-reload preload enable
        pub type ARPE_R = crate::BitReader<bool>;
        ///Field `ARPE` writer - Auto-reload preload enable
        pub type ARPE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `CKD` reader - Clock division
        pub type CKD_R = crate::FieldReader<u8, u8>;
        ///Field `CKD` writer - Clock division
        pub type CKD_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 2, O>;
        ///Field `TMR_CAP_OV_EN` reader - Timer capture value configuration enable
        pub type TMR_CAP_OV_EN_R = crate::BitReader<bool>;
        ///Field `TMR_CAP_OV_EN` writer - Timer capture value configuration enable
        pub type TMR_CAP_OV_EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `TMR_CAP_LVL_EN` reader - Timer capture level indication enable
        pub type TMR_CAP_LVL_EN_R = crate::BitReader<bool>;
        ///Field `TMR_CAP_LVL_EN` writer - Timer capture level indication enable
        pub type TMR_CAP_LVL_EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - Timer capture value configuration enable
            #[inline(always)]
            pub fn tmr_cap_ov_en(&self) -> TMR_CAP_OV_EN_R {
                TMR_CAP_OV_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Timer capture level indication enable
            #[inline(always)]
            pub fn tmr_cap_lvl_en(&self) -> TMR_CAP_LVL_EN_R {
                TMR_CAP_LVL_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            #[must_use]
            pub fn cen(&mut self) -> CEN_W<0> {
                CEN_W::new(self)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            #[must_use]
            pub fn udis(&mut self) -> UDIS_W<1> {
                UDIS_W::new(self)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            #[must_use]
            pub fn urs(&mut self) -> URS_W<2> {
                URS_W::new(self)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            #[must_use]
            pub fn opm(&mut self) -> OPM_W<3> {
                OPM_W::new(self)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            #[must_use]
            pub fn cms(&mut self) -> CMS_W<5> {
                CMS_W::new(self)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn arpe(&mut self) -> ARPE_W<7> {
                ARPE_W::new(self)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            #[must_use]
            pub fn ckd(&mut self) -> CKD_W<8> {
                CKD_W::new(self)
            }
            ///Bit 14 - Timer capture value configuration enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_ov_en(&mut self) -> TMR_CAP_OV_EN_W<14> {
                TMR_CAP_OV_EN_W::new(self)
            }
            ///Bit 15 - Timer capture level indication enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_lvl_en(&mut self) -> TMR_CAP_LVL_EN_W<15> {
                TMR_CAP_LVL_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCPC` reader - Capture/compare preloaded control
        pub type CCPC_R = crate::BitReader<bool>;
        ///Field `CCPC` writer - Capture/compare preloaded control
        pub type CCPC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CCUS` reader - Capture/compare control update selection
        pub type CCUS_R = crate::BitReader<bool>;
        ///Field `CCUS` writer - Capture/compare control update selection
        pub type CCUS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub type CCDS_R = crate::BitReader<bool>;
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub type CCDS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `MMS` reader - Master mode selection
        pub type MMS_R = crate::FieldReader<u8, u8>;
        ///Field `MMS` writer - Master mode selection
        pub type MMS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 3, O>;
        ///Field `TI1S` reader - TI1 selection
        pub type TI1S_R = crate::BitReader<bool>;
        ///Field `TI1S` writer - TI1 selection
        pub type TI1S_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `OIS1` reader - Output Idle state 1
        pub type OIS1_R = crate::BitReader<bool>;
        ///Field `OIS1` writer - Output Idle state 1
        pub type OIS1_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `OIS1N` reader - Output Idle state 1
        pub type OIS1N_R = crate::BitReader<bool>;
        ///Field `OIS1N` writer - Output Idle state 1
        pub type OIS1N_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `OIS2` reader - Output Idle state 2
        pub type OIS2_R = crate::BitReader<bool>;
        ///Field `OIS2` writer - Output Idle state 2
        pub type OIS2_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `OIS2N` reader - Output Idle state 2
        pub type OIS2N_R = crate::BitReader<bool>;
        ///Field `OIS2N` writer - Output Idle state 2
        pub type OIS2N_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `OIS3` reader - Output Idle state 3
        pub type OIS3_R = crate::BitReader<bool>;
        ///Field `OIS3` writer - Output Idle state 3
        pub type OIS3_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `OIS3N` reader - Output Idle state 3
        pub type OIS3N_R = crate::BitReader<bool>;
        ///Field `OIS3N` writer - Output Idle state 3
        pub type OIS3N_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `OIS4` reader - Output Idle state 4
        pub type OIS4_R = crate::BitReader<bool>;
        ///Field `OIS4` writer - Output Idle state 4
        pub type OIS4_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 1) != 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            pub fn ois2n(&self) -> OIS2N_R {
                OIS2N_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            pub fn ois3(&self) -> OIS3_R {
                OIS3_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            pub fn ois3n(&self) -> OIS3N_R {
                OIS3N_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            pub fn ois4(&self) -> OIS4_R {
                OIS4_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            #[must_use]
            pub fn ccpc(&mut self) -> CCPC_W<0> {
                CCPC_W::new(self)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            #[must_use]
            pub fn ccus(&mut self) -> CCUS_W<2> {
                CCUS_W::new(self)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            #[must_use]
            pub fn ccds(&mut self) -> CCDS_W<3> {
                CCDS_W::new(self)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            #[must_use]
            pub fn mms(&mut self) -> MMS_W<4> {
                MMS_W::new(self)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            #[must_use]
            pub fn ti1s(&mut self) -> TI1S_W<7> {
                TI1S_W::new(self)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1(&mut self) -> OIS1_W<8> {
                OIS1_W::new(self)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            #[must_use]
            pub fn ois1n(&mut self) -> OIS1N_W<9> {
                OIS1N_W::new(self)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2(&mut self) -> OIS2_W<10> {
                OIS2_W::new(self)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            #[must_use]
            pub fn ois2n(&mut self) -> OIS2N_W<11> {
                OIS2N_W::new(self)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3(&mut self) -> OIS3_W<12> {
                OIS3_W::new(self)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            #[must_use]
            pub fn ois3n(&mut self) -> OIS3N_W<13> {
                OIS3N_W::new(self)
            }
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            #[must_use]
            pub fn ois4(&mut self) -> OIS4_W<14> {
                OIS4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SMCFGR (rw) register accessor: an alias for `Reg<SMCFGR_SPEC>`
    pub type SMCFGR = crate::Reg<smcfgr::SMCFGR_SPEC>;
    ///slave mode control register
    pub mod smcfgr {
        ///Register `SMCFGR` reader
        pub struct R(crate::R<SMCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SMCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SMCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCFGR` writer
        pub struct W(crate::W<SMCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SMCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SMCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub type SMS_R = crate::FieldReader<u8, u8>;
        ///Field `SMS` writer - Slave mode selection
        pub type SMS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 3, O>;
        ///Field `TS` reader - Trigger selection
        pub type TS_R = crate::FieldReader<u8, u8>;
        ///Field `TS` writer - Trigger selection
        pub type TS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 3, O>;
        ///Field `MSM` reader - Master/Slave mode
        pub type MSM_R = crate::BitReader<bool>;
        ///Field `MSM` writer - Master/Slave mode
        pub type MSM_W<'a, const O: u8> = crate::BitWriter<'a, u32, SMCFGR_SPEC, bool, O>;
        ///Field `ETF` reader - External trigger filter
        pub type ETF_R = crate::FieldReader<u8, u8>;
        ///Field `ETF` writer - External trigger filter
        pub type ETF_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 4, O>;
        ///Field `ETPS` reader - External trigger prescaler
        pub type ETPS_R = crate::FieldReader<u8, u8>;
        ///Field `ETPS` writer - External trigger prescaler
        pub type ETPS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 2, O>;
        ///Field `ECE` reader - External clock enable
        pub type ECE_R = crate::BitReader<bool>;
        ///Field `ECE` writer - External clock enable
        pub type ECE_W<'a, const O: u8> = crate::BitWriter<'a, u32, SMCFGR_SPEC, bool, O>;
        ///Field `ETP` reader - External trigger polarity
        pub type ETP_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 7) as u8)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            #[must_use]
            pub fn sms(&mut self) -> SMS_W<0> {
                SMS_W::new(self)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            #[must_use]
            pub fn ts(&mut self) -> TS_W<4> {
                TS_W::new(self)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            #[must_use]
            pub fn msm(&mut self) -> MSM_W<7> {
                MSM_W::new(self)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            #[must_use]
            pub fn etf(&mut self) -> ETF_W<8> {
                ETF_W::new(self)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            #[must_use]
            pub fn etps(&mut self) -> ETPS_W<12> {
                ETPS_W::new(self)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            #[must_use]
            pub fn ece(&mut self) -> ECE_W<14> {
                ECE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcfgr](index.html) module
        pub struct SMCFGR_SPEC;
        impl crate::RegisterSpec for SMCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smcfgr::R](R) reader structure
        impl crate::Readable for SMCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcfgr::W](W) writer structure
        impl crate::Writable for SMCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SMCFGR to value 0
        impl crate::Resettable for SMCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAINTENR (rw) register accessor: an alias for `Reg<DMAINTENR_SPEC>`
    pub type DMAINTENR = crate::Reg<dmaintenr::DMAINTENR_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dmaintenr {
        ///Register `DMAINTENR` reader
        pub struct R(crate::R<DMAINTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAINTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAINTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAINTENR` writer
        pub struct W(crate::W<DMAINTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAINTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAINTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub type UIE_R = crate::BitReader<bool>;
        ///Field `UIE` writer - Update interrupt enable
        pub type UIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub type CC1IE_R = crate::BitReader<bool>;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub type CC1IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub type CC2IE_R = crate::BitReader<bool>;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub type CC2IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub type CC3IE_R = crate::BitReader<bool>;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub type CC3IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub type CC4IE_R = crate::BitReader<bool>;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub type CC4IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `COMIE` reader - COM interrupt enable
        pub type COMIE_R = crate::BitReader<bool>;
        ///Field `COMIE` writer - COM interrupt enable
        pub type COMIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `TIE` reader - Trigger interrupt enable
        pub type TIE_R = crate::BitReader<bool>;
        ///Field `TIE` writer - Trigger interrupt enable
        pub type TIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `BIE` reader - Break interrupt enable
        pub type BIE_R = crate::BitReader<bool>;
        ///Field `BIE` writer - Break interrupt enable
        pub type BIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `UDE` reader - Update DMA request enable
        pub type UDE_R = crate::BitReader<bool>;
        ///Field `UDE` writer - Update DMA request enable
        pub type UDE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub type CC1DE_R = crate::BitReader<bool>;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub type CC1DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub type CC2DE_R = crate::BitReader<bool>;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub type CC2DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub type CC3DE_R = crate::BitReader<bool>;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub type CC3DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub type CC4DE_R = crate::BitReader<bool>;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub type CC4DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `COMDE` reader - COM DMA request enable
        pub type COMDE_R = crate::BitReader<bool>;
        ///Field `COMDE` writer - COM DMA request enable
        pub type COMDE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `TDE` reader - Trigger DMA request enable
        pub type TDE_R = crate::BitReader<bool>;
        ///Field `TDE` writer - Trigger DMA request enable
        pub type TDE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            pub fn comde(&self) -> COMDE_R {
                COMDE_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn uie(&mut self) -> UIE_W<0> {
                UIE_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ie(&mut self) -> CC1IE_W<1> {
                CC1IE_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ie(&mut self) -> CC2IE_W<2> {
                CC2IE_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ie(&mut self) -> CC3IE_W<3> {
                CC3IE_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc4ie(&mut self) -> CC4IE_W<4> {
                CC4IE_W::new(self)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn comie(&mut self) -> COMIE_W<5> {
                COMIE_W::new(self)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tie(&mut self) -> TIE_W<6> {
                TIE_W::new(self)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn bie(&mut self) -> BIE_W<7> {
                BIE_W::new(self)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn ude(&mut self) -> UDE_W<8> {
                UDE_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc1de(&mut self) -> CC1DE_W<9> {
                CC1DE_W::new(self)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc2de(&mut self) -> CC2DE_W<10> {
                CC2DE_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc3de(&mut self) -> CC3DE_W<11> {
                CC3DE_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc4de(&mut self) -> CC4DE_W<12> {
                CC4DE_W::new(self)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn comde(&mut self) -> COMDE_W<13> {
                COMDE_W::new(self)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn tde(&mut self) -> TDE_W<14> {
                TDE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmaintenr](index.html) module
        pub struct DMAINTENR_SPEC;
        impl crate::RegisterSpec for DMAINTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmaintenr::R](R) reader structure
        impl crate::Readable for DMAINTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmaintenr::W](W) writer structure
        impl crate::Writable for DMAINTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAINTENR to value 0
        impl crate::Resettable for DMAINTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFR (rw) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///status register
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTFR` writer
        pub struct W(crate::W<INTFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub type UIF_R = crate::BitReader<bool>;
        ///Field `UIF` writer - Update interrupt flag
        pub type UIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub type CC1IF_R = crate::BitReader<bool>;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub type CC1IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub type CC2IF_R = crate::BitReader<bool>;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub type CC2IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub type CC3IF_R = crate::BitReader<bool>;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub type CC3IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub type CC4IF_R = crate::BitReader<bool>;
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub type CC4IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `COMIF` reader - COM interrupt flag
        pub type COMIF_R = crate::BitReader<bool>;
        ///Field `COMIF` writer - COM interrupt flag
        pub type COMIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `TIF` reader - Trigger interrupt flag
        pub type TIF_R = crate::BitReader<bool>;
        ///Field `TIF` writer - Trigger interrupt flag
        pub type TIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `BIF` reader - Break interrupt flag
        pub type BIF_R = crate::BitReader<bool>;
        ///Field `BIF` writer - Break interrupt flag
        pub type BIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = crate::BitReader<bool>;
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub type CC1OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub type CC2OF_R = crate::BitReader<bool>;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub type CC2OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub type CC3OF_R = crate::BitReader<bool>;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub type CC3OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub type CC4OF_R = crate::BitReader<bool>;
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub type CC4OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif(&mut self) -> UIF_W<0> {
                UIF_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc1if(&mut self) -> CC1IF_W<1> {
                CC1IF_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc2if(&mut self) -> CC2IF_W<2> {
                CC2IF_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc3if(&mut self) -> CC3IF_W<3> {
                CC3IF_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc4if(&mut self) -> CC4IF_W<4> {
                CC4IF_W::new(self)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn comif(&mut self) -> COMIF_W<5> {
                COMIF_W::new(self)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn tif(&mut self) -> TIF_W<6> {
                TIF_W::new(self)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn bif(&mut self) -> BIF_W<7> {
                BIF_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc1of(&mut self) -> CC1OF_W<9> {
                CC1OF_W::new(self)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc2of(&mut self) -> CC2OF_W<10> {
                CC2OF_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc3of(&mut self) -> CC3OF_W<11> {
                CC3OF_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc4of(&mut self) -> CC4OF_W<12> {
                CC4OF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intfr::W](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SWEVGR (w) register accessor: an alias for `Reg<SWEVGR_SPEC>`
    pub type SWEVGR = crate::Reg<swevgr::SWEVGR_SPEC>;
    ///event generation register
    pub mod swevgr {
        ///Register `SWEVGR` writer
        pub struct W(crate::W<SWEVGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWEVGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SWEVGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SWEVGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UG` writer - Update generation
        pub type UG_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub type CC1G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub type CC2G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub type CC3G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub type CC4G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `COMG` writer - Capture/Compare control update generation
        pub type COMG_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `TG` writer - Trigger generation
        pub type TG_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `BG` writer - Break generation
        pub type BG_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            #[must_use]
            pub fn ug(&mut self) -> UG_W<0> {
                UG_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            #[must_use]
            pub fn cc1g(&mut self) -> CC1G_W<1> {
                CC1G_W::new(self)
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            #[must_use]
            pub fn cc2g(&mut self) -> CC2G_W<2> {
                CC2G_W::new(self)
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            #[must_use]
            pub fn cc3g(&mut self) -> CC3G_W<3> {
                CC3G_W::new(self)
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            #[must_use]
            pub fn cc4g(&mut self) -> CC4G_W<4> {
                CC4G_W::new(self)
            }
            ///Bit 5 - Capture/Compare control update generation
            #[inline(always)]
            #[must_use]
            pub fn comg(&mut self) -> COMG_W<5> {
                COMG_W::new(self)
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            #[must_use]
            pub fn tg(&mut self) -> TG_W<6> {
                TG_W::new(self)
            }
            ///Bit 7 - Break generation
            #[inline(always)]
            #[must_use]
            pub fn bg(&mut self) -> BG_W<7> {
                BG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swevgr](index.html) module
        pub struct SWEVGR_SPEC;
        impl crate::RegisterSpec for SWEVGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [swevgr::W](W) writer structure
        impl crate::Writable for SWEVGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SWEVGR to value 0
        impl crate::Resettable for SWEVGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1_Output (rw) register accessor: an alias for `Reg<CHCTLR1_OUTPUT_SPEC>`
    pub type CHCTLR1_OUTPUT = crate::Reg<chctlr1_output::CHCTLR1_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr1_output {
        ///Register `CHCTLR1_Output` reader
        pub struct R(crate::R<CHCTLR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1_OUTPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1_Output` writer
        pub struct W(crate::W<CHCTLR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1_OUTPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, u8>;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub type OC1FE_R = crate::BitReader<bool>;
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub type OC1FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub type OC1PE_R = crate::BitReader<bool>;
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub type OC1PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC1M` reader - Output Compare 1 mode
        pub type OC1M_R = crate::FieldReader<u8, u8>;
        ///Field `OC1M` writer - Output Compare 1 mode
        pub type OC1M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC1CE` reader - Output Compare 1 clear enable
        pub type OC1CE_R = crate::BitReader<bool>;
        ///Field `OC1CE` writer - Output Compare 1 clear enable
        pub type OC1CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, u8>;
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC2FE` reader - Output Compare 2 fast enable
        pub type OC2FE_R = crate::BitReader<bool>;
        ///Field `OC2FE` writer - Output Compare 2 fast enable
        pub type OC2FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC2PE` reader - Output Compare 2 preload enable
        pub type OC2PE_R = crate::BitReader<bool>;
        ///Field `OC2PE` writer - Output Compare 2 preload enable
        pub type OC2PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC2M` reader - Output Compare 2 mode
        pub type OC2M_R = crate::FieldReader<u8, u8>;
        ///Field `OC2M` writer - Output Compare 2 mode
        pub type OC2M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC2CE` reader - Output Compare 2 clear enable
        pub type OC2CE_R = crate::BitReader<bool>;
        ///Field `OC2CE` writer - Output Compare 2 clear enable
        pub type OC2CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc1fe(&mut self) -> OC1FE_W<2> {
                OC1FE_W::new(self)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc1pe(&mut self) -> OC1PE_W<3> {
                OC1PE_W::new(self)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            #[must_use]
            pub fn oc1m(&mut self) -> OC1M_W<4> {
                OC1M_W::new(self)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc1ce(&mut self) -> OC1CE_W<7> {
                OC1CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc2fe(&mut self) -> OC2FE_W<10> {
                OC2FE_W::new(self)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc2pe(&mut self) -> OC2PE_W<11> {
                OC2PE_W::new(self)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            #[must_use]
            pub fn oc2m(&mut self) -> OC2M_W<12> {
                OC2M_W::new(self)
            }
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc2ce(&mut self) -> OC2CE_W<15> {
                OC2CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1_output](index.html) module
        pub struct CHCTLR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr1_output::R](R) reader structure
        impl crate::Readable for CHCTLR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1_output::W](W) writer structure
        impl crate::Writable for CHCTLR1_OUTPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1_Output to value 0
        impl crate::Resettable for CHCTLR1_OUTPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1_Input (rw) register accessor: an alias for `Reg<CHCTLR1_INPUT_SPEC>`
    pub type CHCTLR1_INPUT = crate::Reg<chctlr1_input::CHCTLR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod chctlr1_input {
        ///Register `CHCTLR1_Input` reader
        pub struct R(crate::R<CHCTLR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1_INPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1_Input` writer
        pub struct W(crate::W<CHCTLR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1_INPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, u8>;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub type IC1PSC_R = crate::FieldReader<u8, u8>;
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub type IC1PSC_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC1F` reader - Input capture 1 filter
        pub type IC1F_R = crate::FieldReader<u8, u8>;
        ///Field `IC1F` writer - Input capture 1 filter
        pub type IC1F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 4, O>;
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, u8>;
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC2PCS` reader - Input capture 2 prescaler
        pub type IC2PCS_R = crate::FieldReader<u8, u8>;
        ///Field `IC2PCS` writer - Input capture 2 prescaler
        pub type IC2PCS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC2F` reader - Input capture 2 filter
        pub type IC2F_R = crate::FieldReader<u8, u8>;
        ///Field `IC2F` writer - Input capture 2 filter
        pub type IC2F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2pcs(&self) -> IC2PCS_R {
                IC2PCS_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic1psc(&mut self) -> IC1PSC_W<2> {
                IC1PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            #[must_use]
            pub fn ic1f(&mut self) -> IC1F_W<4> {
                IC1F_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic2pcs(&mut self) -> IC2PCS_W<10> {
                IC2PCS_W::new(self)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            #[must_use]
            pub fn ic2f(&mut self) -> IC2F_W<12> {
                IC2F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1_input](index.html) module
        pub struct CHCTLR1_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr1_input::R](R) reader structure
        impl crate::Readable for CHCTLR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1_input::W](W) writer structure
        impl crate::Writable for CHCTLR1_INPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1_Input to value 0
        impl crate::Resettable for CHCTLR1_INPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2_Output (rw) register accessor: an alias for `Reg<CHCTLR2_OUTPUT_SPEC>`
    pub type CHCTLR2_OUTPUT = crate::Reg<chctlr2_output::CHCTLR2_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod chctlr2_output {
        ///Register `CHCTLR2_Output` reader
        pub struct R(crate::R<CHCTLR2_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2_OUTPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2_Output` writer
        pub struct W(crate::W<CHCTLR2_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2_OUTPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, u8>;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub type OC3FE_R = crate::BitReader<bool>;
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub type OC3FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub type OC3PE_R = crate::BitReader<bool>;
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub type OC3PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = crate::FieldReader<u8, u8>;
        ///Field `OC3M` writer - Output compare 3 mode
        pub type OC3M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub type OC3CE_R = crate::BitReader<bool>;
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub type OC3CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, u8>;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub type OC4FE_R = crate::BitReader<bool>;
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub type OC4FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub type OC4PE_R = crate::BitReader<bool>;
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub type OC4PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC4M` reader - Output compare 4 mode
        pub type OC4M_R = crate::FieldReader<u8, u8>;
        ///Field `OC4M` writer - Output compare 4 mode
        pub type OC4M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub type OC4CE_R = crate::BitReader<bool>;
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub type OC4CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc3fe(&mut self) -> OC3FE_W<2> {
                OC3FE_W::new(self)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc3pe(&mut self) -> OC3PE_W<3> {
                OC3PE_W::new(self)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            #[must_use]
            pub fn oc3m(&mut self) -> OC3M_W<4> {
                OC3M_W::new(self)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc3ce(&mut self) -> OC3CE_W<7> {
                OC3CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc4fe(&mut self) -> OC4FE_W<10> {
                OC4FE_W::new(self)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc4pe(&mut self) -> OC4PE_W<11> {
                OC4PE_W::new(self)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            #[must_use]
            pub fn oc4m(&mut self) -> OC4M_W<12> {
                OC4M_W::new(self)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc4ce(&mut self) -> OC4CE_W<15> {
                OC4CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2_output](index.html) module
        pub struct CHCTLR2_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr2_output::R](R) reader structure
        impl crate::Readable for CHCTLR2_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2_output::W](W) writer structure
        impl crate::Writable for CHCTLR2_OUTPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2_Output to value 0
        impl crate::Resettable for CHCTLR2_OUTPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2_Input (rw) register accessor: an alias for `Reg<CHCTLR2_INPUT_SPEC>`
    pub type CHCTLR2_INPUT = crate::Reg<chctlr2_input::CHCTLR2_INPUT_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod chctlr2_input {
        ///Register `CHCTLR2_Input` reader
        pub struct R(crate::R<CHCTLR2_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2_INPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2_Input` writer
        pub struct W(crate::W<CHCTLR2_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2_INPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, u8>;
        ///Field `CC3S` writer - Capture/compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub type IC3PSC_R = crate::FieldReader<u8, u8>;
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub type IC3PSC_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC3F` reader - Input capture 3 filter
        pub type IC3F_R = crate::FieldReader<u8, u8>;
        ///Field `IC3F` writer - Input capture 3 filter
        pub type IC3F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 4, O>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, u8>;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub type IC4PSC_R = crate::FieldReader<u8, u8>;
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub type IC4PSC_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC4F` reader - Input capture 4 filter
        pub type IC4F_R = crate::FieldReader<u8, u8>;
        ///Field `IC4F` writer - Input capture 4 filter
        pub type IC4F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic3psc(&mut self) -> IC3PSC_W<2> {
                IC3PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            #[must_use]
            pub fn ic3f(&mut self) -> IC3F_W<4> {
                IC3F_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic4psc(&mut self) -> IC4PSC_W<10> {
                IC4PSC_W::new(self)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            #[must_use]
            pub fn ic4f(&mut self) -> IC4F_W<12> {
                IC4F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2_input](index.html) module
        pub struct CHCTLR2_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr2_input::R](R) reader structure
        impl crate::Readable for CHCTLR2_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2_input::W](W) writer structure
        impl crate::Writable for CHCTLR2_INPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2_Input to value 0
        impl crate::Resettable for CHCTLR2_INPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CCER (rw) register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CCER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CCER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub type CC1E_R = crate::BitReader<bool>;
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub type CC1E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub type CC1P_R = crate::BitReader<bool>;
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub type CC1P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC1NE` reader - Capture/Compare 1 complementary output enable
        pub type CC1NE_R = crate::BitReader<bool>;
        ///Field `CC1NE` writer - Capture/Compare 1 complementary output enable
        pub type CC1NE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub type CC1NP_R = crate::BitReader<bool>;
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub type CC1NP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub type CC2E_R = crate::BitReader<bool>;
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub type CC2E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub type CC2P_R = crate::BitReader<bool>;
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub type CC2P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC2NE` reader - Capture/Compare 2 complementary output enable
        pub type CC2NE_R = crate::BitReader<bool>;
        ///Field `CC2NE` writer - Capture/Compare 2 complementary output enable
        pub type CC2NE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC2NP` reader - Capture/Compare 2 output Polarity
        pub type CC2NP_R = crate::BitReader<bool>;
        ///Field `CC2NP` writer - Capture/Compare 2 output Polarity
        pub type CC2NP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub type CC3E_R = crate::BitReader<bool>;
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub type CC3E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub type CC3P_R = crate::BitReader<bool>;
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub type CC3P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC3NE` reader - Capture/Compare 3 complementary output enable
        pub type CC3NE_R = crate::BitReader<bool>;
        ///Field `CC3NE` writer - Capture/Compare 3 complementary output enable
        pub type CC3NE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC3NP` reader - Capture/Compare 3 output Polarity
        pub type CC3NP_R = crate::BitReader<bool>;
        ///Field `CC3NP` writer - Capture/Compare 3 output Polarity
        pub type CC3NP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub type CC4E_R = crate::BitReader<bool>;
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub type CC4E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub type CC4P_R = crate::BitReader<bool>;
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub type CC4P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            pub fn cc2ne(&self) -> CC2NE_R {
                CC2NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            pub fn cc3ne(&self) -> CC3NE_R {
                CC3NE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3np(&self) -> CC3NP_R {
                CC3NP_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1e(&mut self) -> CC1E_W<0> {
                CC1E_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1p(&mut self) -> CC1P_W<1> {
                CC1P_W::new(self)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ne(&mut self) -> CC1NE_W<2> {
                CC1NE_W::new(self)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1np(&mut self) -> CC1NP_W<3> {
                CC1NP_W::new(self)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2e(&mut self) -> CC2E_W<4> {
                CC2E_W::new(self)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2p(&mut self) -> CC2P_W<5> {
                CC2P_W::new(self)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ne(&mut self) -> CC2NE_W<6> {
                CC2NE_W::new(self)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2np(&mut self) -> CC2NP_W<7> {
                CC2NP_W::new(self)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3e(&mut self) -> CC3E_W<8> {
                CC3E_W::new(self)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3p(&mut self) -> CC3P_W<9> {
                CC3P_W::new(self)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ne(&mut self) -> CC3NE_W<10> {
                CC3NE_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3np(&mut self) -> CC3NP_W<11> {
                CC3NP_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc4e(&mut self) -> CC4E_W<12> {
                CC4E_W::new(self)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc4p(&mut self) -> CC4P_W<13> {
                CC4P_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub type CNT_R = crate::FieldReader<u16, u16>;
        ///Field `CNT` writer - counter value
        pub type CNT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            #[must_use]
            pub fn cnt(&mut self) -> CNT_W<0> {
                CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PSC (rw) register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PSC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u16, u16>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PSC_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<0> {
                PSC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ATRLR (rw) register accessor: an alias for `Reg<ATRLR_SPEC>`
    pub type ATRLR = crate::Reg<atrlr::ATRLR_SPEC>;
    ///auto-reload register
    pub mod atrlr {
        ///Register `ATRLR` reader
        pub struct R(crate::R<ATRLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ATRLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ATRLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ATRLR` writer
        pub struct W(crate::W<ATRLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ATRLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ATRLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ATRLR` reader - Auto-reload value
        pub type ATRLR_R = crate::FieldReader<u16, u16>;
        ///Field `ATRLR` writer - Auto-reload value
        pub type ATRLR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, ATRLR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn atrlr(&self) -> ATRLR_R {
                ATRLR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            #[must_use]
            pub fn atrlr(&mut self) -> ATRLR_W<0> {
                ATRLR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [atrlr](index.html) module
        pub struct ATRLR_SPEC;
        impl crate::RegisterSpec for ATRLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [atrlr::R](R) reader structure
        impl crate::Readable for ATRLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [atrlr::W](W) writer structure
        impl crate::Writable for ATRLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ATRLR to value 0
        impl crate::Resettable for ATRLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RPTCR (rw) register accessor: an alias for `Reg<RPTCR_SPEC>`
    pub type RPTCR = crate::Reg<rptcr::RPTCR_SPEC>;
    ///repetition counter register
    pub mod rptcr {
        ///Register `RPTCR` reader
        pub struct R(crate::R<RPTCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RPTCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RPTCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RPTCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RPTCR` writer
        pub struct W(crate::W<RPTCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RPTCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RPTCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RPTCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RPTCR` reader - Repetition counter value
        pub type RPTCR_R = crate::FieldReader<u8, u8>;
        ///Field `RPTCR` writer - Repetition counter value
        pub type RPTCR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RPTCR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rptcr(&self) -> RPTCR_R {
                RPTCR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            #[must_use]
            pub fn rptcr(&mut self) -> RPTCR_W<0> {
                RPTCR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///repetition counter register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rptcr](index.html) module
        pub struct RPTCR_SPEC;
        impl crate::RegisterSpec for RPTCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rptcr::R](R) reader structure
        impl crate::Readable for RPTCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rptcr::W](W) writer structure
        impl crate::Writable for RPTCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RPTCR to value 0
        impl crate::Resettable for RPTCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH1CVR (rw) register accessor: an alias for `Reg<CH1CVR_SPEC>`
    pub type CH1CVR = crate::Reg<ch1cvr::CH1CVR_SPEC>;
    ///capture/compare register 1
    pub mod ch1cvr {
        ///Register `CH1CVR` reader
        pub struct R(crate::R<CH1CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH1CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH1CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH1CVR` writer
        pub struct W(crate::W<CH1CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH1CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH1CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH1CVR` reader - Capture/Compare 1 value
        pub type CH1CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH1CVR` writer - Capture/Compare 1 value
        pub type CH1CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH1CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ch1cvr(&self) -> CH1CVR_R {
                CH1CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            #[must_use]
            pub fn ch1cvr(&mut self) -> CH1CVR_W<0> {
                CH1CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch1cvr](index.html) module
        pub struct CH1CVR_SPEC;
        impl crate::RegisterSpec for CH1CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch1cvr::R](R) reader structure
        impl crate::Readable for CH1CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch1cvr::W](W) writer structure
        impl crate::Writable for CH1CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH1CVR to value 0
        impl crate::Resettable for CH1CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH2CVR (rw) register accessor: an alias for `Reg<CH2CVR_SPEC>`
    pub type CH2CVR = crate::Reg<ch2cvr::CH2CVR_SPEC>;
    ///capture/compare register 2
    pub mod ch2cvr {
        ///Register `CH2CVR` reader
        pub struct R(crate::R<CH2CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH2CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH2CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH2CVR` writer
        pub struct W(crate::W<CH2CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH2CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH2CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH2CVR` reader - Capture/Compare 2 value
        pub type CH2CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH2CVR` writer - Capture/Compare 2 value
        pub type CH2CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH2CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ch2cvr(&self) -> CH2CVR_R {
                CH2CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            #[must_use]
            pub fn ch2cvr(&mut self) -> CH2CVR_W<0> {
                CH2CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch2cvr](index.html) module
        pub struct CH2CVR_SPEC;
        impl crate::RegisterSpec for CH2CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch2cvr::R](R) reader structure
        impl crate::Readable for CH2CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch2cvr::W](W) writer structure
        impl crate::Writable for CH2CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH2CVR to value 0
        impl crate::Resettable for CH2CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH3CVR (rw) register accessor: an alias for `Reg<CH3CVR_SPEC>`
    pub type CH3CVR = crate::Reg<ch3cvr::CH3CVR_SPEC>;
    ///capture/compare register 3
    pub mod ch3cvr {
        ///Register `CH3CVR` reader
        pub struct R(crate::R<CH3CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH3CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH3CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH3CVR` writer
        pub struct W(crate::W<CH3CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH3CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH3CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH3CVR` reader - Capture/Compare value
        pub type CH3CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH3CVR` writer - Capture/Compare value
        pub type CH3CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH3CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ch3cvr(&self) -> CH3CVR_R {
                CH3CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ch3cvr(&mut self) -> CH3CVR_W<0> {
                CH3CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch3cvr](index.html) module
        pub struct CH3CVR_SPEC;
        impl crate::RegisterSpec for CH3CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch3cvr::R](R) reader structure
        impl crate::Readable for CH3CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch3cvr::W](W) writer structure
        impl crate::Writable for CH3CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH3CVR to value 0
        impl crate::Resettable for CH3CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH4CVR (rw) register accessor: an alias for `Reg<CH4CVR_SPEC>`
    pub type CH4CVR = crate::Reg<ch4cvr::CH4CVR_SPEC>;
    ///capture/compare register 4
    pub mod ch4cvr {
        ///Register `CH4CVR` reader
        pub struct R(crate::R<CH4CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH4CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH4CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH4CVR` writer
        pub struct W(crate::W<CH4CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH4CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH4CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH4CVR` reader - Capture/Compare value
        pub type CH4CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH4CVR` writer - Capture/Compare value
        pub type CH4CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH4CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ch4cvr(&self) -> CH4CVR_R {
                CH4CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ch4cvr(&mut self) -> CH4CVR_W<0> {
                CH4CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch4cvr](index.html) module
        pub struct CH4CVR_SPEC;
        impl crate::RegisterSpec for CH4CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch4cvr::R](R) reader structure
        impl crate::Readable for CH4CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch4cvr::W](W) writer structure
        impl crate::Writable for CH4CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH4CVR to value 0
        impl crate::Resettable for CH4CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BDTR (rw) register accessor: an alias for `Reg<BDTR_SPEC>`
    pub type BDTR = crate::Reg<bdtr::BDTR_SPEC>;
    ///break and dead-time register
    pub mod bdtr {
        ///Register `BDTR` reader
        pub struct R(crate::R<BDTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BDTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BDTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDTR` writer
        pub struct W(crate::W<BDTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BDTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BDTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DTG` reader - Dead-time generator setup
        pub type DTG_R = crate::FieldReader<u8, u8>;
        ///Field `DTG` writer - Dead-time generator setup
        pub type DTG_W<'a, const O: u8> = crate::FieldWriter<'a, u32, BDTR_SPEC, u8, u8, 8, O>;
        ///Field `LOCK` reader - Lock configuration
        pub type LOCK_R = crate::FieldReader<u8, u8>;
        ///Field `LOCK` writer - Lock configuration
        pub type LOCK_W<'a, const O: u8> = crate::FieldWriter<'a, u32, BDTR_SPEC, u8, u8, 2, O>;
        ///Field `OSSI` reader - Off-state selection for Idle mode
        pub type OSSI_R = crate::BitReader<bool>;
        ///Field `OSSI` writer - Off-state selection for Idle mode
        pub type OSSI_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDTR_SPEC, bool, O>;
        ///Field `OSSR` reader - Off-state selection for Run mode
        pub type OSSR_R = crate::BitReader<bool>;
        ///Field `OSSR` writer - Off-state selection for Run mode
        pub type OSSR_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDTR_SPEC, bool, O>;
        ///Field `BKE` reader - Break enable
        pub type BKE_R = crate::BitReader<bool>;
        ///Field `BKE` writer - Break enable
        pub type BKE_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDTR_SPEC, bool, O>;
        ///Field `BKP` reader - Break polarity
        pub type BKP_R = crate::BitReader<bool>;
        ///Field `BKP` writer - Break polarity
        pub type BKP_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDTR_SPEC, bool, O>;
        ///Field `AOE` reader - Automatic output enable
        pub type AOE_R = crate::BitReader<bool>;
        ///Field `AOE` writer - Automatic output enable
        pub type AOE_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDTR_SPEC, bool, O>;
        ///Field `MOE` reader - Main output enable
        pub type MOE_R = crate::BitReader<bool>;
        ///Field `MOE` writer - Main output enable
        pub type MOE_W<'a, const O: u8> = crate::BitWriter<'a, u32, BDTR_SPEC, bool, O>;
        impl R {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            #[must_use]
            pub fn dtg(&mut self) -> DTG_W<0> {
                DTG_W::new(self)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            #[must_use]
            pub fn lock(&mut self) -> LOCK_W<8> {
                LOCK_W::new(self)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            #[must_use]
            pub fn ossi(&mut self) -> OSSI_W<10> {
                OSSI_W::new(self)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            #[must_use]
            pub fn ossr(&mut self) -> OSSR_W<11> {
                OSSR_W::new(self)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            #[must_use]
            pub fn bke(&mut self) -> BKE_W<12> {
                BKE_W::new(self)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            #[must_use]
            pub fn bkp(&mut self) -> BKP_W<13> {
                BKP_W::new(self)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            #[must_use]
            pub fn aoe(&mut self) -> AOE_W<14> {
                AOE_W::new(self)
            }
            ///Bit 15 - Main output enable
            #[inline(always)]
            #[must_use]
            pub fn moe(&mut self) -> MOE_W<15> {
                MOE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///break and dead-time register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdtr](index.html) module
        pub struct BDTR_SPEC;
        impl crate::RegisterSpec for BDTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bdtr::R](R) reader structure
        impl crate::Readable for BDTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdtr::W](W) writer structure
        impl crate::Writable for BDTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BDTR to value 0
        impl crate::Resettable for BDTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMACFGR (rw) register accessor: an alias for `Reg<DMACFGR_SPEC>`
    pub type DMACFGR = crate::Reg<dmacfgr::DMACFGR_SPEC>;
    ///DMA control register
    pub mod dmacfgr {
        ///Register `DMACFGR` reader
        pub struct R(crate::R<DMACFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMACFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMACFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMACFGR` writer
        pub struct W(crate::W<DMACFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMACFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMACFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBA` reader - DMA base address
        pub type DBA_R = crate::FieldReader<u8, u8>;
        ///Field `DBA` writer - DMA base address
        pub type DBA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DMACFGR_SPEC, u8, u8, 5, O>;
        ///Field `DBL` reader - DMA burst length
        pub type DBL_R = crate::FieldReader<u8, u8>;
        ///Field `DBL` writer - DMA burst length
        pub type DBL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DMACFGR_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            #[must_use]
            pub fn dba(&mut self) -> DBA_W<0> {
                DBA_W::new(self)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            #[must_use]
            pub fn dbl(&mut self) -> DBL_W<8> {
                DBL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmacfgr](index.html) module
        pub struct DMACFGR_SPEC;
        impl crate::RegisterSpec for DMACFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmacfgr::R](R) reader structure
        impl crate::Readable for DMACFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmacfgr::W](W) writer structure
        impl crate::Writable for DMACFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMACFGR to value 0
        impl crate::Resettable for DMACFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAADR (rw) register accessor: an alias for `Reg<DMAADR_SPEC>`
    pub type DMAADR = crate::Reg<dmaadr::DMAADR_SPEC>;
    ///DMA address for full transfer
    pub mod dmaadr {
        ///Register `DMAADR` reader
        pub struct R(crate::R<DMAADR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAADR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAADR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAADR` writer
        pub struct W(crate::W<DMAADR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAADR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAADR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAADR` reader - DMA register for burst accesses
        pub type DMAADR_R = crate::FieldReader<u16, u16>;
        ///Field `DMAADR` writer - DMA register for burst accesses
        pub type DMAADR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, DMAADR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmaadr(&self) -> DMAADR_R {
                DMAADR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            #[must_use]
            pub fn dmaadr(&mut self) -> DMAADR_W<0> {
                DMAADR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmaadr](index.html) module
        pub struct DMAADR_SPEC;
        impl crate::RegisterSpec for DMAADR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmaadr::R](R) reader structure
        impl crate::Readable for DMAADR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmaadr::W](W) writer structure
        impl crate::Writable for DMAADR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAADR to value 0
        impl crate::Resettable for DMAADR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///General purpose timer
pub struct TIM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM2 {}
impl TIM2 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM2 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM2").finish()
    }
}
///General purpose timer
pub mod tim2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub ctlr1: CTLR1,
        ///0x04 - control register 2
        pub ctlr2: CTLR2,
        ///0x08 - slave mode control register
        pub smcfgr: SMCFGR,
        ///0x0c - DMA/Interrupt enable register
        pub dmaintenr: DMAINTENR,
        ///0x10 - status register
        pub intfr: INTFR,
        ///0x14 - event generation register
        pub swevgr: SWEVGR,
        _reserved_6_chctlr1: [u8; 0x04],
        _reserved_7_chctlr2: [u8; 0x04],
        ///0x20 - capture/compare enable register
        pub ccer: CCER,
        ///0x24 - counter
        pub cnt: CNT,
        ///0x28 - prescaler
        pub psc: PSC,
        ///0x2c - auto-reload register
        pub atrlr: ATRLR,
        _reserved12: [u8; 0x04],
        ///0x34 - capture/compare register 1
        pub ch1cvr: CH1CVR,
        ///0x38 - capture/compare register 2
        pub ch2cvr: CH2CVR,
        ///0x3c - capture/compare register 3
        pub ch3cvr: CH3CVR,
        ///0x40 - capture/compare register 4
        pub ch4cvr: CH4CVR,
        _reserved16: [u8; 0x04],
        ///0x48 - DMA control register
        pub dmacfgr: DMACFGR,
        ///0x4c - DMA address for full transfer
        pub dmaadr: DMAADR,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub const fn chctlr1_input(&self) -> &CHCTLR1_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x18 - capture/compare mode register 1 (output mode)
        #[inline(always)]
        pub const fn chctlr1_output(&self) -> &CHCTLR1_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(24usize).cast() }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub const fn chctlr2_input(&self) -> &CHCTLR2_INPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
        ///0x1c - capture/compare mode register 2 (output mode)
        #[inline(always)]
        pub const fn chctlr2_output(&self) -> &CHCTLR2_OUTPUT {
            unsafe { &*(self as *const Self).cast::<u8>().add(28usize).cast() }
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CEN` reader - Counter enable
        pub type CEN_R = crate::BitReader<bool>;
        ///Field `CEN` writer - Counter enable
        pub type CEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `UDIS` reader - Update disable
        pub type UDIS_R = crate::BitReader<bool>;
        ///Field `UDIS` writer - Update disable
        pub type UDIS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `URS` reader - Update request source
        pub type URS_R = crate::BitReader<bool>;
        ///Field `URS` writer - Update request source
        pub type URS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `OPM` reader - One-pulse mode
        pub type OPM_R = crate::BitReader<bool>;
        ///Field `OPM` writer - One-pulse mode
        pub type OPM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `DIR` reader - Direction
        pub type DIR_R = crate::BitReader<bool>;
        ///Field `DIR` writer - Direction
        pub type DIR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `CMS` reader - Center-aligned mode selection
        pub type CMS_R = crate::FieldReader<u8, u8>;
        ///Field `CMS` writer - Center-aligned mode selection
        pub type CMS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 2, O>;
        ///Field `ARPE` reader - Auto-reload preload enable
        pub type ARPE_R = crate::BitReader<bool>;
        ///Field `ARPE` writer - Auto-reload preload enable
        pub type ARPE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `CKD` reader - Clock division
        pub type CKD_R = crate::FieldReader<u8, u8>;
        ///Field `CKD` writer - Clock division
        pub type CKD_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 2, O>;
        ///Field `TMR_CAP_OV_EN` reader - Timer capture value configuration enable
        pub type TMR_CAP_OV_EN_R = crate::BitReader<bool>;
        ///Field `TMR_CAP_OV_EN` writer - Timer capture value configuration enable
        pub type TMR_CAP_OV_EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `TMR_CAP_LVL_EN` reader - Timer capture level indication enable
        pub type TMR_CAP_LVL_EN_R = crate::BitReader<bool>;
        ///Field `TMR_CAP_LVL_EN` writer - Timer capture level indication enable
        pub type TMR_CAP_LVL_EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 14 - Timer capture value configuration enable
            #[inline(always)]
            pub fn tmr_cap_ov_en(&self) -> TMR_CAP_OV_EN_R {
                TMR_CAP_OV_EN_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Timer capture level indication enable
            #[inline(always)]
            pub fn tmr_cap_lvl_en(&self) -> TMR_CAP_LVL_EN_R {
                TMR_CAP_LVL_EN_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            #[must_use]
            pub fn cen(&mut self) -> CEN_W<0> {
                CEN_W::new(self)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            #[must_use]
            pub fn udis(&mut self) -> UDIS_W<1> {
                UDIS_W::new(self)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            #[must_use]
            pub fn urs(&mut self) -> URS_W<2> {
                URS_W::new(self)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            #[must_use]
            pub fn opm(&mut self) -> OPM_W<3> {
                OPM_W::new(self)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            #[must_use]
            pub fn dir(&mut self) -> DIR_W<4> {
                DIR_W::new(self)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            #[must_use]
            pub fn cms(&mut self) -> CMS_W<5> {
                CMS_W::new(self)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            #[must_use]
            pub fn arpe(&mut self) -> ARPE_W<7> {
                ARPE_W::new(self)
            }
            ///Bits 8:9 - Clock division
            #[inline(always)]
            #[must_use]
            pub fn ckd(&mut self) -> CKD_W<8> {
                CKD_W::new(self)
            }
            ///Bit 14 - Timer capture value configuration enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_ov_en(&mut self) -> TMR_CAP_OV_EN_W<14> {
                TMR_CAP_OV_EN_W::new(self)
            }
            ///Bit 15 - Timer capture level indication enable
            #[inline(always)]
            #[must_use]
            pub fn tmr_cap_lvl_en(&mut self) -> TMR_CAP_LVL_EN_W<15> {
                TMR_CAP_LVL_EN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub type CCDS_R = crate::BitReader<bool>;
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub type CCDS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `MMS` reader - Master mode selection
        pub type MMS_R = crate::FieldReader<u8, u8>;
        ///Field `MMS` writer - Master mode selection
        pub type MMS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 3, O>;
        ///Field `TI1S` reader - TI1 selection
        pub type TI1S_R = crate::BitReader<bool>;
        ///Field `TI1S` writer - TI1 selection
        pub type TI1S_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            #[must_use]
            pub fn ccds(&mut self) -> CCDS_W<3> {
                CCDS_W::new(self)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            #[must_use]
            pub fn mms(&mut self) -> MMS_W<4> {
                MMS_W::new(self)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            #[must_use]
            pub fn ti1s(&mut self) -> TI1S_W<7> {
                TI1S_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SMCFGR (rw) register accessor: an alias for `Reg<SMCFGR_SPEC>`
    pub type SMCFGR = crate::Reg<smcfgr::SMCFGR_SPEC>;
    ///slave mode control register
    pub mod smcfgr {
        ///Register `SMCFGR` reader
        pub struct R(crate::R<SMCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SMCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SMCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCFGR` writer
        pub struct W(crate::W<SMCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SMCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SMCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub type SMS_R = crate::FieldReader<u8, u8>;
        ///Field `SMS` writer - Slave mode selection
        pub type SMS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 3, O>;
        ///Field `TS` reader - Trigger selection
        pub type TS_R = crate::FieldReader<u8, u8>;
        ///Field `TS` writer - Trigger selection
        pub type TS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 3, O>;
        ///Field `MSM` reader - Master/Slave mode
        pub type MSM_R = crate::BitReader<bool>;
        ///Field `MSM` writer - Master/Slave mode
        pub type MSM_W<'a, const O: u8> = crate::BitWriter<'a, u32, SMCFGR_SPEC, bool, O>;
        ///Field `ETF` reader - External trigger filter
        pub type ETF_R = crate::FieldReader<u8, u8>;
        ///Field `ETF` writer - External trigger filter
        pub type ETF_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 4, O>;
        ///Field `ETPS` reader - External trigger prescaler
        pub type ETPS_R = crate::FieldReader<u8, u8>;
        ///Field `ETPS` writer - External trigger prescaler
        pub type ETPS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SMCFGR_SPEC, u8, u8, 2, O>;
        ///Field `ECE` reader - External clock enable
        pub type ECE_R = crate::BitReader<bool>;
        ///Field `ECE` writer - External clock enable
        pub type ECE_W<'a, const O: u8> = crate::BitWriter<'a, u32, SMCFGR_SPEC, bool, O>;
        ///Field `ETP` reader - External trigger polarity
        pub type ETP_R = crate::BitReader<bool>;
        ///Field `ETP` writer - External trigger polarity
        pub type ETP_W<'a, const O: u8> = crate::BitWriter<'a, u32, SMCFGR_SPEC, bool, O>;
        impl R {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 7) as u8)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            #[must_use]
            pub fn sms(&mut self) -> SMS_W<0> {
                SMS_W::new(self)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            #[must_use]
            pub fn ts(&mut self) -> TS_W<4> {
                TS_W::new(self)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            #[must_use]
            pub fn msm(&mut self) -> MSM_W<7> {
                MSM_W::new(self)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            #[must_use]
            pub fn etf(&mut self) -> ETF_W<8> {
                ETF_W::new(self)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            #[must_use]
            pub fn etps(&mut self) -> ETPS_W<12> {
                ETPS_W::new(self)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            #[must_use]
            pub fn ece(&mut self) -> ECE_W<14> {
                ECE_W::new(self)
            }
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            #[must_use]
            pub fn etp(&mut self) -> ETP_W<15> {
                ETP_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcfgr](index.html) module
        pub struct SMCFGR_SPEC;
        impl crate::RegisterSpec for SMCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smcfgr::R](R) reader structure
        impl crate::Readable for SMCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcfgr::W](W) writer structure
        impl crate::Writable for SMCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SMCFGR to value 0
        impl crate::Resettable for SMCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAINTENR (rw) register accessor: an alias for `Reg<DMAINTENR_SPEC>`
    pub type DMAINTENR = crate::Reg<dmaintenr::DMAINTENR_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dmaintenr {
        ///Register `DMAINTENR` reader
        pub struct R(crate::R<DMAINTENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAINTENR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAINTENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAINTENR` writer
        pub struct W(crate::W<DMAINTENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAINTENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAINTENR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAINTENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub type UIE_R = crate::BitReader<bool>;
        ///Field `UIE` writer - Update interrupt enable
        pub type UIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub type CC1IE_R = crate::BitReader<bool>;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub type CC1IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub type CC2IE_R = crate::BitReader<bool>;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub type CC2IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub type CC3IE_R = crate::BitReader<bool>;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub type CC3IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub type CC4IE_R = crate::BitReader<bool>;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub type CC4IE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `TIE` reader - Trigger interrupt enable
        pub type TIE_R = crate::BitReader<bool>;
        ///Field `TIE` writer - Trigger interrupt enable
        pub type TIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `UDE` reader - Update DMA request enable
        pub type UDE_R = crate::BitReader<bool>;
        ///Field `UDE` writer - Update DMA request enable
        pub type UDE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub type CC1DE_R = crate::BitReader<bool>;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub type CC1DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub type CC2DE_R = crate::BitReader<bool>;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub type CC2DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub type CC3DE_R = crate::BitReader<bool>;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub type CC3DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub type CC4DE_R = crate::BitReader<bool>;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub type CC4DE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        ///Field `TDE` reader - Trigger DMA request enable
        pub type TDE_R = crate::BitReader<bool>;
        ///Field `TDE` writer - Trigger DMA request enable
        pub type TDE_W<'a, const O: u8> = crate::BitWriter<'a, u32, DMAINTENR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn uie(&mut self) -> UIE_W<0> {
                UIE_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc1ie(&mut self) -> CC1IE_W<1> {
                CC1IE_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc2ie(&mut self) -> CC2IE_W<2> {
                CC2IE_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc3ie(&mut self) -> CC3IE_W<3> {
                CC3IE_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn cc4ie(&mut self) -> CC4IE_W<4> {
                CC4IE_W::new(self)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tie(&mut self) -> TIE_W<6> {
                TIE_W::new(self)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn ude(&mut self) -> UDE_W<8> {
                UDE_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc1de(&mut self) -> CC1DE_W<9> {
                CC1DE_W::new(self)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc2de(&mut self) -> CC2DE_W<10> {
                CC2DE_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc3de(&mut self) -> CC3DE_W<11> {
                CC3DE_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn cc4de(&mut self) -> CC4DE_W<12> {
                CC4DE_W::new(self)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            #[must_use]
            pub fn tde(&mut self) -> TDE_W<14> {
                TDE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmaintenr](index.html) module
        pub struct DMAINTENR_SPEC;
        impl crate::RegisterSpec for DMAINTENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmaintenr::R](R) reader structure
        impl crate::Readable for DMAINTENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmaintenr::W](W) writer structure
        impl crate::Writable for DMAINTENR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAINTENR to value 0
        impl crate::Resettable for DMAINTENR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///INTFR (rw) register accessor: an alias for `Reg<INTFR_SPEC>`
    pub type INTFR = crate::Reg<intfr::INTFR_SPEC>;
    ///status register
    pub mod intfr {
        ///Register `INTFR` reader
        pub struct R(crate::R<INTFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<INTFR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<INTFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `INTFR` writer
        pub struct W(crate::W<INTFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<INTFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<INTFR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<INTFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub type UIF_R = crate::BitReader<bool>;
        ///Field `UIF` writer - Update interrupt flag
        pub type UIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub type CC1IF_R = crate::BitReader<bool>;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub type CC1IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub type CC2IF_R = crate::BitReader<bool>;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub type CC2IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub type CC3IF_R = crate::BitReader<bool>;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub type CC3IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub type CC4IF_R = crate::BitReader<bool>;
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub type CC4IF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `TIF` reader - Trigger interrupt flag
        pub type TIF_R = crate::BitReader<bool>;
        ///Field `TIF` writer - Trigger interrupt flag
        pub type TIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = crate::BitReader<bool>;
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub type CC1OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub type CC2OF_R = crate::BitReader<bool>;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub type CC2OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub type CC3OF_R = crate::BitReader<bool>;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub type CC3OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub type CC4OF_R = crate::BitReader<bool>;
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub type CC4OF_W<'a, const O: u8> = crate::BitWriter<'a, u32, INTFR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn uif(&mut self) -> UIF_W<0> {
                UIF_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc1if(&mut self) -> CC1IF_W<1> {
                CC1IF_W::new(self)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc2if(&mut self) -> CC2IF_W<2> {
                CC2IF_W::new(self)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc3if(&mut self) -> CC3IF_W<3> {
                CC3IF_W::new(self)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn cc4if(&mut self) -> CC4IF_W<4> {
                CC4IF_W::new(self)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            #[must_use]
            pub fn tif(&mut self) -> TIF_W<6> {
                TIF_W::new(self)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc1of(&mut self) -> CC1OF_W<9> {
                CC1OF_W::new(self)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc2of(&mut self) -> CC2OF_W<10> {
                CC2OF_W::new(self)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc3of(&mut self) -> CC3OF_W<11> {
                CC3OF_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            #[must_use]
            pub fn cc4of(&mut self) -> CC4OF_W<12> {
                CC4OF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [intfr](index.html) module
        pub struct INTFR_SPEC;
        impl crate::RegisterSpec for INTFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [intfr::R](R) reader structure
        impl crate::Readable for INTFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [intfr::W](W) writer structure
        impl crate::Writable for INTFR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets INTFR to value 0
        impl crate::Resettable for INTFR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SWEVGR (w) register accessor: an alias for `Reg<SWEVGR_SPEC>`
    pub type SWEVGR = crate::Reg<swevgr::SWEVGR_SPEC>;
    ///event generation register
    pub mod swevgr {
        ///Register `SWEVGR` writer
        pub struct W(crate::W<SWEVGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWEVGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SWEVGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SWEVGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `UG` writer - Update generation
        pub type UG_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub type CC1G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub type CC2G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub type CC3G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub type CC4G_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        ///Field `TG` writer - Trigger generation
        pub type TG_W<'a, const O: u8> = crate::BitWriter<'a, u32, SWEVGR_SPEC, bool, O>;
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            #[must_use]
            pub fn ug(&mut self) -> UG_W<0> {
                UG_W::new(self)
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            #[must_use]
            pub fn cc1g(&mut self) -> CC1G_W<1> {
                CC1G_W::new(self)
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            #[must_use]
            pub fn cc2g(&mut self) -> CC2G_W<2> {
                CC2G_W::new(self)
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            #[must_use]
            pub fn cc3g(&mut self) -> CC3G_W<3> {
                CC3G_W::new(self)
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            #[must_use]
            pub fn cc4g(&mut self) -> CC4G_W<4> {
                CC4G_W::new(self)
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            #[must_use]
            pub fn tg(&mut self) -> TG_W<6> {
                TG_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swevgr](index.html) module
        pub struct SWEVGR_SPEC;
        impl crate::RegisterSpec for SWEVGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [swevgr::W](W) writer structure
        impl crate::Writable for SWEVGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SWEVGR to value 0
        impl crate::Resettable for SWEVGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1_Output (rw) register accessor: an alias for `Reg<CHCTLR1_OUTPUT_SPEC>`
    pub type CHCTLR1_OUTPUT = crate::Reg<chctlr1_output::CHCTLR1_OUTPUT_SPEC>;
    ///capture/compare mode register 1 (output mode)
    pub mod chctlr1_output {
        ///Register `CHCTLR1_Output` reader
        pub struct R(crate::R<CHCTLR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1_OUTPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1_Output` writer
        pub struct W(crate::W<CHCTLR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1_OUTPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, u8>;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC1FE` reader - Output compare 1 fast enable
        pub type OC1FE_R = crate::BitReader<bool>;
        ///Field `OC1FE` writer - Output compare 1 fast enable
        pub type OC1FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC1PE` reader - Output compare 1 preload enable
        pub type OC1PE_R = crate::BitReader<bool>;
        ///Field `OC1PE` writer - Output compare 1 preload enable
        pub type OC1PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC1M` reader - Output compare 1 mode
        pub type OC1M_R = crate::FieldReader<u8, u8>;
        ///Field `OC1M` writer - Output compare 1 mode
        pub type OC1M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC1CE` reader - Output compare 1 clear enable
        pub type OC1CE_R = crate::BitReader<bool>;
        ///Field `OC1CE` writer - Output compare 1 clear enable
        pub type OC1CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, u8>;
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC2FE` reader - Output compare 2 fast enable
        pub type OC2FE_R = crate::BitReader<bool>;
        ///Field `OC2FE` writer - Output compare 2 fast enable
        pub type OC2FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC2PE` reader - Output compare 2 preload enable
        pub type OC2PE_R = crate::BitReader<bool>;
        ///Field `OC2PE` writer - Output compare 2 preload enable
        pub type OC2PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        ///Field `OC2M` reader - Output compare 2 mode
        pub type OC2M_R = crate::FieldReader<u8, u8>;
        ///Field `OC2M` writer - Output compare 2 mode
        pub type OC2M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC2CE` reader - Output compare 2 clear enable
        pub type OC2CE_R = crate::BitReader<bool>;
        ///Field `OC2CE` writer - Output compare 2 clear enable
        pub type OC2CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR1_OUTPUT_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc1fe(&mut self) -> OC1FE_W<2> {
                OC1FE_W::new(self)
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc1pe(&mut self) -> OC1PE_W<3> {
                OC1PE_W::new(self)
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            #[must_use]
            pub fn oc1m(&mut self) -> OC1M_W<4> {
                OC1M_W::new(self)
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc1ce(&mut self) -> OC1CE_W<7> {
                OC1CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc2fe(&mut self) -> OC2FE_W<10> {
                OC2FE_W::new(self)
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc2pe(&mut self) -> OC2PE_W<11> {
                OC2PE_W::new(self)
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            #[must_use]
            pub fn oc2m(&mut self) -> OC2M_W<12> {
                OC2M_W::new(self)
            }
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc2ce(&mut self) -> OC2CE_W<15> {
                OC2CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1_output](index.html) module
        pub struct CHCTLR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr1_output::R](R) reader structure
        impl crate::Readable for CHCTLR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1_output::W](W) writer structure
        impl crate::Writable for CHCTLR1_OUTPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1_Output to value 0
        impl crate::Resettable for CHCTLR1_OUTPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR1_Input (rw) register accessor: an alias for `Reg<CHCTLR1_INPUT_SPEC>`
    pub type CHCTLR1_INPUT = crate::Reg<chctlr1_input::CHCTLR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod chctlr1_input {
        ///Register `CHCTLR1_Input` reader
        pub struct R(crate::R<CHCTLR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR1_INPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR1_Input` writer
        pub struct W(crate::W<CHCTLR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR1_INPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub type CC1S_R = crate::FieldReader<u8, u8>;
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub type CC1S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub type IC1PSC_R = crate::FieldReader<u8, u8>;
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub type IC1PSC_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC1F` reader - Input capture 1 filter
        pub type IC1F_R = crate::FieldReader<u8, u8>;
        ///Field `IC1F` writer - Input capture 1 filter
        pub type IC1F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 4, O>;
        ///Field `CC2S` reader - Capture/compare 2 selection
        pub type CC2S_R = crate::FieldReader<u8, u8>;
        ///Field `CC2S` writer - Capture/compare 2 selection
        pub type CC2S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub type IC2PSC_R = crate::FieldReader<u8, u8>;
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub type IC2PSC_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC2F` reader - Input capture 2 filter
        pub type IC2F_R = crate::FieldReader<u8, u8>;
        ///Field `IC2F` writer - Input capture 2 filter
        pub type IC2F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR1_INPUT_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            #[must_use]
            pub fn cc1s(&mut self) -> CC1S_W<0> {
                CC1S_W::new(self)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic1psc(&mut self) -> IC1PSC_W<2> {
                IC1PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            #[must_use]
            pub fn ic1f(&mut self) -> IC1F_W<4> {
                IC1F_W::new(self)
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            #[must_use]
            pub fn cc2s(&mut self) -> CC2S_W<8> {
                CC2S_W::new(self)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic2psc(&mut self) -> IC2PSC_W<10> {
                IC2PSC_W::new(self)
            }
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            #[must_use]
            pub fn ic2f(&mut self) -> IC2F_W<12> {
                IC2F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr1_input](index.html) module
        pub struct CHCTLR1_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr1_input::R](R) reader structure
        impl crate::Readable for CHCTLR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr1_input::W](W) writer structure
        impl crate::Writable for CHCTLR1_INPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR1_Input to value 0
        impl crate::Resettable for CHCTLR1_INPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2_Output (rw) register accessor: an alias for `Reg<CHCTLR2_OUTPUT_SPEC>`
    pub type CHCTLR2_OUTPUT = crate::Reg<chctlr2_output::CHCTLR2_OUTPUT_SPEC>;
    ///capture/compare mode register 2 (output mode)
    pub mod chctlr2_output {
        ///Register `CHCTLR2_Output` reader
        pub struct R(crate::R<CHCTLR2_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2_OUTPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2_Output` writer
        pub struct W(crate::W<CHCTLR2_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2_OUTPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, u8>;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub type OC3FE_R = crate::BitReader<bool>;
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub type OC3FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub type OC3PE_R = crate::BitReader<bool>;
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub type OC3PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = crate::FieldReader<u8, u8>;
        ///Field `OC3M` writer - Output compare 3 mode
        pub type OC3M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub type OC3CE_R = crate::BitReader<bool>;
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub type OC3CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, u8>;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 2, O>;
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub type OC4FE_R = crate::BitReader<bool>;
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub type OC4FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub type OC4PE_R = crate::BitReader<bool>;
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub type OC4PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        ///Field `OC4M` reader - Output compare 4 mode
        pub type OC4M_R = crate::FieldReader<u8, u8>;
        ///Field `OC4M` writer - Output compare 4 mode
        pub type OC4M_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, u8, u8, 3, O>;
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub type OC4CE_R = crate::BitReader<bool>;
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub type OC4CE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CHCTLR2_OUTPUT_SPEC, bool, O>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 7) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc3fe(&mut self) -> OC3FE_W<2> {
                OC3FE_W::new(self)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc3pe(&mut self) -> OC3PE_W<3> {
                OC3PE_W::new(self)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            #[must_use]
            pub fn oc3m(&mut self) -> OC3M_W<4> {
                OC3M_W::new(self)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc3ce(&mut self) -> OC3CE_W<7> {
                OC3CE_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            #[must_use]
            pub fn oc4fe(&mut self) -> OC4FE_W<10> {
                OC4FE_W::new(self)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            #[must_use]
            pub fn oc4pe(&mut self) -> OC4PE_W<11> {
                OC4PE_W::new(self)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            #[must_use]
            pub fn oc4m(&mut self) -> OC4M_W<12> {
                OC4M_W::new(self)
            }
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            #[must_use]
            pub fn oc4ce(&mut self) -> OC4CE_W<15> {
                OC4CE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2_output](index.html) module
        pub struct CHCTLR2_OUTPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr2_output::R](R) reader structure
        impl crate::Readable for CHCTLR2_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2_output::W](W) writer structure
        impl crate::Writable for CHCTLR2_OUTPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2_Output to value 0
        impl crate::Resettable for CHCTLR2_OUTPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CHCTLR2_Input (rw) register accessor: an alias for `Reg<CHCTLR2_INPUT_SPEC>`
    pub type CHCTLR2_INPUT = crate::Reg<chctlr2_input::CHCTLR2_INPUT_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod chctlr2_input {
        ///Register `CHCTLR2_Input` reader
        pub struct R(crate::R<CHCTLR2_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CHCTLR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CHCTLR2_INPUT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CHCTLR2_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CHCTLR2_Input` writer
        pub struct W(crate::W<CHCTLR2_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CHCTLR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CHCTLR2_INPUT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CHCTLR2_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub type CC3S_R = crate::FieldReader<u8, u8>;
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub type CC3S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub type IC3PSC_R = crate::FieldReader<u8, u8>;
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub type IC3PSC_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC3F` reader - Input capture 3 filter
        pub type IC3F_R = crate::FieldReader<u8, u8>;
        ///Field `IC3F` writer - Input capture 3 filter
        pub type IC3F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 4, O>;
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub type CC4S_R = crate::FieldReader<u8, u8>;
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub type CC4S_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub type IC4PSC_R = crate::FieldReader<u8, u8>;
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub type IC4PSC_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 2, O>;
        ///Field `IC4F` reader - Input capture 4 filter
        pub type IC4F_R = crate::FieldReader<u8, u8>;
        ///Field `IC4F` writer - Input capture 4 filter
        pub type IC4F_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CHCTLR2_INPUT_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 3) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 3) as u8)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            #[must_use]
            pub fn cc3s(&mut self) -> CC3S_W<0> {
                CC3S_W::new(self)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic3psc(&mut self) -> IC3PSC_W<2> {
                IC3PSC_W::new(self)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            #[must_use]
            pub fn ic3f(&mut self) -> IC3F_W<4> {
                IC3F_W::new(self)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            #[must_use]
            pub fn cc4s(&mut self) -> CC4S_W<8> {
                CC4S_W::new(self)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            #[must_use]
            pub fn ic4psc(&mut self) -> IC4PSC_W<10> {
                IC4PSC_W::new(self)
            }
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            #[must_use]
            pub fn ic4f(&mut self) -> IC4F_W<12> {
                IC4F_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [chctlr2_input](index.html) module
        pub struct CHCTLR2_INPUT_SPEC;
        impl crate::RegisterSpec for CHCTLR2_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [chctlr2_input::R](R) reader structure
        impl crate::Readable for CHCTLR2_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [chctlr2_input::W](W) writer structure
        impl crate::Writable for CHCTLR2_INPUT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CHCTLR2_Input to value 0
        impl crate::Resettable for CHCTLR2_INPUT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CCER (rw) register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CCER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CCER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub type CC1E_R = crate::BitReader<bool>;
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub type CC1E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub type CC1P_R = crate::BitReader<bool>;
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub type CC1P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub type CC2E_R = crate::BitReader<bool>;
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub type CC2E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub type CC2P_R = crate::BitReader<bool>;
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub type CC2P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub type CC3E_R = crate::BitReader<bool>;
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub type CC3E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub type CC3P_R = crate::BitReader<bool>;
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub type CC3P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub type CC4E_R = crate::BitReader<bool>;
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub type CC4E_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub type CC4P_R = crate::BitReader<bool>;
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub type CC4P_W<'a, const O: u8> = crate::BitWriter<'a, u32, CCER_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc1e(&mut self) -> CC1E_W<0> {
                CC1E_W::new(self)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc1p(&mut self) -> CC1P_W<1> {
                CC1P_W::new(self)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc2e(&mut self) -> CC2E_W<4> {
                CC2E_W::new(self)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc2p(&mut self) -> CC2P_W<5> {
                CC2P_W::new(self)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc3e(&mut self) -> CC3E_W<8> {
                CC3E_W::new(self)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc3p(&mut self) -> CC3P_W<9> {
                CC3P_W::new(self)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            #[must_use]
            pub fn cc4e(&mut self) -> CC4E_W<12> {
                CC4E_W::new(self)
            }
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            #[must_use]
            pub fn cc4p(&mut self) -> CC4P_W<13> {
                CC4P_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CNT_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CNT_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub type CNT_R = crate::FieldReader<u16, u16>;
        ///Field `CNT` writer - counter value
        pub type CNT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CNT_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            #[must_use]
            pub fn cnt(&mut self) -> CNT_W<0> {
                CNT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///PSC (rw) register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<PSC_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<PSC_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u16, u16>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, const O: u8> = crate::FieldWriter<'a, u32, PSC_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<0> {
                PSC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ATRLR (rw) register accessor: an alias for `Reg<ATRLR_SPEC>`
    pub type ATRLR = crate::Reg<atrlr::ATRLR_SPEC>;
    ///auto-reload register
    pub mod atrlr {
        ///Register `ATRLR` reader
        pub struct R(crate::R<ATRLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ATRLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ATRLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ATRLR` writer
        pub struct W(crate::W<ATRLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ATRLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ATRLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ATRLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ATRLR` reader - Auto-reload value
        pub type ATRLR_R = crate::FieldReader<u16, u16>;
        ///Field `ATRLR` writer - Auto-reload value
        pub type ATRLR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, ATRLR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn atrlr(&self) -> ATRLR_R {
                ATRLR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            #[must_use]
            pub fn atrlr(&mut self) -> ATRLR_W<0> {
                ATRLR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [atrlr](index.html) module
        pub struct ATRLR_SPEC;
        impl crate::RegisterSpec for ATRLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [atrlr::R](R) reader structure
        impl crate::Readable for ATRLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [atrlr::W](W) writer structure
        impl crate::Writable for ATRLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ATRLR to value 0
        impl crate::Resettable for ATRLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH1CVR (rw) register accessor: an alias for `Reg<CH1CVR_SPEC>`
    pub type CH1CVR = crate::Reg<ch1cvr::CH1CVR_SPEC>;
    ///capture/compare register 1
    pub mod ch1cvr {
        ///Register `CH1CVR` reader
        pub struct R(crate::R<CH1CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH1CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH1CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH1CVR` writer
        pub struct W(crate::W<CH1CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH1CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH1CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH1CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH1CVR` reader - Capture/Compare 1 value
        pub type CH1CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH1CVR` writer - Capture/Compare 1 value
        pub type CH1CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH1CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ch1cvr(&self) -> CH1CVR_R {
                CH1CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            #[must_use]
            pub fn ch1cvr(&mut self) -> CH1CVR_W<0> {
                CH1CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch1cvr](index.html) module
        pub struct CH1CVR_SPEC;
        impl crate::RegisterSpec for CH1CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch1cvr::R](R) reader structure
        impl crate::Readable for CH1CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch1cvr::W](W) writer structure
        impl crate::Writable for CH1CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH1CVR to value 0
        impl crate::Resettable for CH1CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH2CVR (rw) register accessor: an alias for `Reg<CH2CVR_SPEC>`
    pub type CH2CVR = crate::Reg<ch2cvr::CH2CVR_SPEC>;
    ///capture/compare register 2
    pub mod ch2cvr {
        ///Register `CH2CVR` reader
        pub struct R(crate::R<CH2CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH2CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH2CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH2CVR` writer
        pub struct W(crate::W<CH2CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH2CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH2CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH2CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH2CVR` reader - Capture/Compare 2 value
        pub type CH2CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH2CVR` writer - Capture/Compare 2 value
        pub type CH2CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH2CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ch2cvr(&self) -> CH2CVR_R {
                CH2CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            #[must_use]
            pub fn ch2cvr(&mut self) -> CH2CVR_W<0> {
                CH2CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch2cvr](index.html) module
        pub struct CH2CVR_SPEC;
        impl crate::RegisterSpec for CH2CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch2cvr::R](R) reader structure
        impl crate::Readable for CH2CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch2cvr::W](W) writer structure
        impl crate::Writable for CH2CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH2CVR to value 0
        impl crate::Resettable for CH2CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH3CVR (rw) register accessor: an alias for `Reg<CH3CVR_SPEC>`
    pub type CH3CVR = crate::Reg<ch3cvr::CH3CVR_SPEC>;
    ///capture/compare register 3
    pub mod ch3cvr {
        ///Register `CH3CVR` reader
        pub struct R(crate::R<CH3CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH3CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH3CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH3CVR` writer
        pub struct W(crate::W<CH3CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH3CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH3CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH3CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH3CVR` reader - Capture/Compare value
        pub type CH3CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH3CVR` writer - Capture/Compare value
        pub type CH3CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH3CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ch3cvr(&self) -> CH3CVR_R {
                CH3CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ch3cvr(&mut self) -> CH3CVR_W<0> {
                CH3CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch3cvr](index.html) module
        pub struct CH3CVR_SPEC;
        impl crate::RegisterSpec for CH3CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch3cvr::R](R) reader structure
        impl crate::Readable for CH3CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch3cvr::W](W) writer structure
        impl crate::Writable for CH3CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH3CVR to value 0
        impl crate::Resettable for CH3CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CH4CVR (rw) register accessor: an alias for `Reg<CH4CVR_SPEC>`
    pub type CH4CVR = crate::Reg<ch4cvr::CH4CVR_SPEC>;
    ///capture/compare register 4
    pub mod ch4cvr {
        ///Register `CH4CVR` reader
        pub struct R(crate::R<CH4CVR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CH4CVR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CH4CVR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CH4CVR` writer
        pub struct W(crate::W<CH4CVR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CH4CVR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CH4CVR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CH4CVR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CH4CVR` reader - Capture/Compare value
        pub type CH4CVR_R = crate::FieldReader<u16, u16>;
        ///Field `CH4CVR` writer - Capture/Compare value
        pub type CH4CVR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CH4CVR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            pub fn ch4cvr(&self) -> CH4CVR_R {
                CH4CVR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare value
            #[inline(always)]
            #[must_use]
            pub fn ch4cvr(&mut self) -> CH4CVR_W<0> {
                CH4CVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ch4cvr](index.html) module
        pub struct CH4CVR_SPEC;
        impl crate::RegisterSpec for CH4CVR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ch4cvr::R](R) reader structure
        impl crate::Readable for CH4CVR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ch4cvr::W](W) writer structure
        impl crate::Writable for CH4CVR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CH4CVR to value 0
        impl crate::Resettable for CH4CVR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMACFGR (rw) register accessor: an alias for `Reg<DMACFGR_SPEC>`
    pub type DMACFGR = crate::Reg<dmacfgr::DMACFGR_SPEC>;
    ///DMA control register
    pub mod dmacfgr {
        ///Register `DMACFGR` reader
        pub struct R(crate::R<DMACFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMACFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMACFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMACFGR` writer
        pub struct W(crate::W<DMACFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMACFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMACFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMACFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBA` reader - DMA base address
        pub type DBA_R = crate::FieldReader<u8, u8>;
        ///Field `DBA` writer - DMA base address
        pub type DBA_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DMACFGR_SPEC, u8, u8, 5, O>;
        ///Field `DBL` reader - DMA burst length
        pub type DBL_R = crate::FieldReader<u8, u8>;
        ///Field `DBL` writer - DMA burst length
        pub type DBL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DMACFGR_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            #[must_use]
            pub fn dba(&mut self) -> DBA_W<0> {
                DBA_W::new(self)
            }
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            #[must_use]
            pub fn dbl(&mut self) -> DBL_W<8> {
                DBL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmacfgr](index.html) module
        pub struct DMACFGR_SPEC;
        impl crate::RegisterSpec for DMACFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmacfgr::R](R) reader structure
        impl crate::Readable for DMACFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmacfgr::W](W) writer structure
        impl crate::Writable for DMACFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMACFGR to value 0
        impl crate::Resettable for DMACFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DMAADR (rw) register accessor: an alias for `Reg<DMAADR_SPEC>`
    pub type DMAADR = crate::Reg<dmaadr::DMAADR_SPEC>;
    ///DMA address for full transfer
    pub mod dmaadr {
        ///Register `DMAADR` reader
        pub struct R(crate::R<DMAADR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DMAADR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DMAADR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAADR` writer
        pub struct W(crate::W<DMAADR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAADR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DMAADR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DMAADR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAADR` reader - DMA register for burst accesses
        pub type DMAADR_R = crate::FieldReader<u16, u16>;
        ///Field `DMAADR` writer - DMA register for burst accesses
        pub type DMAADR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, DMAADR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmaadr(&self) -> DMAADR_R {
                DMAADR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            #[must_use]
            pub fn dmaadr(&mut self) -> DMAADR_W<0> {
                DMAADR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmaadr](index.html) module
        pub struct DMAADR_SPEC;
        impl crate::RegisterSpec for DMAADR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmaadr::R](R) reader structure
        impl crate::Readable for DMAADR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmaadr::W](W) writer structure
        impl crate::Writable for DMAADR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DMAADR to value 0
        impl crate::Resettable for DMAADR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Inter integrated circuit
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x4000_5400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C1").finish()
    }
}
///Inter integrated circuit
pub mod i2c1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register 1
        pub ctlr1: CTLR1,
        ///0x04 - Control register 2
        pub ctlr2: CTLR2,
        ///0x08 - Own address register 1
        pub oaddr1: OADDR1,
        ///0x0c - Own address register 2
        pub oaddr2: OADDR2,
        ///0x10 - Data register
        pub datar: DATAR,
        ///0x14 - Status register 1
        pub star1: STAR1,
        ///0x18 - Status register 2
        pub star2: STAR2,
        ///0x1c - Clock control register
        pub ckcfgr: CKCFGR,
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///Control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PE` reader - Peripheral enable
        pub type PE_R = crate::BitReader<bool>;
        ///Field `PE` writer - Peripheral enable
        pub type PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `ENARP` reader - ARP enable
        pub type ENARP_R = crate::BitReader<bool>;
        ///Field `ENARP` writer - ARP enable
        pub type ENARP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `ENPEC` reader - PEC enable
        pub type ENPEC_R = crate::BitReader<bool>;
        ///Field `ENPEC` writer - PEC enable
        pub type ENPEC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `ENGC` reader - General call enable
        pub type ENGC_R = crate::BitReader<bool>;
        ///Field `ENGC` writer - General call enable
        pub type ENGC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `NOSTRETCH` reader - Clock stretching disable (Slave mode)
        pub type NOSTRETCH_R = crate::BitReader<bool>;
        ///Field `NOSTRETCH` writer - Clock stretching disable (Slave mode)
        pub type NOSTRETCH_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `START` reader - Start generation
        pub type START_R = crate::BitReader<bool>;
        ///Field `START` writer - Start generation
        pub type START_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `STOP` reader - Stop generation
        pub type STOP_R = crate::BitReader<bool>;
        ///Field `STOP` writer - Stop generation
        pub type STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `ACK` reader - Acknowledge enable
        pub type ACK_R = crate::BitReader<bool>;
        ///Field `ACK` writer - Acknowledge enable
        pub type ACK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `POS` reader - Acknowledge/PEC Position (for data reception)
        pub type POS_R = crate::BitReader<bool>;
        ///Field `POS` writer - Acknowledge/PEC Position (for data reception)
        pub type POS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `PEC` reader - Packet error checking
        pub type PEC_R = crate::BitReader<bool>;
        ///Field `PEC` writer - Packet error checking
        pub type PEC_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `SWRST` reader - Software reset
        pub type SWRST_R = crate::BitReader<bool>;
        ///Field `SWRST` writer - Software reset
        pub type SWRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            pub fn enarp(&self) -> ENARP_R {
                ENARP_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            pub fn enpec(&self) -> ENPEC_R {
                ENPEC_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            pub fn engc(&self) -> ENGC_R {
                ENGC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn nostretch(&self) -> NOSTRETCH_R {
                NOSTRETCH_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            pub fn ack(&self) -> ACK_R {
                ACK_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn pos(&self) -> POS_R {
                POS_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 15 - Software reset
            #[inline(always)]
            pub fn swrst(&self) -> SWRST_R {
                SWRST_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<0> {
                PE_W::new(self)
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            #[must_use]
            pub fn enarp(&mut self) -> ENARP_W<4> {
                ENARP_W::new(self)
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            #[must_use]
            pub fn enpec(&mut self) -> ENPEC_W<5> {
                ENPEC_W::new(self)
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            #[must_use]
            pub fn engc(&mut self) -> ENGC_W<6> {
                ENGC_W::new(self)
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            #[must_use]
            pub fn nostretch(&mut self) -> NOSTRETCH_W<7> {
                NOSTRETCH_W::new(self)
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            #[must_use]
            pub fn start(&mut self) -> START_W<8> {
                START_W::new(self)
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<9> {
                STOP_W::new(self)
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            #[must_use]
            pub fn ack(&mut self) -> ACK_W<10> {
                ACK_W::new(self)
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            #[must_use]
            pub fn pos(&mut self) -> POS_W<11> {
                POS_W::new(self)
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            #[must_use]
            pub fn pec(&mut self) -> PEC_W<12> {
                PEC_W::new(self)
            }
            ///Bit 15 - Software reset
            #[inline(always)]
            #[must_use]
            pub fn swrst(&mut self) -> SWRST_W<15> {
                SWRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///Control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FREQ` reader - Peripheral clock frequency
        pub type FREQ_R = crate::FieldReader<u8, u8>;
        ///Field `FREQ` writer - Peripheral clock frequency
        pub type FREQ_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 6, O>;
        ///Field `ITERREN` reader - Error interrupt enable
        pub type ITERREN_R = crate::BitReader<bool>;
        ///Field `ITERREN` writer - Error interrupt enable
        pub type ITERREN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `ITEVTEN` reader - Event interrupt enable
        pub type ITEVTEN_R = crate::BitReader<bool>;
        ///Field `ITEVTEN` writer - Event interrupt enable
        pub type ITEVTEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `ITBUFEN` reader - Buffer interrupt enable
        pub type ITBUFEN_R = crate::BitReader<bool>;
        ///Field `ITBUFEN` writer - Buffer interrupt enable
        pub type ITBUFEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `DMAEN` reader - DMA requests enable
        pub type DMAEN_R = crate::BitReader<bool>;
        ///Field `DMAEN` writer - DMA requests enable
        pub type DMAEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `LAST` reader - DMA last transfer
        pub type LAST_R = crate::BitReader<bool>;
        ///Field `LAST` writer - DMA last transfer
        pub type LAST_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            pub fn freq(&self) -> FREQ_R {
                FREQ_R::new((self.bits & 0x3f) as u8)
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            pub fn iterren(&self) -> ITERREN_R {
                ITERREN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            pub fn itevten(&self) -> ITEVTEN_R {
                ITEVTEN_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            pub fn itbufen(&self) -> ITBUFEN_R {
                ITBUFEN_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            pub fn last(&self) -> LAST_R {
                LAST_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            #[must_use]
            pub fn freq(&mut self) -> FREQ_W<0> {
                FREQ_W::new(self)
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn iterren(&mut self) -> ITERREN_W<8> {
                ITERREN_W::new(self)
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itevten(&mut self) -> ITEVTEN_W<9> {
                ITEVTEN_W::new(self)
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn itbufen(&mut self) -> ITBUFEN_W<10> {
                ITBUFEN_W::new(self)
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            #[must_use]
            pub fn dmaen(&mut self) -> DMAEN_W<11> {
                DMAEN_W::new(self)
            }
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            #[must_use]
            pub fn last(&mut self) -> LAST_W<12> {
                LAST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OADDR1 (rw) register accessor: an alias for `Reg<OADDR1_SPEC>`
    pub type OADDR1 = crate::Reg<oaddr1::OADDR1_SPEC>;
    ///Own address register 1
    pub mod oaddr1 {
        ///Register `OADDR1` reader
        pub struct R(crate::R<OADDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OADDR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OADDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OADDR1` writer
        pub struct W(crate::W<OADDR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OADDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OADDR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OADDR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADD0` reader - Interface address
        pub type ADD0_R = crate::BitReader<bool>;
        ///Field `ADD0` writer - Interface address
        pub type ADD0_W<'a, const O: u8> = crate::BitWriter<'a, u32, OADDR1_SPEC, bool, O>;
        ///Field `ADD7_1` reader - Interface address
        pub type ADD7_1_R = crate::FieldReader<u8, u8>;
        ///Field `ADD7_1` writer - Interface address
        pub type ADD7_1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, OADDR1_SPEC, u8, u8, 7, O>;
        ///Field `ADD9_8` reader - Interface address
        pub type ADD9_8_R = crate::FieldReader<u8, u8>;
        ///Field `ADD9_8` writer - Interface address
        pub type ADD9_8_W<'a, const O: u8> = crate::FieldWriter<'a, u32, OADDR1_SPEC, u8, u8, 2, O>;
        ///Field `ADDMODE` reader - Addressing mode (slave mode)
        pub type ADDMODE_R = crate::BitReader<bool>;
        ///Field `ADDMODE` writer - Addressing mode (slave mode)
        pub type ADDMODE_W<'a, const O: u8> = crate::BitWriter<'a, u32, OADDR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Interface address
            #[inline(always)]
            pub fn add0(&self) -> ADD0_R {
                ADD0_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add7_1(&self) -> ADD7_1_R {
                ADD7_1_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bits 8:9 - Interface address
            #[inline(always)]
            pub fn add9_8(&self) -> ADD9_8_R {
                ADD9_8_R::new(((self.bits >> 8) & 3) as u8)
            }
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            pub fn addmode(&self) -> ADDMODE_R {
                ADDMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add0(&mut self) -> ADD0_W<0> {
                ADD0_W::new(self)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add7_1(&mut self) -> ADD7_1_W<1> {
                ADD7_1_W::new(self)
            }
            ///Bits 8:9 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add9_8(&mut self) -> ADD9_8_W<8> {
                ADD9_8_W::new(self)
            }
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            #[must_use]
            pub fn addmode(&mut self) -> ADDMODE_W<15> {
                ADDMODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Own address register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [oaddr1](index.html) module
        pub struct OADDR1_SPEC;
        impl crate::RegisterSpec for OADDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [oaddr1::R](R) reader structure
        impl crate::Readable for OADDR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [oaddr1::W](W) writer structure
        impl crate::Writable for OADDR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OADDR1 to value 0
        impl crate::Resettable for OADDR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OADDR2 (rw) register accessor: an alias for `Reg<OADDR2_SPEC>`
    pub type OADDR2 = crate::Reg<oaddr2::OADDR2_SPEC>;
    ///Own address register 2
    pub mod oaddr2 {
        ///Register `OADDR2` reader
        pub struct R(crate::R<OADDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OADDR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OADDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OADDR2` writer
        pub struct W(crate::W<OADDR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OADDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OADDR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OADDR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ENDUAL` reader - Dual addressing mode enable
        pub type ENDUAL_R = crate::BitReader<bool>;
        ///Field `ENDUAL` writer - Dual addressing mode enable
        pub type ENDUAL_W<'a, const O: u8> = crate::BitWriter<'a, u32, OADDR2_SPEC, bool, O>;
        ///Field `ADD2` reader - Interface address
        pub type ADD2_R = crate::FieldReader<u8, u8>;
        ///Field `ADD2` writer - Interface address
        pub type ADD2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, OADDR2_SPEC, u8, u8, 7, O>;
        impl R {
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            pub fn endual(&self) -> ENDUAL_R {
                ENDUAL_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add2(&self) -> ADD2_R {
                ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            #[must_use]
            pub fn endual(&mut self) -> ENDUAL_W<0> {
                ENDUAL_W::new(self)
            }
            ///Bits 1:7 - Interface address
            #[inline(always)]
            #[must_use]
            pub fn add2(&mut self) -> ADD2_W<1> {
                ADD2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Own address register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [oaddr2](index.html) module
        pub struct OADDR2_SPEC;
        impl crate::RegisterSpec for OADDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [oaddr2::R](R) reader structure
        impl crate::Readable for OADDR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [oaddr2::W](W) writer structure
        impl crate::Writable for OADDR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OADDR2 to value 0
        impl crate::Resettable for OADDR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DATAR (rw) register accessor: an alias for `Reg<DATAR_SPEC>`
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub struct R(crate::R<DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR` writer
        pub struct W(crate::W<DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DATAR` reader - 8-bit data register
        pub type DATAR_R = crate::FieldReader<u8, u8>;
        ///Field `DATAR` writer - 8-bit data register
        pub type DATAR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DATAR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            pub fn datar(&self) -> DATAR_R {
                DATAR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            #[must_use]
            pub fn datar(&mut self) -> DATAR_W<0> {
                DATAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar](index.html) module
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [datar::R](R) reader structure
        impl crate::Readable for DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar::W](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STAR1 (rw) register accessor: an alias for `Reg<STAR1_SPEC>`
    pub type STAR1 = crate::Reg<star1::STAR1_SPEC>;
    ///Status register 1
    pub mod star1 {
        ///Register `STAR1` reader
        pub struct R(crate::R<STAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STAR1` writer
        pub struct W(crate::W<STAR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STAR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STAR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SB` reader - Start bit (Master mode)
        pub type SB_R = crate::BitReader<bool>;
        ///Field `ADDR` reader - Address sent (master mode)/matched (slave mode)
        pub type ADDR_R = crate::BitReader<bool>;
        ///Field `BTF` reader - Byte transfer finished
        pub type BTF_R = crate::BitReader<bool>;
        ///Field `ADD10` reader - 10-bit header sent (Master mode)
        pub type ADD10_R = crate::BitReader<bool>;
        ///Field `STOPF` reader - Stop detection (slave mode)
        pub type STOPF_R = crate::BitReader<bool>;
        ///Field `RxNE` reader - Data register not empty (receivers)
        pub type RX_NE_R = crate::BitReader<bool>;
        ///Field `TxE` reader - Data register empty (transmitters)
        pub type TX_E_R = crate::BitReader<bool>;
        ///Field `BERR` reader - Bus error
        pub type BERR_R = crate::BitReader<bool>;
        ///Field `BERR` writer - Bus error
        pub type BERR_W<'a, const O: u8> = crate::BitWriter<'a, u32, STAR1_SPEC, bool, O>;
        ///Field `ARLO` reader - Arbitration lost (master mode)
        pub type ARLO_R = crate::BitReader<bool>;
        ///Field `ARLO` writer - Arbitration lost (master mode)
        pub type ARLO_W<'a, const O: u8> = crate::BitWriter<'a, u32, STAR1_SPEC, bool, O>;
        ///Field `AF` reader - Acknowledge failure
        pub type AF_R = crate::BitReader<bool>;
        ///Field `AF` writer - Acknowledge failure
        pub type AF_W<'a, const O: u8> = crate::BitWriter<'a, u32, STAR1_SPEC, bool, O>;
        ///Field `OVR` reader - Overrun/Underrun
        pub type OVR_R = crate::BitReader<bool>;
        ///Field `OVR` writer - Overrun/Underrun
        pub type OVR_W<'a, const O: u8> = crate::BitWriter<'a, u32, STAR1_SPEC, bool, O>;
        ///Field `PECERR` reader - PEC Error in reception
        pub type PECERR_R = crate::BitReader<bool>;
        ///Field `PECERR` writer - PEC Error in reception
        pub type PECERR_W<'a, const O: u8> = crate::BitWriter<'a, u32, STAR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Start bit (Master mode)
            #[inline(always)]
            pub fn sb(&self) -> SB_R {
                SB_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Address sent (master mode)/matched (slave mode)
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Byte transfer finished
            #[inline(always)]
            pub fn btf(&self) -> BTF_R {
                BTF_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - 10-bit header sent (Master mode)
            #[inline(always)]
            pub fn add10(&self) -> ADD10_R {
                ADD10_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Stop detection (slave mode)
            #[inline(always)]
            pub fn stopf(&self) -> STOPF_R {
                STOPF_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 6 - Data register not empty (receivers)
            #[inline(always)]
            pub fn rx_ne(&self) -> RX_NE_R {
                RX_NE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Data register empty (transmitters)
            #[inline(always)]
            pub fn tx_e(&self) -> TX_E_R {
                TX_E_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Bus error
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            pub fn arlo(&self) -> ARLO_R {
                ARLO_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            pub fn af(&self) -> AF_R {
                AF_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            pub fn pecerr(&self) -> PECERR_R {
                PECERR_R::new(((self.bits >> 12) & 1) != 0)
            }
        }
        impl W {
            ///Bit 8 - Bus error
            #[inline(always)]
            #[must_use]
            pub fn berr(&mut self) -> BERR_W<8> {
                BERR_W::new(self)
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            #[must_use]
            pub fn arlo(&mut self) -> ARLO_W<9> {
                ARLO_W::new(self)
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            #[must_use]
            pub fn af(&mut self) -> AF_W<10> {
                AF_W::new(self)
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            #[must_use]
            pub fn ovr(&mut self) -> OVR_W<11> {
                OVR_W::new(self)
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            #[must_use]
            pub fn pecerr(&mut self) -> PECERR_W<12> {
                PECERR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [star1](index.html) module
        pub struct STAR1_SPEC;
        impl crate::RegisterSpec for STAR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [star1::R](R) reader structure
        impl crate::Readable for STAR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [star1::W](W) writer structure
        impl crate::Writable for STAR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STAR1 to value 0
        impl crate::Resettable for STAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STAR2 (r) register accessor: an alias for `Reg<STAR2_SPEC>`
    pub type STAR2 = crate::Reg<star2::STAR2_SPEC>;
    ///Status register 2
    pub mod star2 {
        ///Register `STAR2` reader
        pub struct R(crate::R<STAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `MSL` reader - Master/slave
        pub type MSL_R = crate::BitReader<bool>;
        ///Field `BUSY` reader - Bus busy
        pub type BUSY_R = crate::BitReader<bool>;
        ///Field `TRA` reader - Transmitter/receiver
        pub type TRA_R = crate::BitReader<bool>;
        ///Field `GENCALL` reader - General call address (Slave mode)
        pub type GENCALL_R = crate::BitReader<bool>;
        ///Field `DUALF` reader - Dual flag (Slave mode)
        pub type DUALF_R = crate::BitReader<bool>;
        ///Field `PEC` reader - acket error checking register
        pub type PEC_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bit 0 - Master/slave
            #[inline(always)]
            pub fn msl(&self) -> MSL_R {
                MSL_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Bus busy
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Transmitter/receiver
            #[inline(always)]
            pub fn tra(&self) -> TRA_R {
                TRA_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - General call address (Slave mode)
            #[inline(always)]
            pub fn gencall(&self) -> GENCALL_R {
                GENCALL_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 7 - Dual flag (Slave mode)
            #[inline(always)]
            pub fn dualf(&self) -> DUALF_R {
                DUALF_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bits 8:15 - acket error checking register
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        ///Status register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [star2](index.html) module
        pub struct STAR2_SPEC;
        impl crate::RegisterSpec for STAR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [star2::R](R) reader structure
        impl crate::Readable for STAR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets STAR2 to value 0
        impl crate::Resettable for STAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CKCFGR (rw) register accessor: an alias for `Reg<CKCFGR_SPEC>`
    pub type CKCFGR = crate::Reg<ckcfgr::CKCFGR_SPEC>;
    ///Clock control register
    pub mod ckcfgr {
        ///Register `CKCFGR` reader
        pub struct R(crate::R<CKCFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CKCFGR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CKCFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CKCFGR` writer
        pub struct W(crate::W<CKCFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CKCFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CKCFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CKCFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR` reader - Clock control register in Fast/Standard mode (Master mode)
        pub type CCR_R = crate::FieldReader<u16, u16>;
        ///Field `CCR` writer - Clock control register in Fast/Standard mode (Master mode)
        pub type CCR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CKCFGR_SPEC, u16, u16, 12, O>;
        ///Field `DUTY` reader - Fast mode duty cycle
        pub type DUTY_R = crate::BitReader<bool>;
        ///Field `DUTY` writer - Fast mode duty cycle
        pub type DUTY_W<'a, const O: u8> = crate::BitWriter<'a, u32, CKCFGR_SPEC, bool, O>;
        ///Field `F_S` reader - I2C master mode selection
        pub type F_S_R = crate::BitReader<bool>;
        ///Field `F_S` writer - I2C master mode selection
        pub type F_S_W<'a, const O: u8> = crate::BitWriter<'a, u32, CKCFGR_SPEC, bool, O>;
        impl R {
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0x0fff) as u16)
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            pub fn duty(&self) -> DUTY_R {
                DUTY_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            pub fn f_s(&self) -> F_S_R {
                F_S_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            #[must_use]
            pub fn ccr(&mut self) -> CCR_W<0> {
                CCR_W::new(self)
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            #[must_use]
            pub fn duty(&mut self) -> DUTY_W<14> {
                DUTY_W::new(self)
            }
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            #[must_use]
            pub fn f_s(&mut self) -> F_S_W<15> {
                F_S_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ckcfgr](index.html) module
        pub struct CKCFGR_SPEC;
        impl crate::RegisterSpec for CKCFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ckcfgr::R](R) reader structure
        impl crate::Readable for CKCFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ckcfgr::W](W) writer structure
        impl crate::Writable for CKCFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CKCFGR to value 0
        impl crate::Resettable for CKCFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Serial peripheral interface
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4001_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///Serial peripheral interface
pub mod spi1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub ctlr1: CTLR1,
        ///0x04 - control register 2
        pub ctlr2: CTLR2,
        ///0x08 - status register
        pub statr: STATR,
        ///0x0c - data register
        pub datar: DATAR,
        ///0x10 - CRCR polynomial register
        pub crcr: CRCR,
        ///0x14 - RX CRC register
        pub rcrcr: RCRCR,
        ///0x18 - send CRC register
        pub tcrcr: TCRCR,
        _reserved7: [u8; 0x08],
        ///0x24 - high speed control register
        pub hscr: HSCR,
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CPHA` reader - Clock phase
        pub type CPHA_R = crate::BitReader<bool>;
        ///Field `CPHA` writer - Clock phase
        pub type CPHA_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `CPOL` reader - Clock polarity
        pub type CPOL_R = crate::BitReader<bool>;
        ///Field `CPOL` writer - Clock polarity
        pub type CPOL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `MSTR` reader - Master selection
        pub type MSTR_R = crate::BitReader<bool>;
        ///Field `MSTR` writer - Master selection
        pub type MSTR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `BR` reader - Baud rate control
        pub type BR_R = crate::FieldReader<u8, u8>;
        ///Field `BR` writer - Baud rate control
        pub type BR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 3, O>;
        ///Field `SPE` reader - SPI enable
        pub type SPE_R = crate::BitReader<bool>;
        ///Field `SPE` writer - SPI enable
        pub type SPE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `LSBFIRST` reader - Frame format
        pub type LSBFIRST_R = crate::BitReader<bool>;
        ///Field `LSBFIRST` writer - Frame format
        pub type LSBFIRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `SSI` reader - Internal slave select
        pub type SSI_R = crate::BitReader<bool>;
        ///Field `SSI` writer - Internal slave select
        pub type SSI_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `SSM` reader - Software slave management
        pub type SSM_R = crate::BitReader<bool>;
        ///Field `SSM` writer - Software slave management
        pub type SSM_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `RXONLY` reader - Receive only
        pub type RXONLY_R = crate::BitReader<bool>;
        ///Field `RXONLY` writer - Receive only
        pub type RXONLY_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `DFF` reader - Data frame format
        pub type DFF_R = crate::BitReader<bool>;
        ///Field `DFF` writer - Data frame format
        pub type DFF_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `CRCNEXT` reader - CRC transfer next
        pub type CRCNEXT_R = crate::BitReader<bool>;
        ///Field `CRCNEXT` writer - CRC transfer next
        pub type CRCNEXT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `CRCEN` reader - Hardware CRC calculation enable
        pub type CRCEN_R = crate::BitReader<bool>;
        ///Field `CRCEN` writer - Hardware CRC calculation enable
        pub type CRCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `BIDIOE` reader - Output enable in bidirectional mode
        pub type BIDIOE_R = crate::BitReader<bool>;
        ///Field `BIDIOE` writer - Output enable in bidirectional mode
        pub type BIDIOE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `BIDIMODE` reader - Bidirectional data mode enable
        pub type BIDIMODE_R = crate::BitReader<bool>;
        ///Field `BIDIMODE` writer - Bidirectional data mode enable
        pub type BIDIMODE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            pub fn mstr(&self) -> MSTR_R {
                MSTR_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            pub fn br(&self) -> BR_R {
                BR_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            pub fn spe(&self) -> SPE_R {
                SPE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            pub fn lsbfirst(&self) -> LSBFIRST_R {
                LSBFIRST_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            pub fn ssi(&self) -> SSI_R {
                SSI_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            pub fn ssm(&self) -> SSM_R {
                SSM_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            pub fn rxonly(&self) -> RXONLY_R {
                RXONLY_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            pub fn dff(&self) -> DFF_R {
                DFF_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            pub fn crcnext(&self) -> CRCNEXT_R {
                CRCNEXT_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 13) & 1) != 0)
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            pub fn bidioe(&self) -> BIDIOE_R {
                BIDIOE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            pub fn bidimode(&self) -> BIDIMODE_R {
                BIDIMODE_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Clock phase
            #[inline(always)]
            #[must_use]
            pub fn cpha(&mut self) -> CPHA_W<0> {
                CPHA_W::new(self)
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            #[must_use]
            pub fn cpol(&mut self) -> CPOL_W<1> {
                CPOL_W::new(self)
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            #[must_use]
            pub fn mstr(&mut self) -> MSTR_W<2> {
                MSTR_W::new(self)
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            #[must_use]
            pub fn br(&mut self) -> BR_W<3> {
                BR_W::new(self)
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            #[must_use]
            pub fn spe(&mut self) -> SPE_W<6> {
                SPE_W::new(self)
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            #[must_use]
            pub fn lsbfirst(&mut self) -> LSBFIRST_W<7> {
                LSBFIRST_W::new(self)
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            #[must_use]
            pub fn ssi(&mut self) -> SSI_W<8> {
                SSI_W::new(self)
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            #[must_use]
            pub fn ssm(&mut self) -> SSM_W<9> {
                SSM_W::new(self)
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            #[must_use]
            pub fn rxonly(&mut self) -> RXONLY_W<10> {
                RXONLY_W::new(self)
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            #[must_use]
            pub fn dff(&mut self) -> DFF_W<11> {
                DFF_W::new(self)
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            #[must_use]
            pub fn crcnext(&mut self) -> CRCNEXT_W<12> {
                CRCNEXT_W::new(self)
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            #[must_use]
            pub fn crcen(&mut self) -> CRCEN_W<13> {
                CRCEN_W::new(self)
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            #[must_use]
            pub fn bidioe(&mut self) -> BIDIOE_W<14> {
                BIDIOE_W::new(self)
            }
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            #[must_use]
            pub fn bidimode(&mut self) -> BIDIMODE_W<15> {
                BIDIMODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RXDMAEN` reader - Rx buffer DMA enable
        pub type RXDMAEN_R = crate::BitReader<bool>;
        ///Field `RXDMAEN` writer - Rx buffer DMA enable
        pub type RXDMAEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `TXDMAEN` reader - Tx buffer DMA enable
        pub type TXDMAEN_R = crate::BitReader<bool>;
        ///Field `TXDMAEN` writer - Tx buffer DMA enable
        pub type TXDMAEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `SSOE` reader - SS output enable
        pub type SSOE_R = crate::BitReader<bool>;
        ///Field `SSOE` writer - SS output enable
        pub type SSOE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `ERRIE` reader - Error interrupt enable
        pub type ERRIE_R = crate::BitReader<bool>;
        ///Field `ERRIE` writer - Error interrupt enable
        pub type ERRIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `RXNEIE` reader - RX buffer not empty interrupt enable
        pub type RXNEIE_R = crate::BitReader<bool>;
        ///Field `RXNEIE` writer - RX buffer not empty interrupt enable
        pub type RXNEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `TXEIE` reader - Tx buffer empty interrupt enable
        pub type TXEIE_R = crate::BitReader<bool>;
        ///Field `TXEIE` writer - Tx buffer empty interrupt enable
        pub type TXEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            pub fn rxdmaen(&self) -> RXDMAEN_R {
                RXDMAEN_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            pub fn txdmaen(&self) -> TXDMAEN_R {
                TXDMAEN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            pub fn ssoe(&self) -> SSOE_R {
                SSOE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            #[must_use]
            pub fn rxdmaen(&mut self) -> RXDMAEN_W<0> {
                RXDMAEN_W::new(self)
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            #[must_use]
            pub fn txdmaen(&mut self) -> TXDMAEN_W<1> {
                TXDMAEN_W::new(self)
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            #[must_use]
            pub fn ssoe(&mut self) -> SSOE_W<2> {
                SSOE_W::new(self)
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn errie(&mut self) -> ERRIE_W<5> {
                ERRIE_W::new(self)
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rxneie(&mut self) -> RXNEIE_W<6> {
                RXNEIE_W::new(self)
            }
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn txeie(&mut self) -> TXEIE_W<7> {
                TXEIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RXNE` reader - Receive buffer not empty
        pub type RXNE_R = crate::BitReader<bool>;
        ///Field `TXE` reader - Transmit buffer empty
        pub type TXE_R = crate::BitReader<bool>;
        ///Field `CHSID` reader - Channel side
        pub type CHSID_R = crate::BitReader<bool>;
        ///Field `UDR` reader - Underrun flag
        pub type UDR_R = crate::BitReader<bool>;
        ///Field `CRCERR` reader - CRC error flag
        pub type CRCERR_R = crate::BitReader<bool>;
        ///Field `CRCERR` writer - CRC error flag
        pub type CRCERR_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `MODF` reader - Mode fault
        pub type MODF_R = crate::BitReader<bool>;
        ///Field `OVR` reader - Overrun flag
        pub type OVR_R = crate::BitReader<bool>;
        ///Field `OVR` writer - Overrun flag
        pub type OVR_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `BSY` reader - Busy flag
        pub type BSY_R = crate::BitReader<bool>;
        impl R {
            ///Bit 0 - Receive buffer not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Transmit buffer empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Channel side
            #[inline(always)]
            pub fn chsid(&self) -> CHSID_R {
                CHSID_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Underrun flag
            #[inline(always)]
            pub fn udr(&self) -> UDR_R {
                UDR_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - CRC error flag
            #[inline(always)]
            pub fn crcerr(&self) -> CRCERR_R {
                CRCERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Mode fault
            #[inline(always)]
            pub fn modf(&self) -> MODF_R {
                MODF_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Overrun flag
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Busy flag
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - CRC error flag
            #[inline(always)]
            #[must_use]
            pub fn crcerr(&mut self) -> CRCERR_W<4> {
                CRCERR_W::new(self)
            }
            ///Bit 6 - Overrun flag
            #[inline(always)]
            #[must_use]
            pub fn ovr(&mut self) -> OVR_W<6> {
                OVR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0x02
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0x02;
        }
    }
    ///DATAR (rw) register accessor: an alias for `Reg<DATAR_SPEC>`
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///data register
    pub mod datar {
        ///Register `DATAR` reader
        pub struct R(crate::R<DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR` writer
        pub struct W(crate::W<DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DATAR` reader - Data register
        pub type DATAR_R = crate::FieldReader<u16, u16>;
        ///Field `DATAR` writer - Data register
        pub type DATAR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, DATAR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - Data register
            #[inline(always)]
            pub fn datar(&self) -> DATAR_R {
                DATAR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Data register
            #[inline(always)]
            #[must_use]
            pub fn datar(&mut self) -> DATAR_W<0> {
                DATAR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar](index.html) module
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [datar::R](R) reader structure
        impl crate::Readable for DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar::W](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CRCR (rw) register accessor: an alias for `Reg<CRCR_SPEC>`
    pub type CRCR = crate::Reg<crcr::CRCR_SPEC>;
    ///CRCR polynomial register
    pub mod crcr {
        ///Register `CRCR` reader
        pub struct R(crate::R<CRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CRCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CRCR` writer
        pub struct W(crate::W<CRCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CRCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CRCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CRCPOLY` reader - CRC polynomial register
        pub type CRCPOLY_R = crate::FieldReader<u16, u16>;
        ///Field `CRCPOLY` writer - CRC polynomial register
        pub type CRCPOLY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CRCR_SPEC, u16, u16, 16, O>;
        impl R {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            pub fn crcpoly(&self) -> CRCPOLY_R {
                CRCPOLY_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            #[must_use]
            pub fn crcpoly(&mut self) -> CRCPOLY_W<0> {
                CRCPOLY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///CRCR polynomial register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [crcr](index.html) module
        pub struct CRCR_SPEC;
        impl crate::RegisterSpec for CRCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [crcr::R](R) reader structure
        impl crate::Readable for CRCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [crcr::W](W) writer structure
        impl crate::Writable for CRCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CRCR to value 0x07
        impl crate::Resettable for CRCR_SPEC {
            const RESET_VALUE: Self::Ux = 0x07;
        }
    }
    ///RCRCR (r) register accessor: an alias for `Reg<RCRCR_SPEC>`
    pub type RCRCR = crate::Reg<rcrcr::RCRCR_SPEC>;
    ///RX CRC register
    pub mod rcrcr {
        ///Register `RCRCR` reader
        pub struct R(crate::R<RCRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RCRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RCRCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RCRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RXCRC` reader - Rx CRC register
        pub type RXCRC_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Rx CRC register
            #[inline(always)]
            pub fn rxcrc(&self) -> RXCRC_R {
                RXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///RX CRC register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rcrcr](index.html) module
        pub struct RCRCR_SPEC;
        impl crate::RegisterSpec for RCRCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rcrcr::R](R) reader structure
        impl crate::Readable for RCRCR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RCRCR to value 0
        impl crate::Resettable for RCRCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///TCRCR (r) register accessor: an alias for `Reg<TCRCR_SPEC>`
    pub type TCRCR = crate::Reg<tcrcr::TCRCR_SPEC>;
    ///send CRC register
    pub mod tcrcr {
        ///Register `TCRCR` reader
        pub struct R(crate::R<TCRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TCRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<TCRCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<TCRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TXCRC` reader - Tx CRC register
        pub type TXCRC_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Tx CRC register
            #[inline(always)]
            pub fn txcrc(&self) -> TXCRC_R {
                TXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///send CRC register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [tcrcr](index.html) module
        pub struct TCRCR_SPEC;
        impl crate::RegisterSpec for TCRCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [tcrcr::R](R) reader structure
        impl crate::Readable for TCRCR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TCRCR to value 0
        impl crate::Resettable for TCRCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///HSCR (w) register accessor: an alias for `Reg<HSCR_SPEC>`
    pub type HSCR = crate::Reg<hscr::HSCR_SPEC>;
    ///high speed control register
    pub mod hscr {
        ///Register `HSCR` writer
        pub struct W(crate::W<HSCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<HSCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<HSCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<HSCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HSRXEN` writer - High speed mode read enable
        pub type HSRXEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, HSCR_SPEC, bool, O>;
        impl W {
            ///Bit 0 - High speed mode read enable
            #[inline(always)]
            #[must_use]
            pub fn hsrxen(&mut self) -> HSRXEN_W<0> {
                HSRXEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///high speed control register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [hscr](index.html) module
        pub struct HSCR_SPEC;
        impl crate::RegisterSpec for HSCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [hscr::W](W) writer structure
        impl crate::Writable for HSCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets HSCR to value 0
        impl crate::Resettable for HSCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Universal synchronous asynchronous receiver transmitter
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART1 {}
impl USART1 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4001_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USART1 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART1").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub mod usart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Status register
        pub statr: STATR,
        ///0x04 - Data register
        pub datar: DATAR,
        ///0x08 - Baud rate register
        pub brr: BRR,
        ///0x0c - Control register 1
        pub ctlr1: CTLR1,
        ///0x10 - Control register 2
        pub ctlr2: CTLR2,
        ///0x14 - Control register 3
        pub ctlr3: CTLR3,
        ///0x18 - Guard time and prescaler register
        pub gpr: GPR,
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PE` reader - Parity error
        pub type PE_R = crate::BitReader<bool>;
        ///Field `FE` reader - Framing error
        pub type FE_R = crate::BitReader<bool>;
        ///Field `NE` reader - Noise error flag
        pub type NE_R = crate::BitReader<bool>;
        ///Field `ORE` reader - Overrun error
        pub type ORE_R = crate::BitReader<bool>;
        ///Field `IDLE` reader - IDLE line detected
        pub type IDLE_R = crate::BitReader<bool>;
        ///Field `RXNE` reader - Read data register not empty
        pub type RXNE_R = crate::BitReader<bool>;
        ///Field `RXNE` writer - Read data register not empty
        pub type RXNE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `TC` reader - Transmission complete
        pub type TC_R = crate::BitReader<bool>;
        ///Field `TC` writer - Transmission complete
        pub type TC_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `TXE` reader - Transmit data register empty
        pub type TXE_R = crate::BitReader<bool>;
        ///Field `LBD` reader - LIN break detection flag
        pub type LBD_R = crate::BitReader<bool>;
        ///Field `LBD` writer - LIN break detection flag
        pub type LBD_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `CTS` reader - CTS flag
        pub type CTS_R = crate::BitReader<bool>;
        ///Field `CTS` writer - CTS flag
        pub type CTS_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Parity error
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Framing error
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Noise error flag
            #[inline(always)]
            pub fn ne(&self) -> NE_R {
                NE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Overrun error
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IDLE line detected
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Transmit data register empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            pub fn lbd(&self) -> LBD_R {
                LBD_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - CTS flag
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            #[must_use]
            pub fn rxne(&mut self) -> RXNE_W<5> {
                RXNE_W::new(self)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            #[must_use]
            pub fn tc(&mut self) -> TC_W<6> {
                TC_W::new(self)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            #[must_use]
            pub fn lbd(&mut self) -> LBD_W<8> {
                LBD_W::new(self)
            }
            ///Bit 9 - CTS flag
            #[inline(always)]
            #[must_use]
            pub fn cts(&mut self) -> CTS_W<9> {
                CTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0xc0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0xc0;
        }
    }
    ///DATAR (rw) register accessor: an alias for `Reg<DATAR_SPEC>`
    pub type DATAR = crate::Reg<datar::DATAR_SPEC>;
    ///Data register
    pub mod datar {
        ///Register `DATAR` reader
        pub struct R(crate::R<DATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DATAR` writer
        pub struct W(crate::W<DATAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DATAR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DATAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - Data value
        pub type DR_R = crate::FieldReader<u16, u16>;
        ///Field `DR` writer - Data value
        pub type DR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DATAR_SPEC, u16, u16, 9, O>;
        impl R {
            ///Bits 0:8 - Data value
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            ///Bits 0:8 - Data value
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<0> {
                DR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [datar](index.html) module
        pub struct DATAR_SPEC;
        impl crate::RegisterSpec for DATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [datar::R](R) reader structure
        impl crate::Readable for DATAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [datar::W](W) writer structure
        impl crate::Writable for DATAR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DATAR to value 0
        impl crate::Resettable for DATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BRR (rw) register accessor: an alias for `Reg<BRR_SPEC>`
    pub type BRR = crate::Reg<brr::BRR_SPEC>;
    ///Baud rate register
    pub mod brr {
        ///Register `BRR` reader
        pub struct R(crate::R<BRR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<BRR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<BRR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BRR` writer
        pub struct W(crate::W<BRR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BRR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BRR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DIV_Fraction` reader - fraction of USARTDIV
        pub type DIV_FRACTION_R = crate::FieldReader<u8, u8>;
        ///Field `DIV_Fraction` writer - fraction of USARTDIV
        pub type DIV_FRACTION_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BRR_SPEC, u8, u8, 4, O>;
        ///Field `DIV_Mantissa` reader - mantissa of USARTDIV
        pub type DIV_MANTISSA_R = crate::FieldReader<u16, u16>;
        ///Field `DIV_Mantissa` writer - mantissa of USARTDIV
        pub type DIV_MANTISSA_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BRR_SPEC, u16, u16, 12, O>;
        impl R {
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            pub fn div_fraction(&self) -> DIV_FRACTION_R {
                DIV_FRACTION_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            pub fn div_mantissa(&self) -> DIV_MANTISSA_R {
                DIV_MANTISSA_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            #[must_use]
            pub fn div_fraction(&mut self) -> DIV_FRACTION_W<0> {
                DIV_FRACTION_W::new(self)
            }
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            #[must_use]
            pub fn div_mantissa(&mut self) -> DIV_MANTISSA_W<4> {
                DIV_MANTISSA_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Baud rate register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [brr](index.html) module
        pub struct BRR_SPEC;
        impl crate::RegisterSpec for BRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [brr::R](R) reader structure
        impl crate::Readable for BRR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [brr::W](W) writer structure
        impl crate::Writable for BRR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BRR to value 0
        impl crate::Resettable for BRR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///Control register 1
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SBK` reader - Send break
        pub type SBK_R = crate::BitReader<bool>;
        ///Field `SBK` writer - Send break
        pub type SBK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `RWU` reader - Receiver wakeup
        pub type RWU_R = crate::BitReader<bool>;
        ///Field `RWU` writer - Receiver wakeup
        pub type RWU_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `RE` reader - Receiver enable
        pub type RE_R = crate::BitReader<bool>;
        ///Field `RE` writer - Receiver enable
        pub type RE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `TE` reader - Transmitter enable
        pub type TE_R = crate::BitReader<bool>;
        ///Field `TE` writer - Transmitter enable
        pub type TE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `IDLEIE` reader - IDLE interrupt enable
        pub type IDLEIE_R = crate::BitReader<bool>;
        ///Field `IDLEIE` writer - IDLE interrupt enable
        pub type IDLEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `RXNEIE` reader - RXNE interrupt enable
        pub type RXNEIE_R = crate::BitReader<bool>;
        ///Field `RXNEIE` writer - RXNE interrupt enable
        pub type RXNEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `TCIE` reader - Transmission complete interrupt enable
        pub type TCIE_R = crate::BitReader<bool>;
        ///Field `TCIE` writer - Transmission complete interrupt enable
        pub type TCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `TXEIE` reader - TXE interrupt enable
        pub type TXEIE_R = crate::BitReader<bool>;
        ///Field `TXEIE` writer - TXE interrupt enable
        pub type TXEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `PEIE` reader - PE interrupt enable
        pub type PEIE_R = crate::BitReader<bool>;
        ///Field `PEIE` writer - PE interrupt enable
        pub type PEIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `PS` reader - Parity selection
        pub type PS_R = crate::BitReader<bool>;
        ///Field `PS` writer - Parity selection
        pub type PS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `PCE` reader - Parity control enable
        pub type PCE_R = crate::BitReader<bool>;
        ///Field `PCE` writer - Parity control enable
        pub type PCE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `WAKE` reader - Wakeup method
        pub type WAKE_R = crate::BitReader<bool>;
        ///Field `WAKE` writer - Wakeup method
        pub type WAKE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `M` reader - Word length
        pub type M_R = crate::BitReader<bool>;
        ///Field `M` writer - Word length
        pub type M_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `UE` reader - USART enable
        pub type UE_R = crate::BitReader<bool>;
        ///Field `UE` writer - USART enable
        pub type UE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Send break
            #[inline(always)]
            pub fn sbk(&self) -> SBK_R {
                SBK_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            pub fn m(&self) -> M_R {
                M_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new(((self.bits >> 13) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Send break
            #[inline(always)]
            #[must_use]
            pub fn sbk(&mut self) -> SBK_W<0> {
                SBK_W::new(self)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            #[must_use]
            pub fn rwu(&mut self) -> RWU_W<1> {
                RWU_W::new(self)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            #[must_use]
            pub fn re(&mut self) -> RE_W<2> {
                RE_W::new(self)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            #[must_use]
            pub fn te(&mut self) -> TE_W<3> {
                TE_W::new(self)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn idleie(&mut self) -> IDLEIE_W<4> {
                IDLEIE_W::new(self)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn rxneie(&mut self) -> RXNEIE_W<5> {
                RXNEIE_W::new(self)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn tcie(&mut self) -> TCIE_W<6> {
                TCIE_W::new(self)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn txeie(&mut self) -> TXEIE_W<7> {
                TXEIE_W::new(self)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn peie(&mut self) -> PEIE_W<8> {
                PEIE_W::new(self)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            #[must_use]
            pub fn ps(&mut self) -> PS_W<9> {
                PS_W::new(self)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            #[must_use]
            pub fn pce(&mut self) -> PCE_W<10> {
                PCE_W::new(self)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            #[must_use]
            pub fn wake(&mut self) -> WAKE_W<11> {
                WAKE_W::new(self)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            #[must_use]
            pub fn m(&mut self) -> M_W<12> {
                M_W::new(self)
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            #[must_use]
            pub fn ue(&mut self) -> UE_W<13> {
                UE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///Control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADD` reader - Address of the USART node
        pub type ADD_R = crate::FieldReader<u8, u8>;
        ///Field `ADD` writer - Address of the USART node
        pub type ADD_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 4, O>;
        ///Field `LBDL` reader - lin break detection length
        pub type LBDL_R = crate::BitReader<bool>;
        ///Field `LBDL` writer - lin break detection length
        pub type LBDL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `LBDIE` reader - LIN break detection interrupt enable
        pub type LBDIE_R = crate::BitReader<bool>;
        ///Field `LBDIE` writer - LIN break detection interrupt enable
        pub type LBDIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `LBCL` reader - Last bit clock pulse
        pub type LBCL_R = crate::BitReader<bool>;
        ///Field `LBCL` writer - Last bit clock pulse
        pub type LBCL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CPHA` reader - Clock phase
        pub type CPHA_R = crate::BitReader<bool>;
        ///Field `CPHA` writer - Clock phase
        pub type CPHA_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CPOL` reader - Clock polarity
        pub type CPOL_R = crate::BitReader<bool>;
        ///Field `CPOL` writer - Clock polarity
        pub type CPOL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CLKEN` reader - Clock enable
        pub type CLKEN_R = crate::BitReader<bool>;
        ///Field `CLKEN` writer - Clock enable
        pub type CLKEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `STOP` reader - STOP bits
        pub type STOP_R = crate::FieldReader<u8, u8>;
        ///Field `STOP` writer - STOP bits
        pub type STOP_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 2, O>;
        ///Field `LINEN` reader - LIN mode enable
        pub type LINEN_R = crate::BitReader<bool>;
        ///Field `LINEN` writer - LIN mode enable
        pub type LINEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            pub fn lbcl(&self) -> LBCL_R {
                LBCL_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 3) as u8)
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            #[must_use]
            pub fn add(&mut self) -> ADD_W<0> {
                ADD_W::new(self)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            #[must_use]
            pub fn lbdl(&mut self) -> LBDL_W<5> {
                LBDL_W::new(self)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn lbdie(&mut self) -> LBDIE_W<6> {
                LBDIE_W::new(self)
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            #[must_use]
            pub fn lbcl(&mut self) -> LBCL_W<8> {
                LBCL_W::new(self)
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            #[must_use]
            pub fn cpha(&mut self) -> CPHA_W<9> {
                CPHA_W::new(self)
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            #[must_use]
            pub fn cpol(&mut self) -> CPOL_W<10> {
                CPOL_W::new(self)
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            #[must_use]
            pub fn clken(&mut self) -> CLKEN_W<11> {
                CLKEN_W::new(self)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<12> {
                STOP_W::new(self)
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            #[must_use]
            pub fn linen(&mut self) -> LINEN_W<14> {
                LINEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR3 (rw) register accessor: an alias for `Reg<CTLR3_SPEC>`
    pub type CTLR3 = crate::Reg<ctlr3::CTLR3_SPEC>;
    ///Control register 3
    pub mod ctlr3 {
        ///Register `CTLR3` reader
        pub struct R(crate::R<CTLR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR3` writer
        pub struct W(crate::W<CTLR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EIE` reader - Error interrupt enable
        pub type EIE_R = crate::BitReader<bool>;
        ///Field `EIE` writer - Error interrupt enable
        pub type EIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `IREN` reader - IrDA mode enable
        pub type IREN_R = crate::BitReader<bool>;
        ///Field `IREN` writer - IrDA mode enable
        pub type IREN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `IRLP` reader - IrDA low-power
        pub type IRLP_R = crate::BitReader<bool>;
        ///Field `IRLP` writer - IrDA low-power
        pub type IRLP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `HDSEL` reader - Half-duplex selection
        pub type HDSEL_R = crate::BitReader<bool>;
        ///Field `HDSEL` writer - Half-duplex selection
        pub type HDSEL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `NACK` reader - Smartcard NACK enable
        pub type NACK_R = crate::BitReader<bool>;
        ///Field `NACK` writer - Smartcard NACK enable
        pub type NACK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `SCEN` reader - Smartcard mode enable
        pub type SCEN_R = crate::BitReader<bool>;
        ///Field `SCEN` writer - Smartcard mode enable
        pub type SCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `DMAR` reader - DMA enable receiver
        pub type DMAR_R = crate::BitReader<bool>;
        ///Field `DMAR` writer - DMA enable receiver
        pub type DMAR_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `DMAT` reader - DMA enable transmitter
        pub type DMAT_R = crate::BitReader<bool>;
        ///Field `DMAT` writer - DMA enable transmitter
        pub type DMAT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `RTSE` reader - RTS enable
        pub type RTSE_R = crate::BitReader<bool>;
        ///Field `RTSE` writer - RTS enable
        pub type RTSE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `CTSE` reader - CTS enable
        pub type CTSE_R = crate::BitReader<bool>;
        ///Field `CTSE` writer - CTS enable
        pub type CTSE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        ///Field `CTSIE` reader - CTS interrupt enable
        pub type CTSIE_R = crate::BitReader<bool>;
        ///Field `CTSIE` writer - CTS interrupt enable
        pub type CTSIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR3_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            pub fn scen(&self) -> SCEN_R {
                SCEN_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            pub fn rtse(&self) -> RTSE_R {
                RTSE_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            pub fn ctse(&self) -> CTSE_R {
                CTSE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            pub fn ctsie(&self) -> CTSIE_R {
                CTSIE_R::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn eie(&mut self) -> EIE_W<0> {
                EIE_W::new(self)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            #[must_use]
            pub fn iren(&mut self) -> IREN_W<1> {
                IREN_W::new(self)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            #[must_use]
            pub fn irlp(&mut self) -> IRLP_W<2> {
                IRLP_W::new(self)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            #[must_use]
            pub fn hdsel(&mut self) -> HDSEL_W<3> {
                HDSEL_W::new(self)
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            #[must_use]
            pub fn nack(&mut self) -> NACK_W<4> {
                NACK_W::new(self)
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            #[must_use]
            pub fn scen(&mut self) -> SCEN_W<5> {
                SCEN_W::new(self)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            #[must_use]
            pub fn dmar(&mut self) -> DMAR_W<6> {
                DMAR_W::new(self)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            #[must_use]
            pub fn dmat(&mut self) -> DMAT_W<7> {
                DMAT_W::new(self)
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            #[must_use]
            pub fn rtse(&mut self) -> RTSE_W<8> {
                RTSE_W::new(self)
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            #[must_use]
            pub fn ctse(&mut self) -> CTSE_W<9> {
                CTSE_W::new(self)
            }
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn ctsie(&mut self) -> CTSIE_W<10> {
                CTSIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr3](index.html) module
        pub struct CTLR3_SPEC;
        impl crate::RegisterSpec for CTLR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr3::R](R) reader structure
        impl crate::Readable for CTLR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr3::W](W) writer structure
        impl crate::Writable for CTLR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR3 to value 0
        impl crate::Resettable for CTLR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///GPR (rw) register accessor: an alias for `Reg<GPR_SPEC>`
    pub type GPR = crate::Reg<gpr::GPR_SPEC>;
    ///Guard time and prescaler register
    pub mod gpr {
        ///Register `GPR` reader
        pub struct R(crate::R<GPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GPR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `GPR` writer
        pub struct W(crate::W<GPR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<GPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<GPR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<GPR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub type PSC_R = crate::FieldReader<u8, u8>;
        ///Field `PSC` writer - Prescaler value
        pub type PSC_W<'a, const O: u8> = crate::FieldWriter<'a, u32, GPR_SPEC, u8, u8, 8, O>;
        ///Field `GT` reader - Guard time value
        pub type GT_R = crate::FieldReader<u8, u8>;
        ///Field `GT` writer - Guard time value
        pub type GT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, GPR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            pub fn gt(&self) -> GT_R {
                GT_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            #[must_use]
            pub fn psc(&mut self) -> PSC_W<0> {
                PSC_W::new(self)
            }
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            #[must_use]
            pub fn gt(&mut self) -> GT_W<8> {
                GT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Guard time and prescaler register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [gpr](index.html) module
        pub struct GPR_SPEC;
        impl crate::RegisterSpec for GPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [gpr::R](R) reader structure
        impl crate::Readable for GPR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [gpr::W](W) writer structure
        impl crate::Writable for GPR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets GPR to value 0
        impl crate::Resettable for GPR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Analog to digital converter
pub struct ADC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC1 {}
impl ADC1 {
    ///Pointer to the register block
    pub const PTR: *const adc1::RegisterBlock = 0x4001_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const adc1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ADC1 {
    type Target = adc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC1").finish()
    }
}
///Analog to digital converter
pub mod adc1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - status register
        pub statr: STATR,
        ///0x04 - control register 1/TKEY_V_CTLR
        pub ctlr1: CTLR1,
        ///0x08 - control register 2
        pub ctlr2: CTLR2,
        ///0x0c - sample time register 1
        pub samptr1_charge1: SAMPTR1_CHARGE1,
        ///0x10 - sample time register 2
        pub samptr2_charge2: SAMPTR2_CHARGE2,
        ///0x14 - injected channel data offset register x
        pub iofr1: IOFR1,
        ///0x18 - injected channel data offset register x
        pub iofr2: IOFR2,
        ///0x1c - injected channel data offset register x
        pub iofr3: IOFR3,
        ///0x20 - injected channel data offset register x
        pub iofr4: IOFR4,
        ///0x24 - watchdog higher threshold register
        pub wdhtr: WDHTR,
        ///0x28 - watchdog lower threshold register
        pub wdltr: WDLTR,
        ///0x2c - regular sequence register 1
        pub rsqr1: RSQR1,
        ///0x30 - regular sequence register 2
        pub rsqr2: RSQR2,
        ///0x34 - regular sequence register 3
        pub rsqr3: RSQR3,
        ///0x38 - injected sequence register
        pub isqr: ISQR,
        ///0x3c - injected data register 1
        pub idatar1: IDATAR1,
        ///0x40 - injected data register 2
        pub idatar2: IDATAR2,
        ///0x44 - injected data register 3
        pub idatar3: IDATAR3,
        ///0x48 - injected data register 4
        pub idatar4: IDATAR4,
        ///0x4c - regular data register
        pub rdatar: RDATAR,
        ///0x50 - delay data register
        pub dlyr: DLYR,
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AWD` reader - Analog watchdog flag
        pub type AWD_R = crate::BitReader<bool>;
        ///Field `AWD` writer - Analog watchdog flag
        pub type AWD_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `EOC` reader - Regular channel end of conversion
        pub type EOC_R = crate::BitReader<bool>;
        ///Field `EOC` writer - Regular channel end of conversion
        pub type EOC_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `JEOC` reader - Injected channel end of conversion
        pub type JEOC_R = crate::BitReader<bool>;
        ///Field `JEOC` writer - Injected channel end of conversion
        pub type JEOC_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `JSTRT` reader - Injected channel start flag
        pub type JSTRT_R = crate::BitReader<bool>;
        ///Field `JSTRT` writer - Injected channel start flag
        pub type JSTRT_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `STRT` reader - Regular channel start flag
        pub type STRT_R = crate::BitReader<bool>;
        ///Field `STRT` writer - Regular channel start flag
        pub type STRT_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            pub fn awd(&self) -> AWD_R {
                AWD_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            pub fn jeoc(&self) -> JEOC_R {
                JEOC_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            pub fn jstrt(&self) -> JSTRT_R {
                JSTRT_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            #[must_use]
            pub fn awd(&mut self) -> AWD_W<0> {
                AWD_W::new(self)
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            #[must_use]
            pub fn eoc(&mut self) -> EOC_W<1> {
                EOC_W::new(self)
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            #[must_use]
            pub fn jeoc(&mut self) -> JEOC_W<2> {
                JEOC_W::new(self)
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            #[must_use]
            pub fn jstrt(&mut self) -> JSTRT_W<3> {
                JSTRT_W::new(self)
            }
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            #[must_use]
            pub fn strt(&mut self) -> STRT_W<4> {
                STRT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR1 (rw) register accessor: an alias for `Reg<CTLR1_SPEC>`
    pub type CTLR1 = crate::Reg<ctlr1::CTLR1_SPEC>;
    ///control register 1/TKEY_V_CTLR
    pub mod ctlr1 {
        ///Register `CTLR1` reader
        pub struct R(crate::R<CTLR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR1` writer
        pub struct W(crate::W<CTLR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `AWDCH` reader - Analog watchdog channel select bits
        pub type AWDCH_R = crate::FieldReader<u8, u8>;
        ///Field `AWDCH` writer - Analog watchdog channel select bits
        pub type AWDCH_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 5, O>;
        ///Field `EOCIE` reader - Interrupt enable for EOC
        pub type EOCIE_R = crate::BitReader<bool>;
        ///Field `EOCIE` writer - Interrupt enable for EOC
        pub type EOCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `AWDIE` reader - Analog watchdog interrupt enable
        pub type AWDIE_R = crate::BitReader<bool>;
        ///Field `AWDIE` writer - Analog watchdog interrupt enable
        pub type AWDIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `JEOCIE` reader - Interrupt enable for injected channels
        pub type JEOCIE_R = crate::BitReader<bool>;
        ///Field `JEOCIE` writer - Interrupt enable for injected channels
        pub type JEOCIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `SCAN` reader - Scan mode enable
        pub type SCAN_R = crate::BitReader<bool>;
        ///Field `SCAN` writer - Scan mode enable
        pub type SCAN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `AWDSGL` reader - Enable the watchdog on a single channel in scan mode
        pub type AWDSGL_R = crate::BitReader<bool>;
        ///Field `AWDSGL` writer - Enable the watchdog on a single channel in scan mode
        pub type AWDSGL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `JAUTO` reader - Automatic injected group conversion
        pub type JAUTO_R = crate::BitReader<bool>;
        ///Field `JAUTO` writer - Automatic injected group conversion
        pub type JAUTO_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `DISCEN` reader - Discontinuous mode on regular channels
        pub type DISCEN_R = crate::BitReader<bool>;
        ///Field `DISCEN` writer - Discontinuous mode on regular channels
        pub type DISCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `JDISCEN` reader - Discontinuous mode on injected channels
        pub type JDISCEN_R = crate::BitReader<bool>;
        ///Field `JDISCEN` writer - Discontinuous mode on injected channels
        pub type JDISCEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `DISCNUM` reader - Discontinuous mode channel count
        pub type DISCNUM_R = crate::FieldReader<u8, u8>;
        ///Field `DISCNUM` writer - Discontinuous mode channel count
        pub type DISCNUM_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 3, O>;
        ///Field `JAWDEN` reader - Analog watchdog enable on injected channels
        pub type JAWDEN_R = crate::BitReader<bool>;
        ///Field `JAWDEN` writer - Analog watchdog enable on injected channels
        pub type JAWDEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `AWDEN` reader - Analog watchdog enable on regular channels
        pub type AWDEN_R = crate::BitReader<bool>;
        ///Field `AWDEN` writer - Analog watchdog enable on regular channels
        pub type AWDEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR1_SPEC, bool, O>;
        ///Field `ADC_CAL_VOL` reader - ADC Calibration voltage selection
        pub type ADC_CAL_VOL_R = crate::FieldReader<u8, u8>;
        ///Field `ADC_CAL_VOL` writer - ADC Calibration voltage selection
        pub type ADC_CAL_VOL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CTLR1_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            pub fn awdch(&self) -> AWDCH_R {
                AWDCH_R::new((self.bits & 0x1f) as u8)
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            pub fn eocie(&self) -> EOCIE_R {
                EOCIE_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            pub fn awdie(&self) -> AWDIE_R {
                AWDIE_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            pub fn jeocie(&self) -> JEOCIE_R {
                JEOCIE_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 8 - Scan mode enable
            #[inline(always)]
            pub fn scan(&self) -> SCAN_R {
                SCAN_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            pub fn awdsgl(&self) -> AWDSGL_R {
                AWDSGL_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            pub fn jauto(&self) -> JAUTO_R {
                JAUTO_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            pub fn discen(&self) -> DISCEN_R {
                DISCEN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            pub fn jdiscen(&self) -> JDISCEN_R {
                JDISCEN_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            pub fn discnum(&self) -> DISCNUM_R {
                DISCNUM_R::new(((self.bits >> 13) & 7) as u8)
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            pub fn jawden(&self) -> JAWDEN_R {
                JAWDEN_R::new(((self.bits >> 22) & 1) != 0)
            }
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            pub fn awden(&self) -> AWDEN_R {
                AWDEN_R::new(((self.bits >> 23) & 1) != 0)
            }
            ///Bits 25:26 - ADC Calibration voltage selection
            #[inline(always)]
            pub fn adc_cal_vol(&self) -> ADC_CAL_VOL_R {
                ADC_CAL_VOL_R::new(((self.bits >> 25) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            #[must_use]
            pub fn awdch(&mut self) -> AWDCH_W<0> {
                AWDCH_W::new(self)
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            #[must_use]
            pub fn eocie(&mut self) -> EOCIE_W<5> {
                EOCIE_W::new(self)
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn awdie(&mut self) -> AWDIE_W<6> {
                AWDIE_W::new(self)
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            #[must_use]
            pub fn jeocie(&mut self) -> JEOCIE_W<7> {
                JEOCIE_W::new(self)
            }
            ///Bit 8 - Scan mode enable
            #[inline(always)]
            #[must_use]
            pub fn scan(&mut self) -> SCAN_W<8> {
                SCAN_W::new(self)
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            #[must_use]
            pub fn awdsgl(&mut self) -> AWDSGL_W<9> {
                AWDSGL_W::new(self)
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            #[must_use]
            pub fn jauto(&mut self) -> JAUTO_W<10> {
                JAUTO_W::new(self)
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            #[must_use]
            pub fn discen(&mut self) -> DISCEN_W<11> {
                DISCEN_W::new(self)
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            #[must_use]
            pub fn jdiscen(&mut self) -> JDISCEN_W<12> {
                JDISCEN_W::new(self)
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            #[must_use]
            pub fn discnum(&mut self) -> DISCNUM_W<13> {
                DISCNUM_W::new(self)
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            #[must_use]
            pub fn jawden(&mut self) -> JAWDEN_W<22> {
                JAWDEN_W::new(self)
            }
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            #[must_use]
            pub fn awden(&mut self) -> AWDEN_W<23> {
                AWDEN_W::new(self)
            }
            ///Bits 25:26 - ADC Calibration voltage selection
            #[inline(always)]
            #[must_use]
            pub fn adc_cal_vol(&mut self) -> ADC_CAL_VOL_W<25> {
                ADC_CAL_VOL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1/TKEY_V_CTLR
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr1](index.html) module
        pub struct CTLR1_SPEC;
        impl crate::RegisterSpec for CTLR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr1::R](R) reader structure
        impl crate::Readable for CTLR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr1::W](W) writer structure
        impl crate::Writable for CTLR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR1 to value 0
        impl crate::Resettable for CTLR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CTLR2 (rw) register accessor: an alias for `Reg<CTLR2_SPEC>`
    pub type CTLR2 = crate::Reg<ctlr2::CTLR2_SPEC>;
    ///control register 2
    pub mod ctlr2 {
        ///Register `CTLR2` reader
        pub struct R(crate::R<CTLR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR2` writer
        pub struct W(crate::W<CTLR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADON` reader - A/D converter ON / OFF
        pub type ADON_R = crate::BitReader<bool>;
        ///Field `ADON` writer - A/D converter ON / OFF
        pub type ADON_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CONT` reader - Continuous conversion
        pub type CONT_R = crate::BitReader<bool>;
        ///Field `CONT` writer - Continuous conversion
        pub type CONT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `CAL` reader - A/D calibration
        pub type CAL_R = crate::BitReader<bool>;
        ///Field `CAL` writer - A/D calibration
        pub type CAL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `RSTCAL` reader - Reset calibration
        pub type RSTCAL_R = crate::BitReader<bool>;
        ///Field `RSTCAL` writer - Reset calibration
        pub type RSTCAL_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `DMA` reader - Direct memory access mode
        pub type DMA_R = crate::BitReader<bool>;
        ///Field `DMA` writer - Direct memory access mode
        pub type DMA_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `ALIGN` reader - Data alignment
        pub type ALIGN_R = crate::BitReader<bool>;
        ///Field `ALIGN` writer - Data alignment
        pub type ALIGN_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `JEXTSEL` reader - External event select for injected group
        pub type JEXTSEL_R = crate::FieldReader<u8, u8>;
        ///Field `JEXTSEL` writer - External event select for injected group
        pub type JEXTSEL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 3, O>;
        ///Field `JEXTTRIG` reader - External trigger conversion mode for injected channels
        pub type JEXTTRIG_R = crate::BitReader<bool>;
        ///Field `JEXTTRIG` writer - External trigger conversion mode for injected channels
        pub type JEXTTRIG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `EXTSEL` reader - External event select for regular group
        pub type EXTSEL_R = crate::FieldReader<u8, u8>;
        ///Field `EXTSEL` writer - External event select for regular group
        pub type EXTSEL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, CTLR2_SPEC, u8, u8, 3, O>;
        ///Field `EXTTRIG` reader - External trigger conversion mode for regular channels
        pub type EXTTRIG_R = crate::BitReader<bool>;
        ///Field `EXTTRIG` writer - External trigger conversion mode for regular channels
        pub type EXTTRIG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `JSWSTART` reader - Start conversion of injected channels
        pub type JSWSTART_R = crate::BitReader<bool>;
        ///Field `JSWSTART` writer - Start conversion of injected channels
        pub type JSWSTART_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        ///Field `SWSTART` reader - Start conversion of regular channels
        pub type SWSTART_R = crate::BitReader<bool>;
        ///Field `SWSTART` writer - Start conversion of regular channels
        pub type SWSTART_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR2_SPEC, bool, O>;
        impl R {
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            pub fn adon(&self) -> ADON_R {
                ADON_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            pub fn cont(&self) -> CONT_R {
                CONT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            pub fn rstcal(&self) -> RSTCAL_R {
                RSTCAL_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            pub fn dma(&self) -> DMA_R {
                DMA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            pub fn align(&self) -> ALIGN_R {
                ALIGN_R::new(((self.bits >> 11) & 1) != 0)
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            pub fn jextsel(&self) -> JEXTSEL_R {
                JEXTSEL_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            pub fn jexttrig(&self) -> JEXTTRIG_R {
                JEXTTRIG_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            pub fn extsel(&self) -> EXTSEL_R {
                EXTSEL_R::new(((self.bits >> 17) & 7) as u8)
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            pub fn exttrig(&self) -> EXTTRIG_R {
                EXTTRIG_R::new(((self.bits >> 20) & 1) != 0)
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            pub fn jswstart(&self) -> JSWSTART_R {
                JSWSTART_R::new(((self.bits >> 21) & 1) != 0)
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            pub fn swstart(&self) -> SWSTART_R {
                SWSTART_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            #[must_use]
            pub fn adon(&mut self) -> ADON_W<0> {
                ADON_W::new(self)
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            #[must_use]
            pub fn cont(&mut self) -> CONT_W<1> {
                CONT_W::new(self)
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            #[must_use]
            pub fn cal(&mut self) -> CAL_W<2> {
                CAL_W::new(self)
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            #[must_use]
            pub fn rstcal(&mut self) -> RSTCAL_W<3> {
                RSTCAL_W::new(self)
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            #[must_use]
            pub fn dma(&mut self) -> DMA_W<8> {
                DMA_W::new(self)
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            #[must_use]
            pub fn align(&mut self) -> ALIGN_W<11> {
                ALIGN_W::new(self)
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            #[must_use]
            pub fn jextsel(&mut self) -> JEXTSEL_W<12> {
                JEXTSEL_W::new(self)
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            #[must_use]
            pub fn jexttrig(&mut self) -> JEXTTRIG_W<15> {
                JEXTTRIG_W::new(self)
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            #[must_use]
            pub fn extsel(&mut self) -> EXTSEL_W<17> {
                EXTSEL_W::new(self)
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            #[must_use]
            pub fn exttrig(&mut self) -> EXTTRIG_W<20> {
                EXTTRIG_W::new(self)
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            #[must_use]
            pub fn jswstart(&mut self) -> JSWSTART_W<21> {
                JSWSTART_W::new(self)
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            #[must_use]
            pub fn swstart(&mut self) -> SWSTART_W<22> {
                SWSTART_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr2](index.html) module
        pub struct CTLR2_SPEC;
        impl crate::RegisterSpec for CTLR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr2::R](R) reader structure
        impl crate::Readable for CTLR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr2::W](W) writer structure
        impl crate::Writable for CTLR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR2 to value 0
        impl crate::Resettable for CTLR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SAMPTR1_CHARGE1 (rw) register accessor: an alias for `Reg<SAMPTR1_CHARGE1_SPEC>`
    pub type SAMPTR1_CHARGE1 = crate::Reg<samptr1_charge1::SAMPTR1_CHARGE1_SPEC>;
    ///sample time register 1
    pub mod samptr1_charge1 {
        ///Register `SAMPTR1_CHARGE1` reader
        pub struct R(crate::R<SAMPTR1_CHARGE1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAMPTR1_CHARGE1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAMPTR1_CHARGE1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAMPTR1_CHARGE1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SAMPTR1_CHARGE1` writer
        pub struct W(crate::W<SAMPTR1_CHARGE1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SAMPTR1_CHARGE1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SAMPTR1_CHARGE1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SAMPTR1_CHARGE1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMP10_TKCG10` reader - Channel 10 sample time selection
        pub type SMP10_TKCG10_R = crate::FieldReader<u8, u8>;
        ///Field `SMP10_TKCG10` writer - Channel 10 sample time selection
        pub type SMP10_TKCG10_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR1_CHARGE1_SPEC, u8, u8, 3, O>;
        ///Field `SMP11_TKCG11` reader - Channel 11 sample time selection
        pub type SMP11_TKCG11_R = crate::FieldReader<u8, u8>;
        ///Field `SMP11_TKCG11` writer - Channel 11 sample time selection
        pub type SMP11_TKCG11_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR1_CHARGE1_SPEC, u8, u8, 3, O>;
        ///Field `SMP12_TKCG12` reader - Channel 12 sample time selection
        pub type SMP12_TKCG12_R = crate::FieldReader<u8, u8>;
        ///Field `SMP12_TKCG12` writer - Channel 12 sample time selection
        pub type SMP12_TKCG12_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR1_CHARGE1_SPEC, u8, u8, 3, O>;
        ///Field `SMP13_TKCG13` reader - Channel 13 sample time selection
        pub type SMP13_TKCG13_R = crate::FieldReader<u8, u8>;
        ///Field `SMP13_TKCG13` writer - Channel 13 sample time selection
        pub type SMP13_TKCG13_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR1_CHARGE1_SPEC, u8, u8, 3, O>;
        ///Field `SMP14_TKCG14` reader - Channel 14 sample time selection
        pub type SMP14_TKCG14_R = crate::FieldReader<u8, u8>;
        ///Field `SMP14_TKCG14` writer - Channel 14 sample time selection
        pub type SMP14_TKCG14_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR1_CHARGE1_SPEC, u8, u8, 3, O>;
        ///Field `SMP15_TKCG15` reader - Channel 15 sample time selection
        pub type SMP15_TKCG15_R = crate::FieldReader<u8, u8>;
        ///Field `SMP15_TKCG15` writer - Channel 15 sample time selection
        pub type SMP15_TKCG15_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR1_CHARGE1_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:2 - Channel 10 sample time selection
            #[inline(always)]
            pub fn smp10_tkcg10(&self) -> SMP10_TKCG10_R {
                SMP10_TKCG10_R::new((self.bits & 7) as u8)
            }
            ///Bits 3:5 - Channel 11 sample time selection
            #[inline(always)]
            pub fn smp11_tkcg11(&self) -> SMP11_TKCG11_R {
                SMP11_TKCG11_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:8 - Channel 12 sample time selection
            #[inline(always)]
            pub fn smp12_tkcg12(&self) -> SMP12_TKCG12_R {
                SMP12_TKCG12_R::new(((self.bits >> 6) & 7) as u8)
            }
            ///Bits 9:11 - Channel 13 sample time selection
            #[inline(always)]
            pub fn smp13_tkcg13(&self) -> SMP13_TKCG13_R {
                SMP13_TKCG13_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bits 12:14 - Channel 14 sample time selection
            #[inline(always)]
            pub fn smp14_tkcg14(&self) -> SMP14_TKCG14_R {
                SMP14_TKCG14_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bits 15:17 - Channel 15 sample time selection
            #[inline(always)]
            pub fn smp15_tkcg15(&self) -> SMP15_TKCG15_R {
                SMP15_TKCG15_R::new(((self.bits >> 15) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Channel 10 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp10_tkcg10(&mut self) -> SMP10_TKCG10_W<0> {
                SMP10_TKCG10_W::new(self)
            }
            ///Bits 3:5 - Channel 11 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp11_tkcg11(&mut self) -> SMP11_TKCG11_W<3> {
                SMP11_TKCG11_W::new(self)
            }
            ///Bits 6:8 - Channel 12 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp12_tkcg12(&mut self) -> SMP12_TKCG12_W<6> {
                SMP12_TKCG12_W::new(self)
            }
            ///Bits 9:11 - Channel 13 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp13_tkcg13(&mut self) -> SMP13_TKCG13_W<9> {
                SMP13_TKCG13_W::new(self)
            }
            ///Bits 12:14 - Channel 14 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp14_tkcg14(&mut self) -> SMP14_TKCG14_W<12> {
                SMP14_TKCG14_W::new(self)
            }
            ///Bits 15:17 - Channel 15 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp15_tkcg15(&mut self) -> SMP15_TKCG15_W<15> {
                SMP15_TKCG15_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///sample time register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [samptr1_charge1](index.html) module
        pub struct SAMPTR1_CHARGE1_SPEC;
        impl crate::RegisterSpec for SAMPTR1_CHARGE1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [samptr1_charge1::R](R) reader structure
        impl crate::Readable for SAMPTR1_CHARGE1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [samptr1_charge1::W](W) writer structure
        impl crate::Writable for SAMPTR1_CHARGE1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SAMPTR1_CHARGE1 to value 0
        impl crate::Resettable for SAMPTR1_CHARGE1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SAMPTR2_CHARGE2 (rw) register accessor: an alias for `Reg<SAMPTR2_CHARGE2_SPEC>`
    pub type SAMPTR2_CHARGE2 = crate::Reg<samptr2_charge2::SAMPTR2_CHARGE2_SPEC>;
    ///sample time register 2
    pub mod samptr2_charge2 {
        ///Register `SAMPTR2_CHARGE2` reader
        pub struct R(crate::R<SAMPTR2_CHARGE2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SAMPTR2_CHARGE2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SAMPTR2_CHARGE2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SAMPTR2_CHARGE2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SAMPTR2_CHARGE2` writer
        pub struct W(crate::W<SAMPTR2_CHARGE2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SAMPTR2_CHARGE2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SAMPTR2_CHARGE2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SAMPTR2_CHARGE2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SMP0_TKCG0` reader - Channel 0 sample time selection
        pub type SMP0_TKCG0_R = crate::FieldReader<u8, u8>;
        ///Field `SMP0_TKCG0` writer - Channel 0 sample time selection
        pub type SMP0_TKCG0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP1_TKCG1` reader - Channel 1 sample time selection
        pub type SMP1_TKCG1_R = crate::FieldReader<u8, u8>;
        ///Field `SMP1_TKCG1` writer - Channel 1 sample time selection
        pub type SMP1_TKCG1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP2_TKCG2` reader - Channel 2 sample time selection
        pub type SMP2_TKCG2_R = crate::FieldReader<u8, u8>;
        ///Field `SMP2_TKCG2` writer - Channel 2 sample time selection
        pub type SMP2_TKCG2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP3_TKCG3` reader - Channel 3 sample time selection
        pub type SMP3_TKCG3_R = crate::FieldReader<u8, u8>;
        ///Field `SMP3_TKCG3` writer - Channel 3 sample time selection
        pub type SMP3_TKCG3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP4_TKCG4` reader - Channel 4 sample time selection
        pub type SMP4_TKCG4_R = crate::FieldReader<u8, u8>;
        ///Field `SMP4_TKCG4` writer - Channel 4 sample time selection
        pub type SMP4_TKCG4_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP5_TKCG5` reader - Channel 5 sample time selection
        pub type SMP5_TKCG5_R = crate::FieldReader<u8, u8>;
        ///Field `SMP5_TKCG5` writer - Channel 5 sample time selection
        pub type SMP5_TKCG5_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP6_TKCG6` reader - Channel 6 sample time selection
        pub type SMP6_TKCG6_R = crate::FieldReader<u8, u8>;
        ///Field `SMP6_TKCG6` writer - Channel 6 sample time selection
        pub type SMP6_TKCG6_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP7_TKCG7` reader - Channel 7 sample time selection
        pub type SMP7_TKCG7_R = crate::FieldReader<u8, u8>;
        ///Field `SMP7_TKCG7` writer - Channel 7 sample time selection
        pub type SMP7_TKCG7_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP8_TKCG8` reader - Channel 8 sample time selection
        pub type SMP8_TKCG8_R = crate::FieldReader<u8, u8>;
        ///Field `SMP8_TKCG8` writer - Channel 8 sample time selection
        pub type SMP8_TKCG8_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        ///Field `SMP9_TKCG9` reader - Channel 9 sample time selection
        pub type SMP9_TKCG9_R = crate::FieldReader<u8, u8>;
        ///Field `SMP9_TKCG9` writer - Channel 9 sample time selection
        pub type SMP9_TKCG9_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, SAMPTR2_CHARGE2_SPEC, u8, u8, 3, O>;
        impl R {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            pub fn smp0_tkcg0(&self) -> SMP0_TKCG0_R {
                SMP0_TKCG0_R::new((self.bits & 7) as u8)
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            pub fn smp1_tkcg1(&self) -> SMP1_TKCG1_R {
                SMP1_TKCG1_R::new(((self.bits >> 3) & 7) as u8)
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            pub fn smp2_tkcg2(&self) -> SMP2_TKCG2_R {
                SMP2_TKCG2_R::new(((self.bits >> 6) & 7) as u8)
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            pub fn smp3_tkcg3(&self) -> SMP3_TKCG3_R {
                SMP3_TKCG3_R::new(((self.bits >> 9) & 7) as u8)
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            pub fn smp4_tkcg4(&self) -> SMP4_TKCG4_R {
                SMP4_TKCG4_R::new(((self.bits >> 12) & 7) as u8)
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            pub fn smp5_tkcg5(&self) -> SMP5_TKCG5_R {
                SMP5_TKCG5_R::new(((self.bits >> 15) & 7) as u8)
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            pub fn smp6_tkcg6(&self) -> SMP6_TKCG6_R {
                SMP6_TKCG6_R::new(((self.bits >> 18) & 7) as u8)
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            pub fn smp7_tkcg7(&self) -> SMP7_TKCG7_R {
                SMP7_TKCG7_R::new(((self.bits >> 21) & 7) as u8)
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            pub fn smp8_tkcg8(&self) -> SMP8_TKCG8_R {
                SMP8_TKCG8_R::new(((self.bits >> 24) & 7) as u8)
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            pub fn smp9_tkcg9(&self) -> SMP9_TKCG9_R {
                SMP9_TKCG9_R::new(((self.bits >> 27) & 7) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp0_tkcg0(&mut self) -> SMP0_TKCG0_W<0> {
                SMP0_TKCG0_W::new(self)
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp1_tkcg1(&mut self) -> SMP1_TKCG1_W<3> {
                SMP1_TKCG1_W::new(self)
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp2_tkcg2(&mut self) -> SMP2_TKCG2_W<6> {
                SMP2_TKCG2_W::new(self)
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp3_tkcg3(&mut self) -> SMP3_TKCG3_W<9> {
                SMP3_TKCG3_W::new(self)
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp4_tkcg4(&mut self) -> SMP4_TKCG4_W<12> {
                SMP4_TKCG4_W::new(self)
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp5_tkcg5(&mut self) -> SMP5_TKCG5_W<15> {
                SMP5_TKCG5_W::new(self)
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp6_tkcg6(&mut self) -> SMP6_TKCG6_W<18> {
                SMP6_TKCG6_W::new(self)
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp7_tkcg7(&mut self) -> SMP7_TKCG7_W<21> {
                SMP7_TKCG7_W::new(self)
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp8_tkcg8(&mut self) -> SMP8_TKCG8_W<24> {
                SMP8_TKCG8_W::new(self)
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            #[must_use]
            pub fn smp9_tkcg9(&mut self) -> SMP9_TKCG9_W<27> {
                SMP9_TKCG9_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///sample time register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [samptr2_charge2](index.html) module
        pub struct SAMPTR2_CHARGE2_SPEC;
        impl crate::RegisterSpec for SAMPTR2_CHARGE2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [samptr2_charge2::R](R) reader structure
        impl crate::Readable for SAMPTR2_CHARGE2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [samptr2_charge2::W](W) writer structure
        impl crate::Writable for SAMPTR2_CHARGE2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SAMPTR2_CHARGE2 to value 0
        impl crate::Resettable for SAMPTR2_CHARGE2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR1 (rw) register accessor: an alias for `Reg<IOFR1_SPEC>`
    pub type IOFR1 = crate::Reg<iofr1::IOFR1_SPEC>;
    ///injected channel data offset register x
    pub mod iofr1 {
        ///Register `IOFR1` reader
        pub struct R(crate::R<IOFR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR1` writer
        pub struct W(crate::W<IOFR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET1` reader - Data offset for injected channel x
        pub type JOFFSET1_R = crate::FieldReader<u16, u16>;
        ///Field `JOFFSET1` writer - Data offset for injected channel x
        pub type JOFFSET1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR1_SPEC, u16, u16, 10, O>;
        impl R {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset1(&self) -> JOFFSET1_R {
                JOFFSET1_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset1(&mut self) -> JOFFSET1_W<0> {
                JOFFSET1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr1](index.html) module
        pub struct IOFR1_SPEC;
        impl crate::RegisterSpec for IOFR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr1::R](R) reader structure
        impl crate::Readable for IOFR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr1::W](W) writer structure
        impl crate::Writable for IOFR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR1 to value 0
        impl crate::Resettable for IOFR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR2 (rw) register accessor: an alias for `Reg<IOFR2_SPEC>`
    pub type IOFR2 = crate::Reg<iofr2::IOFR2_SPEC>;
    ///injected channel data offset register x
    pub mod iofr2 {
        ///Register `IOFR2` reader
        pub struct R(crate::R<IOFR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR2` writer
        pub struct W(crate::W<IOFR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET2` reader - Data offset for injected channel x
        pub type JOFFSET2_R = crate::FieldReader<u16, u16>;
        ///Field `JOFFSET2` writer - Data offset for injected channel x
        pub type JOFFSET2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR2_SPEC, u16, u16, 10, O>;
        impl R {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset2(&self) -> JOFFSET2_R {
                JOFFSET2_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset2(&mut self) -> JOFFSET2_W<0> {
                JOFFSET2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr2](index.html) module
        pub struct IOFR2_SPEC;
        impl crate::RegisterSpec for IOFR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr2::R](R) reader structure
        impl crate::Readable for IOFR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr2::W](W) writer structure
        impl crate::Writable for IOFR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR2 to value 0
        impl crate::Resettable for IOFR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR3 (rw) register accessor: an alias for `Reg<IOFR3_SPEC>`
    pub type IOFR3 = crate::Reg<iofr3::IOFR3_SPEC>;
    ///injected channel data offset register x
    pub mod iofr3 {
        ///Register `IOFR3` reader
        pub struct R(crate::R<IOFR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR3` writer
        pub struct W(crate::W<IOFR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET3` reader - Data offset for injected channel x
        pub type JOFFSET3_R = crate::FieldReader<u16, u16>;
        ///Field `JOFFSET3` writer - Data offset for injected channel x
        pub type JOFFSET3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR3_SPEC, u16, u16, 10, O>;
        impl R {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset3(&self) -> JOFFSET3_R {
                JOFFSET3_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset3(&mut self) -> JOFFSET3_W<0> {
                JOFFSET3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr3](index.html) module
        pub struct IOFR3_SPEC;
        impl crate::RegisterSpec for IOFR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr3::R](R) reader structure
        impl crate::Readable for IOFR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr3::W](W) writer structure
        impl crate::Writable for IOFR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR3 to value 0
        impl crate::Resettable for IOFR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IOFR4 (rw) register accessor: an alias for `Reg<IOFR4_SPEC>`
    pub type IOFR4 = crate::Reg<iofr4::IOFR4_SPEC>;
    ///injected channel data offset register x
    pub mod iofr4 {
        ///Register `IOFR4` reader
        pub struct R(crate::R<IOFR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IOFR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IOFR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IOFR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IOFR4` writer
        pub struct W(crate::W<IOFR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IOFR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IOFR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IOFR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET4` reader - Data offset for injected channel x
        pub type JOFFSET4_R = crate::FieldReader<u16, u16>;
        ///Field `JOFFSET4` writer - Data offset for injected channel x
        pub type JOFFSET4_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IOFR4_SPEC, u16, u16, 10, O>;
        impl R {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            pub fn joffset4(&self) -> JOFFSET4_R {
                JOFFSET4_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bits 0:9 - Data offset for injected channel x
            #[inline(always)]
            #[must_use]
            pub fn joffset4(&mut self) -> JOFFSET4_W<0> {
                JOFFSET4_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iofr4](index.html) module
        pub struct IOFR4_SPEC;
        impl crate::RegisterSpec for IOFR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [iofr4::R](R) reader structure
        impl crate::Readable for IOFR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iofr4::W](W) writer structure
        impl crate::Writable for IOFR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IOFR4 to value 0
        impl crate::Resettable for IOFR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///WDHTR (rw) register accessor: an alias for `Reg<WDHTR_SPEC>`
    pub type WDHTR = crate::Reg<wdhtr::WDHTR_SPEC>;
    ///watchdog higher threshold register
    pub mod wdhtr {
        ///Register `WDHTR` reader
        pub struct R(crate::R<WDHTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WDHTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WDHTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WDHTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `WDHTR` writer
        pub struct W(crate::W<WDHTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<WDHTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<WDHTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<WDHTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HT` reader - Analog watchdog higher threshold
        pub type HT_R = crate::FieldReader<u16, u16>;
        ///Field `HT` writer - Analog watchdog higher threshold
        pub type HT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, WDHTR_SPEC, u16, u16, 10, O>;
        impl R {
            ///Bits 0:9 - Analog watchdog higher threshold
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bits 0:9 - Analog watchdog higher threshold
            #[inline(always)]
            #[must_use]
            pub fn ht(&mut self) -> HT_W<0> {
                HT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///watchdog higher threshold register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wdhtr](index.html) module
        pub struct WDHTR_SPEC;
        impl crate::RegisterSpec for WDHTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [wdhtr::R](R) reader structure
        impl crate::Readable for WDHTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [wdhtr::W](W) writer structure
        impl crate::Writable for WDHTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets WDHTR to value 0
        impl crate::Resettable for WDHTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///WDLTR (rw) register accessor: an alias for `Reg<WDLTR_SPEC>`
    pub type WDLTR = crate::Reg<wdltr::WDLTR_SPEC>;
    ///watchdog lower threshold register
    pub mod wdltr {
        ///Register `WDLTR` reader
        pub struct R(crate::R<WDLTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WDLTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WDLTR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WDLTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `WDLTR` writer
        pub struct W(crate::W<WDLTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<WDLTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<WDLTR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<WDLTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LT` reader - Analog watchdog lower threshold
        pub type LT_R = crate::FieldReader<u16, u16>;
        ///Field `LT` writer - Analog watchdog lower threshold
        pub type LT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, WDLTR_SPEC, u16, u16, 10, O>;
        impl R {
            ///Bits 0:9 - Analog watchdog lower threshold
            #[inline(always)]
            pub fn lt(&self) -> LT_R {
                LT_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bits 0:9 - Analog watchdog lower threshold
            #[inline(always)]
            #[must_use]
            pub fn lt(&mut self) -> LT_W<0> {
                LT_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///watchdog lower threshold register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wdltr](index.html) module
        pub struct WDLTR_SPEC;
        impl crate::RegisterSpec for WDLTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [wdltr::R](R) reader structure
        impl crate::Readable for WDLTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [wdltr::W](W) writer structure
        impl crate::Writable for WDLTR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets WDLTR to value 0
        impl crate::Resettable for WDLTR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSQR1 (rw) register accessor: an alias for `Reg<RSQR1_SPEC>`
    pub type RSQR1 = crate::Reg<rsqr1::RSQR1_SPEC>;
    ///regular sequence register 1
    pub mod rsqr1 {
        ///Register `RSQR1` reader
        pub struct R(crate::R<RSQR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSQR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSQR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSQR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSQR1` writer
        pub struct W(crate::W<RSQR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSQR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSQR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSQR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ13` reader - 13th conversion in regular sequence
        pub type SQ13_R = crate::FieldReader<u8, u8>;
        ///Field `SQ13` writer - 13th conversion in regular sequence
        pub type SQ13_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `SQ14` reader - 14th conversion in regular sequence
        pub type SQ14_R = crate::FieldReader<u8, u8>;
        ///Field `SQ14` writer - 14th conversion in regular sequence
        pub type SQ14_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `SQ15` reader - 15th conversion in regular sequence
        pub type SQ15_R = crate::FieldReader<u8, u8>;
        ///Field `SQ15` writer - 15th conversion in regular sequence
        pub type SQ15_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `SQ16` reader - 16th conversion in regular sequence
        pub type SQ16_R = crate::FieldReader<u8, u8>;
        ///Field `SQ16` writer - 16th conversion in regular sequence
        pub type SQ16_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 5, O>;
        ///Field `L` reader - Regular channel sequence length
        pub type L_R = crate::FieldReader<u8, u8>;
        ///Field `L` writer - Regular channel sequence length
        pub type L_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR1_SPEC, u8, u8, 4, O>;
        impl R {
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            pub fn sq13(&self) -> SQ13_R {
                SQ13_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            pub fn sq14(&self) -> SQ14_R {
                SQ14_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            pub fn sq15(&self) -> SQ15_R {
                SQ15_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            pub fn sq16(&self) -> SQ16_R {
                SQ16_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            pub fn l(&self) -> L_R {
                L_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq13(&mut self) -> SQ13_W<0> {
                SQ13_W::new(self)
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq14(&mut self) -> SQ14_W<5> {
                SQ14_W::new(self)
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq15(&mut self) -> SQ15_W<10> {
                SQ15_W::new(self)
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq16(&mut self) -> SQ16_W<15> {
                SQ16_W::new(self)
            }
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            #[must_use]
            pub fn l(&mut self) -> L_W<20> {
                L_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rsqr1](index.html) module
        pub struct RSQR1_SPEC;
        impl crate::RegisterSpec for RSQR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rsqr1::R](R) reader structure
        impl crate::Readable for RSQR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rsqr1::W](W) writer structure
        impl crate::Writable for RSQR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RSQR1 to value 0
        impl crate::Resettable for RSQR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSQR2 (rw) register accessor: an alias for `Reg<RSQR2_SPEC>`
    pub type RSQR2 = crate::Reg<rsqr2::RSQR2_SPEC>;
    ///regular sequence register 2
    pub mod rsqr2 {
        ///Register `RSQR2` reader
        pub struct R(crate::R<RSQR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSQR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSQR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSQR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSQR2` writer
        pub struct W(crate::W<RSQR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSQR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSQR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSQR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ7` reader - 7th conversion in regular sequence
        pub type SQ7_R = crate::FieldReader<u8, u8>;
        ///Field `SQ7` writer - 7th conversion in regular sequence
        pub type SQ7_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ8` reader - 8th conversion in regular sequence
        pub type SQ8_R = crate::FieldReader<u8, u8>;
        ///Field `SQ8` writer - 8th conversion in regular sequence
        pub type SQ8_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ9` reader - 9th conversion in regular sequence
        pub type SQ9_R = crate::FieldReader<u8, u8>;
        ///Field `SQ9` writer - 9th conversion in regular sequence
        pub type SQ9_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ10` reader - 10th conversion in regular sequence
        pub type SQ10_R = crate::FieldReader<u8, u8>;
        ///Field `SQ10` writer - 10th conversion in regular sequence
        pub type SQ10_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ11` reader - 11th conversion in regular sequence
        pub type SQ11_R = crate::FieldReader<u8, u8>;
        ///Field `SQ11` writer - 11th conversion in regular sequence
        pub type SQ11_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        ///Field `SQ12` reader - 12th conversion in regular sequence
        pub type SQ12_R = crate::FieldReader<u8, u8>;
        ///Field `SQ12` writer - 12th conversion in regular sequence
        pub type SQ12_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR2_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            pub fn sq7(&self) -> SQ7_R {
                SQ7_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            pub fn sq8(&self) -> SQ8_R {
                SQ8_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            pub fn sq9(&self) -> SQ9_R {
                SQ9_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            pub fn sq10(&self) -> SQ10_R {
                SQ10_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            pub fn sq11(&self) -> SQ11_R {
                SQ11_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            pub fn sq12(&self) -> SQ12_R {
                SQ12_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq7(&mut self) -> SQ7_W<0> {
                SQ7_W::new(self)
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq8(&mut self) -> SQ8_W<5> {
                SQ8_W::new(self)
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq9(&mut self) -> SQ9_W<10> {
                SQ9_W::new(self)
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq10(&mut self) -> SQ10_W<15> {
                SQ10_W::new(self)
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq11(&mut self) -> SQ11_W<20> {
                SQ11_W::new(self)
            }
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq12(&mut self) -> SQ12_W<25> {
                SQ12_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rsqr2](index.html) module
        pub struct RSQR2_SPEC;
        impl crate::RegisterSpec for RSQR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rsqr2::R](R) reader structure
        impl crate::Readable for RSQR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rsqr2::W](W) writer structure
        impl crate::Writable for RSQR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RSQR2 to value 0
        impl crate::Resettable for RSQR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RSQR3 (rw) register accessor: an alias for `Reg<RSQR3_SPEC>`
    pub type RSQR3 = crate::Reg<rsqr3::RSQR3_SPEC>;
    ///regular sequence register 3
    pub mod rsqr3 {
        ///Register `RSQR3` reader
        pub struct R(crate::R<RSQR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RSQR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RSQR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RSQR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RSQR3` writer
        pub struct W(crate::W<RSQR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RSQR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<RSQR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<RSQR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ1` reader - 1st conversion in regular sequence
        pub type SQ1_R = crate::FieldReader<u8, u8>;
        ///Field `SQ1` writer - 1st conversion in regular sequence
        pub type SQ1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ2` reader - 2nd conversion in regular sequence
        pub type SQ2_R = crate::FieldReader<u8, u8>;
        ///Field `SQ2` writer - 2nd conversion in regular sequence
        pub type SQ2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ3` reader - 3rd conversion in regular sequence
        pub type SQ3_R = crate::FieldReader<u8, u8>;
        ///Field `SQ3` writer - 3rd conversion in regular sequence
        pub type SQ3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ4` reader - 4th conversion in regular sequence
        pub type SQ4_R = crate::FieldReader<u8, u8>;
        ///Field `SQ4` writer - 4th conversion in regular sequence
        pub type SQ4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ5` reader - 5th conversion in regular sequence
        pub type SQ5_R = crate::FieldReader<u8, u8>;
        ///Field `SQ5` writer - 5th conversion in regular sequence
        pub type SQ5_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        ///Field `SQ6` reader - 6th conversion in regular sequence
        pub type SQ6_R = crate::FieldReader<u8, u8>;
        ///Field `SQ6` writer - 6th conversion in regular sequence
        pub type SQ6_W<'a, const O: u8> = crate::FieldWriter<'a, u32, RSQR3_SPEC, u8, u8, 5, O>;
        impl R {
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            pub fn sq1(&self) -> SQ1_R {
                SQ1_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            pub fn sq2(&self) -> SQ2_R {
                SQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            pub fn sq3(&self) -> SQ3_R {
                SQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            pub fn sq4(&self) -> SQ4_R {
                SQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            pub fn sq5(&self) -> SQ5_R {
                SQ5_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            pub fn sq6(&self) -> SQ6_R {
                SQ6_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq1(&mut self) -> SQ1_W<0> {
                SQ1_W::new(self)
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq2(&mut self) -> SQ2_W<5> {
                SQ2_W::new(self)
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq3(&mut self) -> SQ3_W<10> {
                SQ3_W::new(self)
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq4(&mut self) -> SQ4_W<15> {
                SQ4_W::new(self)
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq5(&mut self) -> SQ5_W<20> {
                SQ5_W::new(self)
            }
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            #[must_use]
            pub fn sq6(&mut self) -> SQ6_W<25> {
                SQ6_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rsqr3](index.html) module
        pub struct RSQR3_SPEC;
        impl crate::RegisterSpec for RSQR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rsqr3::R](R) reader structure
        impl crate::Readable for RSQR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rsqr3::W](W) writer structure
        impl crate::Writable for RSQR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets RSQR3 to value 0
        impl crate::Resettable for RSQR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ISQR (rw) register accessor: an alias for `Reg<ISQR_SPEC>`
    pub type ISQR = crate::Reg<isqr::ISQR_SPEC>;
    ///injected sequence register
    pub mod isqr {
        ///Register `ISQR` reader
        pub struct R(crate::R<ISQR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISQR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISQR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISQR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ISQR` writer
        pub struct W(crate::W<ISQR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ISQR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ISQR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ISQR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JSQ1` reader - 1st conversion in injected sequence
        pub type JSQ1_R = crate::FieldReader<u8, u8>;
        ///Field `JSQ1` writer - 1st conversion in injected sequence
        pub type JSQ1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `JSQ2` reader - 2nd conversion in injected sequence
        pub type JSQ2_R = crate::FieldReader<u8, u8>;
        ///Field `JSQ2` writer - 2nd conversion in injected sequence
        pub type JSQ2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `JSQ3` reader - 3rd conversion in injected sequence
        pub type JSQ3_R = crate::FieldReader<u8, u8>;
        ///Field `JSQ3` writer - 3rd conversion in injected sequence
        pub type JSQ3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `JSQ4` reader - 4th conversion in injected sequence
        pub type JSQ4_R = crate::FieldReader<u8, u8>;
        ///Field `JSQ4` writer - 4th conversion in injected sequence
        pub type JSQ4_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 5, O>;
        ///Field `JL` reader - Injected sequence length
        pub type JL_R = crate::FieldReader<u8, u8>;
        ///Field `JL` writer - Injected sequence length
        pub type JL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ISQR_SPEC, u8, u8, 2, O>;
        impl R {
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            pub fn jsq1(&self) -> JSQ1_R {
                JSQ1_R::new((self.bits & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            pub fn jsq2(&self) -> JSQ2_R {
                JSQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            pub fn jsq3(&self) -> JSQ3_R {
                JSQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            pub fn jsq4(&self) -> JSQ4_R {
                JSQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            pub fn jl(&self) -> JL_R {
                JL_R::new(((self.bits >> 20) & 3) as u8)
            }
        }
        impl W {
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq1(&mut self) -> JSQ1_W<0> {
                JSQ1_W::new(self)
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq2(&mut self) -> JSQ2_W<5> {
                JSQ2_W::new(self)
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq3(&mut self) -> JSQ3_W<10> {
                JSQ3_W::new(self)
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            #[must_use]
            pub fn jsq4(&mut self) -> JSQ4_W<15> {
                JSQ4_W::new(self)
            }
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            #[must_use]
            pub fn jl(&mut self) -> JL_W<20> {
                JL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected sequence register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isqr](index.html) module
        pub struct ISQR_SPEC;
        impl crate::RegisterSpec for ISQR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isqr::R](R) reader structure
        impl crate::Readable for ISQR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [isqr::W](W) writer structure
        impl crate::Writable for ISQR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ISQR to value 0
        impl crate::Resettable for ISQR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR1 (r) register accessor: an alias for `Reg<IDATAR1_SPEC>`
    pub type IDATAR1 = crate::Reg<idatar1::IDATAR1_SPEC>;
    ///injected data register 1
    pub mod idatar1 {
        ///Register `IDATAR1` reader
        pub struct R(crate::R<IDATAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar1](index.html) module
        pub struct IDATAR1_SPEC;
        impl crate::RegisterSpec for IDATAR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar1::R](R) reader structure
        impl crate::Readable for IDATAR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR1 to value 0
        impl crate::Resettable for IDATAR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR2 (r) register accessor: an alias for `Reg<IDATAR2_SPEC>`
    pub type IDATAR2 = crate::Reg<idatar2::IDATAR2_SPEC>;
    ///injected data register 2
    pub mod idatar2 {
        ///Register `IDATAR2` reader
        pub struct R(crate::R<IDATAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar2](index.html) module
        pub struct IDATAR2_SPEC;
        impl crate::RegisterSpec for IDATAR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar2::R](R) reader structure
        impl crate::Readable for IDATAR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR2 to value 0
        impl crate::Resettable for IDATAR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR3 (r) register accessor: an alias for `Reg<IDATAR3_SPEC>`
    pub type IDATAR3 = crate::Reg<idatar3::IDATAR3_SPEC>;
    ///injected data register 3
    pub mod idatar3 {
        ///Register `IDATAR3` reader
        pub struct R(crate::R<IDATAR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar3](index.html) module
        pub struct IDATAR3_SPEC;
        impl crate::RegisterSpec for IDATAR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar3::R](R) reader structure
        impl crate::Readable for IDATAR3_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR3 to value 0
        impl crate::Resettable for IDATAR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IDATAR4 (r) register accessor: an alias for `Reg<IDATAR4_SPEC>`
    pub type IDATAR4 = crate::Reg<idatar4::IDATAR4_SPEC>;
    ///injected data register 4
    pub mod idatar4 {
        ///Register `IDATAR4` reader
        pub struct R(crate::R<IDATAR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDATAR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IDATAR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IDATAR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `IDATA` reader - Injected data
        pub type IDATA_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn idata(&self) -> IDATA_R {
                IDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register 4
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idatar4](index.html) module
        pub struct IDATAR4_SPEC;
        impl crate::RegisterSpec for IDATAR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idatar4::R](R) reader structure
        impl crate::Readable for IDATAR4_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDATAR4 to value 0
        impl crate::Resettable for IDATAR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///RDATAR (r) register accessor: an alias for `Reg<RDATAR_SPEC>`
    pub type RDATAR = crate::Reg<rdatar::RDATAR_SPEC>;
    ///regular data register
    pub mod rdatar {
        ///Register `RDATAR` reader
        pub struct R(crate::R<RDATAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RDATAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RDATAR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RDATAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DATA` reader - Regular data
        pub type DATA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - Regular data
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new(self.bits)
            }
        }
        ///regular data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rdatar](index.html) module
        pub struct RDATAR_SPEC;
        impl crate::RegisterSpec for RDATAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rdatar::R](R) reader structure
        impl crate::Readable for RDATAR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RDATAR to value 0
        impl crate::Resettable for RDATAR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///DLYR (rw) register accessor: an alias for `Reg<DLYR_SPEC>`
    pub type DLYR = crate::Reg<dlyr::DLYR_SPEC>;
    ///delay data register
    pub mod dlyr {
        ///Register `DLYR` reader
        pub struct R(crate::R<DLYR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DLYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DLYR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DLYR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DLYR` writer
        pub struct W(crate::W<DLYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DLYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DLYR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DLYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DLYVLU` reader - External trigger data delay time configuration
        pub type DLYVLU_R = crate::FieldReader<u16, u16>;
        ///Field `DLYVLU` writer - External trigger data delay time configuration
        pub type DLYVLU_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DLYR_SPEC, u16, u16, 9, O>;
        ///Field `DLYSRC` reader - External trigger source delay selection
        pub type DLYSRC_R = crate::BitReader<bool>;
        ///Field `DLYSRC` writer - External trigger source delay selection
        pub type DLYSRC_W<'a, const O: u8> = crate::BitWriter<'a, u32, DLYR_SPEC, bool, O>;
        impl R {
            ///Bits 0:8 - External trigger data delay time configuration
            #[inline(always)]
            pub fn dlyvlu(&self) -> DLYVLU_R {
                DLYVLU_R::new((self.bits & 0x01ff) as u16)
            }
            ///Bit 9 - External trigger source delay selection
            #[inline(always)]
            pub fn dlysrc(&self) -> DLYSRC_R {
                DLYSRC_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            ///Bits 0:8 - External trigger data delay time configuration
            #[inline(always)]
            #[must_use]
            pub fn dlyvlu(&mut self) -> DLYVLU_W<0> {
                DLYVLU_W::new(self)
            }
            ///Bit 9 - External trigger source delay selection
            #[inline(always)]
            #[must_use]
            pub fn dlysrc(&mut self) -> DLYSRC_W<9> {
                DLYSRC_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///delay data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dlyr](index.html) module
        pub struct DLYR_SPEC;
        impl crate::RegisterSpec for DLYR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dlyr::R](R) reader structure
        impl crate::Readable for DLYR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dlyr::W](W) writer structure
        impl crate::Writable for DLYR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets DLYR to value 0
        impl crate::Resettable for DLYR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Debug support
pub struct DBG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DBG {}
impl DBG {
    ///Pointer to the register block
    pub const PTR: *const dbg::RegisterBlock = 0xe000_d000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dbg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DBG {
    type Target = dbg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DBG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DBG").finish()
    }
}
///Debug support
pub mod dbg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - DBGMCU_CFGR1
        pub cfgr1: CFGR1,
        ///0x04 - DBGMCU_CFGR2
        pub cfgr2: CFGR2,
    }
    ///CFGR1 (rw) register accessor: an alias for `Reg<CFGR1_SPEC>`
    pub type CFGR1 = crate::Reg<cfgr1::CFGR1_SPEC>;
    ///DBGMCU_CFGR1
    pub mod cfgr1 {
        ///Register `CFGR1` reader
        pub struct R(crate::R<CFGR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR1` writer
        pub struct W(crate::W<CFGR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DEG_IWDG` reader - DEG_IWDG
        pub type DEG_IWDG_R = crate::BitReader<bool>;
        ///Field `DEG_IWDG` writer - DEG_IWDG
        pub type DEG_IWDG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `DEG_WWDG` reader - DEG_WWDG
        pub type DEG_WWDG_R = crate::BitReader<bool>;
        ///Field `DEG_WWDG` writer - DEG_WWDG
        pub type DEG_WWDG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `DEG_I2C1` reader - DEG_I2C1
        pub type DEG_I2C1_R = crate::BitReader<bool>;
        ///Field `DEG_I2C1` writer - DEG_I2C1
        pub type DEG_I2C1_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `DEG_TIM1` reader - DEG_TIM1
        pub type DEG_TIM1_R = crate::BitReader<bool>;
        ///Field `DEG_TIM1` writer - DEG_TIM1
        pub type DEG_TIM1_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        ///Field `DEG_TIM2` reader - DEG_TIM2
        pub type DEG_TIM2_R = crate::BitReader<bool>;
        ///Field `DEG_TIM2` writer - DEG_TIM2
        pub type DEG_TIM2_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR1_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DEG_IWDG
            #[inline(always)]
            pub fn deg_iwdg(&self) -> DEG_IWDG_R {
                DEG_IWDG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DEG_WWDG
            #[inline(always)]
            pub fn deg_wwdg(&self) -> DEG_WWDG_R {
                DEG_WWDG_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DEG_I2C1
            #[inline(always)]
            pub fn deg_i2c1(&self) -> DEG_I2C1_R {
                DEG_I2C1_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - DEG_TIM1
            #[inline(always)]
            pub fn deg_tim1(&self) -> DEG_TIM1_R {
                DEG_TIM1_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - DEG_TIM2
            #[inline(always)]
            pub fn deg_tim2(&self) -> DEG_TIM2_R {
                DEG_TIM2_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DEG_IWDG
            #[inline(always)]
            #[must_use]
            pub fn deg_iwdg(&mut self) -> DEG_IWDG_W<0> {
                DEG_IWDG_W::new(self)
            }
            ///Bit 1 - DEG_WWDG
            #[inline(always)]
            #[must_use]
            pub fn deg_wwdg(&mut self) -> DEG_WWDG_W<1> {
                DEG_WWDG_W::new(self)
            }
            ///Bit 2 - DEG_I2C1
            #[inline(always)]
            #[must_use]
            pub fn deg_i2c1(&mut self) -> DEG_I2C1_W<2> {
                DEG_I2C1_W::new(self)
            }
            ///Bit 4 - DEG_TIM1
            #[inline(always)]
            #[must_use]
            pub fn deg_tim1(&mut self) -> DEG_TIM1_W<4> {
                DEG_TIM1_W::new(self)
            }
            ///Bit 5 - DEG_TIM2
            #[inline(always)]
            #[must_use]
            pub fn deg_tim2(&mut self) -> DEG_TIM2_W<5> {
                DEG_TIM2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DBGMCU_CFGR1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr1](index.html) module
        pub struct CFGR1_SPEC;
        impl crate::RegisterSpec for CFGR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr1::R](R) reader structure
        impl crate::Readable for CFGR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr1::W](W) writer structure
        impl crate::Writable for CFGR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR1 to value 0
        impl crate::Resettable for CFGR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR2 (rw) register accessor: an alias for `Reg<CFGR2_SPEC>`
    pub type CFGR2 = crate::Reg<cfgr2::CFGR2_SPEC>;
    ///DBGMCU_CFGR2
    pub mod cfgr2 {
        ///Register `CFGR2` reader
        pub struct R(crate::R<CFGR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CFGR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CFGR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR2` writer
        pub struct W(crate::W<CFGR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBG_SLEEP` reader - DBG_SLEEP
        pub type DBG_SLEEP_R = crate::BitReader<bool>;
        ///Field `DBG_SLEEP` writer - DBG_SLEEP
        pub type DBG_SLEEP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `DBG_STOP` reader - DBG_STOP
        pub type DBG_STOP_R = crate::BitReader<bool>;
        ///Field `DBG_STOP` writer - DBG_STOP
        pub type DBG_STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        ///Field `DBG_STANDBY` reader - DBG_STANDBY
        pub type DBG_STANDBY_R = crate::BitReader<bool>;
        ///Field `DBG_STANDBY` writer - DBG_STANDBY
        pub type DBG_STANDBY_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR2_SPEC, bool, O>;
        impl R {
            ///Bit 0 - DBG_SLEEP
            #[inline(always)]
            pub fn dbg_sleep(&self) -> DBG_SLEEP_R {
                DBG_SLEEP_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - DBG_STOP
            #[inline(always)]
            pub fn dbg_stop(&self) -> DBG_STOP_R {
                DBG_STOP_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - DBG_STANDBY
            #[inline(always)]
            pub fn dbg_standby(&self) -> DBG_STANDBY_R {
                DBG_STANDBY_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - DBG_SLEEP
            #[inline(always)]
            #[must_use]
            pub fn dbg_sleep(&mut self) -> DBG_SLEEP_W<0> {
                DBG_SLEEP_W::new(self)
            }
            ///Bit 1 - DBG_STOP
            #[inline(always)]
            #[must_use]
            pub fn dbg_stop(&mut self) -> DBG_STOP_W<1> {
                DBG_STOP_W::new(self)
            }
            ///Bit 2 - DBG_STANDBY
            #[inline(always)]
            #[must_use]
            pub fn dbg_standby(&mut self) -> DBG_STANDBY_W<2> {
                DBG_STANDBY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DBGMCU_CFGR2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr2](index.html) module
        pub struct CFGR2_SPEC;
        impl crate::RegisterSpec for CFGR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr2::R](R) reader structure
        impl crate::Readable for CFGR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr2::W](W) writer structure
        impl crate::Writable for CFGR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR2 to value 0
        impl crate::Resettable for CFGR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Device electronic signature
pub struct ESIG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ESIG {}
impl ESIG {
    ///Pointer to the register block
    pub const PTR: *const esig::RegisterBlock = 0x1fff_f7e0 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const esig::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ESIG {
    type Target = esig::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ESIG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ESIG").finish()
    }
}
///Device electronic signature
pub mod esig {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Flash capacity register
        pub flacap: FLACAP,
        _reserved1: [u8; 0x06],
        ///0x08 - Unique identity 1
        pub uniid1: UNIID1,
        ///0x0c - Unique identity 2
        pub uniid2: UNIID2,
        ///0x10 - Unique identity 3
        pub uniid3: UNIID3,
    }
    ///FLACAP (r) register accessor: an alias for `Reg<FLACAP_SPEC>`
    pub type FLACAP = crate::Reg<flacap::FLACAP_SPEC>;
    ///Flash capacity register
    pub mod flacap {
        ///Register `FLACAP` reader
        pub struct R(crate::R<FLACAP_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FLACAP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<FLACAP_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<FLACAP_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `FLASHSIZE` reader - Flash size
        pub type FLASHSIZE_R = crate::FieldReader<u16, u16>;
        impl R {
            ///Bits 0:15 - Flash size
            #[inline(always)]
            pub fn flashsize(&self) -> FLASHSIZE_R {
                FLASHSIZE_R::new(self.bits)
            }
        }
        ///Flash capacity register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [flacap](index.html) module
        pub struct FLACAP_SPEC;
        impl crate::RegisterSpec for FLACAP_SPEC {
            type Ux = u16;
        }
        ///`read()` method returns [flacap::R](R) reader structure
        impl crate::Readable for FLACAP_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets FLACAP to value 0
        impl crate::Resettable for FLACAP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UNIID1 (r) register accessor: an alias for `Reg<UNIID1_SPEC>`
    pub type UNIID1 = crate::Reg<uniid1::UNIID1_SPEC>;
    ///Unique identity 1
    pub mod uniid1 {
        ///Register `UNIID1` reader
        pub struct R(crate::R<UNIID1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UNIID1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UNIID1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UNIID1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `U_ID` reader - Unique identity\[31:0\]
        pub type U_ID_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - Unique identity\[31:0\]
            #[inline(always)]
            pub fn u_id(&self) -> U_ID_R {
                U_ID_R::new(self.bits)
            }
        }
        ///Unique identity 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uniid1](index.html) module
        pub struct UNIID1_SPEC;
        impl crate::RegisterSpec for UNIID1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [uniid1::R](R) reader structure
        impl crate::Readable for UNIID1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UNIID1 to value 0
        impl crate::Resettable for UNIID1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UNIID2 (r) register accessor: an alias for `Reg<UNIID2_SPEC>`
    pub type UNIID2 = crate::Reg<uniid2::UNIID2_SPEC>;
    ///Unique identity 2
    pub mod uniid2 {
        ///Register `UNIID2` reader
        pub struct R(crate::R<UNIID2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UNIID2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UNIID2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UNIID2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `U_ID` reader - Unique identity\[63:32\]
        pub type U_ID_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - Unique identity\[63:32\]
            #[inline(always)]
            pub fn u_id(&self) -> U_ID_R {
                U_ID_R::new(self.bits)
            }
        }
        ///Unique identity 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uniid2](index.html) module
        pub struct UNIID2_SPEC;
        impl crate::RegisterSpec for UNIID2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [uniid2::R](R) reader structure
        impl crate::Readable for UNIID2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UNIID2 to value 0
        impl crate::Resettable for UNIID2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///UNIID3 (r) register accessor: an alias for `Reg<UNIID3_SPEC>`
    pub type UNIID3 = crate::Reg<uniid3::UNIID3_SPEC>;
    ///Unique identity 3
    pub mod uniid3 {
        ///Register `UNIID3` reader
        pub struct R(crate::R<UNIID3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<UNIID3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<UNIID3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<UNIID3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `U_ID` reader - Unique identity\[95:64\]
        pub type U_ID_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - Unique identity\[95:64\]
            #[inline(always)]
            pub fn u_id(&self) -> U_ID_R {
                U_ID_R::new(self.bits)
            }
        }
        ///Unique identity 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [uniid3](index.html) module
        pub struct UNIID3_SPEC;
        impl crate::RegisterSpec for UNIID3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [uniid3::R](R) reader structure
        impl crate::Readable for UNIID3_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets UNIID3 to value 0
        impl crate::Resettable for UNIID3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///FLASH
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    ///Pointer to the register block
    pub const PTR: *const flash::RegisterBlock = 0x4002_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH").finish()
    }
}
///FLASH
pub mod flash {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Flash key register
        pub actlr: ACTLR,
        ///0x04 - Flash key register
        pub keyr: KEYR,
        ///0x08 - Flash option key register
        pub obkeyr: OBKEYR,
        ///0x0c - Status register
        pub statr: STATR,
        ///0x10 - Control register
        pub ctlr: CTLR,
        ///0x14 - Flash address register
        pub addr: ADDR,
        _reserved6: [u8; 0x04],
        ///0x1c - Option byte register
        pub obr: OBR,
        ///0x20 - Write protection register
        pub wpr: WPR,
        ///0x24 - Mode select register
        pub modekeyr: MODEKEYR,
        ///0x28 - Boot mode key register
        pub boot_modekeyp: BOOT_MODEKEYP,
    }
    ///ACTLR (rw) register accessor: an alias for `Reg<ACTLR_SPEC>`
    pub type ACTLR = crate::Reg<actlr::ACTLR_SPEC>;
    ///Flash key register
    pub mod actlr {
        ///Register `ACTLR` reader
        pub struct R(crate::R<ACTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ACTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ACTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ACTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ACTLR` writer
        pub struct W(crate::W<ACTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ACTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ACTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ACTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LATENCY` reader - Number of FLASH wait states
        pub type LATENCY_R = crate::BitReader<bool>;
        ///Field `LATENCY` writer - Number of FLASH wait states
        pub type LATENCY_W<'a, const O: u8> = crate::BitWriter<'a, u32, ACTLR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Number of FLASH wait states
            #[inline(always)]
            pub fn latency(&self) -> LATENCY_R {
                LATENCY_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Number of FLASH wait states
            #[inline(always)]
            #[must_use]
            pub fn latency(&mut self) -> LATENCY_W<0> {
                LATENCY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash key register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [actlr](index.html) module
        pub struct ACTLR_SPEC;
        impl crate::RegisterSpec for ACTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [actlr::R](R) reader structure
        impl crate::Readable for ACTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [actlr::W](W) writer structure
        impl crate::Writable for ACTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ACTLR to value 0
        impl crate::Resettable for ACTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///KEYR (w) register accessor: an alias for `Reg<KEYR_SPEC>`
    pub type KEYR = crate::Reg<keyr::KEYR_SPEC>;
    ///Flash key register
    pub mod keyr {
        ///Register `KEYR` writer
        pub struct W(crate::W<KEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<KEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<KEYR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<KEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `KEYR` writer - FPEC key
        pub type KEYR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, KEYR_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - FPEC key
            #[inline(always)]
            #[must_use]
            pub fn keyr(&mut self) -> KEYR_W<0> {
                KEYR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [keyr](index.html) module
        pub struct KEYR_SPEC;
        impl crate::RegisterSpec for KEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [keyr::W](W) writer structure
        impl crate::Writable for KEYR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets KEYR to value 0
        impl crate::Resettable for KEYR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OBKEYR (w) register accessor: an alias for `Reg<OBKEYR_SPEC>`
    pub type OBKEYR = crate::Reg<obkeyr::OBKEYR_SPEC>;
    ///Flash option key register
    pub mod obkeyr {
        ///Register `OBKEYR` writer
        pub struct W(crate::W<OBKEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OBKEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<OBKEYR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<OBKEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OPTKEY` writer - Option byte key
        pub type OPTKEY_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, OBKEYR_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - Option byte key
            #[inline(always)]
            #[must_use]
            pub fn optkey(&mut self) -> OPTKEY_W<0> {
                OPTKEY_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash option key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [obkeyr](index.html) module
        pub struct OBKEYR_SPEC;
        impl crate::RegisterSpec for OBKEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [obkeyr::W](W) writer structure
        impl crate::Writable for OBKEYR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets OBKEYR to value 0
        impl crate::Resettable for OBKEYR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STATR (rw) register accessor: an alias for `Reg<STATR_SPEC>`
    pub type STATR = crate::Reg<statr::STATR_SPEC>;
    ///Status register
    pub mod statr {
        ///Register `STATR` reader
        pub struct R(crate::R<STATR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STATR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STATR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STATR` writer
        pub struct W(crate::W<STATR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STATR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STATR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STATR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BSY` reader - Busy
        pub type BSY_R = crate::BitReader<bool>;
        ///Field `WRPRTERR` reader - Write protection error
        pub type WRPRTERR_R = crate::BitReader<bool>;
        ///Field `WRPRTERR` writer - Write protection error
        pub type WRPRTERR_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `EOP` reader - End of operation
        pub type EOP_R = crate::BitReader<bool>;
        ///Field `EOP` writer - End of operation
        pub type EOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `BOOT_MODE` reader - BOOT mode
        pub type BOOT_MODE_R = crate::BitReader<bool>;
        ///Field `BOOT_MODE` writer - BOOT mode
        pub type BOOT_MODE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        ///Field `BOOT_LOCK` reader - BOOT lock
        pub type BOOT_LOCK_R = crate::BitReader<bool>;
        ///Field `BOOT_LOCK` writer - BOOT lock
        pub type BOOT_LOCK_W<'a, const O: u8> = crate::BitWriter<'a, u32, STATR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Busy
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new((self.bits & 1) != 0)
            }
            ///Bit 4 - Write protection error
            #[inline(always)]
            pub fn wrprterr(&self) -> WRPRTERR_R {
                WRPRTERR_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - End of operation
            #[inline(always)]
            pub fn eop(&self) -> EOP_R {
                EOP_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 14 - BOOT mode
            #[inline(always)]
            pub fn boot_mode(&self) -> BOOT_MODE_R {
                BOOT_MODE_R::new(((self.bits >> 14) & 1) != 0)
            }
            ///Bit 15 - BOOT lock
            #[inline(always)]
            pub fn boot_lock(&self) -> BOOT_LOCK_R {
                BOOT_LOCK_R::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            ///Bit 4 - Write protection error
            #[inline(always)]
            #[must_use]
            pub fn wrprterr(&mut self) -> WRPRTERR_W<4> {
                WRPRTERR_W::new(self)
            }
            ///Bit 5 - End of operation
            #[inline(always)]
            #[must_use]
            pub fn eop(&mut self) -> EOP_W<5> {
                EOP_W::new(self)
            }
            ///Bit 14 - BOOT mode
            #[inline(always)]
            #[must_use]
            pub fn boot_mode(&mut self) -> BOOT_MODE_W<14> {
                BOOT_MODE_W::new(self)
            }
            ///Bit 15 - BOOT lock
            #[inline(always)]
            #[must_use]
            pub fn boot_lock(&mut self) -> BOOT_LOCK_W<15> {
                BOOT_LOCK_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [statr](index.html) module
        pub struct STATR_SPEC;
        impl crate::RegisterSpec for STATR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [statr::R](R) reader structure
        impl crate::Readable for STATR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [statr::W](W) writer structure
        impl crate::Writable for STATR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STATR to value 0x8000
        impl crate::Resettable for STATR_SPEC {
            const RESET_VALUE: Self::Ux = 0x8000;
        }
    }
    ///CTLR (rw) register accessor: an alias for `Reg<CTLR_SPEC>`
    pub type CTLR = crate::Reg<ctlr::CTLR_SPEC>;
    ///Control register
    pub mod ctlr {
        ///Register `CTLR` reader
        pub struct R(crate::R<CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTLR` writer
        pub struct W(crate::W<CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PG` reader - Programming
        pub type PG_R = crate::BitReader<bool>;
        ///Field `PG` writer - Programming
        pub type PG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PER` reader - Page Erase
        pub type PER_R = crate::BitReader<bool>;
        ///Field `PER` writer - Page Erase
        pub type PER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `MER` reader - Mass Erase
        pub type MER_R = crate::BitReader<bool>;
        ///Field `MER` writer - Mass Erase
        pub type MER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `OBPG` reader - Option byte programming
        pub type OBPG_R = crate::BitReader<bool>;
        ///Field `OBPG` writer - Option byte programming
        pub type OBPG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `OBER` reader - Option byte erase
        pub type OBER_R = crate::BitReader<bool>;
        ///Field `OBER` writer - Option byte erase
        pub type OBER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `STRT` reader - Start
        pub type STRT_R = crate::BitReader<bool>;
        ///Field `STRT` writer - Start
        pub type STRT_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `LOCK` reader - Lock
        pub type LOCK_R = crate::BitReader<bool>;
        ///Field `LOCK` writer - Lock
        pub type LOCK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `OBWRE` reader - Option bytes write enable
        pub type OBWRE_R = crate::BitReader<bool>;
        ///Field `OBWRE` writer - Option bytes write enable
        pub type OBWRE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `ERRIE` reader - Error interrupt enable
        pub type ERRIE_R = crate::BitReader<bool>;
        ///Field `ERRIE` writer - Error interrupt enable
        pub type ERRIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `EOPIE` reader - End of operation interrupt enable
        pub type EOPIE_R = crate::BitReader<bool>;
        ///Field `EOPIE` writer - End of operation interrupt enable
        pub type EOPIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `FLOCK` reader - Fast programmable lock
        pub type FLOCK_R = crate::BitReader<bool>;
        ///Field `FLOCK` writer - Fast programmable lock
        pub type FLOCK_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PAGE_PG` reader - Fast programming
        pub type PAGE_PG_R = crate::BitReader<bool>;
        ///Field `PAGE_PG` writer - Fast programming
        pub type PAGE_PG_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `PAGE_ER` reader - Fast erase
        pub type PAGE_ER_R = crate::BitReader<bool>;
        ///Field `PAGE_ER` writer - Fast erase
        pub type PAGE_ER_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `BUFLOAD` reader - Buffer load
        pub type BUFLOAD_R = crate::BitReader<bool>;
        ///Field `BUFLOAD` writer - Buffer load
        pub type BUFLOAD_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        ///Field `BUFRST` reader - Buffer reset
        pub type BUFRST_R = crate::BitReader<bool>;
        ///Field `BUFRST` writer - Buffer reset
        pub type BUFRST_W<'a, const O: u8> = crate::BitWriter<'a, u32, CTLR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - Programming
            #[inline(always)]
            pub fn pg(&self) -> PG_R {
                PG_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Page Erase
            #[inline(always)]
            pub fn per(&self) -> PER_R {
                PER_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            pub fn mer(&self) -> MER_R {
                MER_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            pub fn obpg(&self) -> OBPG_R {
                OBPG_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            pub fn ober(&self) -> OBER_R {
                OBER_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 6 - Start
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 6) & 1) != 0)
            }
            ///Bit 7 - Lock
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 7) & 1) != 0)
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            pub fn obwre(&self) -> OBWRE_R {
                OBWRE_R::new(((self.bits >> 9) & 1) != 0)
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 10) & 1) != 0)
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            pub fn eopie(&self) -> EOPIE_R {
                EOPIE_R::new(((self.bits >> 12) & 1) != 0)
            }
            ///Bit 15 - Fast programmable lock
            #[inline(always)]
            pub fn flock(&self) -> FLOCK_R {
                FLOCK_R::new(((self.bits >> 15) & 1) != 0)
            }
            ///Bit 16 - Fast programming
            #[inline(always)]
            pub fn page_pg(&self) -> PAGE_PG_R {
                PAGE_PG_R::new(((self.bits >> 16) & 1) != 0)
            }
            ///Bit 17 - Fast erase
            #[inline(always)]
            pub fn page_er(&self) -> PAGE_ER_R {
                PAGE_ER_R::new(((self.bits >> 17) & 1) != 0)
            }
            ///Bit 18 - Buffer load
            #[inline(always)]
            pub fn bufload(&self) -> BUFLOAD_R {
                BUFLOAD_R::new(((self.bits >> 18) & 1) != 0)
            }
            ///Bit 19 - Buffer reset
            #[inline(always)]
            pub fn bufrst(&self) -> BUFRST_R {
                BUFRST_R::new(((self.bits >> 19) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - Programming
            #[inline(always)]
            #[must_use]
            pub fn pg(&mut self) -> PG_W<0> {
                PG_W::new(self)
            }
            ///Bit 1 - Page Erase
            #[inline(always)]
            #[must_use]
            pub fn per(&mut self) -> PER_W<1> {
                PER_W::new(self)
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            #[must_use]
            pub fn mer(&mut self) -> MER_W<2> {
                MER_W::new(self)
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            #[must_use]
            pub fn obpg(&mut self) -> OBPG_W<4> {
                OBPG_W::new(self)
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            #[must_use]
            pub fn ober(&mut self) -> OBER_W<5> {
                OBER_W::new(self)
            }
            ///Bit 6 - Start
            #[inline(always)]
            #[must_use]
            pub fn strt(&mut self) -> STRT_W<6> {
                STRT_W::new(self)
            }
            ///Bit 7 - Lock
            #[inline(always)]
            #[must_use]
            pub fn lock(&mut self) -> LOCK_W<7> {
                LOCK_W::new(self)
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            #[must_use]
            pub fn obwre(&mut self) -> OBWRE_W<9> {
                OBWRE_W::new(self)
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn errie(&mut self) -> ERRIE_W<10> {
                ERRIE_W::new(self)
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn eopie(&mut self) -> EOPIE_W<12> {
                EOPIE_W::new(self)
            }
            ///Bit 15 - Fast programmable lock
            #[inline(always)]
            #[must_use]
            pub fn flock(&mut self) -> FLOCK_W<15> {
                FLOCK_W::new(self)
            }
            ///Bit 16 - Fast programming
            #[inline(always)]
            #[must_use]
            pub fn page_pg(&mut self) -> PAGE_PG_W<16> {
                PAGE_PG_W::new(self)
            }
            ///Bit 17 - Fast erase
            #[inline(always)]
            #[must_use]
            pub fn page_er(&mut self) -> PAGE_ER_W<17> {
                PAGE_ER_W::new(self)
            }
            ///Bit 18 - Buffer load
            #[inline(always)]
            #[must_use]
            pub fn bufload(&mut self) -> BUFLOAD_W<18> {
                BUFLOAD_W::new(self)
            }
            ///Bit 19 - Buffer reset
            #[inline(always)]
            #[must_use]
            pub fn bufrst(&mut self) -> BUFRST_W<19> {
                BUFRST_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctlr](index.html) module
        pub struct CTLR_SPEC;
        impl crate::RegisterSpec for CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctlr::R](R) reader structure
        impl crate::Readable for CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctlr::W](W) writer structure
        impl crate::Writable for CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CTLR to value 0x8080
        impl crate::Resettable for CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0x8080;
        }
    }
    ///ADDR (w) register accessor: an alias for `Reg<ADDR_SPEC>`
    pub type ADDR = crate::Reg<addr::ADDR_SPEC>;
    ///Flash address register
    pub mod addr {
        ///Register `ADDR` writer
        pub struct W(crate::W<ADDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ADDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ADDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ADDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADDR` writer - Flash Address
        pub type ADDR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, ADDR_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - Flash Address
            #[inline(always)]
            #[must_use]
            pub fn addr(&mut self) -> ADDR_W<0> {
                ADDR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash address register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [addr](index.html) module
        pub struct ADDR_SPEC;
        impl crate::RegisterSpec for ADDR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [addr::W](W) writer structure
        impl crate::Writable for ADDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ADDR to value 0
        impl crate::Resettable for ADDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///OBR (r) register accessor: an alias for `Reg<OBR_SPEC>`
    pub type OBR = crate::Reg<obr::OBR_SPEC>;
    ///Option byte register
    pub mod obr {
        ///Register `OBR` reader
        pub struct R(crate::R<OBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<OBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<OBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `OBERR` reader - Option byte error
        pub type OBERR_R = crate::BitReader<bool>;
        ///Field `RDPRT` reader - Read protection
        pub type RDPRT_R = crate::BitReader<bool>;
        ///Field `IWDG_SW` reader - IWDG_SW
        pub type IWDG_SW_R = crate::BitReader<bool>;
        ///Field `STOP_RST` reader - STOP_RST
        pub type STOP_RST_R = crate::BitReader<bool>;
        ///Field `STANDY_RST` reader - STANDY_RST
        pub type STANDY_RST_R = crate::BitReader<bool>;
        ///Field `CFG_RST_MODE` reader - CFG_RST_MODE
        pub type CFG_RST_MODE_R = crate::FieldReader<u8, u8>;
        ///Field `DATA0` reader - DATA0
        pub type DATA0_R = crate::FieldReader<u8, u8>;
        ///Field `DATA1` reader - DATA1
        pub type DATA1_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bit 0 - Option byte error
            #[inline(always)]
            pub fn oberr(&self) -> OBERR_R {
                OBERR_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - Read protection
            #[inline(always)]
            pub fn rdprt(&self) -> RDPRT_R {
                RDPRT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - IWDG_SW
            #[inline(always)]
            pub fn iwdg_sw(&self) -> IWDG_SW_R {
                IWDG_SW_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - STOP_RST
            #[inline(always)]
            pub fn stop_rst(&self) -> STOP_RST_R {
                STOP_RST_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - STANDY_RST
            #[inline(always)]
            pub fn standy_rst(&self) -> STANDY_RST_R {
                STANDY_RST_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bits 5:6 - CFG_RST_MODE
            #[inline(always)]
            pub fn cfg_rst_mode(&self) -> CFG_RST_MODE_R {
                CFG_RST_MODE_R::new(((self.bits >> 5) & 3) as u8)
            }
            ///Bits 10:17 - DATA0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new(((self.bits >> 10) & 0xff) as u8)
            }
            ///Bits 18:25 - DATA1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 18) & 0xff) as u8)
            }
        }
        ///Option byte register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [obr](index.html) module
        pub struct OBR_SPEC;
        impl crate::RegisterSpec for OBR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [obr::R](R) reader structure
        impl crate::Readable for OBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets OBR to value 0x03ff_fffe
        impl crate::Resettable for OBR_SPEC {
            const RESET_VALUE: Self::Ux = 0x03ff_fffe;
        }
    }
    ///WPR (r) register accessor: an alias for `Reg<WPR_SPEC>`
    pub type WPR = crate::Reg<wpr::WPR_SPEC>;
    ///Write protection register
    pub mod wpr {
        ///Register `WPR` reader
        pub struct R(crate::R<WPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<WPR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<WPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `WRP` reader - Write protect
        pub type WRP_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - Write protect
            #[inline(always)]
            pub fn wrp(&self) -> WRP_R {
                WRP_R::new(self.bits)
            }
        }
        ///Write protection register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wpr](index.html) module
        pub struct WPR_SPEC;
        impl crate::RegisterSpec for WPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [wpr::R](R) reader structure
        impl crate::Readable for WPR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets WPR to value 0xffff_ffff
        impl crate::Resettable for WPR_SPEC {
            const RESET_VALUE: Self::Ux = 0xffff_ffff;
        }
    }
    ///MODEKEYR (w) register accessor: an alias for `Reg<MODEKEYR_SPEC>`
    pub type MODEKEYR = crate::Reg<modekeyr::MODEKEYR_SPEC>;
    ///Mode select register
    pub mod modekeyr {
        ///Register `MODEKEYR` writer
        pub struct W(crate::W<MODEKEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MODEKEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MODEKEYR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MODEKEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MODEKEYR` writer - Mode select
        pub type MODEKEYR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, MODEKEYR_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - Mode select
            #[inline(always)]
            #[must_use]
            pub fn modekeyr(&mut self) -> MODEKEYR_W<0> {
                MODEKEYR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Mode select register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [modekeyr](index.html) module
        pub struct MODEKEYR_SPEC;
        impl crate::RegisterSpec for MODEKEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [modekeyr::W](W) writer structure
        impl crate::Writable for MODEKEYR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets MODEKEYR to value 0
        impl crate::Resettable for MODEKEYR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///BOOT_MODEKEYP (w) register accessor: an alias for `Reg<BOOT_MODEKEYP_SPEC>`
    pub type BOOT_MODEKEYP = crate::Reg<boot_modekeyp::BOOT_MODEKEYP_SPEC>;
    ///Boot mode key register
    pub mod boot_modekeyp {
        ///Register `BOOT_MODEKEYP` writer
        pub struct W(crate::W<BOOT_MODEKEYP_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BOOT_MODEKEYP_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<BOOT_MODEKEYP_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<BOOT_MODEKEYP_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MODEKEYR` writer - Boot mode key
        pub type MODEKEYR_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, BOOT_MODEKEYP_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - Boot mode key
            #[inline(always)]
            #[must_use]
            pub fn modekeyr(&mut self) -> MODEKEYR_W<0> {
                MODEKEYR_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Boot mode key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [boot_modekeyp](index.html) module
        pub struct BOOT_MODEKEYP_SPEC;
        impl crate::RegisterSpec for BOOT_MODEKEYP_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [boot_modekeyp::W](W) writer structure
        impl crate::Writable for BOOT_MODEKEYP_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets BOOT_MODEKEYP to value 0
        impl crate::Resettable for BOOT_MODEKEYP_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
///Programmable Fast Interrupt Controller
pub struct PFIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PFIC {}
impl PFIC {
    ///Pointer to the register block
    pub const PTR: *const pfic::RegisterBlock = 0xe000_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pfic::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PFIC {
    type Target = pfic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PFIC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PFIC").finish()
    }
}
///Programmable Fast Interrupt Controller
pub mod pfic {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Interrupt Status Register
        pub isr1: ISR1,
        ///0x04 - Interrupt Status Register
        pub isr2: ISR2,
        ///0x08 - Interrupt Status Register
        pub isr3: ISR3,
        ///0x0c - Interrupt Status Register
        pub isr4: ISR4,
        _reserved4: [u8; 0x10],
        ///0x20 - Interrupt Pending Register
        pub ipr1: IPR1,
        ///0x24 - Interrupt Pending Register
        pub ipr2: IPR2,
        ///0x28 - Interrupt Pending Register
        pub ipr3: IPR3,
        ///0x2c - Interrupt Pending Register
        pub ipr4: IPR4,
        _reserved8: [u8; 0x10],
        ///0x40 - Interrupt Priority Register
        pub ithresdr: ITHRESDR,
        _reserved9: [u8; 0x04],
        ///0x48 - Interrupt Config Register
        pub cfgr: CFGR,
        ///0x4c - Interrupt Global Register
        pub gisr: GISR,
        ///0x50 - ID Config Register
        pub vtfidr: VTFIDR,
        _reserved12: [u8; 0x0c],
        ///0x60 - Interrupt 0 address Register
        pub vtfaddrr0: VTFADDRR0,
        ///0x64 - Interrupt 1 address Register
        pub vtfaddrr1: VTFADDRR1,
        ///0x68 - Interrupt 2 address Register
        pub vtfaddrr2: VTFADDRR2,
        ///0x6c - Interrupt 3 address Register
        pub vtfaddrr3: VTFADDRR3,
        _reserved16: [u8; 0x90],
        ///0x100 - Interrupt Setting Register
        pub ienr1: IENR1,
        ///0x104 - Interrupt Setting Register
        pub ienr2: IENR2,
        ///0x108 - Interrupt Setting Register
        pub ienr3: IENR3,
        ///0x10c - Interrupt Setting Register
        pub ienr4: IENR4,
        _reserved20: [u8; 0x70],
        ///0x180 - Interrupt Clear Register
        pub irer1: IRER1,
        ///0x184 - Interrupt Clear Register
        pub irer2: IRER2,
        ///0x188 - Interrupt Clear Register
        pub irer3: IRER3,
        ///0x18c - Interrupt Clear Register
        pub irer4: IRER4,
        _reserved24: [u8; 0x70],
        ///0x200 - Interrupt Pending Register
        pub ipsr1: IPSR1,
        ///0x204 - Interrupt Pending Register
        pub ipsr2: IPSR2,
        ///0x208 - Interrupt Pending Register
        pub ipsr3: IPSR3,
        ///0x20c - Interrupt Pending Register
        pub ipsr4: IPSR4,
        _reserved28: [u8; 0x70],
        ///0x280 - Interrupt Pending Clear Register
        pub iprr1: IPRR1,
        ///0x284 - Interrupt Pending Clear Register
        pub iprr2: IPRR2,
        ///0x288 - Interrupt Pending Clear Register
        pub iprr3: IPRR3,
        ///0x28c - Interrupt Pending Clear Register
        pub iprr4: IPRR4,
        _reserved32: [u8; 0x70],
        ///0x300 - Interrupt ACTIVE Register
        pub iactr1: IACTR1,
        ///0x304 - Interrupt ACTIVE Register
        pub iactr2: IACTR2,
        ///0x308 - Interrupt ACTIVE Register
        pub iactr3: IACTR3,
        ///0x30c - Interrupt ACTIVE Register
        pub iactr4: IACTR4,
        _reserved36: [u8; 0xf0],
        ///0x400 - Interrupt Priority Register
        pub iprior0: IPRIOR0,
        ///0x401 - Interrupt Priority Register
        pub iprior1: IPRIOR1,
        ///0x402 - Interrupt Priority Register
        pub iprior2: IPRIOR2,
        ///0x403 - Interrupt Priority Register
        pub iprior3: IPRIOR3,
        ///0x404 - Interrupt Priority Register
        pub iprior4: IPRIOR4,
        ///0x405 - Interrupt Priority Register
        pub iprior5: IPRIOR5,
        ///0x406 - Interrupt Priority Register
        pub iprior6: IPRIOR6,
        ///0x407 - Interrupt Priority Register
        pub iprior7: IPRIOR7,
        ///0x408 - Interrupt Priority Register
        pub iprior8: IPRIOR8,
        ///0x409 - Interrupt Priority Register
        pub iprior9: IPRIOR9,
        ///0x40a - Interrupt Priority Register
        pub iprior10: IPRIOR10,
        ///0x40b - Interrupt Priority Register
        pub iprior11: IPRIOR11,
        ///0x40c - Interrupt Priority Register
        pub iprior12: IPRIOR12,
        ///0x40d - Interrupt Priority Register
        pub iprior13: IPRIOR13,
        ///0x40e - Interrupt Priority Register
        pub iprior14: IPRIOR14,
        ///0x40f - Interrupt Priority Register
        pub iprior15: IPRIOR15,
        ///0x410 - Interrupt Priority Register
        pub iprior16: IPRIOR16,
        ///0x411 - Interrupt Priority Register
        pub iprior17: IPRIOR17,
        ///0x412 - Interrupt Priority Register
        pub iprior18: IPRIOR18,
        ///0x413 - Interrupt Priority Register
        pub iprior19: IPRIOR19,
        ///0x414 - Interrupt Priority Register
        pub iprior20: IPRIOR20,
        ///0x415 - Interrupt Priority Register
        pub iprior21: IPRIOR21,
        ///0x416 - Interrupt Priority Register
        pub iprior22: IPRIOR22,
        ///0x417 - Interrupt Priority Register
        pub iprior23: IPRIOR23,
        ///0x418 - Interrupt Priority Register
        pub iprior24: IPRIOR24,
        ///0x419 - Interrupt Priority Register
        pub iprior25: IPRIOR25,
        ///0x41a - Interrupt Priority Register
        pub iprior26: IPRIOR26,
        ///0x41b - Interrupt Priority Register
        pub iprior27: IPRIOR27,
        ///0x41c - Interrupt Priority Register
        pub iprior28: IPRIOR28,
        ///0x41d - Interrupt Priority Register
        pub iprior29: IPRIOR29,
        ///0x41e - Interrupt Priority Register
        pub iprior30: IPRIOR30,
        ///0x41f - Interrupt Priority Register
        pub iprior31: IPRIOR31,
        ///0x420 - Interrupt Priority Register
        pub iprior32: IPRIOR32,
        ///0x421 - Interrupt Priority Register
        pub iprior33: IPRIOR33,
        ///0x422 - Interrupt Priority Register
        pub iprior34: IPRIOR34,
        ///0x423 - Interrupt Priority Register
        pub iprior35: IPRIOR35,
        ///0x424 - Interrupt Priority Register
        pub iprior36: IPRIOR36,
        ///0x425 - Interrupt Priority Register
        pub iprior37: IPRIOR37,
        ///0x426 - Interrupt Priority Register
        pub iprior38: IPRIOR38,
        ///0x427 - Interrupt Priority Register
        pub iprior39: IPRIOR39,
        ///0x428 - Interrupt Priority Register
        pub iprior40: IPRIOR40,
        ///0x429 - Interrupt Priority Register
        pub iprior41: IPRIOR41,
        ///0x42a - Interrupt Priority Register
        pub iprior42: IPRIOR42,
        ///0x42b - Interrupt Priority Register
        pub iprior43: IPRIOR43,
        ///0x42c - Interrupt Priority Register
        pub iprior44: IPRIOR44,
        ///0x42d - Interrupt Priority Register
        pub iprior45: IPRIOR45,
        ///0x42e - Interrupt Priority Register
        pub iprior46: IPRIOR46,
        ///0x42f - Interrupt Priority Register
        pub iprior47: IPRIOR47,
        ///0x430 - Interrupt Priority Register
        pub iprior48: IPRIOR48,
        ///0x431 - Interrupt Priority Register
        pub iprior49: IPRIOR49,
        ///0x432 - Interrupt Priority Register
        pub iprior50: IPRIOR50,
        ///0x433 - Interrupt Priority Register
        pub iprior51: IPRIOR51,
        ///0x434 - Interrupt Priority Register
        pub iprior52: IPRIOR52,
        ///0x435 - Interrupt Priority Register
        pub iprior53: IPRIOR53,
        ///0x436 - Interrupt Priority Register
        pub iprior54: IPRIOR54,
        ///0x437 - Interrupt Priority Register
        pub iprior55: IPRIOR55,
        ///0x438 - Interrupt Priority Register
        pub iprior56: IPRIOR56,
        ///0x439 - Interrupt Priority Register
        pub iprior57: IPRIOR57,
        ///0x43a - Interrupt Priority Register
        pub iprior58: IPRIOR58,
        ///0x43b - Interrupt Priority Register
        pub iprior59: IPRIOR59,
        ///0x43c - Interrupt Priority Register
        pub iprior60: IPRIOR60,
        ///0x43d - Interrupt Priority Register
        pub iprior61: IPRIOR61,
        ///0x43e - Interrupt Priority Register
        pub iprior62: IPRIOR62,
        ///0x43f - Interrupt Priority Register
        pub iprior63: IPRIOR63,
        _reserved100: [u8; 0x08d0],
        ///0xd10 - System Control Register
        pub sctlr: SCTLR,
        _reserved101: [u8; 0x02ec],
        ///0x1000 - System counter control register
        pub stk_ctlr: STK_CTLR,
        ///0x1004 - System START
        pub stk_sr: STK_SR,
        ///0x1008 - System counter low register
        pub stk_cntl: STK_CNTL,
        _reserved104: [u8; 0x04],
        ///0x1010 - System compare low register
        pub stk_cmplr: STK_CMPLR,
    }
    ///ISR1 (r) register accessor: an alias for `Reg<ISR1_SPEC>`
    pub type ISR1 = crate::Reg<isr1::ISR1_SPEC>;
    ///Interrupt Status Register
    pub mod isr1 {
        ///Register `ISR1` reader
        pub struct R(crate::R<ISR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA2_3` reader - Interrupt ID Status
        pub type INTENSTA2_3_R = crate::FieldReader<u8, u8>;
        ///Field `INTENSTA12_31` reader - Interrupt ID Status
        pub type INTENSTA12_31_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 2:3 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta2_3(&self) -> INTENSTA2_3_R {
                INTENSTA2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 12:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta12_31(&self) -> INTENSTA12_31_R {
                INTENSTA12_31_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///Interrupt Status Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr1](index.html) module
        pub struct ISR1_SPEC;
        impl crate::RegisterSpec for ISR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr1::R](R) reader structure
        impl crate::Readable for ISR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR1 to value 0x0c
        impl crate::Resettable for ISR1_SPEC {
            const RESET_VALUE: Self::Ux = 0x0c;
        }
    }
    ///ISR2 (r) register accessor: an alias for `Reg<ISR2_SPEC>`
    pub type ISR2 = crate::Reg<isr2::ISR2_SPEC>;
    ///Interrupt Status Register
    pub mod isr2 {
        ///Register `ISR2` reader
        pub struct R(crate::R<ISR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new(self.bits)
            }
        }
        ///Interrupt Status Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr2](index.html) module
        pub struct ISR2_SPEC;
        impl crate::RegisterSpec for ISR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr2::R](R) reader structure
        impl crate::Readable for ISR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR2 to value 0
        impl crate::Resettable for ISR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ISR3 (r) register accessor: an alias for `Reg<ISR3_SPEC>`
    pub type ISR3 = crate::Reg<isr3::ISR3_SPEC>;
    ///Interrupt Status Register
    pub mod isr3 {
        ///Register `ISR3` reader
        pub struct R(crate::R<ISR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new(self.bits)
            }
        }
        ///Interrupt Status Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr3](index.html) module
        pub struct ISR3_SPEC;
        impl crate::RegisterSpec for ISR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr3::R](R) reader structure
        impl crate::Readable for ISR3_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR3 to value 0
        impl crate::Resettable for ISR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ISR4 (r) register accessor: an alias for `Reg<ISR4_SPEC>`
    pub type ISR4 = crate::Reg<isr4::ISR4_SPEC>;
    ///Interrupt Status Register
    pub mod isr4 {
        ///Register `ISR4` reader
        pub struct R(crate::R<ISR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ISR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ISR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `INTENSTA` reader - Interrupt ID Status
        pub type INTENSTA_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - Interrupt ID Status
            #[inline(always)]
            pub fn intensta(&self) -> INTENSTA_R {
                INTENSTA_R::new((self.bits & 0xff) as u8)
            }
        }
        ///Interrupt Status Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr4](index.html) module
        pub struct ISR4_SPEC;
        impl crate::RegisterSpec for ISR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr4::R](R) reader structure
        impl crate::Readable for ISR4_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR4 to value 0
        impl crate::Resettable for ISR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR1 (r) register accessor: an alias for `Reg<IPR1_SPEC>`
    pub type IPR1 = crate::Reg<ipr1::IPR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr1 {
        ///Register `IPR1` reader
        pub struct R(crate::R<IPR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA2_3` reader - PENDSTA
        pub type PENDSTA2_3_R = crate::FieldReader<u8, u8>;
        ///Field `PENDSTA12_31` reader - PENDSTA
        pub type PENDSTA12_31_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 2:3 - PENDSTA
            #[inline(always)]
            pub fn pendsta2_3(&self) -> PENDSTA2_3_R {
                PENDSTA2_3_R::new(((self.bits >> 2) & 3) as u8)
            }
            ///Bits 12:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta12_31(&self) -> PENDSTA12_31_R {
                PENDSTA12_31_R::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr1](index.html) module
        pub struct IPR1_SPEC;
        impl crate::RegisterSpec for IPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr1::R](R) reader structure
        impl crate::Readable for IPR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR1 to value 0
        impl crate::Resettable for IPR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR2 (r) register accessor: an alias for `Reg<IPR2_SPEC>`
    pub type IPR2 = crate::Reg<ipr2::IPR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr2 {
        ///Register `IPR2` reader
        pub struct R(crate::R<IPR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new(self.bits)
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr2](index.html) module
        pub struct IPR2_SPEC;
        impl crate::RegisterSpec for IPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr2::R](R) reader structure
        impl crate::Readable for IPR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR2 to value 0
        impl crate::Resettable for IPR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR3 (r) register accessor: an alias for `Reg<IPR3_SPEC>`
    pub type IPR3 = crate::Reg<ipr3::IPR3_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr3 {
        ///Register `IPR3` reader
        pub struct R(crate::R<IPR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u32, u32>;
        impl R {
            ///Bits 0:31 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new(self.bits)
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr3](index.html) module
        pub struct IPR3_SPEC;
        impl crate::RegisterSpec for IPR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr3::R](R) reader structure
        impl crate::Readable for IPR3_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR3 to value 0
        impl crate::Resettable for IPR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPR4 (r) register accessor: an alias for `Reg<IPR4_SPEC>`
    pub type IPR4 = crate::Reg<ipr4::IPR4_SPEC>;
    ///Interrupt Pending Register
    pub mod ipr4 {
        ///Register `IPR4` reader
        pub struct R(crate::R<IPR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PENDSTA` reader - PENDSTA
        pub type PENDSTA_R = crate::FieldReader<u8, u8>;
        impl R {
            ///Bits 0:7 - PENDSTA
            #[inline(always)]
            pub fn pendsta(&self) -> PENDSTA_R {
                PENDSTA_R::new((self.bits & 0xff) as u8)
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipr4](index.html) module
        pub struct IPR4_SPEC;
        impl crate::RegisterSpec for IPR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ipr4::R](R) reader structure
        impl crate::Readable for IPR4_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IPR4 to value 0
        impl crate::Resettable for IPR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///ITHRESDR (rw) register accessor: an alias for `Reg<ITHRESDR_SPEC>`
    pub type ITHRESDR = crate::Reg<ithresdr::ITHRESDR_SPEC>;
    ///Interrupt Priority Register
    pub mod ithresdr {
        ///Register `ITHRESDR` reader
        pub struct R(crate::R<ITHRESDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<ITHRESDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<ITHRESDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ITHRESDR` writer
        pub struct W(crate::W<ITHRESDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ITHRESDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<ITHRESDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<ITHRESDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `THRESHOLD` reader - THRESHOLD
        pub type THRESHOLD_R = crate::FieldReader<u8, u8>;
        ///Field `THRESHOLD` writer - THRESHOLD
        pub type THRESHOLD_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, ITHRESDR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            pub fn threshold(&self) -> THRESHOLD_R {
                THRESHOLD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - THRESHOLD
            #[inline(always)]
            #[must_use]
            pub fn threshold(&mut self) -> THRESHOLD_W<0> {
                THRESHOLD_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ithresdr](index.html) module
        pub struct ITHRESDR_SPEC;
        impl crate::RegisterSpec for ITHRESDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ithresdr::R](R) reader structure
        impl crate::Readable for ITHRESDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ithresdr::W](W) writer structure
        impl crate::Writable for ITHRESDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets ITHRESDR to value 0
        impl crate::Resettable for ITHRESDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///CFGR (w) register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Interrupt Config Register
    pub mod cfgr {
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<CFGR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RESETSYS` writer - RESETSYS
        pub type RESETSYS_W<'a, const O: u8> = crate::BitWriter<'a, u32, CFGR_SPEC, bool, O>;
        ///Field `KEYCODE` writer - KEYCODE
        pub type KEYCODE_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, CFGR_SPEC, u16, u16, 16, O>;
        impl W {
            ///Bit 7 - RESETSYS
            #[inline(always)]
            #[must_use]
            pub fn resetsys(&mut self) -> RESETSYS_W<7> {
                RESETSYS_W::new(self)
            }
            ///Bits 16:31 - KEYCODE
            #[inline(always)]
            #[must_use]
            pub fn keycode(&mut self) -> KEYCODE_W<16> {
                KEYCODE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Config Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///GISR (r) register accessor: an alias for `Reg<GISR_SPEC>`
    pub type GISR = crate::Reg<gisr::GISR_SPEC>;
    ///Interrupt Global Register
    pub mod gisr {
        ///Register `GISR` reader
        pub struct R(crate::R<GISR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GISR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<GISR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<GISR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `NESTSTA` reader - NESTSTA
        pub type NESTSTA_R = crate::FieldReader<u8, u8>;
        ///Field `GACTSTA` reader - GACTSTA
        pub type GACTSTA_R = crate::BitReader<bool>;
        ///Field `GPENDSTA` reader - GPENDSTA
        pub type GPENDSTA_R = crate::BitReader<bool>;
        impl R {
            ///Bits 0:7 - NESTSTA
            #[inline(always)]
            pub fn neststa(&self) -> NESTSTA_R {
                NESTSTA_R::new((self.bits & 0xff) as u8)
            }
            ///Bit 8 - GACTSTA
            #[inline(always)]
            pub fn gactsta(&self) -> GACTSTA_R {
                GACTSTA_R::new(((self.bits >> 8) & 1) != 0)
            }
            ///Bit 9 - GPENDSTA
            #[inline(always)]
            pub fn gpendsta(&self) -> GPENDSTA_R {
                GPENDSTA_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        ///Interrupt Global Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [gisr](index.html) module
        pub struct GISR_SPEC;
        impl crate::RegisterSpec for GISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [gisr::R](R) reader structure
        impl crate::Readable for GISR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets GISR to value 0
        impl crate::Resettable for GISR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VTFIDR (rw) register accessor: an alias for `Reg<VTFIDR_SPEC>`
    pub type VTFIDR = crate::Reg<vtfidr::VTFIDR_SPEC>;
    ///ID Config Register
    pub mod vtfidr {
        ///Register `VTFIDR` reader
        pub struct R(crate::R<VTFIDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VTFIDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VTFIDR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VTFIDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VTFIDR` writer
        pub struct W(crate::W<VTFIDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VTFIDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<VTFIDR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<VTFIDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `VTFID0` reader - VTFID0
        pub type VTFID0_R = crate::FieldReader<u8, u8>;
        ///Field `VTFID0` writer - VTFID0
        pub type VTFID0_W<'a, const O: u8> = crate::FieldWriter<'a, u32, VTFIDR_SPEC, u8, u8, 8, O>;
        ///Field `VTFID1` reader - VTFID1
        pub type VTFID1_R = crate::FieldReader<u8, u8>;
        ///Field `VTFID1` writer - VTFID1
        pub type VTFID1_W<'a, const O: u8> = crate::FieldWriter<'a, u32, VTFIDR_SPEC, u8, u8, 8, O>;
        ///Field `VTFID2` reader - VTFID2
        pub type VTFID2_R = crate::FieldReader<u8, u8>;
        ///Field `VTFID2` writer - VTFID2
        pub type VTFID2_W<'a, const O: u8> = crate::FieldWriter<'a, u32, VTFIDR_SPEC, u8, u8, 8, O>;
        ///Field `VTFID3` reader - VTFID3
        pub type VTFID3_R = crate::FieldReader<u8, u8>;
        ///Field `VTFID3` writer - VTFID3
        pub type VTFID3_W<'a, const O: u8> = crate::FieldWriter<'a, u32, VTFIDR_SPEC, u8, u8, 8, O>;
        impl R {
            ///Bits 0:7 - VTFID0
            #[inline(always)]
            pub fn vtfid0(&self) -> VTFID0_R {
                VTFID0_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - VTFID1
            #[inline(always)]
            pub fn vtfid1(&self) -> VTFID1_R {
                VTFID1_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 16:23 - VTFID2
            #[inline(always)]
            pub fn vtfid2(&self) -> VTFID2_R {
                VTFID2_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            ///Bits 24:31 - VTFID3
            #[inline(always)]
            pub fn vtfid3(&self) -> VTFID3_R {
                VTFID3_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - VTFID0
            #[inline(always)]
            #[must_use]
            pub fn vtfid0(&mut self) -> VTFID0_W<0> {
                VTFID0_W::new(self)
            }
            ///Bits 8:15 - VTFID1
            #[inline(always)]
            #[must_use]
            pub fn vtfid1(&mut self) -> VTFID1_W<8> {
                VTFID1_W::new(self)
            }
            ///Bits 16:23 - VTFID2
            #[inline(always)]
            #[must_use]
            pub fn vtfid2(&mut self) -> VTFID2_W<16> {
                VTFID2_W::new(self)
            }
            ///Bits 24:31 - VTFID3
            #[inline(always)]
            #[must_use]
            pub fn vtfid3(&mut self) -> VTFID3_W<24> {
                VTFID3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///ID Config Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vtfidr](index.html) module
        pub struct VTFIDR_SPEC;
        impl crate::RegisterSpec for VTFIDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vtfidr::R](R) reader structure
        impl crate::Readable for VTFIDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [vtfidr::W](W) writer structure
        impl crate::Writable for VTFIDR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets VTFIDR to value 0
        impl crate::Resettable for VTFIDR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VTFADDRR0 (rw) register accessor: an alias for `Reg<VTFADDRR0_SPEC>`
    pub type VTFADDRR0 = crate::Reg<vtfaddrr0::VTFADDRR0_SPEC>;
    ///Interrupt 0 address Register
    pub mod vtfaddrr0 {
        ///Register `VTFADDRR0` reader
        pub struct R(crate::R<VTFADDRR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VTFADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VTFADDRR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VTFADDRR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VTFADDRR0` writer
        pub struct W(crate::W<VTFADDRR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VTFADDRR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<VTFADDRR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<VTFADDRR0_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `VTF0EN` reader - VTF0EN
        pub type VTF0EN_R = crate::BitReader<bool>;
        ///Field `VTF0EN` writer - VTF0EN
        pub type VTF0EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, VTFADDRR0_SPEC, bool, O>;
        ///Field `ADDR0` reader - ADDR0
        pub type ADDR0_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR0` writer - ADDR0
        pub type ADDR0_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, VTFADDRR0_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - VTF0EN
            #[inline(always)]
            pub fn vtf0en(&self) -> VTF0EN_R {
                VTF0EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR0
            #[inline(always)]
            pub fn addr0(&self) -> ADDR0_R {
                ADDR0_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF0EN
            #[inline(always)]
            #[must_use]
            pub fn vtf0en(&mut self) -> VTF0EN_W<0> {
                VTF0EN_W::new(self)
            }
            ///Bits 1:31 - ADDR0
            #[inline(always)]
            #[must_use]
            pub fn addr0(&mut self) -> ADDR0_W<1> {
                ADDR0_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 0 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vtfaddrr0](index.html) module
        pub struct VTFADDRR0_SPEC;
        impl crate::RegisterSpec for VTFADDRR0_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vtfaddrr0::R](R) reader structure
        impl crate::Readable for VTFADDRR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [vtfaddrr0::W](W) writer structure
        impl crate::Writable for VTFADDRR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets VTFADDRR0 to value 0
        impl crate::Resettable for VTFADDRR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VTFADDRR1 (rw) register accessor: an alias for `Reg<VTFADDRR1_SPEC>`
    pub type VTFADDRR1 = crate::Reg<vtfaddrr1::VTFADDRR1_SPEC>;
    ///Interrupt 1 address Register
    pub mod vtfaddrr1 {
        ///Register `VTFADDRR1` reader
        pub struct R(crate::R<VTFADDRR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VTFADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VTFADDRR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VTFADDRR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VTFADDRR1` writer
        pub struct W(crate::W<VTFADDRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VTFADDRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<VTFADDRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<VTFADDRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `VTF1EN` reader - VTF1EN
        pub type VTF1EN_R = crate::BitReader<bool>;
        ///Field `VTF1EN` writer - VTF1EN
        pub type VTF1EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, VTFADDRR1_SPEC, bool, O>;
        ///Field `ADDR1` reader - ADDR1
        pub type ADDR1_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR1` writer - ADDR1
        pub type ADDR1_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, VTFADDRR1_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - VTF1EN
            #[inline(always)]
            pub fn vtf1en(&self) -> VTF1EN_R {
                VTF1EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR1
            #[inline(always)]
            pub fn addr1(&self) -> ADDR1_R {
                ADDR1_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF1EN
            #[inline(always)]
            #[must_use]
            pub fn vtf1en(&mut self) -> VTF1EN_W<0> {
                VTF1EN_W::new(self)
            }
            ///Bits 1:31 - ADDR1
            #[inline(always)]
            #[must_use]
            pub fn addr1(&mut self) -> ADDR1_W<1> {
                ADDR1_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 1 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vtfaddrr1](index.html) module
        pub struct VTFADDRR1_SPEC;
        impl crate::RegisterSpec for VTFADDRR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vtfaddrr1::R](R) reader structure
        impl crate::Readable for VTFADDRR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [vtfaddrr1::W](W) writer structure
        impl crate::Writable for VTFADDRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets VTFADDRR1 to value 0
        impl crate::Resettable for VTFADDRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VTFADDRR2 (rw) register accessor: an alias for `Reg<VTFADDRR2_SPEC>`
    pub type VTFADDRR2 = crate::Reg<vtfaddrr2::VTFADDRR2_SPEC>;
    ///Interrupt 2 address Register
    pub mod vtfaddrr2 {
        ///Register `VTFADDRR2` reader
        pub struct R(crate::R<VTFADDRR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VTFADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VTFADDRR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VTFADDRR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VTFADDRR2` writer
        pub struct W(crate::W<VTFADDRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VTFADDRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<VTFADDRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<VTFADDRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `VTF2EN` reader - VTF2EN
        pub type VTF2EN_R = crate::BitReader<bool>;
        ///Field `VTF2EN` writer - VTF2EN
        pub type VTF2EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, VTFADDRR2_SPEC, bool, O>;
        ///Field `ADDR2` reader - ADDR2
        pub type ADDR2_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR2` writer - ADDR2
        pub type ADDR2_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, VTFADDRR2_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - VTF2EN
            #[inline(always)]
            pub fn vtf2en(&self) -> VTF2EN_R {
                VTF2EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR2
            #[inline(always)]
            pub fn addr2(&self) -> ADDR2_R {
                ADDR2_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF2EN
            #[inline(always)]
            #[must_use]
            pub fn vtf2en(&mut self) -> VTF2EN_W<0> {
                VTF2EN_W::new(self)
            }
            ///Bits 1:31 - ADDR2
            #[inline(always)]
            #[must_use]
            pub fn addr2(&mut self) -> ADDR2_W<1> {
                ADDR2_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 2 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vtfaddrr2](index.html) module
        pub struct VTFADDRR2_SPEC;
        impl crate::RegisterSpec for VTFADDRR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vtfaddrr2::R](R) reader structure
        impl crate::Readable for VTFADDRR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [vtfaddrr2::W](W) writer structure
        impl crate::Writable for VTFADDRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets VTFADDRR2 to value 0
        impl crate::Resettable for VTFADDRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///VTFADDRR3 (rw) register accessor: an alias for `Reg<VTFADDRR3_SPEC>`
    pub type VTFADDRR3 = crate::Reg<vtfaddrr3::VTFADDRR3_SPEC>;
    ///Interrupt 3 address Register
    pub mod vtfaddrr3 {
        ///Register `VTFADDRR3` reader
        pub struct R(crate::R<VTFADDRR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VTFADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<VTFADDRR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<VTFADDRR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VTFADDRR3` writer
        pub struct W(crate::W<VTFADDRR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VTFADDRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<VTFADDRR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<VTFADDRR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `VTF3EN` reader - VTF3EN
        pub type VTF3EN_R = crate::BitReader<bool>;
        ///Field `VTF3EN` writer - VTF3EN
        pub type VTF3EN_W<'a, const O: u8> = crate::BitWriter<'a, u32, VTFADDRR3_SPEC, bool, O>;
        ///Field `ADDR3` reader - ADDR3
        pub type ADDR3_R = crate::FieldReader<u32, u32>;
        ///Field `ADDR3` writer - ADDR3
        pub type ADDR3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, VTFADDRR3_SPEC, u32, u32, 31, O>;
        impl R {
            ///Bit 0 - VTF3EN
            #[inline(always)]
            pub fn vtf3en(&self) -> VTF3EN_R {
                VTF3EN_R::new((self.bits & 1) != 0)
            }
            ///Bits 1:31 - ADDR3
            #[inline(always)]
            pub fn addr3(&self) -> ADDR3_R {
                ADDR3_R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            ///Bit 0 - VTF3EN
            #[inline(always)]
            #[must_use]
            pub fn vtf3en(&mut self) -> VTF3EN_W<0> {
                VTF3EN_W::new(self)
            }
            ///Bits 1:31 - ADDR3
            #[inline(always)]
            #[must_use]
            pub fn addr3(&mut self) -> ADDR3_W<1> {
                ADDR3_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt 3 address Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [vtfaddrr3](index.html) module
        pub struct VTFADDRR3_SPEC;
        impl crate::RegisterSpec for VTFADDRR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [vtfaddrr3::R](R) reader structure
        impl crate::Readable for VTFADDRR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [vtfaddrr3::W](W) writer structure
        impl crate::Writable for VTFADDRR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets VTFADDRR3 to value 0
        impl crate::Resettable for VTFADDRR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR1 (w) register accessor: an alias for `Reg<IENR1_SPEC>`
    pub type IENR1 = crate::Reg<ienr1::IENR1_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr1 {
        ///Register `IENR1` writer
        pub struct W(crate::W<IENR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IENR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<12> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr1](index.html) module
        pub struct IENR1_SPEC;
        impl crate::RegisterSpec for IENR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ienr1::W](W) writer structure
        impl crate::Writable for IENR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR1 to value 0
        impl crate::Resettable for IENR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR2 (w) register accessor: an alias for `Reg<IENR2_SPEC>`
    pub type IENR2 = crate::Reg<ienr2::IENR2_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr2 {
        ///Register `IENR2` writer
        pub struct W(crate::W<IENR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IENR2_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<0> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr2](index.html) module
        pub struct IENR2_SPEC;
        impl crate::RegisterSpec for IENR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ienr2::W](W) writer structure
        impl crate::Writable for IENR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR2 to value 0
        impl crate::Resettable for IENR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR3 (w) register accessor: an alias for `Reg<IENR3_SPEC>`
    pub type IENR3 = crate::Reg<ienr3::IENR3_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr3 {
        ///Register `IENR3` writer
        pub struct W(crate::W<IENR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IENR3_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<0> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr3](index.html) module
        pub struct IENR3_SPEC;
        impl crate::RegisterSpec for IENR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ienr3::W](W) writer structure
        impl crate::Writable for IENR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR3 to value 0
        impl crate::Resettable for IENR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IENR4 (w) register accessor: an alias for `Reg<IENR4_SPEC>`
    pub type IENR4 = crate::Reg<ienr4::IENR4_SPEC>;
    ///Interrupt Setting Register
    pub mod ienr4 {
        ///Register `IENR4` writer
        pub struct W(crate::W<IENR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IENR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IENR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IENR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTEN` writer - INTEN
        pub type INTEN_W<'a, const O: u8> = crate::FieldWriter<'a, u32, IENR4_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - INTEN
            #[inline(always)]
            #[must_use]
            pub fn inten(&mut self) -> INTEN_W<0> {
                INTEN_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Setting Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ienr4](index.html) module
        pub struct IENR4_SPEC;
        impl crate::RegisterSpec for IENR4_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ienr4::W](W) writer structure
        impl crate::Writable for IENR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IENR4 to value 0
        impl crate::Resettable for IENR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER1 (w) register accessor: an alias for `Reg<IRER1_SPEC>`
    pub type IRER1 = crate::Reg<irer1::IRER1_SPEC>;
    ///Interrupt Clear Register
    pub mod irer1 {
        ///Register `IRER1` writer
        pub struct W(crate::W<IRER1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IRER1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 12:31 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<12> {
                INTRSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer1](index.html) module
        pub struct IRER1_SPEC;
        impl crate::RegisterSpec for IRER1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [irer1::W](W) writer structure
        impl crate::Writable for IRER1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER1 to value 0
        impl crate::Resettable for IRER1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER2 (w) register accessor: an alias for `Reg<IRER2_SPEC>`
    pub type IRER2 = crate::Reg<irer2::IRER2_SPEC>;
    ///Interrupt Clear Register
    pub mod irer2 {
        ///Register `IRER2` writer
        pub struct W(crate::W<IRER2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IRER2_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<0> {
                INTRSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer2](index.html) module
        pub struct IRER2_SPEC;
        impl crate::RegisterSpec for IRER2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [irer2::W](W) writer structure
        impl crate::Writable for IRER2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER2 to value 0
        impl crate::Resettable for IRER2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER3 (w) register accessor: an alias for `Reg<IRER3_SPEC>`
    pub type IRER3 = crate::Reg<irer3::IRER3_SPEC>;
    ///Interrupt Clear Register
    pub mod irer3 {
        ///Register `IRER3` writer
        pub struct W(crate::W<IRER3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IRER3_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<0> {
                INTRSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer3](index.html) module
        pub struct IRER3_SPEC;
        impl crate::RegisterSpec for IRER3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [irer3::W](W) writer structure
        impl crate::Writable for IRER3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER3 to value 0
        impl crate::Resettable for IRER3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IRER4 (w) register accessor: an alias for `Reg<IRER4_SPEC>`
    pub type IRER4 = crate::Reg<irer4::IRER4_SPEC>;
    ///Interrupt Clear Register
    pub mod irer4 {
        ///Register `IRER4` writer
        pub struct W(crate::W<IRER4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IRER4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IRER4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IRER4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTRSET` writer - INTRSET
        pub type INTRSET_W<'a, const O: u8> = crate::FieldWriter<'a, u32, IRER4_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - INTRSET
            #[inline(always)]
            #[must_use]
            pub fn intrset(&mut self) -> INTRSET_W<0> {
                INTRSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [irer4](index.html) module
        pub struct IRER4_SPEC;
        impl crate::RegisterSpec for IRER4_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [irer4::W](W) writer structure
        impl crate::Writable for IRER4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IRER4 to value 0
        impl crate::Resettable for IRER4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR1 (w) register accessor: an alias for `Reg<IPSR1_SPEC>`
    pub type IPSR1 = crate::Reg<ipsr1::IPSR1_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr1 {
        ///Register `IPSR1` writer
        pub struct W(crate::W<IPSR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET2_3` writer - PENDSET
        pub type PENDSET2_3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPSR1_SPEC, u8, u8, 2, O>;
        ///Field `PENDSET12_31` writer - PENDSET
        pub type PENDSET12_31_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPSR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 2:3 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset2_3(&mut self) -> PENDSET2_3_W<2> {
                PENDSET2_3_W::new(self)
            }
            ///Bits 12:31 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset12_31(&mut self) -> PENDSET12_31_W<12> {
                PENDSET12_31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr1](index.html) module
        pub struct IPSR1_SPEC;
        impl crate::RegisterSpec for IPSR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ipsr1::W](W) writer structure
        impl crate::Writable for IPSR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR1 to value 0
        impl crate::Resettable for IPSR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR2 (w) register accessor: an alias for `Reg<IPSR2_SPEC>`
    pub type IPSR2 = crate::Reg<ipsr2::IPSR2_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr2 {
        ///Register `IPSR2` writer
        pub struct W(crate::W<IPSR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPSR2_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<0> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr2](index.html) module
        pub struct IPSR2_SPEC;
        impl crate::RegisterSpec for IPSR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ipsr2::W](W) writer structure
        impl crate::Writable for IPSR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR2 to value 0
        impl crate::Resettable for IPSR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR3 (w) register accessor: an alias for `Reg<IPSR3_SPEC>`
    pub type IPSR3 = crate::Reg<ipsr3::IPSR3_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr3 {
        ///Register `IPSR3` writer
        pub struct W(crate::W<IPSR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPSR3_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<0> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr3](index.html) module
        pub struct IPSR3_SPEC;
        impl crate::RegisterSpec for IPSR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ipsr3::W](W) writer structure
        impl crate::Writable for IPSR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR3 to value 0
        impl crate::Resettable for IPSR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPSR4 (w) register accessor: an alias for `Reg<IPSR4_SPEC>`
    pub type IPSR4 = crate::Reg<ipsr4::IPSR4_SPEC>;
    ///Interrupt Pending Register
    pub mod ipsr4 {
        ///Register `IPSR4` writer
        pub struct W(crate::W<IPSR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPSR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPSR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPSR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDSET` writer - PENDSET
        pub type PENDSET_W<'a, const O: u8> = crate::FieldWriter<'a, u32, IPSR4_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - PENDSET
            #[inline(always)]
            #[must_use]
            pub fn pendset(&mut self) -> PENDSET_W<0> {
                PENDSET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ipsr4](index.html) module
        pub struct IPSR4_SPEC;
        impl crate::RegisterSpec for IPSR4_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ipsr4::W](W) writer structure
        impl crate::Writable for IPSR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPSR4 to value 0
        impl crate::Resettable for IPSR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR1 (w) register accessor: an alias for `Reg<IPRR1_SPEC>`
    pub type IPRR1 = crate::Reg<iprr1::IPRR1_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr1 {
        ///Register `IPRR1` writer
        pub struct W(crate::W<IPRR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET2_3` writer - PENDRESET
        pub type PENDRESET2_3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR1_SPEC, u8, u8, 2, O>;
        ///Field `PENDRESET12_31` writer - PENDRESET
        pub type PENDRESET12_31_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 2:3 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset2_3(&mut self) -> PENDRESET2_3_W<2> {
                PENDRESET2_3_W::new(self)
            }
            ///Bits 12:31 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset12_31(&mut self) -> PENDRESET12_31_W<12> {
                PENDRESET12_31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr1](index.html) module
        pub struct IPRR1_SPEC;
        impl crate::RegisterSpec for IPRR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iprr1::W](W) writer structure
        impl crate::Writable for IPRR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR1 to value 0
        impl crate::Resettable for IPRR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR2 (w) register accessor: an alias for `Reg<IPRR2_SPEC>`
    pub type IPRR2 = crate::Reg<iprr2::IPRR2_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr2 {
        ///Register `IPRR2` writer
        pub struct W(crate::W<IPRR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR2_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<0> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr2](index.html) module
        pub struct IPRR2_SPEC;
        impl crate::RegisterSpec for IPRR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iprr2::W](W) writer structure
        impl crate::Writable for IPRR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR2 to value 0
        impl crate::Resettable for IPRR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR3 (w) register accessor: an alias for `Reg<IPRR3_SPEC>`
    pub type IPRR3 = crate::Reg<iprr3::IPRR3_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr3 {
        ///Register `IPRR3` writer
        pub struct W(crate::W<IPRR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR3_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<0> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr3](index.html) module
        pub struct IPRR3_SPEC;
        impl crate::RegisterSpec for IPRR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iprr3::W](W) writer structure
        impl crate::Writable for IPRR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR3 to value 0
        impl crate::Resettable for IPRR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRR4 (w) register accessor: an alias for `Reg<IPRR4_SPEC>`
    pub type IPRR4 = crate::Reg<iprr4::IPRR4_SPEC>;
    ///Interrupt Pending Clear Register
    pub mod iprr4 {
        ///Register `IPRR4` writer
        pub struct W(crate::W<IPRR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PENDRESET` writer - PENDRESET
        pub type PENDRESET_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IPRR4_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - PENDRESET
            #[inline(always)]
            #[must_use]
            pub fn pendreset(&mut self) -> PENDRESET_W<0> {
                PENDRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Pending Clear Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprr4](index.html) module
        pub struct IPRR4_SPEC;
        impl crate::RegisterSpec for IPRR4_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iprr4::W](W) writer structure
        impl crate::Writable for IPRR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRR4 to value 0
        impl crate::Resettable for IPRR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR1 (w) register accessor: an alias for `Reg<IACTR1_SPEC>`
    pub type IACTR1 = crate::Reg<iactr1::IACTR1_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr1 {
        ///Register `IACTR1` writer
        pub struct W(crate::W<IACTR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS2_3` writer - IACTS
        pub type IACTS2_3_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IACTR1_SPEC, u8, u8, 2, O>;
        ///Field `IACTS12_31` writer - IACTS
        pub type IACTS12_31_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IACTR1_SPEC, u32, u32, 20, O>;
        impl W {
            ///Bits 2:3 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts2_3(&mut self) -> IACTS2_3_W<2> {
                IACTS2_3_W::new(self)
            }
            ///Bits 12:31 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts12_31(&mut self) -> IACTS12_31_W<12> {
                IACTS12_31_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr1](index.html) module
        pub struct IACTR1_SPEC;
        impl crate::RegisterSpec for IACTR1_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iactr1::W](W) writer structure
        impl crate::Writable for IACTR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR1 to value 0
        impl crate::Resettable for IACTR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR2 (w) register accessor: an alias for `Reg<IACTR2_SPEC>`
    pub type IACTR2 = crate::Reg<iactr2::IACTR2_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr2 {
        ///Register `IACTR2` writer
        pub struct W(crate::W<IACTR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IACTR2_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<0> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr2](index.html) module
        pub struct IACTR2_SPEC;
        impl crate::RegisterSpec for IACTR2_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iactr2::W](W) writer structure
        impl crate::Writable for IACTR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR2 to value 0
        impl crate::Resettable for IACTR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR3 (w) register accessor: an alias for `Reg<IACTR3_SPEC>`
    pub type IACTR3 = crate::Reg<iactr3::IACTR3_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr3 {
        ///Register `IACTR3` writer
        pub struct W(crate::W<IACTR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, IACTR3_SPEC, u32, u32, 32, O>;
        impl W {
            ///Bits 0:31 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<0> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr3](index.html) module
        pub struct IACTR3_SPEC;
        impl crate::RegisterSpec for IACTR3_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iactr3::W](W) writer structure
        impl crate::Writable for IACTR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR3 to value 0
        impl crate::Resettable for IACTR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IACTR4 (w) register accessor: an alias for `Reg<IACTR4_SPEC>`
    pub type IACTR4 = crate::Reg<iactr4::IACTR4_SPEC>;
    ///Interrupt ACTIVE Register
    pub mod iactr4 {
        ///Register `IACTR4` writer
        pub struct W(crate::W<IACTR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IACTR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IACTR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IACTR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IACTS` writer - IACTS
        pub type IACTS_W<'a, const O: u8> = crate::FieldWriter<'a, u32, IACTR4_SPEC, u8, u8, 8, O>;
        impl W {
            ///Bits 0:7 - IACTS
            #[inline(always)]
            #[must_use]
            pub fn iacts(&mut self) -> IACTS_W<0> {
                IACTS_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt ACTIVE Register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iactr4](index.html) module
        pub struct IACTR4_SPEC;
        impl crate::RegisterSpec for IACTR4_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [iactr4::W](W) writer structure
        impl crate::Writable for IACTR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IACTR4 to value 0
        impl crate::Resettable for IACTR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR0 (rw) register accessor: an alias for `Reg<IPRIOR0_SPEC>`
    pub type IPRIOR0 = crate::Reg<iprior0::IPRIOR0_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior0 {
        ///Register `IPRIOR0` reader
        pub struct R(crate::R<IPRIOR0_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR0_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR0_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR0` writer
        pub struct W(crate::W<IPRIOR0_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR0_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR0_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR0_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior0](index.html) module
        pub struct IPRIOR0_SPEC;
        impl crate::RegisterSpec for IPRIOR0_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior0::R](R) reader structure
        impl crate::Readable for IPRIOR0_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior0::W](W) writer structure
        impl crate::Writable for IPRIOR0_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR0 to value 0
        impl crate::Resettable for IPRIOR0_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR1 (rw) register accessor: an alias for `Reg<IPRIOR1_SPEC>`
    pub type IPRIOR1 = crate::Reg<iprior1::IPRIOR1_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior1 {
        ///Register `IPRIOR1` reader
        pub struct R(crate::R<IPRIOR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR1_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR1` writer
        pub struct W(crate::W<IPRIOR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR1_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR1_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior1](index.html) module
        pub struct IPRIOR1_SPEC;
        impl crate::RegisterSpec for IPRIOR1_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior1::R](R) reader structure
        impl crate::Readable for IPRIOR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior1::W](W) writer structure
        impl crate::Writable for IPRIOR1_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR1 to value 0
        impl crate::Resettable for IPRIOR1_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR2 (rw) register accessor: an alias for `Reg<IPRIOR2_SPEC>`
    pub type IPRIOR2 = crate::Reg<iprior2::IPRIOR2_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior2 {
        ///Register `IPRIOR2` reader
        pub struct R(crate::R<IPRIOR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR2_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR2` writer
        pub struct W(crate::W<IPRIOR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR2_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR2_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior2](index.html) module
        pub struct IPRIOR2_SPEC;
        impl crate::RegisterSpec for IPRIOR2_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior2::R](R) reader structure
        impl crate::Readable for IPRIOR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior2::W](W) writer structure
        impl crate::Writable for IPRIOR2_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR2 to value 0
        impl crate::Resettable for IPRIOR2_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR3 (rw) register accessor: an alias for `Reg<IPRIOR3_SPEC>`
    pub type IPRIOR3 = crate::Reg<iprior3::IPRIOR3_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior3 {
        ///Register `IPRIOR3` reader
        pub struct R(crate::R<IPRIOR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR3_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR3` writer
        pub struct W(crate::W<IPRIOR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR3_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR3_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior3](index.html) module
        pub struct IPRIOR3_SPEC;
        impl crate::RegisterSpec for IPRIOR3_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior3::R](R) reader structure
        impl crate::Readable for IPRIOR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior3::W](W) writer structure
        impl crate::Writable for IPRIOR3_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR3 to value 0
        impl crate::Resettable for IPRIOR3_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR4 (rw) register accessor: an alias for `Reg<IPRIOR4_SPEC>`
    pub type IPRIOR4 = crate::Reg<iprior4::IPRIOR4_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior4 {
        ///Register `IPRIOR4` reader
        pub struct R(crate::R<IPRIOR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR4_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR4` writer
        pub struct W(crate::W<IPRIOR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR4_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR4_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior4](index.html) module
        pub struct IPRIOR4_SPEC;
        impl crate::RegisterSpec for IPRIOR4_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior4::R](R) reader structure
        impl crate::Readable for IPRIOR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior4::W](W) writer structure
        impl crate::Writable for IPRIOR4_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR4 to value 0
        impl crate::Resettable for IPRIOR4_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR5 (rw) register accessor: an alias for `Reg<IPRIOR5_SPEC>`
    pub type IPRIOR5 = crate::Reg<iprior5::IPRIOR5_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior5 {
        ///Register `IPRIOR5` reader
        pub struct R(crate::R<IPRIOR5_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR5_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR5_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR5` writer
        pub struct W(crate::W<IPRIOR5_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR5_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR5_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR5_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior5](index.html) module
        pub struct IPRIOR5_SPEC;
        impl crate::RegisterSpec for IPRIOR5_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior5::R](R) reader structure
        impl crate::Readable for IPRIOR5_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior5::W](W) writer structure
        impl crate::Writable for IPRIOR5_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR5 to value 0
        impl crate::Resettable for IPRIOR5_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR6 (rw) register accessor: an alias for `Reg<IPRIOR6_SPEC>`
    pub type IPRIOR6 = crate::Reg<iprior6::IPRIOR6_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior6 {
        ///Register `IPRIOR6` reader
        pub struct R(crate::R<IPRIOR6_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR6_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR6_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR6` writer
        pub struct W(crate::W<IPRIOR6_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR6_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR6_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR6_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior6](index.html) module
        pub struct IPRIOR6_SPEC;
        impl crate::RegisterSpec for IPRIOR6_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior6::R](R) reader structure
        impl crate::Readable for IPRIOR6_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior6::W](W) writer structure
        impl crate::Writable for IPRIOR6_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR6 to value 0
        impl crate::Resettable for IPRIOR6_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR7 (rw) register accessor: an alias for `Reg<IPRIOR7_SPEC>`
    pub type IPRIOR7 = crate::Reg<iprior7::IPRIOR7_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior7 {
        ///Register `IPRIOR7` reader
        pub struct R(crate::R<IPRIOR7_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR7_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR7_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR7` writer
        pub struct W(crate::W<IPRIOR7_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR7_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR7_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR7_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior7](index.html) module
        pub struct IPRIOR7_SPEC;
        impl crate::RegisterSpec for IPRIOR7_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior7::R](R) reader structure
        impl crate::Readable for IPRIOR7_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior7::W](W) writer structure
        impl crate::Writable for IPRIOR7_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR7 to value 0
        impl crate::Resettable for IPRIOR7_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR8 (rw) register accessor: an alias for `Reg<IPRIOR8_SPEC>`
    pub type IPRIOR8 = crate::Reg<iprior8::IPRIOR8_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior8 {
        ///Register `IPRIOR8` reader
        pub struct R(crate::R<IPRIOR8_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR8_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR8_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR8` writer
        pub struct W(crate::W<IPRIOR8_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR8_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR8_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR8_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior8](index.html) module
        pub struct IPRIOR8_SPEC;
        impl crate::RegisterSpec for IPRIOR8_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior8::R](R) reader structure
        impl crate::Readable for IPRIOR8_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior8::W](W) writer structure
        impl crate::Writable for IPRIOR8_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR8 to value 0
        impl crate::Resettable for IPRIOR8_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR9 (rw) register accessor: an alias for `Reg<IPRIOR9_SPEC>`
    pub type IPRIOR9 = crate::Reg<iprior9::IPRIOR9_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior9 {
        ///Register `IPRIOR9` reader
        pub struct R(crate::R<IPRIOR9_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR9_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR9_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR9` writer
        pub struct W(crate::W<IPRIOR9_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR9_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR9_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR9_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior9](index.html) module
        pub struct IPRIOR9_SPEC;
        impl crate::RegisterSpec for IPRIOR9_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior9::R](R) reader structure
        impl crate::Readable for IPRIOR9_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior9::W](W) writer structure
        impl crate::Writable for IPRIOR9_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR9 to value 0
        impl crate::Resettable for IPRIOR9_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR10 (rw) register accessor: an alias for `Reg<IPRIOR10_SPEC>`
    pub type IPRIOR10 = crate::Reg<iprior10::IPRIOR10_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior10 {
        ///Register `IPRIOR10` reader
        pub struct R(crate::R<IPRIOR10_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR10_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR10_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR10` writer
        pub struct W(crate::W<IPRIOR10_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR10_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR10_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR10_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior10](index.html) module
        pub struct IPRIOR10_SPEC;
        impl crate::RegisterSpec for IPRIOR10_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior10::R](R) reader structure
        impl crate::Readable for IPRIOR10_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior10::W](W) writer structure
        impl crate::Writable for IPRIOR10_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR10 to value 0
        impl crate::Resettable for IPRIOR10_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR11 (rw) register accessor: an alias for `Reg<IPRIOR11_SPEC>`
    pub type IPRIOR11 = crate::Reg<iprior11::IPRIOR11_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior11 {
        ///Register `IPRIOR11` reader
        pub struct R(crate::R<IPRIOR11_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR11_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR11_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR11` writer
        pub struct W(crate::W<IPRIOR11_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR11_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR11_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR11_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior11](index.html) module
        pub struct IPRIOR11_SPEC;
        impl crate::RegisterSpec for IPRIOR11_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior11::R](R) reader structure
        impl crate::Readable for IPRIOR11_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior11::W](W) writer structure
        impl crate::Writable for IPRIOR11_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR11 to value 0
        impl crate::Resettable for IPRIOR11_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR12 (rw) register accessor: an alias for `Reg<IPRIOR12_SPEC>`
    pub type IPRIOR12 = crate::Reg<iprior12::IPRIOR12_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior12 {
        ///Register `IPRIOR12` reader
        pub struct R(crate::R<IPRIOR12_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR12_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR12_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR12` writer
        pub struct W(crate::W<IPRIOR12_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR12_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR12_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR12_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior12](index.html) module
        pub struct IPRIOR12_SPEC;
        impl crate::RegisterSpec for IPRIOR12_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior12::R](R) reader structure
        impl crate::Readable for IPRIOR12_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior12::W](W) writer structure
        impl crate::Writable for IPRIOR12_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR12 to value 0
        impl crate::Resettable for IPRIOR12_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR13 (rw) register accessor: an alias for `Reg<IPRIOR13_SPEC>`
    pub type IPRIOR13 = crate::Reg<iprior13::IPRIOR13_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior13 {
        ///Register `IPRIOR13` reader
        pub struct R(crate::R<IPRIOR13_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR13_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR13_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR13` writer
        pub struct W(crate::W<IPRIOR13_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR13_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR13_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR13_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior13](index.html) module
        pub struct IPRIOR13_SPEC;
        impl crate::RegisterSpec for IPRIOR13_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior13::R](R) reader structure
        impl crate::Readable for IPRIOR13_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior13::W](W) writer structure
        impl crate::Writable for IPRIOR13_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR13 to value 0
        impl crate::Resettable for IPRIOR13_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR14 (rw) register accessor: an alias for `Reg<IPRIOR14_SPEC>`
    pub type IPRIOR14 = crate::Reg<iprior14::IPRIOR14_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior14 {
        ///Register `IPRIOR14` reader
        pub struct R(crate::R<IPRIOR14_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR14_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR14_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR14` writer
        pub struct W(crate::W<IPRIOR14_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR14_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR14_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR14_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior14](index.html) module
        pub struct IPRIOR14_SPEC;
        impl crate::RegisterSpec for IPRIOR14_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior14::R](R) reader structure
        impl crate::Readable for IPRIOR14_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior14::W](W) writer structure
        impl crate::Writable for IPRIOR14_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR14 to value 0
        impl crate::Resettable for IPRIOR14_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR15 (rw) register accessor: an alias for `Reg<IPRIOR15_SPEC>`
    pub type IPRIOR15 = crate::Reg<iprior15::IPRIOR15_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior15 {
        ///Register `IPRIOR15` reader
        pub struct R(crate::R<IPRIOR15_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR15_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR15_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR15` writer
        pub struct W(crate::W<IPRIOR15_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR15_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR15_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR15_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior15](index.html) module
        pub struct IPRIOR15_SPEC;
        impl crate::RegisterSpec for IPRIOR15_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior15::R](R) reader structure
        impl crate::Readable for IPRIOR15_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior15::W](W) writer structure
        impl crate::Writable for IPRIOR15_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR15 to value 0
        impl crate::Resettable for IPRIOR15_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR16 (rw) register accessor: an alias for `Reg<IPRIOR16_SPEC>`
    pub type IPRIOR16 = crate::Reg<iprior16::IPRIOR16_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior16 {
        ///Register `IPRIOR16` reader
        pub struct R(crate::R<IPRIOR16_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR16_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR16_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR16` writer
        pub struct W(crate::W<IPRIOR16_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR16_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR16_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR16_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior16](index.html) module
        pub struct IPRIOR16_SPEC;
        impl crate::RegisterSpec for IPRIOR16_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior16::R](R) reader structure
        impl crate::Readable for IPRIOR16_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior16::W](W) writer structure
        impl crate::Writable for IPRIOR16_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR16 to value 0
        impl crate::Resettable for IPRIOR16_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR17 (rw) register accessor: an alias for `Reg<IPRIOR17_SPEC>`
    pub type IPRIOR17 = crate::Reg<iprior17::IPRIOR17_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior17 {
        ///Register `IPRIOR17` reader
        pub struct R(crate::R<IPRIOR17_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR17_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR17_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR17` writer
        pub struct W(crate::W<IPRIOR17_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR17_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR17_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR17_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior17](index.html) module
        pub struct IPRIOR17_SPEC;
        impl crate::RegisterSpec for IPRIOR17_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior17::R](R) reader structure
        impl crate::Readable for IPRIOR17_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior17::W](W) writer structure
        impl crate::Writable for IPRIOR17_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR17 to value 0
        impl crate::Resettable for IPRIOR17_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR18 (rw) register accessor: an alias for `Reg<IPRIOR18_SPEC>`
    pub type IPRIOR18 = crate::Reg<iprior18::IPRIOR18_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior18 {
        ///Register `IPRIOR18` reader
        pub struct R(crate::R<IPRIOR18_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR18_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR18_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR18` writer
        pub struct W(crate::W<IPRIOR18_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR18_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR18_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR18_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior18](index.html) module
        pub struct IPRIOR18_SPEC;
        impl crate::RegisterSpec for IPRIOR18_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior18::R](R) reader structure
        impl crate::Readable for IPRIOR18_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior18::W](W) writer structure
        impl crate::Writable for IPRIOR18_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR18 to value 0
        impl crate::Resettable for IPRIOR18_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR19 (rw) register accessor: an alias for `Reg<IPRIOR19_SPEC>`
    pub type IPRIOR19 = crate::Reg<iprior19::IPRIOR19_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior19 {
        ///Register `IPRIOR19` reader
        pub struct R(crate::R<IPRIOR19_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR19_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR19_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR19` writer
        pub struct W(crate::W<IPRIOR19_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR19_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR19_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR19_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior19](index.html) module
        pub struct IPRIOR19_SPEC;
        impl crate::RegisterSpec for IPRIOR19_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior19::R](R) reader structure
        impl crate::Readable for IPRIOR19_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior19::W](W) writer structure
        impl crate::Writable for IPRIOR19_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR19 to value 0
        impl crate::Resettable for IPRIOR19_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR20 (rw) register accessor: an alias for `Reg<IPRIOR20_SPEC>`
    pub type IPRIOR20 = crate::Reg<iprior20::IPRIOR20_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior20 {
        ///Register `IPRIOR20` reader
        pub struct R(crate::R<IPRIOR20_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR20_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR20_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR20` writer
        pub struct W(crate::W<IPRIOR20_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR20_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR20_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR20_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior20](index.html) module
        pub struct IPRIOR20_SPEC;
        impl crate::RegisterSpec for IPRIOR20_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior20::R](R) reader structure
        impl crate::Readable for IPRIOR20_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior20::W](W) writer structure
        impl crate::Writable for IPRIOR20_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR20 to value 0
        impl crate::Resettable for IPRIOR20_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR21 (rw) register accessor: an alias for `Reg<IPRIOR21_SPEC>`
    pub type IPRIOR21 = crate::Reg<iprior21::IPRIOR21_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior21 {
        ///Register `IPRIOR21` reader
        pub struct R(crate::R<IPRIOR21_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR21_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR21_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR21` writer
        pub struct W(crate::W<IPRIOR21_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR21_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR21_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR21_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior21](index.html) module
        pub struct IPRIOR21_SPEC;
        impl crate::RegisterSpec for IPRIOR21_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior21::R](R) reader structure
        impl crate::Readable for IPRIOR21_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior21::W](W) writer structure
        impl crate::Writable for IPRIOR21_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR21 to value 0
        impl crate::Resettable for IPRIOR21_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR22 (rw) register accessor: an alias for `Reg<IPRIOR22_SPEC>`
    pub type IPRIOR22 = crate::Reg<iprior22::IPRIOR22_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior22 {
        ///Register `IPRIOR22` reader
        pub struct R(crate::R<IPRIOR22_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR22_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR22_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR22` writer
        pub struct W(crate::W<IPRIOR22_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR22_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR22_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR22_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior22](index.html) module
        pub struct IPRIOR22_SPEC;
        impl crate::RegisterSpec for IPRIOR22_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior22::R](R) reader structure
        impl crate::Readable for IPRIOR22_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior22::W](W) writer structure
        impl crate::Writable for IPRIOR22_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR22 to value 0
        impl crate::Resettable for IPRIOR22_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR23 (rw) register accessor: an alias for `Reg<IPRIOR23_SPEC>`
    pub type IPRIOR23 = crate::Reg<iprior23::IPRIOR23_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior23 {
        ///Register `IPRIOR23` reader
        pub struct R(crate::R<IPRIOR23_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR23_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR23_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR23` writer
        pub struct W(crate::W<IPRIOR23_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR23_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR23_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR23_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior23](index.html) module
        pub struct IPRIOR23_SPEC;
        impl crate::RegisterSpec for IPRIOR23_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior23::R](R) reader structure
        impl crate::Readable for IPRIOR23_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior23::W](W) writer structure
        impl crate::Writable for IPRIOR23_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR23 to value 0
        impl crate::Resettable for IPRIOR23_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR24 (rw) register accessor: an alias for `Reg<IPRIOR24_SPEC>`
    pub type IPRIOR24 = crate::Reg<iprior24::IPRIOR24_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior24 {
        ///Register `IPRIOR24` reader
        pub struct R(crate::R<IPRIOR24_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR24_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR24_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR24` writer
        pub struct W(crate::W<IPRIOR24_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR24_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR24_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR24_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior24](index.html) module
        pub struct IPRIOR24_SPEC;
        impl crate::RegisterSpec for IPRIOR24_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior24::R](R) reader structure
        impl crate::Readable for IPRIOR24_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior24::W](W) writer structure
        impl crate::Writable for IPRIOR24_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR24 to value 0
        impl crate::Resettable for IPRIOR24_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR25 (rw) register accessor: an alias for `Reg<IPRIOR25_SPEC>`
    pub type IPRIOR25 = crate::Reg<iprior25::IPRIOR25_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior25 {
        ///Register `IPRIOR25` reader
        pub struct R(crate::R<IPRIOR25_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR25_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR25_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR25` writer
        pub struct W(crate::W<IPRIOR25_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR25_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR25_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR25_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior25](index.html) module
        pub struct IPRIOR25_SPEC;
        impl crate::RegisterSpec for IPRIOR25_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior25::R](R) reader structure
        impl crate::Readable for IPRIOR25_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior25::W](W) writer structure
        impl crate::Writable for IPRIOR25_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR25 to value 0
        impl crate::Resettable for IPRIOR25_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR26 (rw) register accessor: an alias for `Reg<IPRIOR26_SPEC>`
    pub type IPRIOR26 = crate::Reg<iprior26::IPRIOR26_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior26 {
        ///Register `IPRIOR26` reader
        pub struct R(crate::R<IPRIOR26_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR26_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR26_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR26` writer
        pub struct W(crate::W<IPRIOR26_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR26_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR26_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR26_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior26](index.html) module
        pub struct IPRIOR26_SPEC;
        impl crate::RegisterSpec for IPRIOR26_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior26::R](R) reader structure
        impl crate::Readable for IPRIOR26_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior26::W](W) writer structure
        impl crate::Writable for IPRIOR26_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR26 to value 0
        impl crate::Resettable for IPRIOR26_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR27 (rw) register accessor: an alias for `Reg<IPRIOR27_SPEC>`
    pub type IPRIOR27 = crate::Reg<iprior27::IPRIOR27_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior27 {
        ///Register `IPRIOR27` reader
        pub struct R(crate::R<IPRIOR27_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR27_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR27_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR27` writer
        pub struct W(crate::W<IPRIOR27_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR27_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR27_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR27_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior27](index.html) module
        pub struct IPRIOR27_SPEC;
        impl crate::RegisterSpec for IPRIOR27_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior27::R](R) reader structure
        impl crate::Readable for IPRIOR27_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior27::W](W) writer structure
        impl crate::Writable for IPRIOR27_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR27 to value 0
        impl crate::Resettable for IPRIOR27_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR28 (rw) register accessor: an alias for `Reg<IPRIOR28_SPEC>`
    pub type IPRIOR28 = crate::Reg<iprior28::IPRIOR28_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior28 {
        ///Register `IPRIOR28` reader
        pub struct R(crate::R<IPRIOR28_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR28_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR28_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR28` writer
        pub struct W(crate::W<IPRIOR28_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR28_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR28_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR28_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior28](index.html) module
        pub struct IPRIOR28_SPEC;
        impl crate::RegisterSpec for IPRIOR28_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior28::R](R) reader structure
        impl crate::Readable for IPRIOR28_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior28::W](W) writer structure
        impl crate::Writable for IPRIOR28_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR28 to value 0
        impl crate::Resettable for IPRIOR28_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR29 (rw) register accessor: an alias for `Reg<IPRIOR29_SPEC>`
    pub type IPRIOR29 = crate::Reg<iprior29::IPRIOR29_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior29 {
        ///Register `IPRIOR29` reader
        pub struct R(crate::R<IPRIOR29_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR29_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR29_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR29` writer
        pub struct W(crate::W<IPRIOR29_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR29_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR29_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR29_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior29](index.html) module
        pub struct IPRIOR29_SPEC;
        impl crate::RegisterSpec for IPRIOR29_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior29::R](R) reader structure
        impl crate::Readable for IPRIOR29_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior29::W](W) writer structure
        impl crate::Writable for IPRIOR29_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR29 to value 0
        impl crate::Resettable for IPRIOR29_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR30 (rw) register accessor: an alias for `Reg<IPRIOR30_SPEC>`
    pub type IPRIOR30 = crate::Reg<iprior30::IPRIOR30_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior30 {
        ///Register `IPRIOR30` reader
        pub struct R(crate::R<IPRIOR30_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR30_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR30_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR30` writer
        pub struct W(crate::W<IPRIOR30_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR30_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR30_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR30_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior30](index.html) module
        pub struct IPRIOR30_SPEC;
        impl crate::RegisterSpec for IPRIOR30_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior30::R](R) reader structure
        impl crate::Readable for IPRIOR30_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior30::W](W) writer structure
        impl crate::Writable for IPRIOR30_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR30 to value 0
        impl crate::Resettable for IPRIOR30_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR31 (rw) register accessor: an alias for `Reg<IPRIOR31_SPEC>`
    pub type IPRIOR31 = crate::Reg<iprior31::IPRIOR31_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior31 {
        ///Register `IPRIOR31` reader
        pub struct R(crate::R<IPRIOR31_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR31_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR31_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR31` writer
        pub struct W(crate::W<IPRIOR31_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR31_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR31_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR31_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior31](index.html) module
        pub struct IPRIOR31_SPEC;
        impl crate::RegisterSpec for IPRIOR31_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior31::R](R) reader structure
        impl crate::Readable for IPRIOR31_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior31::W](W) writer structure
        impl crate::Writable for IPRIOR31_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR31 to value 0
        impl crate::Resettable for IPRIOR31_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR32 (rw) register accessor: an alias for `Reg<IPRIOR32_SPEC>`
    pub type IPRIOR32 = crate::Reg<iprior32::IPRIOR32_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior32 {
        ///Register `IPRIOR32` reader
        pub struct R(crate::R<IPRIOR32_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR32_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR32_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR32` writer
        pub struct W(crate::W<IPRIOR32_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR32_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR32_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR32_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior32](index.html) module
        pub struct IPRIOR32_SPEC;
        impl crate::RegisterSpec for IPRIOR32_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior32::R](R) reader structure
        impl crate::Readable for IPRIOR32_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior32::W](W) writer structure
        impl crate::Writable for IPRIOR32_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR32 to value 0
        impl crate::Resettable for IPRIOR32_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR33 (rw) register accessor: an alias for `Reg<IPRIOR33_SPEC>`
    pub type IPRIOR33 = crate::Reg<iprior33::IPRIOR33_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior33 {
        ///Register `IPRIOR33` reader
        pub struct R(crate::R<IPRIOR33_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR33_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR33_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR33` writer
        pub struct W(crate::W<IPRIOR33_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR33_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR33_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR33_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior33](index.html) module
        pub struct IPRIOR33_SPEC;
        impl crate::RegisterSpec for IPRIOR33_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior33::R](R) reader structure
        impl crate::Readable for IPRIOR33_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior33::W](W) writer structure
        impl crate::Writable for IPRIOR33_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR33 to value 0
        impl crate::Resettable for IPRIOR33_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR34 (rw) register accessor: an alias for `Reg<IPRIOR34_SPEC>`
    pub type IPRIOR34 = crate::Reg<iprior34::IPRIOR34_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior34 {
        ///Register `IPRIOR34` reader
        pub struct R(crate::R<IPRIOR34_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR34_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR34_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR34` writer
        pub struct W(crate::W<IPRIOR34_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR34_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR34_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR34_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior34](index.html) module
        pub struct IPRIOR34_SPEC;
        impl crate::RegisterSpec for IPRIOR34_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior34::R](R) reader structure
        impl crate::Readable for IPRIOR34_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior34::W](W) writer structure
        impl crate::Writable for IPRIOR34_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR34 to value 0
        impl crate::Resettable for IPRIOR34_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR35 (rw) register accessor: an alias for `Reg<IPRIOR35_SPEC>`
    pub type IPRIOR35 = crate::Reg<iprior35::IPRIOR35_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior35 {
        ///Register `IPRIOR35` reader
        pub struct R(crate::R<IPRIOR35_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR35_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR35_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR35` writer
        pub struct W(crate::W<IPRIOR35_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR35_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR35_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR35_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior35](index.html) module
        pub struct IPRIOR35_SPEC;
        impl crate::RegisterSpec for IPRIOR35_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior35::R](R) reader structure
        impl crate::Readable for IPRIOR35_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior35::W](W) writer structure
        impl crate::Writable for IPRIOR35_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR35 to value 0
        impl crate::Resettable for IPRIOR35_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR36 (rw) register accessor: an alias for `Reg<IPRIOR36_SPEC>`
    pub type IPRIOR36 = crate::Reg<iprior36::IPRIOR36_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior36 {
        ///Register `IPRIOR36` reader
        pub struct R(crate::R<IPRIOR36_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR36_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR36_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR36` writer
        pub struct W(crate::W<IPRIOR36_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR36_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR36_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR36_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior36](index.html) module
        pub struct IPRIOR36_SPEC;
        impl crate::RegisterSpec for IPRIOR36_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior36::R](R) reader structure
        impl crate::Readable for IPRIOR36_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior36::W](W) writer structure
        impl crate::Writable for IPRIOR36_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR36 to value 0
        impl crate::Resettable for IPRIOR36_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR37 (rw) register accessor: an alias for `Reg<IPRIOR37_SPEC>`
    pub type IPRIOR37 = crate::Reg<iprior37::IPRIOR37_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior37 {
        ///Register `IPRIOR37` reader
        pub struct R(crate::R<IPRIOR37_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR37_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR37_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR37` writer
        pub struct W(crate::W<IPRIOR37_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR37_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR37_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR37_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior37](index.html) module
        pub struct IPRIOR37_SPEC;
        impl crate::RegisterSpec for IPRIOR37_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior37::R](R) reader structure
        impl crate::Readable for IPRIOR37_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior37::W](W) writer structure
        impl crate::Writable for IPRIOR37_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR37 to value 0
        impl crate::Resettable for IPRIOR37_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR38 (rw) register accessor: an alias for `Reg<IPRIOR38_SPEC>`
    pub type IPRIOR38 = crate::Reg<iprior38::IPRIOR38_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior38 {
        ///Register `IPRIOR38` reader
        pub struct R(crate::R<IPRIOR38_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR38_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR38_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR38` writer
        pub struct W(crate::W<IPRIOR38_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR38_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR38_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR38_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior38](index.html) module
        pub struct IPRIOR38_SPEC;
        impl crate::RegisterSpec for IPRIOR38_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior38::R](R) reader structure
        impl crate::Readable for IPRIOR38_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior38::W](W) writer structure
        impl crate::Writable for IPRIOR38_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR38 to value 0
        impl crate::Resettable for IPRIOR38_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR39 (rw) register accessor: an alias for `Reg<IPRIOR39_SPEC>`
    pub type IPRIOR39 = crate::Reg<iprior39::IPRIOR39_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior39 {
        ///Register `IPRIOR39` reader
        pub struct R(crate::R<IPRIOR39_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR39_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR39_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR39` writer
        pub struct W(crate::W<IPRIOR39_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR39_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR39_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR39_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior39](index.html) module
        pub struct IPRIOR39_SPEC;
        impl crate::RegisterSpec for IPRIOR39_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior39::R](R) reader structure
        impl crate::Readable for IPRIOR39_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior39::W](W) writer structure
        impl crate::Writable for IPRIOR39_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR39 to value 0
        impl crate::Resettable for IPRIOR39_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR40 (rw) register accessor: an alias for `Reg<IPRIOR40_SPEC>`
    pub type IPRIOR40 = crate::Reg<iprior40::IPRIOR40_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior40 {
        ///Register `IPRIOR40` reader
        pub struct R(crate::R<IPRIOR40_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR40_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR40_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR40` writer
        pub struct W(crate::W<IPRIOR40_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR40_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR40_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR40_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior40](index.html) module
        pub struct IPRIOR40_SPEC;
        impl crate::RegisterSpec for IPRIOR40_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior40::R](R) reader structure
        impl crate::Readable for IPRIOR40_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior40::W](W) writer structure
        impl crate::Writable for IPRIOR40_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR40 to value 0
        impl crate::Resettable for IPRIOR40_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR41 (rw) register accessor: an alias for `Reg<IPRIOR41_SPEC>`
    pub type IPRIOR41 = crate::Reg<iprior41::IPRIOR41_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior41 {
        ///Register `IPRIOR41` reader
        pub struct R(crate::R<IPRIOR41_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR41_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR41_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR41` writer
        pub struct W(crate::W<IPRIOR41_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR41_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR41_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR41_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior41](index.html) module
        pub struct IPRIOR41_SPEC;
        impl crate::RegisterSpec for IPRIOR41_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior41::R](R) reader structure
        impl crate::Readable for IPRIOR41_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior41::W](W) writer structure
        impl crate::Writable for IPRIOR41_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR41 to value 0
        impl crate::Resettable for IPRIOR41_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR42 (rw) register accessor: an alias for `Reg<IPRIOR42_SPEC>`
    pub type IPRIOR42 = crate::Reg<iprior42::IPRIOR42_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior42 {
        ///Register `IPRIOR42` reader
        pub struct R(crate::R<IPRIOR42_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR42_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR42_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR42` writer
        pub struct W(crate::W<IPRIOR42_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR42_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR42_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR42_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior42](index.html) module
        pub struct IPRIOR42_SPEC;
        impl crate::RegisterSpec for IPRIOR42_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior42::R](R) reader structure
        impl crate::Readable for IPRIOR42_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior42::W](W) writer structure
        impl crate::Writable for IPRIOR42_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR42 to value 0
        impl crate::Resettable for IPRIOR42_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR43 (rw) register accessor: an alias for `Reg<IPRIOR43_SPEC>`
    pub type IPRIOR43 = crate::Reg<iprior43::IPRIOR43_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior43 {
        ///Register `IPRIOR43` reader
        pub struct R(crate::R<IPRIOR43_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR43_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR43_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR43` writer
        pub struct W(crate::W<IPRIOR43_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR43_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR43_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR43_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior43](index.html) module
        pub struct IPRIOR43_SPEC;
        impl crate::RegisterSpec for IPRIOR43_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior43::R](R) reader structure
        impl crate::Readable for IPRIOR43_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior43::W](W) writer structure
        impl crate::Writable for IPRIOR43_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR43 to value 0
        impl crate::Resettable for IPRIOR43_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR44 (rw) register accessor: an alias for `Reg<IPRIOR44_SPEC>`
    pub type IPRIOR44 = crate::Reg<iprior44::IPRIOR44_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior44 {
        ///Register `IPRIOR44` reader
        pub struct R(crate::R<IPRIOR44_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR44_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR44_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR44` writer
        pub struct W(crate::W<IPRIOR44_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR44_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR44_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR44_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior44](index.html) module
        pub struct IPRIOR44_SPEC;
        impl crate::RegisterSpec for IPRIOR44_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior44::R](R) reader structure
        impl crate::Readable for IPRIOR44_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior44::W](W) writer structure
        impl crate::Writable for IPRIOR44_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR44 to value 0
        impl crate::Resettable for IPRIOR44_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR45 (rw) register accessor: an alias for `Reg<IPRIOR45_SPEC>`
    pub type IPRIOR45 = crate::Reg<iprior45::IPRIOR45_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior45 {
        ///Register `IPRIOR45` reader
        pub struct R(crate::R<IPRIOR45_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR45_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR45_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR45` writer
        pub struct W(crate::W<IPRIOR45_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR45_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR45_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR45_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior45](index.html) module
        pub struct IPRIOR45_SPEC;
        impl crate::RegisterSpec for IPRIOR45_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior45::R](R) reader structure
        impl crate::Readable for IPRIOR45_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior45::W](W) writer structure
        impl crate::Writable for IPRIOR45_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR45 to value 0
        impl crate::Resettable for IPRIOR45_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR46 (rw) register accessor: an alias for `Reg<IPRIOR46_SPEC>`
    pub type IPRIOR46 = crate::Reg<iprior46::IPRIOR46_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior46 {
        ///Register `IPRIOR46` reader
        pub struct R(crate::R<IPRIOR46_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR46_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR46_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR46` writer
        pub struct W(crate::W<IPRIOR46_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR46_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR46_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR46_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior46](index.html) module
        pub struct IPRIOR46_SPEC;
        impl crate::RegisterSpec for IPRIOR46_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior46::R](R) reader structure
        impl crate::Readable for IPRIOR46_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior46::W](W) writer structure
        impl crate::Writable for IPRIOR46_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR46 to value 0
        impl crate::Resettable for IPRIOR46_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR47 (rw) register accessor: an alias for `Reg<IPRIOR47_SPEC>`
    pub type IPRIOR47 = crate::Reg<iprior47::IPRIOR47_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior47 {
        ///Register `IPRIOR47` reader
        pub struct R(crate::R<IPRIOR47_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR47_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR47_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR47` writer
        pub struct W(crate::W<IPRIOR47_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR47_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR47_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR47_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior47](index.html) module
        pub struct IPRIOR47_SPEC;
        impl crate::RegisterSpec for IPRIOR47_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior47::R](R) reader structure
        impl crate::Readable for IPRIOR47_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior47::W](W) writer structure
        impl crate::Writable for IPRIOR47_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR47 to value 0
        impl crate::Resettable for IPRIOR47_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR48 (rw) register accessor: an alias for `Reg<IPRIOR48_SPEC>`
    pub type IPRIOR48 = crate::Reg<iprior48::IPRIOR48_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior48 {
        ///Register `IPRIOR48` reader
        pub struct R(crate::R<IPRIOR48_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR48_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR48_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR48` writer
        pub struct W(crate::W<IPRIOR48_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR48_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR48_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR48_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior48](index.html) module
        pub struct IPRIOR48_SPEC;
        impl crate::RegisterSpec for IPRIOR48_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior48::R](R) reader structure
        impl crate::Readable for IPRIOR48_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior48::W](W) writer structure
        impl crate::Writable for IPRIOR48_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR48 to value 0
        impl crate::Resettable for IPRIOR48_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR49 (rw) register accessor: an alias for `Reg<IPRIOR49_SPEC>`
    pub type IPRIOR49 = crate::Reg<iprior49::IPRIOR49_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior49 {
        ///Register `IPRIOR49` reader
        pub struct R(crate::R<IPRIOR49_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR49_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR49_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR49` writer
        pub struct W(crate::W<IPRIOR49_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR49_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR49_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR49_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior49](index.html) module
        pub struct IPRIOR49_SPEC;
        impl crate::RegisterSpec for IPRIOR49_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior49::R](R) reader structure
        impl crate::Readable for IPRIOR49_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior49::W](W) writer structure
        impl crate::Writable for IPRIOR49_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR49 to value 0
        impl crate::Resettable for IPRIOR49_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR50 (rw) register accessor: an alias for `Reg<IPRIOR50_SPEC>`
    pub type IPRIOR50 = crate::Reg<iprior50::IPRIOR50_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior50 {
        ///Register `IPRIOR50` reader
        pub struct R(crate::R<IPRIOR50_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR50_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR50_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR50` writer
        pub struct W(crate::W<IPRIOR50_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR50_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR50_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR50_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior50](index.html) module
        pub struct IPRIOR50_SPEC;
        impl crate::RegisterSpec for IPRIOR50_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior50::R](R) reader structure
        impl crate::Readable for IPRIOR50_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior50::W](W) writer structure
        impl crate::Writable for IPRIOR50_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR50 to value 0
        impl crate::Resettable for IPRIOR50_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR51 (rw) register accessor: an alias for `Reg<IPRIOR51_SPEC>`
    pub type IPRIOR51 = crate::Reg<iprior51::IPRIOR51_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior51 {
        ///Register `IPRIOR51` reader
        pub struct R(crate::R<IPRIOR51_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR51_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR51_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR51` writer
        pub struct W(crate::W<IPRIOR51_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR51_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR51_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR51_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior51](index.html) module
        pub struct IPRIOR51_SPEC;
        impl crate::RegisterSpec for IPRIOR51_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior51::R](R) reader structure
        impl crate::Readable for IPRIOR51_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior51::W](W) writer structure
        impl crate::Writable for IPRIOR51_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR51 to value 0
        impl crate::Resettable for IPRIOR51_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR52 (rw) register accessor: an alias for `Reg<IPRIOR52_SPEC>`
    pub type IPRIOR52 = crate::Reg<iprior52::IPRIOR52_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior52 {
        ///Register `IPRIOR52` reader
        pub struct R(crate::R<IPRIOR52_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR52_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR52_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR52` writer
        pub struct W(crate::W<IPRIOR52_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR52_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR52_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR52_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior52](index.html) module
        pub struct IPRIOR52_SPEC;
        impl crate::RegisterSpec for IPRIOR52_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior52::R](R) reader structure
        impl crate::Readable for IPRIOR52_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior52::W](W) writer structure
        impl crate::Writable for IPRIOR52_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR52 to value 0
        impl crate::Resettable for IPRIOR52_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR53 (rw) register accessor: an alias for `Reg<IPRIOR53_SPEC>`
    pub type IPRIOR53 = crate::Reg<iprior53::IPRIOR53_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior53 {
        ///Register `IPRIOR53` reader
        pub struct R(crate::R<IPRIOR53_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR53_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR53_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR53` writer
        pub struct W(crate::W<IPRIOR53_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR53_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR53_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR53_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior53](index.html) module
        pub struct IPRIOR53_SPEC;
        impl crate::RegisterSpec for IPRIOR53_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior53::R](R) reader structure
        impl crate::Readable for IPRIOR53_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior53::W](W) writer structure
        impl crate::Writable for IPRIOR53_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR53 to value 0
        impl crate::Resettable for IPRIOR53_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR54 (rw) register accessor: an alias for `Reg<IPRIOR54_SPEC>`
    pub type IPRIOR54 = crate::Reg<iprior54::IPRIOR54_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior54 {
        ///Register `IPRIOR54` reader
        pub struct R(crate::R<IPRIOR54_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR54_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR54_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR54` writer
        pub struct W(crate::W<IPRIOR54_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR54_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR54_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR54_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior54](index.html) module
        pub struct IPRIOR54_SPEC;
        impl crate::RegisterSpec for IPRIOR54_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior54::R](R) reader structure
        impl crate::Readable for IPRIOR54_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior54::W](W) writer structure
        impl crate::Writable for IPRIOR54_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR54 to value 0
        impl crate::Resettable for IPRIOR54_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR55 (rw) register accessor: an alias for `Reg<IPRIOR55_SPEC>`
    pub type IPRIOR55 = crate::Reg<iprior55::IPRIOR55_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior55 {
        ///Register `IPRIOR55` reader
        pub struct R(crate::R<IPRIOR55_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR55_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR55_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR55` writer
        pub struct W(crate::W<IPRIOR55_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR55_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR55_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR55_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior55](index.html) module
        pub struct IPRIOR55_SPEC;
        impl crate::RegisterSpec for IPRIOR55_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior55::R](R) reader structure
        impl crate::Readable for IPRIOR55_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior55::W](W) writer structure
        impl crate::Writable for IPRIOR55_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR55 to value 0
        impl crate::Resettable for IPRIOR55_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR56 (rw) register accessor: an alias for `Reg<IPRIOR56_SPEC>`
    pub type IPRIOR56 = crate::Reg<iprior56::IPRIOR56_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior56 {
        ///Register `IPRIOR56` reader
        pub struct R(crate::R<IPRIOR56_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR56_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR56_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR56` writer
        pub struct W(crate::W<IPRIOR56_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR56_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR56_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR56_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior56](index.html) module
        pub struct IPRIOR56_SPEC;
        impl crate::RegisterSpec for IPRIOR56_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior56::R](R) reader structure
        impl crate::Readable for IPRIOR56_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior56::W](W) writer structure
        impl crate::Writable for IPRIOR56_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR56 to value 0
        impl crate::Resettable for IPRIOR56_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR57 (rw) register accessor: an alias for `Reg<IPRIOR57_SPEC>`
    pub type IPRIOR57 = crate::Reg<iprior57::IPRIOR57_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior57 {
        ///Register `IPRIOR57` reader
        pub struct R(crate::R<IPRIOR57_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR57_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR57_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR57` writer
        pub struct W(crate::W<IPRIOR57_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR57_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR57_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR57_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior57](index.html) module
        pub struct IPRIOR57_SPEC;
        impl crate::RegisterSpec for IPRIOR57_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior57::R](R) reader structure
        impl crate::Readable for IPRIOR57_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior57::W](W) writer structure
        impl crate::Writable for IPRIOR57_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR57 to value 0
        impl crate::Resettable for IPRIOR57_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR58 (rw) register accessor: an alias for `Reg<IPRIOR58_SPEC>`
    pub type IPRIOR58 = crate::Reg<iprior58::IPRIOR58_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior58 {
        ///Register `IPRIOR58` reader
        pub struct R(crate::R<IPRIOR58_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR58_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR58_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR58` writer
        pub struct W(crate::W<IPRIOR58_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR58_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR58_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR58_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior58](index.html) module
        pub struct IPRIOR58_SPEC;
        impl crate::RegisterSpec for IPRIOR58_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior58::R](R) reader structure
        impl crate::Readable for IPRIOR58_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior58::W](W) writer structure
        impl crate::Writable for IPRIOR58_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR58 to value 0
        impl crate::Resettable for IPRIOR58_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR59 (rw) register accessor: an alias for `Reg<IPRIOR59_SPEC>`
    pub type IPRIOR59 = crate::Reg<iprior59::IPRIOR59_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior59 {
        ///Register `IPRIOR59` reader
        pub struct R(crate::R<IPRIOR59_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR59_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR59_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR59` writer
        pub struct W(crate::W<IPRIOR59_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR59_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR59_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR59_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior59](index.html) module
        pub struct IPRIOR59_SPEC;
        impl crate::RegisterSpec for IPRIOR59_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior59::R](R) reader structure
        impl crate::Readable for IPRIOR59_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior59::W](W) writer structure
        impl crate::Writable for IPRIOR59_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR59 to value 0
        impl crate::Resettable for IPRIOR59_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR60 (rw) register accessor: an alias for `Reg<IPRIOR60_SPEC>`
    pub type IPRIOR60 = crate::Reg<iprior60::IPRIOR60_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior60 {
        ///Register `IPRIOR60` reader
        pub struct R(crate::R<IPRIOR60_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR60_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR60_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR60` writer
        pub struct W(crate::W<IPRIOR60_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR60_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR60_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR60_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior60](index.html) module
        pub struct IPRIOR60_SPEC;
        impl crate::RegisterSpec for IPRIOR60_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior60::R](R) reader structure
        impl crate::Readable for IPRIOR60_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior60::W](W) writer structure
        impl crate::Writable for IPRIOR60_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR60 to value 0
        impl crate::Resettable for IPRIOR60_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR61 (rw) register accessor: an alias for `Reg<IPRIOR61_SPEC>`
    pub type IPRIOR61 = crate::Reg<iprior61::IPRIOR61_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior61 {
        ///Register `IPRIOR61` reader
        pub struct R(crate::R<IPRIOR61_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR61_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR61_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR61` writer
        pub struct W(crate::W<IPRIOR61_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR61_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR61_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR61_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior61](index.html) module
        pub struct IPRIOR61_SPEC;
        impl crate::RegisterSpec for IPRIOR61_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior61::R](R) reader structure
        impl crate::Readable for IPRIOR61_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior61::W](W) writer structure
        impl crate::Writable for IPRIOR61_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR61 to value 0
        impl crate::Resettable for IPRIOR61_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR62 (rw) register accessor: an alias for `Reg<IPRIOR62_SPEC>`
    pub type IPRIOR62 = crate::Reg<iprior62::IPRIOR62_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior62 {
        ///Register `IPRIOR62` reader
        pub struct R(crate::R<IPRIOR62_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR62_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR62_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR62` writer
        pub struct W(crate::W<IPRIOR62_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR62_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR62_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR62_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior62](index.html) module
        pub struct IPRIOR62_SPEC;
        impl crate::RegisterSpec for IPRIOR62_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior62::R](R) reader structure
        impl crate::Readable for IPRIOR62_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior62::W](W) writer structure
        impl crate::Writable for IPRIOR62_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR62 to value 0
        impl crate::Resettable for IPRIOR62_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///IPRIOR63 (rw) register accessor: an alias for `Reg<IPRIOR63_SPEC>`
    pub type IPRIOR63 = crate::Reg<iprior63::IPRIOR63_SPEC>;
    ///Interrupt Priority Register
    pub mod iprior63 {
        ///Register `IPRIOR63` reader
        pub struct R(crate::R<IPRIOR63_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IPRIOR63_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IPRIOR63_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IPRIOR63` writer
        pub struct W(crate::W<IPRIOR63_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IPRIOR63_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IPRIOR63_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IPRIOR63_SPEC>) -> Self {
                W(writer)
            }
        }
        impl W {
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt Priority Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [iprior63](index.html) module
        pub struct IPRIOR63_SPEC;
        impl crate::RegisterSpec for IPRIOR63_SPEC {
            type Ux = u8;
        }
        ///`read()` method returns [iprior63::R](R) reader structure
        impl crate::Readable for IPRIOR63_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [iprior63::W](W) writer structure
        impl crate::Writable for IPRIOR63_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets IPRIOR63 to value 0
        impl crate::Resettable for IPRIOR63_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///SCTLR (rw) register accessor: an alias for `Reg<SCTLR_SPEC>`
    pub type SCTLR = crate::Reg<sctlr::SCTLR_SPEC>;
    ///System Control Register
    pub mod sctlr {
        ///Register `SCTLR` reader
        pub struct R(crate::R<SCTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SCTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SCTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SCTLR` writer
        pub struct W(crate::W<SCTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SCTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SCTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SCTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SLEEPONEXIT` reader - SLEEPONEXIT
        pub type SLEEPONEXIT_R = crate::BitReader<bool>;
        ///Field `SLEEPONEXIT` writer - SLEEPONEXIT
        pub type SLEEPONEXIT_W<'a, const O: u8> = crate::BitWriter<'a, u32, SCTLR_SPEC, bool, O>;
        ///Field `SLEEPDEEP` reader - SLEEPDEEP
        pub type SLEEPDEEP_R = crate::BitReader<bool>;
        ///Field `SLEEPDEEP` writer - SLEEPDEEP
        pub type SLEEPDEEP_W<'a, const O: u8> = crate::BitWriter<'a, u32, SCTLR_SPEC, bool, O>;
        ///Field `WFITOWFE` reader - WFITOWFE
        pub type WFITOWFE_R = crate::BitReader<bool>;
        ///Field `WFITOWFE` writer - WFITOWFE
        pub type WFITOWFE_W<'a, const O: u8> = crate::BitWriter<'a, u32, SCTLR_SPEC, bool, O>;
        ///Field `SEVONPEND` reader - SEVONPEND
        pub type SEVONPEND_R = crate::BitReader<bool>;
        ///Field `SEVONPEND` writer - SEVONPEND
        pub type SEVONPEND_W<'a, const O: u8> = crate::BitWriter<'a, u32, SCTLR_SPEC, bool, O>;
        ///Field `SETEVENT` reader - SETEVENT
        pub type SETEVENT_R = crate::BitReader<bool>;
        ///Field `SETEVENT` writer - SETEVENT
        pub type SETEVENT_W<'a, const O: u8> = crate::BitWriter<'a, u32, SCTLR_SPEC, bool, O>;
        ///Field `SYSRESET` reader - SYSRESET
        pub type SYSRESET_R = crate::BitReader<bool>;
        ///Field `SYSRESET` writer - SYSRESET
        pub type SYSRESET_W<'a, const O: u8> = crate::BitWriter<'a, u32, SCTLR_SPEC, bool, O>;
        impl R {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            pub fn sleeponexit(&self) -> SLEEPONEXIT_R {
                SLEEPONEXIT_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            pub fn sleepdeep(&self) -> SLEEPDEEP_R {
                SLEEPDEEP_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            pub fn wfitowfe(&self) -> WFITOWFE_R {
                WFITOWFE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            pub fn sevonpend(&self) -> SEVONPEND_R {
                SEVONPEND_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            pub fn setevent(&self) -> SETEVENT_R {
                SETEVENT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - SYSRESET
            #[inline(always)]
            pub fn sysreset(&self) -> SYSRESET_R {
                SYSRESET_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 1 - SLEEPONEXIT
            #[inline(always)]
            #[must_use]
            pub fn sleeponexit(&mut self) -> SLEEPONEXIT_W<1> {
                SLEEPONEXIT_W::new(self)
            }
            ///Bit 2 - SLEEPDEEP
            #[inline(always)]
            #[must_use]
            pub fn sleepdeep(&mut self) -> SLEEPDEEP_W<2> {
                SLEEPDEEP_W::new(self)
            }
            ///Bit 3 - WFITOWFE
            #[inline(always)]
            #[must_use]
            pub fn wfitowfe(&mut self) -> WFITOWFE_W<3> {
                WFITOWFE_W::new(self)
            }
            ///Bit 4 - SEVONPEND
            #[inline(always)]
            #[must_use]
            pub fn sevonpend(&mut self) -> SEVONPEND_W<4> {
                SEVONPEND_W::new(self)
            }
            ///Bit 5 - SETEVENT
            #[inline(always)]
            #[must_use]
            pub fn setevent(&mut self) -> SETEVENT_W<5> {
                SETEVENT_W::new(self)
            }
            ///Bit 31 - SYSRESET
            #[inline(always)]
            #[must_use]
            pub fn sysreset(&mut self) -> SYSRESET_W<31> {
                SYSRESET_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System Control Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sctlr](index.html) module
        pub struct SCTLR_SPEC;
        impl crate::RegisterSpec for SCTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sctlr::R](R) reader structure
        impl crate::Readable for SCTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sctlr::W](W) writer structure
        impl crate::Writable for SCTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets SCTLR to value 0
        impl crate::Resettable for SCTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_CTLR (rw) register accessor: an alias for `Reg<STK_CTLR_SPEC>`
    pub type STK_CTLR = crate::Reg<stk_ctlr::STK_CTLR_SPEC>;
    ///System counter control register
    pub mod stk_ctlr {
        ///Register `STK_CTLR` reader
        pub struct R(crate::R<STK_CTLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CTLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CTLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CTLR` writer
        pub struct W(crate::W<STK_CTLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CTLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CTLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CTLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `STE` reader - System counter enable
        pub type STE_R = crate::BitReader<bool>;
        ///Field `STE` writer - System counter enable
        pub type STE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `STIE` reader - System counter interrupt enable
        pub type STIE_R = crate::BitReader<bool>;
        ///Field `STIE` writer - System counter interrupt enable
        pub type STIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `STCLK` reader - System selects the clock source
        pub type STCLK_R = crate::BitReader<bool>;
        ///Field `STCLK` writer - System selects the clock source
        pub type STCLK_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `STRE` reader - System reload register
        pub type STRE_R = crate::BitReader<bool>;
        ///Field `STRE` writer - System reload register
        pub type STRE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `MODE` reader - System Mode
        pub type MODE_R = crate::BitReader<bool>;
        ///Field `MODE` writer - System Mode
        pub type MODE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `INIT` reader - System Initialization update
        pub type INIT_R = crate::BitReader<bool>;
        ///Field `INIT` writer - System Initialization update
        pub type INIT_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        ///Field `SWIE` reader - System software triggered interrupts enable
        pub type SWIE_R = crate::BitReader<bool>;
        ///Field `SWIE` writer - System software triggered interrupts enable
        pub type SWIE_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_CTLR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - System counter enable
            #[inline(always)]
            pub fn ste(&self) -> STE_R {
                STE_R::new((self.bits & 1) != 0)
            }
            ///Bit 1 - System counter interrupt enable
            #[inline(always)]
            pub fn stie(&self) -> STIE_R {
                STIE_R::new(((self.bits >> 1) & 1) != 0)
            }
            ///Bit 2 - System selects the clock source
            #[inline(always)]
            pub fn stclk(&self) -> STCLK_R {
                STCLK_R::new(((self.bits >> 2) & 1) != 0)
            }
            ///Bit 3 - System reload register
            #[inline(always)]
            pub fn stre(&self) -> STRE_R {
                STRE_R::new(((self.bits >> 3) & 1) != 0)
            }
            ///Bit 4 - System Mode
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 4) & 1) != 0)
            }
            ///Bit 5 - System Initialization update
            #[inline(always)]
            pub fn init(&self) -> INIT_R {
                INIT_R::new(((self.bits >> 5) & 1) != 0)
            }
            ///Bit 31 - System software triggered interrupts enable
            #[inline(always)]
            pub fn swie(&self) -> SWIE_R {
                SWIE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - System counter enable
            #[inline(always)]
            #[must_use]
            pub fn ste(&mut self) -> STE_W<0> {
                STE_W::new(self)
            }
            ///Bit 1 - System counter interrupt enable
            #[inline(always)]
            #[must_use]
            pub fn stie(&mut self) -> STIE_W<1> {
                STIE_W::new(self)
            }
            ///Bit 2 - System selects the clock source
            #[inline(always)]
            #[must_use]
            pub fn stclk(&mut self) -> STCLK_W<2> {
                STCLK_W::new(self)
            }
            ///Bit 3 - System reload register
            #[inline(always)]
            #[must_use]
            pub fn stre(&mut self) -> STRE_W<3> {
                STRE_W::new(self)
            }
            ///Bit 4 - System Mode
            #[inline(always)]
            #[must_use]
            pub fn mode(&mut self) -> MODE_W<4> {
                MODE_W::new(self)
            }
            ///Bit 5 - System Initialization update
            #[inline(always)]
            #[must_use]
            pub fn init(&mut self) -> INIT_W<5> {
                INIT_W::new(self)
            }
            ///Bit 31 - System software triggered interrupts enable
            #[inline(always)]
            #[must_use]
            pub fn swie(&mut self) -> SWIE_W<31> {
                SWIE_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System counter control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_ctlr](index.html) module
        pub struct STK_CTLR_SPEC;
        impl crate::RegisterSpec for STK_CTLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_ctlr::R](R) reader structure
        impl crate::Readable for STK_CTLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_ctlr::W](W) writer structure
        impl crate::Writable for STK_CTLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CTLR to value 0
        impl crate::Resettable for STK_CTLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_SR (rw) register accessor: an alias for `Reg<STK_SR_SPEC>`
    pub type STK_SR = crate::Reg<stk_sr::STK_SR_SPEC>;
    ///System START
    pub mod stk_sr {
        ///Register `STK_SR` reader
        pub struct R(crate::R<STK_SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_SR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_SR` writer
        pub struct W(crate::W<STK_SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_SR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTIF` reader - CNTIF
        pub type CNTIF_R = crate::BitReader<bool>;
        ///Field `CNTIF` writer - CNTIF
        pub type CNTIF_W<'a, const O: u8> = crate::BitWriter<'a, u32, STK_SR_SPEC, bool, O>;
        impl R {
            ///Bit 0 - CNTIF
            #[inline(always)]
            pub fn cntif(&self) -> CNTIF_R {
                CNTIF_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            ///Bit 0 - CNTIF
            #[inline(always)]
            #[must_use]
            pub fn cntif(&mut self) -> CNTIF_W<0> {
                CNTIF_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System START
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_sr](index.html) module
        pub struct STK_SR_SPEC;
        impl crate::RegisterSpec for STK_SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_sr::R](R) reader structure
        impl crate::Readable for STK_SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_sr::W](W) writer structure
        impl crate::Writable for STK_SR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_SR to value 0
        impl crate::Resettable for STK_SR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_CNTL (rw) register accessor: an alias for `Reg<STK_CNTL_SPEC>`
    pub type STK_CNTL = crate::Reg<stk_cntl::STK_CNTL_SPEC>;
    ///System counter low register
    pub mod stk_cntl {
        ///Register `STK_CNTL` reader
        pub struct R(crate::R<STK_CNTL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CNTL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CNTL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CNTL` writer
        pub struct W(crate::W<STK_CNTL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CNTL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CNTL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - CNTL
        pub type CNTL_R = crate::FieldReader<u32, u32>;
        ///Field `CNTL` writer - CNTL
        pub type CNTL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, STK_CNTL_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - CNTL
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CNTL
            #[inline(always)]
            #[must_use]
            pub fn cntl(&mut self) -> CNTL_W<0> {
                CNTL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System counter low register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_cntl](index.html) module
        pub struct STK_CNTL_SPEC;
        impl crate::RegisterSpec for STK_CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_cntl::R](R) reader structure
        impl crate::Readable for STK_CNTL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_cntl::W](W) writer structure
        impl crate::Writable for STK_CNTL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CNTL to value 0
        impl crate::Resettable for STK_CNTL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    ///STK_CMPLR (rw) register accessor: an alias for `Reg<STK_CMPLR_SPEC>`
    pub type STK_CMPLR = crate::Reg<stk_cmplr::STK_CMPLR_SPEC>;
    ///System compare low register
    pub mod stk_cmplr {
        ///Register `STK_CMPLR` reader
        pub struct R(crate::R<STK_CMPLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STK_CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<STK_CMPLR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<STK_CMPLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STK_CMPLR` writer
        pub struct W(crate::W<STK_CMPLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STK_CMPLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<STK_CMPLR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<STK_CMPLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CMPL` reader - CMPL
        pub type CMPL_R = crate::FieldReader<u32, u32>;
        ///Field `CMPL` writer - CMPL
        pub type CMPL_W<'a, const O: u8> =
            crate::FieldWriter<'a, u32, STK_CMPLR_SPEC, u32, u32, 32, O>;
        impl R {
            ///Bits 0:31 - CMPL
            #[inline(always)]
            pub fn cmpl(&self) -> CMPL_R {
                CMPL_R::new(self.bits)
            }
        }
        impl W {
            ///Bits 0:31 - CMPL
            #[inline(always)]
            #[must_use]
            pub fn cmpl(&mut self) -> CMPL_W<0> {
                CMPL_W::new(self)
            }
            ///Writes raw bits to the register.
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///System compare low register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stk_cmplr](index.html) module
        pub struct STK_CMPLR_SPEC;
        impl crate::RegisterSpec for STK_CMPLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stk_cmplr::R](R) reader structure
        impl crate::Readable for STK_CMPLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stk_cmplr::W](W) writer structure
        impl crate::Writable for STK_CMPLR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        ///`reset()` method sets STK_CMPLR to value 0
        impl crate::Resettable for STK_CMPLR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///PWR
    pub PWR: PWR,
    ///RCC
    pub RCC: RCC,
    ///EXTEND
    pub EXTEND: EXTEND,
    ///GPIOA
    pub GPIOA: GPIOA,
    ///GPIOC
    pub GPIOC: GPIOC,
    ///GPIOD
    pub GPIOD: GPIOD,
    ///AFIO
    pub AFIO: AFIO,
    ///EXTI
    pub EXTI: EXTI,
    ///DMA1
    pub DMA1: DMA1,
    ///IWDG
    pub IWDG: IWDG,
    ///WWDG
    pub WWDG: WWDG,
    ///TIM1
    pub TIM1: TIM1,
    ///TIM2
    pub TIM2: TIM2,
    ///I2C1
    pub I2C1: I2C1,
    ///SPI1
    pub SPI1: SPI1,
    ///USART1
    pub USART1: USART1,
    ///ADC1
    pub ADC1: ADC1,
    ///DBG
    pub DBG: DBG,
    ///ESIG
    pub ESIG: ESIG,
    ///FLASH
    pub FLASH: FLASH,
    ///PFIC
    pub PFIC: PFIC,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PWR: PWR {
                _marker: PhantomData,
            },
            RCC: RCC {
                _marker: PhantomData,
            },
            EXTEND: EXTEND {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            AFIO: AFIO {
                _marker: PhantomData,
            },
            EXTI: EXTI {
                _marker: PhantomData,
            },
            DMA1: DMA1 {
                _marker: PhantomData,
            },
            IWDG: IWDG {
                _marker: PhantomData,
            },
            WWDG: WWDG {
                _marker: PhantomData,
            },
            TIM1: TIM1 {
                _marker: PhantomData,
            },
            TIM2: TIM2 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            USART1: USART1 {
                _marker: PhantomData,
            },
            ADC1: ADC1 {
                _marker: PhantomData,
            },
            DBG: DBG {
                _marker: PhantomData,
            },
            ESIG: ESIG {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            PFIC: PFIC {
                _marker: PhantomData,
            },
        }
    }
}
